{"meta":{"title":"gtoo8888","subtitle":"会扇扇子的猪","description":"Linux学习者","author":"Kuku De","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"26/07/2022","updated":"26/07/2022","comments":true,"path":"README.html","permalink":"http://example.com/README.html","excerpt":"","text":"blog_detail博客的具体内容"},{"title":"分类","date":"21/06/2022","updated":"21/06/2022","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"16/08/2022","updated":"16/08/2022","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"关于","date":"21/06/2022","updated":"21/06/2022","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"常用链接","date":"21/06/2022","updated":"25/09/2022","comments":true,"path":"source/index.html","permalink":"http://example.com/source/index.html","excerpt":"","text":"官方网站和文档 CMake https://cmake.org/ hexo https://hexo.io/zh-cn/ raspberry https://www.raspberrypi.org/ 路过图床 https://imgtu.com/ halo博客系统https://halo.run/ 阿里云开发者网站 https://developer.aliyun.com/?spm=a2c6h.23182525.J_5404914170.1.77483b2fjWTL8k Google Research https://research.google/ docker hub https://hub.docker.com/ WIKI PythonRobotics documentation https://pythonrobotics.readthedocs.io/en/latest/index.html CMake Document https://cmake.org/cmake/help/v3.23/ ROS document http://wiki.ros.org/Documentation TIDB https://docs.pingcap.com/zh/tidb/stable/overview redis https://www.redis.net.cn/ 腾讯云开发者社区 https://cloud.tencent.com/developer/chapter/12850 opencv document https://docs.opencv.org/4.x/ pytorch document https://pytorch.org/tutorials/ Wireshark User’s Guide https://www.wireshark.org/docs/wsug_html_chunked/ 鸟哥的Linuxs私房菜 http://cn.linux.vbird.org/linux_basic/linux_basic.php zeromq https://zguide.zeromq.org/ ZeroMQ 教程 https://www.jianshu.com/p/a8b657472518 zeroguide 中文翻译 https://wizardforcel.gitbooks.io/zmq-guide/content/chapter1.html https://www.cnblogs.com/Anker/p/4706244.html https://blog.csdn.net/a19891024/article/details/78182287 摩天轮中国数据库流行排名 https://www.modb.pro/dbRank LABULADONG 的算法网站 https://labuladong.github.io/algo/5/43/ 中文WIKI 鸟哥的Linux私房菜 https://linux.vbird.org/ 树莓派实验室 https://shumeipai.nxez.com/download 古月居 https://www.guyuehome.com/ 外文网站 Hacker News https://news.ycombinator.com/ stackoverflow https://stackoverflow.com/ Reddit https://www.reddit.com/ &#x2F;cpp: &#x2F;programming： &#x2F;java： https://www.reddit.com/r/programming/ &#x2F;shittyprogramming： Medium https://medium.com/ Quora https://www.quora.com/ InfoQ https://www.infoq.com/ 求职 牛客网 https://www.nowcoder.com/discuss/experience/index?parentJobId=1 大佬自己建的网站 代码随想录 https://programmercarl.com/ 阿秀的求职笔记 https://interviewguide.cn/#/ 编程之路 https://www.r2coding.com/#/ 经典技术书籍 https://awesome-programming-books.github.io/ 数据结构的演示 https://www.cs.usfca.edu/~galles/visualization/ pkucs自学指南 https://csdiy.wiki/ 小白视角：一文读懂社长的TinyWebServer 追梦算法网 http://acm.mangata.ltd/ vincents https://vincents.top/2022/08/14/60.html 被删的前端游乐场 https://godbasin.github.io/front-end-playground/ go+pythonhttps://jiajunhuang.com/ LearnData 开源笔记 https://vincentsx.github.io/ 一些动画在线练习 Learn Git Branching https://learngitbranching.js.org/?locale=zh_CN 技术博客学习 Luc https://www.cnblogs.com/figure9 codedump的网络日志 https://www.codedump.info/post/20200122-series-pages/ 程序员的喵 https://catcoding.me/ 秦怀杂货店 http://aphysia.cn/ 外国博客 Kent C. Dodds https://kentcdodds.com/ 软件社区 v2ex https://www.v2ex.com/t/852843#reply11 博客形式学习 阮一峰的博客 http://www.ruanyifeng.com/home.html 小冰的博客 https://zfe.space/ 鴻塵 https://hwame.top/ hexo https://bestzuo.cn/ goodwell https://goodwell42.github.io/ std::mutex 用法與範例 https://shengyu7697.github.io/std-mutex/ 前端写的博客 https://carefulsuper.github.io/#articles ACM学习计划 https://gist.github.com/dodola/6227480 NOIP2018游记 http://lycltb.top/post/noip2018/ 打了三年ACM，拿了几个金牌 https://mp.ofweek.com/ee/a356714167237 课程 MIT 6.828 Fall 2018 https://pdos.csail.mit.edu/6.828/2018/schedule.html MIT 6.828 Fall 2011 https://pdos.csail.mit.edu/6.828/2011/schedule.html CS144 https://cs144.github.io/ C++高薪求职项目 Linux高并发服务器开发 https://www.nowcoder.com/courses/cover/live/504 刷题 leetcode https://leetcode-cn.com/ 洛谷 https://www.luogu.com.cn/ codeforces https://codeforces.com/ AtCoder https://atcoder.jp/ 代码源 http://oj.daimayuan.top/ AcWing https://www.acwing.com/ vjudge https://vjudge.net/ codetop企业题库 https://codetop.cc/home 牛客竞赛OJ https://ac.nowcoder.com/acm/home/935083664 AtCoder从小白到大神的进阶攻略 https://www.cnblogs.com/LHYLHY/p/11572011.html OIWIKI https://oi-wiki.org/ 宫水三叶的刷题日记 https://github.com/SharingSource/LogicStack-LeetCode/wiki 技术文档 进程间通讯 https://www.cnblogs.com/xiaolincoding/p/13402297.html 嵌入式相关电子社区 电路城 https://www.cirmall.com/ 51黑论坛 http://www.51hei.com/bbs/ 电子发烧友 https://bbs.elecfans.com/ Free PCB Design https://circuitmaker.com/ 官网 ST https://www.st.com/content/st_com/en.html keil https://www.keil.com/download/product/ TI官网 https://www.ti.com.cn/ ADI https://www.analog.com/cn/index.html arduino中文社区 https://www.arduino.cn/ alldatesheet https://www.alldatasheet.com/ 淘宝购物 洋桃电子 http://www.doyoung.net/YT/ 野火产品下载中心 https://doc.embedfire.com/products/link/zh/latest/index.html crazepony http://www.crazepony.com/wiki/algorithm-pid.html 工具索引类 w3school https://www.w3school.com.cn/ 重庆大学开源镜像 https://mirrors.cqu.edu.cn/ 站长工具ping https://ping.chinaz.com/ 找文献arxiv https://arxiv.org/ 翻译 DeepL翻译 https://www.deepl.com/translator 其他 Starting Strength https://startingstrength.com/ 测网速 https://beta.speedtest.net/ 思维导图 https://www.processon.com/ 路过图床 https://imgtu.com/ make a gif https://makeagif.com/ 木及简历 https://www.mujicv.com/ RSS订阅其他博主 https://feedly.com/i/welcome 地图 阿里云地图 http://datav.aliyun.com/portal/school/atlas/area_selector 中国标准地图服务网站 http://bzdt.ch.mnr.gov.cn/ PPT模板 第一PPT https://www.1ppt.com/ 优品PPT https://www.ypppt.com/ 小软件 everything https://www.voidtools.com/zh-cn/downloads/ 阿里云服务器白嫖 https://developer.aliyun.com/plan/acc"}],"posts":[{"title":"k8s命令","date":"25/09/2022","path":"2022/09/25/Course/k8s-commad/","text":"1. 命令式对象管理 kubectl命令1kubectl [command] [type] [name] [flags] comand：指定要对资源执行的操作，例如create、get、deletetype：指定资源类型，比如deployment、pod、servicename：指定资源的名称，名称大小写敏感flags：指定额外的可选参数 1.1 操作（command）kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令kubectl –help 经常使用的操作有下面这些： 命令分类 命令 翻译 命令作用 基本命令 create 创建 创建一个资源 edit 编辑 编辑一个资源 get 获取 获取一个资源 patch 更新 更新一个资源 delete 删除 删除一个资源 explain 解释 展示资源文档 运行和调试 run 运行 在集群中运行一个指定的镜像 expose 暴露 暴露资源为Service describe 描述 显示资源内部信息 logs 日志输出容器在 pod 中的日志 输出容器在 pod 中的日志 attach 缠绕进入运行中的容器 进入运行中的容器 exec 执行容器中的一个命令 执行容器中的一个命令 cp 复制 在Pod内外复制文件 rollout 首次展示 管理资源的发布 scale 规模 扩(缩)容Pod的数量 autoscale 自动调整 自动调整Pod的数量 高级命令 apply rc 通过文件对资源进行配置 label 标签 更新资源上的标签 其他命令 cluster-info 集群信息 显示集群信息 version 版本 显示当前Server和Client的版本 1.2 资源类型（type）kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看: 1kubectl api-resources 经常使用的资源有下面这些： 资源分类 资源名称 缩写 资源作用 集群级别资源 nodes no 集群组成部分 namespaces ns 隔离Pod pod资源 pods po 装载容器 pod资源控制器 replicationcontrollers rc 控制pod资源 replicasets rs 控制pod资源 deployments deploy 控制pod资源 daemonsets ds 控制pod资源 jobs 控制pod资源 cronjobs cj 控制pod资源 horizontalpodautoscalers hpa 控制pod资源 statefulsets sts 控制pod资源 服务发现资源 services svc 统一pod对外接口 ingress ing 统一pod对外接口 存储资源 volumeattachments 存储 persistentvolumes pv 存储 persistentvolumeclaims pvc 存储 配置资源 configmaps cm 配置 secrets 配置 1.3 应用示例123456kubectl create namespace dev # 创建一个namespacekubectl get ns # 获取namespacekubectl run pod --image=nginx:latest -n dev # 在此namespace下创建并运行一个nginx的Podkubectl get pod -n dev # 查看新创建的podkubectl delete pod pod-864f9875b9-pcw7x # 删除指定的podkubectl delete ns dev # 删除指定的namespace 2 常见资源2.1 namspace123456789101112131415161718# 查看所有的命名空间kubectl get namespacekubectl get nc# 查看指定的命名空间kubectl get namespace defaultkubectl get ns default# 指定命名空间的输出格式kubectl get ns default -o widekubectl get ns default -o jsonkubectl get ns default -o yaml# 查看命名空间的详情kubectl describe namespace defaultkubectl describe ns default# 创建命名空间kubectl create namespace devkubectl create ns dev# 除命名空间kubectl delete ns dev 3 Pod详解3.1 Pod的配置3.2 Pod的生命周期3.3 Pod的调度4 Pod控制器详解 在kubernetes中，按照Pod的创建方式可以将其分为两类： 自主式Pod：kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建。 控制器创建Pod：通过Pod控制器创建的Pod，这种Pod删除之后还会自动重建。 Pod控制器：Pod控制器是管理Pod的中间层，使用了Pod控制器之后，我们只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它就会创建出满足条件的Pod并确保每一个Pod处于用户期望的状态，如果Pod在运行中出现故障，控制器会基于指定的策略重启或重建Pod。 在kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些： ReplicationController：比较原始的Pod控制器，已经被废弃，由ReplicaSet替代。 ReplicaSet：保证指定数量的Pod运行，并支持Pod数量变更，镜像版本变更。 Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、版本回退。 Horizontal Pod Autoscaler：可以根据集群负载自动调整Pod的数量，实现削峰填谷。 DaemonSet：在集群中的指定Node上都运行一个副本，一般用于守护进程类的任务。 Job：它创建出来的Pod只要完成任务就立即退出，用于执行一次性任务。 CronJob：它创建的Pod会周期性的执行，用于执行周期性的任务。 StatefulSet：管理有状态的应用。 4.1 Pod控制器的介绍4.2 ReplicaSet（RS）4.3 Deployment（Deploy）4.4 Horizontal Pod Autoscaler（HPA）4.5 DaemonSet（DS）4.6 Job4.7 CronJob（CJ）4.8 StatefulSet（有状态）5 Service详解在kubernetes中，Pod是应用程序的载体，我们可以通过Pod的IP来访问应用程序，但是Pod的IP地址不是固定的，这就意味着不方便直接采用Pod的IP对服务进行访问。 spec.type的说明： ClusterIP：默认值，它是kubernetes系统自动分配的虚拟IP，只能在集群内部访问。 NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务。 LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境的支持。 ExternalName：把集群外部的服务引入集群内部，直接使用。 5.1 ClusterIP类型的Service5.2 HeadLiness类型的Service5.3 NodePort类型的Service5.4 LoadBalancer类型的Service5.5 ExternalName类型的Service5.1 Ingress介绍6 k8s的数据存储 在前面已经提到，容器的生命周期可能很短，会被频繁的创建和销毁。那么容器在销毁的时候，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器中的数据，kubernetes引入了Volume的概念。 Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命周期不和Pod中的单个容器的生命周期有关，当容器终止或者重启的时候，Volume中的数据也不会丢失。 kubernetes的Volume支持多种类型，比较常见的有下面的几个： 简单存储：EmptyDir、HostPath、NFS。 高级存储：PV、PVC。 配置存储：ConfigMap、Secret。 6.1 基本存储6.1.1 EmptyDir6.1.2 HostPath6.1.3 NFS6.2 高级存储6.1.2 PV6.1.3 PVC6.3 配置存储6.1.2 ConfigMap6.1.3 Secret7 高级部分（暂时不准备做）k8s的Helmk8s的安全认证搭建DashBoardkubeadm安装高可用k8s集群k8s的项目部署","raw":"---\ntitle: k8s命令\ndate: 2022-09-25 20:26:56\ntags:\n- 课程\n---\n\n\n# 1. 命令式对象管理 kubectl命令\n\n```\nkubectl [command] [type] [name] [flags]\n```\n**comand**：指定要对资源执行的操作，例如create、get、delete\n**type**：指定资源类型，比如deployment、pod、service\n**name**：指定资源的名称，名称大小写敏感\n**flags**：指定额外的可选参数\n\n## 1.1 操作（command）\n\nkubernetes允许对资源进行多种操作，可以通过--help查看详细的操作命令\nkubectl --help\n\n\n经常使用的操作有下面这些：\n\n| 命令分类   | 命令         | 翻译                        | 命令作用                     |\n| :--------- | :----------- | :-------------------------- | :--------------------------- |\n| 基本命令   | create       | 创建                        | 创建一个资源                 |\n|            | edit         | 编辑                        | 编辑一个资源                 |\n|            | get          | 获取                        | 获取一个资源                 |\n|            | patch        | 更新                        | 更新一个资源                 |\n|            | delete       | 删除                        | 删除一个资源                 |\n|            | explain      | 解释                        | 展示资源文档                 |\n| 运行和调试 | run          | 运行                        | 在集群中运行一个指定的镜像   |\n|            | expose       | 暴露                        | 暴露资源为Service            |\n|            | describe     | 描述                        | 显示资源内部信息             |\n|            | logs         | 日志输出容器在 pod 中的日志 | 输出容器在 pod 中的日志      |\n|            | attach       | 缠绕进入运行中的容器        | 进入运行中的容器             |\n|            | exec         | 执行容器中的一个命令        | 执行容器中的一个命令         |\n|            | cp           | 复制                        | 在Pod内外复制文件            |\n|            | rollout      | 首次展示                    | 管理资源的发布               |\n|            | scale        | 规模                        | 扩(缩)容Pod的数量            |\n|            | autoscale    | 自动调整                    | 自动调整Pod的数量            |\n| 高级命令   | apply        | rc                          | 通过文件对资源进行配置       |\n|            | label        | 标签                        | 更新资源上的标签             |\n| 其他命令   | cluster-info | 集群信息                    | 显示集群信息                 |\n|            | version      | 版本                        | 显示当前Server和Client的版本 |\n\n\n\n\n\n## 1.2 资源类型（type）\n\n\nkubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:\n\n```\nkubectl api-resources\n```\n经常使用的资源有下面这些：\n\n| 资源分类      | 资源名称                 | 缩写    | 资源作用        |\n| :------------ | :----------------------- | :------ | :-------------- |\n| 集群级别资源  | nodes                    | no      | 集群组成部分    |\n|               | namespaces    | ns      | 隔离Pod |                 |\n| pod资源       | pods                     | po      | 装载容器        |\n| pod资源控制器 | replicationcontrollers   | rc      | 控制pod资源     |\n|               | replicasets              | rs      | 控制pod资源     |\n|               | deployments              | deploy  | 控制pod资源     |\n|               | daemonsets               | ds      | 控制pod资源     |\n|               | jobs                     |         | 控制pod资源     |\n|               | cronjobs                 | cj      | 控制pod资源     |\n|               | horizontalpodautoscalers | hpa     | 控制pod资源     |\n|               | statefulsets             | sts     | 控制pod资源     |\n| 服务发现资源  | services                 | svc     | 统一pod对外接口 |\n|               | ingress                  | ing     | 统一pod对外接口 |\n| 存储资源      | volumeattachments        |         | 存储            |\n|               | persistentvolumes        | pv      | 存储            |\n|               | persistentvolumeclaims   | pvc     | 存储            |\n| 配置资源      | configmaps               | cm      | 配置            |\n|               | secrets                  |         | 配置            |\n\n\n## 1.3 应用示例\n```shell\nkubectl create namespace dev  # 创建一个namespace\nkubectl get ns # 获取namespace\nkubectl run pod --image=nginx:latest -n dev # 在此namespace下创建并运行一个nginx的Pod\nkubectl get pod -n dev # 查看新创建的pod\nkubectl delete pod pod-864f9875b9-pcw7x # 删除指定的pod\nkubectl delete ns dev # 删除指定的namespace\n```\n\n\n\n\n# 2 常见资源\n# 2.1 namspace\n\n```shell\n# 查看所有的命名空间\nkubectl get namespace\nkubectl get nc\n# 查看指定的命名空间\nkubectl get namespace default\nkubectl get ns default\n# 指定命名空间的输出格式\nkubectl get ns default -o wide\nkubectl get ns default -o json\nkubectl get ns default -o yaml\n# 查看命名空间的详情\nkubectl describe namespace default\nkubectl describe ns default\n# 创建命名空间\nkubectl create namespace dev\nkubectl create ns dev\n# 除命名空间\nkubectl delete ns dev\n```\n\n\n\n\n\n# 3 Pod详解\n\n## 3.1 Pod的配置\n\n\n\n## 3.2 Pod的生命周期\n## 3.3 Pod的调度\n\n\n# 4 Pod控制器详解\n\n- 在kubernetes中，按照Pod的创建方式可以将其分为两类：\n  - 自主式Pod：kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建。\n  - 控制器创建Pod：通过Pod控制器创建的Pod，这种Pod删除之后还会自动重建。\n- Pod控制器：Pod控制器是管理Pod的中间层，使用了Pod控制器之后，我们只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它就会创建出满足条件的Pod并确保每一个Pod处于用户期望的状态，如果Pod在运行中出现故障，控制器会基于指定的策略重启或重建Pod。\n- 在kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些：\n  - ReplicationController：比较原始的Pod控制器，已经被废弃，由ReplicaSet替代。\n  - ReplicaSet：保证指定数量的Pod运行，并支持Pod数量变更，镜像版本变更。\n  - Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、版本回退。\n  - Horizontal Pod Autoscaler：可以根据集群负载自动调整Pod的数量，实现削峰填谷。\n  - DaemonSet：在集群中的指定Node上都运行一个副本，一般用于守护进程类的任务。\n  - Job：它创建出来的Pod只要完成任务就立即退出，用于执行一次性任务。\n  - CronJob：它创建的Pod会周期性的执行，用于执行周期性的任务。\n  - StatefulSet：管理有状态的应用。\n\n## 4.1 Pod控制器的介绍\n## 4.2 ReplicaSet（RS）\n## 4.3 Deployment（Deploy）\n## 4.4 Horizontal Pod Autoscaler（HPA）\n## 4.5 DaemonSet（DS）\n## 4.6 Job\n## 4.7 CronJob（CJ）\n## 4.8 StatefulSet（有状态）\n\n\n\n# 5 Service详解\n在kubernetes中，Pod是应用程序的载体，我们可以通过Pod的IP来访问应用程序，但是Pod的IP地址不是固定的，这就意味着不方便直接采用Pod的IP对服务进行访问。\n\nspec.type的说明：\n- ClusterIP：默认值，它是kubernetes系统自动分配的虚拟IP，只能在集群内部访问。\n- NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务。\n- LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境的支持。\n- ExternalName：把集群外部的服务引入集群内部，直接使用。\n\n## 5.1 ClusterIP类型的Service\n## 5.2 HeadLiness类型的Service\n## 5.3 NodePort类型的Service\n## 5.4 LoadBalancer类型的Service\n## 5.5 ExternalName类型的Service\n\n## 5.1 Ingress介绍\n\n\n\n\n\n\n# 6 k8s的数据存储\n- 在前面已经提到，容器的生命周期可能很短，会被频繁的创建和销毁。那么容器在销毁的时候，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器中的数据，kubernetes引入了Volume的概念。\n- Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命周期不和Pod中的单个容器的生命周期有关，当容器终止或者重启的时候，Volume中的数据也不会丢失。\n- kubernetes的Volume支持多种类型，比较常见的有下面的几个：\n  - 简单存储：EmptyDir、HostPath、NFS。\n  - 高级存储：PV、PVC。\n  - 配置存储：ConfigMap、Secret。\n\n## 6.1 基本存储\n### 6.1.1 EmptyDir\n### 6.1.2 HostPath\n### 6.1.3 NFS\n\n## 6.2 高级存储\n### 6.1.2 PV\n### 6.1.3 PVC\n\n## 6.3 配置存储\n### 6.1.2 ConfigMap\n### 6.1.3 Secret\n\n\n\n# 7 高级部分（暂时不准备做）\n## k8s的Helm\n## k8s的安全认证\n## 搭建DashBoard\n## kubeadm安装高可用k8s集群\n## k8s的项目部署\n\n\n\n\n\n","content":"<h1 id=\"1-命令式对象管理-kubectl命令\"><a href=\"#1-命令式对象管理-kubectl命令\" class=\"headerlink\" title=\"1. 命令式对象管理 kubectl命令\"></a>1. 命令式对象管理 kubectl命令</h1><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl <span class=\"selector-attr\">[command]</span> <span class=\"selector-attr\">[type]</span> <span class=\"selector-attr\">[name]</span> <span class=\"selector-attr\">[flags]</span></span><br></pre></td></tr></table></figure>\n<p><strong>comand</strong>：指定要对资源执行的操作，例如create、get、delete<br><strong>type</strong>：指定资源类型，比如deployment、pod、service<br><strong>name</strong>：指定资源的名称，名称大小写敏感<br><strong>flags</strong>：指定额外的可选参数</p>\n<h2 id=\"1-1-操作（command）\"><a href=\"#1-1-操作（command）\" class=\"headerlink\" title=\"1.1 操作（command）\"></a>1.1 操作（command）</h2><p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令<br>kubectl –help</p>\n<p>经常使用的操作有下面这些：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">命令分类</th>\n<th align=\"left\">命令</th>\n<th align=\"left\">翻译</th>\n<th align=\"left\">命令作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">基本命令</td>\n<td align=\"left\">create</td>\n<td align=\"left\">创建</td>\n<td align=\"left\">创建一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">edit</td>\n<td align=\"left\">编辑</td>\n<td align=\"left\">编辑一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">get</td>\n<td align=\"left\">获取</td>\n<td align=\"left\">获取一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">patch</td>\n<td align=\"left\">更新</td>\n<td align=\"left\">更新一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">delete</td>\n<td align=\"left\">删除</td>\n<td align=\"left\">删除一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">explain</td>\n<td align=\"left\">解释</td>\n<td align=\"left\">展示资源文档</td>\n</tr>\n<tr>\n<td align=\"left\">运行和调试</td>\n<td align=\"left\">run</td>\n<td align=\"left\">运行</td>\n<td align=\"left\">在集群中运行一个指定的镜像</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">expose</td>\n<td align=\"left\">暴露</td>\n<td align=\"left\">暴露资源为Service</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">describe</td>\n<td align=\"left\">描述</td>\n<td align=\"left\">显示资源内部信息</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">logs</td>\n<td align=\"left\">日志输出容器在 pod 中的日志</td>\n<td align=\"left\">输出容器在 pod 中的日志</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">attach</td>\n<td align=\"left\">缠绕进入运行中的容器</td>\n<td align=\"left\">进入运行中的容器</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">exec</td>\n<td align=\"left\">执行容器中的一个命令</td>\n<td align=\"left\">执行容器中的一个命令</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">cp</td>\n<td align=\"left\">复制</td>\n<td align=\"left\">在Pod内外复制文件</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">rollout</td>\n<td align=\"left\">首次展示</td>\n<td align=\"left\">管理资源的发布</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">scale</td>\n<td align=\"left\">规模</td>\n<td align=\"left\">扩(缩)容Pod的数量</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">autoscale</td>\n<td align=\"left\">自动调整</td>\n<td align=\"left\">自动调整Pod的数量</td>\n</tr>\n<tr>\n<td align=\"left\">高级命令</td>\n<td align=\"left\">apply</td>\n<td align=\"left\">rc</td>\n<td align=\"left\">通过文件对资源进行配置</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">label</td>\n<td align=\"left\">标签</td>\n<td align=\"left\">更新资源上的标签</td>\n</tr>\n<tr>\n<td align=\"left\">其他命令</td>\n<td align=\"left\">cluster-info</td>\n<td align=\"left\">集群信息</td>\n<td align=\"left\">显示集群信息</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">version</td>\n<td align=\"left\">版本</td>\n<td align=\"left\">显示当前Server和Client的版本</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-2-资源类型（type）\"><a href=\"#1-2-资源类型（type）\" class=\"headerlink\" title=\"1.2 资源类型（type）\"></a>1.2 资源类型（type）</h2><p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">kubectl api-resources</span></span><br></pre></td></tr></table></figure>\n<p>经常使用的资源有下面这些：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">资源分类</th>\n<th align=\"left\">资源名称</th>\n<th align=\"left\">缩写</th>\n<th align=\"left\">资源作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">集群级别资源</td>\n<td align=\"left\">nodes</td>\n<td align=\"left\">no</td>\n<td align=\"left\">集群组成部分</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">namespaces</td>\n<td align=\"left\">ns</td>\n<td align=\"left\">隔离Pod</td>\n</tr>\n<tr>\n<td align=\"left\">pod资源</td>\n<td align=\"left\">pods</td>\n<td align=\"left\">po</td>\n<td align=\"left\">装载容器</td>\n</tr>\n<tr>\n<td align=\"left\">pod资源控制器</td>\n<td align=\"left\">replicationcontrollers</td>\n<td align=\"left\">rc</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">replicasets</td>\n<td align=\"left\">rs</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">deployments</td>\n<td align=\"left\">deploy</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">daemonsets</td>\n<td align=\"left\">ds</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">jobs</td>\n<td align=\"left\"></td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">cronjobs</td>\n<td align=\"left\">cj</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">horizontalpodautoscalers</td>\n<td align=\"left\">hpa</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">statefulsets</td>\n<td align=\"left\">sts</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\">服务发现资源</td>\n<td align=\"left\">services</td>\n<td align=\"left\">svc</td>\n<td align=\"left\">统一pod对外接口</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">ingress</td>\n<td align=\"left\">ing</td>\n<td align=\"left\">统一pod对外接口</td>\n</tr>\n<tr>\n<td align=\"left\">存储资源</td>\n<td align=\"left\">volumeattachments</td>\n<td align=\"left\"></td>\n<td align=\"left\">存储</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">persistentvolumes</td>\n<td align=\"left\">pv</td>\n<td align=\"left\">存储</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">persistentvolumeclaims</td>\n<td align=\"left\">pvc</td>\n<td align=\"left\">存储</td>\n</tr>\n<tr>\n<td align=\"left\">配置资源</td>\n<td align=\"left\">configmaps</td>\n<td align=\"left\">cm</td>\n<td align=\"left\">配置</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">secrets</td>\n<td align=\"left\"></td>\n<td align=\"left\">配置</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-3-应用示例\"><a href=\"#1-3-应用示例\" class=\"headerlink\" title=\"1.3 应用示例\"></a>1.3 应用示例</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace dev  # 创建一个namespace</span><br><span class=\"line\">kubectl get ns # 获取namespace</span><br><span class=\"line\">kubectl run pod --image=nginx:latest -n dev # 在此namespace下创建并运行一个nginx的Pod</span><br><span class=\"line\">kubectl get pod -n dev # 查看新创建的pod</span><br><span class=\"line\">kubectl delete pod pod-864f9875b9-pcw7x # 删除指定的pod</span><br><span class=\"line\">kubectl delete ns dev # 删除指定的namespace</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"2-常见资源\"><a href=\"#2-常见资源\" class=\"headerlink\" title=\"2 常见资源\"></a>2 常见资源</h1><h1 id=\"2-1-namspace\"><a href=\"#2-1-namspace\" class=\"headerlink\" title=\"2.1 namspace\"></a>2.1 namspace</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看所有的命名空间</span></span><br><span class=\"line\">kubectl get namespace</span><br><span class=\"line\">kubectl get nc</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看指定的命名空间</span></span><br><span class=\"line\">kubectl get namespace default</span><br><span class=\"line\">kubectl get ns default</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">指定命名空间的输出格式</span></span><br><span class=\"line\">kubectl get ns default -o wide</span><br><span class=\"line\">kubectl get ns default -o json</span><br><span class=\"line\">kubectl get ns default -o yaml</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看命名空间的详情</span></span><br><span class=\"line\">kubectl describe namespace default</span><br><span class=\"line\">kubectl describe ns default</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">创建命名空间</span></span><br><span class=\"line\">kubectl create namespace dev</span><br><span class=\"line\">kubectl create ns dev</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">除命名空间</span></span><br><span class=\"line\">kubectl delete ns dev</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"3-Pod详解\"><a href=\"#3-Pod详解\" class=\"headerlink\" title=\"3 Pod详解\"></a>3 Pod详解</h1><h2 id=\"3-1-Pod的配置\"><a href=\"#3-1-Pod的配置\" class=\"headerlink\" title=\"3.1 Pod的配置\"></a>3.1 Pod的配置</h2><h2 id=\"3-2-Pod的生命周期\"><a href=\"#3-2-Pod的生命周期\" class=\"headerlink\" title=\"3.2 Pod的生命周期\"></a>3.2 Pod的生命周期</h2><h2 id=\"3-3-Pod的调度\"><a href=\"#3-3-Pod的调度\" class=\"headerlink\" title=\"3.3 Pod的调度\"></a>3.3 Pod的调度</h2><h1 id=\"4-Pod控制器详解\"><a href=\"#4-Pod控制器详解\" class=\"headerlink\" title=\"4 Pod控制器详解\"></a>4 Pod控制器详解</h1><ul>\n<li>在kubernetes中，按照Pod的创建方式可以将其分为两类：<ul>\n<li>自主式Pod：kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建。</li>\n<li>控制器创建Pod：通过Pod控制器创建的Pod，这种Pod删除之后还会自动重建。</li>\n</ul>\n</li>\n<li>Pod控制器：Pod控制器是管理Pod的中间层，使用了Pod控制器之后，我们只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它就会创建出满足条件的Pod并确保每一个Pod处于用户期望的状态，如果Pod在运行中出现故障，控制器会基于指定的策略重启或重建Pod。</li>\n<li>在kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些：<ul>\n<li>ReplicationController：比较原始的Pod控制器，已经被废弃，由ReplicaSet替代。</li>\n<li>ReplicaSet：保证指定数量的Pod运行，并支持Pod数量变更，镜像版本变更。</li>\n<li>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、版本回退。</li>\n<li>Horizontal Pod Autoscaler：可以根据集群负载自动调整Pod的数量，实现削峰填谷。</li>\n<li>DaemonSet：在集群中的指定Node上都运行一个副本，一般用于守护进程类的任务。</li>\n<li>Job：它创建出来的Pod只要完成任务就立即退出，用于执行一次性任务。</li>\n<li>CronJob：它创建的Pod会周期性的执行，用于执行周期性的任务。</li>\n<li>StatefulSet：管理有状态的应用。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-1-Pod控制器的介绍\"><a href=\"#4-1-Pod控制器的介绍\" class=\"headerlink\" title=\"4.1 Pod控制器的介绍\"></a>4.1 Pod控制器的介绍</h2><h2 id=\"4-2-ReplicaSet（RS）\"><a href=\"#4-2-ReplicaSet（RS）\" class=\"headerlink\" title=\"4.2 ReplicaSet（RS）\"></a>4.2 ReplicaSet（RS）</h2><h2 id=\"4-3-Deployment（Deploy）\"><a href=\"#4-3-Deployment（Deploy）\" class=\"headerlink\" title=\"4.3 Deployment（Deploy）\"></a>4.3 Deployment（Deploy）</h2><h2 id=\"4-4-Horizontal-Pod-Autoscaler（HPA）\"><a href=\"#4-4-Horizontal-Pod-Autoscaler（HPA）\" class=\"headerlink\" title=\"4.4 Horizontal Pod Autoscaler（HPA）\"></a>4.4 Horizontal Pod Autoscaler（HPA）</h2><h2 id=\"4-5-DaemonSet（DS）\"><a href=\"#4-5-DaemonSet（DS）\" class=\"headerlink\" title=\"4.5 DaemonSet（DS）\"></a>4.5 DaemonSet（DS）</h2><h2 id=\"4-6-Job\"><a href=\"#4-6-Job\" class=\"headerlink\" title=\"4.6 Job\"></a>4.6 Job</h2><h2 id=\"4-7-CronJob（CJ）\"><a href=\"#4-7-CronJob（CJ）\" class=\"headerlink\" title=\"4.7 CronJob（CJ）\"></a>4.7 CronJob（CJ）</h2><h2 id=\"4-8-StatefulSet（有状态）\"><a href=\"#4-8-StatefulSet（有状态）\" class=\"headerlink\" title=\"4.8 StatefulSet（有状态）\"></a>4.8 StatefulSet（有状态）</h2><h1 id=\"5-Service详解\"><a href=\"#5-Service详解\" class=\"headerlink\" title=\"5 Service详解\"></a>5 Service详解</h1><p>在kubernetes中，Pod是应用程序的载体，我们可以通过Pod的IP来访问应用程序，但是Pod的IP地址不是固定的，这就意味着不方便直接采用Pod的IP对服务进行访问。</p>\n<p>spec.type的说明：</p>\n<ul>\n<li>ClusterIP：默认值，它是kubernetes系统自动分配的虚拟IP，只能在集群内部访问。</li>\n<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务。</li>\n<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境的支持。</li>\n<li>ExternalName：把集群外部的服务引入集群内部，直接使用。</li>\n</ul>\n<h2 id=\"5-1-ClusterIP类型的Service\"><a href=\"#5-1-ClusterIP类型的Service\" class=\"headerlink\" title=\"5.1 ClusterIP类型的Service\"></a>5.1 ClusterIP类型的Service</h2><h2 id=\"5-2-HeadLiness类型的Service\"><a href=\"#5-2-HeadLiness类型的Service\" class=\"headerlink\" title=\"5.2 HeadLiness类型的Service\"></a>5.2 HeadLiness类型的Service</h2><h2 id=\"5-3-NodePort类型的Service\"><a href=\"#5-3-NodePort类型的Service\" class=\"headerlink\" title=\"5.3 NodePort类型的Service\"></a>5.3 NodePort类型的Service</h2><h2 id=\"5-4-LoadBalancer类型的Service\"><a href=\"#5-4-LoadBalancer类型的Service\" class=\"headerlink\" title=\"5.4 LoadBalancer类型的Service\"></a>5.4 LoadBalancer类型的Service</h2><h2 id=\"5-5-ExternalName类型的Service\"><a href=\"#5-5-ExternalName类型的Service\" class=\"headerlink\" title=\"5.5 ExternalName类型的Service\"></a>5.5 ExternalName类型的Service</h2><h2 id=\"5-1-Ingress介绍\"><a href=\"#5-1-Ingress介绍\" class=\"headerlink\" title=\"5.1 Ingress介绍\"></a>5.1 Ingress介绍</h2><h1 id=\"6-k8s的数据存储\"><a href=\"#6-k8s的数据存储\" class=\"headerlink\" title=\"6 k8s的数据存储\"></a>6 k8s的数据存储</h1><ul>\n<li>在前面已经提到，容器的生命周期可能很短，会被频繁的创建和销毁。那么容器在销毁的时候，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器中的数据，kubernetes引入了Volume的概念。</li>\n<li>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命周期不和Pod中的单个容器的生命周期有关，当容器终止或者重启的时候，Volume中的数据也不会丢失。</li>\n<li>kubernetes的Volume支持多种类型，比较常见的有下面的几个：<ul>\n<li>简单存储：EmptyDir、HostPath、NFS。</li>\n<li>高级存储：PV、PVC。</li>\n<li>配置存储：ConfigMap、Secret。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-1-基本存储\"><a href=\"#6-1-基本存储\" class=\"headerlink\" title=\"6.1 基本存储\"></a>6.1 基本存储</h2><h3 id=\"6-1-1-EmptyDir\"><a href=\"#6-1-1-EmptyDir\" class=\"headerlink\" title=\"6.1.1 EmptyDir\"></a>6.1.1 EmptyDir</h3><h3 id=\"6-1-2-HostPath\"><a href=\"#6-1-2-HostPath\" class=\"headerlink\" title=\"6.1.2 HostPath\"></a>6.1.2 HostPath</h3><h3 id=\"6-1-3-NFS\"><a href=\"#6-1-3-NFS\" class=\"headerlink\" title=\"6.1.3 NFS\"></a>6.1.3 NFS</h3><h2 id=\"6-2-高级存储\"><a href=\"#6-2-高级存储\" class=\"headerlink\" title=\"6.2 高级存储\"></a>6.2 高级存储</h2><h3 id=\"6-1-2-PV\"><a href=\"#6-1-2-PV\" class=\"headerlink\" title=\"6.1.2 PV\"></a>6.1.2 PV</h3><h3 id=\"6-1-3-PVC\"><a href=\"#6-1-3-PVC\" class=\"headerlink\" title=\"6.1.3 PVC\"></a>6.1.3 PVC</h3><h2 id=\"6-3-配置存储\"><a href=\"#6-3-配置存储\" class=\"headerlink\" title=\"6.3 配置存储\"></a>6.3 配置存储</h2><h3 id=\"6-1-2-ConfigMap\"><a href=\"#6-1-2-ConfigMap\" class=\"headerlink\" title=\"6.1.2 ConfigMap\"></a>6.1.2 ConfigMap</h3><h3 id=\"6-1-3-Secret\"><a href=\"#6-1-3-Secret\" class=\"headerlink\" title=\"6.1.3 Secret\"></a>6.1.3 Secret</h3><h1 id=\"7-高级部分（暂时不准备做）\"><a href=\"#7-高级部分（暂时不准备做）\" class=\"headerlink\" title=\"7 高级部分（暂时不准备做）\"></a>7 高级部分（暂时不准备做）</h1><h2 id=\"k8s的Helm\"><a href=\"#k8s的Helm\" class=\"headerlink\" title=\"k8s的Helm\"></a>k8s的Helm</h2><h2 id=\"k8s的安全认证\"><a href=\"#k8s的安全认证\" class=\"headerlink\" title=\"k8s的安全认证\"></a>k8s的安全认证</h2><h2 id=\"搭建DashBoard\"><a href=\"#搭建DashBoard\" class=\"headerlink\" title=\"搭建DashBoard\"></a>搭建DashBoard</h2><h2 id=\"kubeadm安装高可用k8s集群\"><a href=\"#kubeadm安装高可用k8s集群\" class=\"headerlink\" title=\"kubeadm安装高可用k8s集群\"></a>kubeadm安装高可用k8s集群</h2><h2 id=\"k8s的项目部署\"><a href=\"#k8s的项目部署\" class=\"headerlink\" title=\"k8s的项目部署\"></a>k8s的项目部署</h2>","slug":"Course/k8s-commad","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/09/25/Course/k8s-commad/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"VScode 环境安装","date":"22/09/2022","path":"2022/09/22/Environment-Configuration/vscode-install-tutorial/","text":"一、官网下载vscode二、安装安装的时候记得把将”通过 code打开”操作添加到 Windows资源管理器文件上下文菜单打钩 三、常用的扩展 扩展名 功能 通用的 Chinese (Simplified) (简体中文) 中文翻译 Code Runner 展开全部代码 Markdown Preview Enhanced Markdown查看 C++相关 C&#x2F;C++ 写C++代码 C&#x2F;C++ Extension CMake CMake Tools C&#x2F;C++ Extension Pack HTML Auto Rename Tag 自动修改前后标签名 open in browser 在浏览器中打开 CSS Peek 追踪CSS样式 HTML CSS Support HTML样式支持 Git Git History 查看git历史提交记录 GitLens GoLang go 语法支持 vscode-proto3 查看protobuf格式 Jinja2 Jinja jinja语法支持 Shell shell-format 格式化工具 shellman 代码提示工具 远程控制 Remote - SSH 远程ssh连接 Remote - Containers Remote - SSH: Editing Configuration Files 五、配置c&#x2F;c++环境 安装mingw ctl+shift+PC&#x2F;C++: Edit Configurations (UI)编译器路径D:\\MinGW\\bin\\gcc.exe c++调试的原理 先使用tasks.json来创建一个任务 tasks.json文件可以对程序进行编译，对于C++来说，可以使用gcc,g++,make,cmake,shell脚本 可以先测试task能否正常运行，这一步的测试就是测试程序是否能编译通过 通过launch.json调用想要使用的任务这是启动vscode的调试功能需要做一些配置再启动gdb调试器来进行调试 添加c_cpp_properties.json增加C++的语言支持 使用步骤创建一个.vscode文件夹 1.tasks.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;cplusplustest&quot;, //任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置 &quot;type&quot;: &quot;shell&quot;, // &quot;command&quot;: &quot;g++ ./123.cpp -o 123 -g -std=c++11&quot;, // 可以使用一行命令的方法，不需要下面添加参数 &quot;command&quot;: &quot;g++&quot;, // 或者就只写g++,下面添加参数 // &quot;args&quot;: [//编译时候的参数 // &quot;./123.cpp&quot;, // 想要调试的文件，可以写相对路径也可以写绝对路径 // &quot;-o&quot;, // 指定生成可执行文件的名称 // &quot;debug.exe&quot;, // 如果不加后缀名，自动会添加.exe // &quot;-g&quot;, // 添加gdb调试选项 // &quot;-std=c++11&quot; // 使用C++11标准 // ], &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, // 自动查找当前执行的文件 &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, // 设置生成的文件名，可以为中文 &quot;-std=c++11&quot;, // &quot;-fexec-charset=GBK&quot; //解决中文乱码问题,还没有遇到过 ], &quot;problemMatcher&quot;: &#123; // &quot;owner&quot;: &quot;cpp&quot;, // &quot;fileLocation&quot;: [ // &quot;relative&quot;, // &quot;$&#123;workspaceRoot&#125;&quot; // ], // &quot;pattern&quot;: &#123; // &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, // &quot;file&quot;: 1, // &quot;line&quot;: 2, // &quot;column&quot;: 3, // &quot;severity&quot;: 4, // &quot;message&quot;: 5 // &#125; &#125;, // 问题分析器,还不太会用 &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true //表示快捷键Ctrl+Shift+B可以运行该任务 &#125;, &#125; ]&#125; 2.launch.json12345678910111213141516171819202122232425262728293031323334&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;preLaunchTask&quot;: &quot;cplusplustest&quot;, //调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 &quot;name&quot;: &quot;(gdb) Debug&quot;, //配置文件的名字，可以随便起 &quot;type&quot;: &quot;cppdbg&quot;, //调试的类型，Vscode现在支持很多，我这里主要是C，所以只能是cppdbg &quot;request&quot;: &quot;launch&quot;, //配置文件的请求类型，有launch和attach两种，具体看官方文档 &quot;targetArchitecture&quot;: &quot;x64&quot;, //硬件内核架构，为64bit，如图设置 // &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/123.exe&quot;, //可执行文件的路径和文件名称 &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, //可执行文件的路径和文件名称 // 整个路径名中，必须全部是是英文名称才可以进行调试 &quot;args&quot;: [], //主函数调用时传入的参数 &quot;stopAtEntry&quot;: false, //设为true时程序将暂停在程序入口处 &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/1-Algorithm_test&quot;, //调试时的工作目录 &quot;environment&quot;: [], //不知道干嘛的 &quot;internalConsoleOptions&quot;: &quot;openOnSessionStart&quot;, &quot;externalConsole&quot;: false, //调试时是否显示控制台窗口 &quot;MIMode&quot;: &quot;gdb&quot;, //指定连接的调试器，可以省略不写 &quot;miDebuggerPath&quot;: &quot;D:/Qt/Qt5.9.9/Tools/mingw530_32/bin/gdb.exe&quot;, // 在windows调试的时候，需要加上gdb的路径 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; 3.c_cpp_properties.json12345678910111213141516171819202122232425262728293031323334// https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference//.vscode文件夹局部的配置c_cpp_properties.json&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ // 这个是使用头文件时候vscode查找的路径，如果路径没有包含进来，头文件会有红色波浪线 &quot;$&#123;workspaceFolder&#125;/**&quot;, // 当前工作目录下包含的所有文件 &quot;/vcpkg/x64-linux/installed/x64-linux/include/**&quot;, // 路径错误或者不存在看起来可以运行 &quot;D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**&quot; ], &quot;defines&quot;: [// 这里定义的头文件在程序中使用的时候，#ifndef的内容不会灰色 &quot;F_OS_LINUX&quot;, &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot;, &quot;LOCAL&quot; ], &quot;cStandard&quot;: &quot;c17&quot;, // 指定c语言使用的语法版本 &quot;cppStandard&quot;: &quot;c++17&quot;, // 指定c++使用的语法版本 &quot;intelliSenseMode&quot;: &quot;linux-gcc-x64&quot;, // 使用智能感知模式(IntelliSense)，映射到特定的体系 // &quot;intelliSenseMode&quot;: &quot;windows-gcc-x86&quot;, // windows中使用的配置 &quot;browse&quot;: &#123; // 浏览选项，主要用在转跳#include文件的时候，可以做一些模糊搜索 &quot;path&quot;: [ // 需要查找的路径 &quot;$&#123;workspaceFolder&#125;&quot;, &quot;D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**&quot;, ], &quot;limitSymbolsToIncludedHeaders&quot;: true, // 如果为true,只解析$&#123;workspaceFolder&#125;中的文件，false还会解析browse中的文件，存疑 &quot;databaseFilename&quot;: &quot;&quot; &#125; &#125; ], &quot;version&quot;: 4&#125; 关于调试的一些疑问 使用了C++11的语法，但是C++11的语句，比如auto还是会报错c_cpp_properties.json中添加12&quot;cStandard&quot;: &quot;c17&quot;,&quot;cppStandard&quot;: &quot;c++17&quot;, 使用了外部的库，比如opencv,QThread等库的时候，编译可以通过但是无法转跳没有在include中增加包含库的路径 四、卸载C:\\Users$用户名.vscodeC:\\Users$用户名\\AppData\\Roaming\\Code【注】这里的“$用户名”根据自己的用户名而定。 参考文献mingw安装教程VSCode 任务配置参数及任务结果分析-problemMatcher[VSCode配置C&#x2F;C++环境]https://zhuanlan.zhihu.com/p/87864677[VScode配置c&#x2F;c++环境（无数试错版本）]https://blog.csdn.net/Pretty_Anno/article/details/126978142[windwos11没有Hyper-V的解决方法]https://www.jianshu.com/p/96aa6eeacb56","raw":"---\ntitle: VScode 环境安装\ndate: 2022-09-22 16:30:31\ntags:\n- 环境配置\n---\n\n# 一、官网下载vscode\n\n# 二、安装\n\n安装的时候记得把\n将\"通过 code打开\"操作添加到 Windows资源管理器文件上下文菜单\n打钩\n\n# 三、常用的扩展\n\n| 扩展名 | 功能 | \n| ---- | ---- | \n| **通用的** | \n| Chinese (Simplified) (简体中文) | 中文翻译 | \n| Code Runner | 展开全部代码 | \n| Markdown Preview Enhanced | Markdown查看 | \n| C++相关 | |\n| **C/C++**| 写C++代码 | \n| C/C++ Extension | | \n| CMake |  | \n| CMake Tools |  | \n| C/C++ Extension Pack |  | \n| **HTML** | |\n| Auto Rename Tag | 自动修改前后标签名 | \n| open in browser | 在浏览器中打开 | \n| CSS Peek | 追踪CSS样式 | \n| HTML CSS Support | HTML样式支持 | \n| **Git** | |\n| Git History | 查看git历史提交记录 | \n| GitLens  |  | \n| **GoLang** | |\n| go | 语法支持 | \n| vscode-proto3  | 查看protobuf格式 | \n| **Jinja2** | |\n| Jinja | jinja语法支持 | \n| **Shell** | |\n| shell-format | 格式化工具 | \n| shellman | 代码提示工具 | \n| **远程控制** | |\n| Remote - SSH | 远程ssh连接 | \n| Remote - Containers |  | \n|Remote - SSH: Editing Configuration Files | |\n\n\n# 五、配置c/c++环境\n\n1. 安装mingw\n2. ctl+shift+P\nC/C++: Edit Configurations (UI)\n编译器路径\nD:\\MinGW\\bin\\gcc.exe\n\n## c++调试的原理\n1. 先使用tasks.json来创建一个任务\n- tasks.json文件可以对程序进行编译，对于C++来说，可以使用gcc,g++,make,cmake,shell脚本\n- 可以先测试task能否正常运行，这一步的测试就是测试程序是否能编译通过\n2. 通过launch.json调用想要使用的任务\n这是启动vscode的调试功能\n需要做一些配置\n再启动gdb调试器来进行调试\n3. 添加c_cpp_properties.json增加C++的语言支持\n\n## 使用步骤\n创建一个.vscode文件夹\n\n### 1.tasks.json\n```json\n{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558 \n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"cplusplustest\",   //任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置\n            \"type\": \"shell\",\n            // \"command\": \"g++ ./123.cpp -o 123 -g -std=c++11\", // 可以使用一行命令的方法，不需要下面添加参数\n            \"command\": \"g++\",   // 或者就只写g++,下面添加参数\n            // \"args\": [//编译时候的参数\n            //     \"./123.cpp\",    // 想要调试的文件，可以写相对路径也可以写绝对路径\n            //     \"-o\",           // 指定生成可执行文件的名称\n            //     \"debug.exe\",    // 如果不加后缀名，自动会添加.exe\n            //     \"-g\",           // 添加gdb调试选项\n            //     \"-std=c++11\"    // 使用C++11标准\n            // ],\n            \"args\": [\n                \"-g\",\n                \"${file}\",   // 自动查找当前执行的文件\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",   // 设置生成的文件名，可以为中文\n                \"-std=c++11\",\n                // \"-fexec-charset=GBK\" //解决中文乱码问题,还没有遇到过\n            ],\n            \"problemMatcher\": {\n                // \"owner\": \"cpp\",\n                // \"fileLocation\": [\n                //     \"relative\",\n                //     \"${workspaceRoot}\"\n                // ],\n                // \"pattern\": {\n                //     \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",\n                //     \"file\": 1,\n                //     \"line\": 2,\n                //     \"column\": 3,\n                //     \"severity\": 4,\n                //     \"message\": 5\n                // }\n            },   // 问题分析器,还不太会用\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true   //表示快捷键Ctrl+Shift+B可以运行该任务\n            },\n        }\n    ]\n}\n\n```\n\n### 2.launch.json\n```json\n{\n    // 使用 IntelliSense 了解相关属性。\n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"preLaunchTask\": \"cplusplustest\", //调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应\n            \"name\": \"(gdb) Debug\",       //配置文件的名字，可以随便起\n            \"type\": \"cppdbg\",           //调试的类型，Vscode现在支持很多，我这里主要是C，所以只能是cppdbg\n            \"request\": \"launch\",        //配置文件的请求类型，有launch和attach两种，具体看官方文档\n            \"targetArchitecture\": \"x64\", //硬件内核架构，为64bit，如图设置\n            // \"program\": \"${workspaceFolder}/123.exe\",   //可执行文件的路径和文件名称\n            \"program\": \"${fileDirname}/${fileBasenameNoExtension}.exe\",   //可执行文件的路径和文件名称\n            // 整个路径名中，必须全部是是英文名称才可以进行调试\n            \"args\": [],                 //主函数调用时传入的参数\n            \"stopAtEntry\": false,       //设为true时程序将暂停在程序入口处\n            \"cwd\": \"${workspaceFolder}/1-Algorithm_test\",    //调试时的工作目录\n            \"environment\": [],          //不知道干嘛的\n            \"internalConsoleOptions\": \"openOnSessionStart\",\n            \"externalConsole\": false,   //调试时是否显示控制台窗口\n            \"MIMode\": \"gdb\",            //指定连接的调试器，可以省略不写\n            \"miDebuggerPath\": \"D:/Qt/Qt5.9.9/Tools/mingw530_32/bin/gdb.exe\",    // 在windows调试的时候，需要加上gdb的路径\n            \"setupCommands\": [\n                {\n                    \"description\": \"为 gdb 启用整齐打印\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ]\n        }\n    ]\n}\n\n```\n\n### 3.c_cpp_properties.json\n```json\n// https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference\n//.vscode文件夹局部的配置c_cpp_properties.json\n{\n    \"configurations\": [\n        {\n            \"name\": \"Linux\",\n            \"includePath\": [            // 这个是使用头文件时候vscode查找的路径，如果路径没有包含进来，头文件会有红色波浪线\n                \"${workspaceFolder}/**\", // 当前工作目录下包含的所有文件\n                \"/vcpkg/x64-linux/installed/x64-linux/include/**\",  // 路径错误或者不存在看起来可以运行\n                \"D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**\"\n            ],\n            \"defines\": [// 这里定义的头文件在程序中使用的时候，#ifndef的内容不会灰色\n                \"F_OS_LINUX\",         \n                \"_DEBUG\",\n                \"UNICODE\",\n                \"_UNICODE\",\n                \"LOCAL\"\n            ],\n            \"cStandard\": \"c17\",       // 指定c语言使用的语法版本\n            \"cppStandard\": \"c++17\",   // 指定c++使用的语法版本\n            \"intelliSenseMode\": \"linux-gcc-x64\", // 使用智能感知模式(IntelliSense)，映射到特定的体系\n            // \"intelliSenseMode\": \"windows-gcc-x86\",   // windows中使用的配置\n            \"browse\": { // 浏览选项，主要用在转跳#include文件的时候，可以做一些模糊搜索\n                \"path\": [   // 需要查找的路径\n                    \"${workspaceFolder}\",\n                    \"D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**\",\n                ],\n                \"limitSymbolsToIncludedHeaders\": true,  // 如果为true,只解析${workspaceFolder}中的文件，false还会解析browse中的文件，存疑\n                \"databaseFilename\": \"\"\n            }\n        }\n    ],\n    \"version\": 4\n}\n```\n\n\n### 关于调试的一些疑问\n1. 使用了C++11的语法，但是C++11的语句，比如auto还是会报错\nc_cpp_properties.json中添加\n```json\n\"cStandard\": \"c17\",\n\"cppStandard\": \"c++17\",\n```\n2. 使用了外部的库，比如opencv,QThread等库的时候，编译可以通过但是无法转跳\n没有在include中增加包含库的路径\n\n# 四、卸载\nC:\\Users\\$用户名\\.vscode\nC:\\Users\\$用户名\\AppData\\Roaming\\Code【注】这里的“$用户名”根据自己的用户名而定。\n\n# 参考文献\n[mingw安装教程](https://www.cnblogs.com/LIJIH/p/12533926.html#:~:text=%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85mingw%E8%BD%AF%E4%BB%B6%201.%20%E8%BF%9B%E5%85%A5%E5%AE%98%E7%BD%91%20www.mingw.org%202.%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BDdownloads%203.%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E5%9B%BE%E6%A0%87%204.%E7%82%B9%E5%87%BBinstall%20z,Changes%204.%E7%82%B9%E5%87%BBapply%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%205.%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%9C%A8%E7%82%B9%E5%87%BBclose%E5%85%B3%E9%97%AD%E8%BD%AF%E4%BB%B6%EF%BC%8C%E5%88%B0%E8%BF%99%E9%87%8Cmingw%E5%B0%B1%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E4%BA%86%E3%80%82%20%E4%B8%8B%E9%9D%A2%E5%B0%B1%E6%98%AF%E9%85%8D%E7%BD%AE%20%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%201%E9%80%89%E6%8B%A9%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%EF%BC%8C%E5%8F%B3%E9%94%AE%E9%80%89%E6%8B%A9%E5%B1%9E%E6%80%A7%202.%E9%80%89%E6%8B%A9%E9%AB%98%E7%BA%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%203.%E9%80%89%E6%8B%A9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n[VSCode 任务配置参数及任务结果分析-problemMatcher](https://geek-docs.com/vscode/vscode-tutorials/vscode-task-configuration-parameters-and-task-results-analysis.html#:~:text=%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E7%94%B1%20tasks.json%20%E9%87%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%20problemMatcher,%E6%9D%A5%E6%8E%A7%E5%88%B6%E7%9A%84%E3%80%82%20%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%20VS%20Code%20%E5%86%85%E7%BD%AE%E7%9A%84%EF%BC%8C%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%8C%E7%94%9A%E8%87%B3%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E4%B9%A6%E5%86%99%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%99%A8%E6%9D%A5%E5%88%86%E6%9E%90%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E5%85%B6%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%E6%88%96%E8%80%85%E8%AD%A6%E5%91%8A%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%9C%A8%E9%97%AE%E9%A2%98%E9%9D%A2%E6%9D%BF%E4%B8%AD%E3%80%82)\n[VSCode配置C/C++环境]https://zhuanlan.zhihu.com/p/87864677\n[VScode配置c/c++环境（无数试错版本）]https://blog.csdn.net/Pretty_Anno/article/details/126978142\n[windwos11没有Hyper-V的解决方法]https://www.jianshu.com/p/96aa6eeacb56\n\n\n\n","content":"<h1 id=\"一、官网下载vscode\"><a href=\"#一、官网下载vscode\" class=\"headerlink\" title=\"一、官网下载vscode\"></a>一、官网下载vscode</h1><h1 id=\"二、安装\"><a href=\"#二、安装\" class=\"headerlink\" title=\"二、安装\"></a>二、安装</h1><p>安装的时候记得把<br>将”通过 code打开”操作添加到 Windows资源管理器文件上下文菜单<br>打钩</p>\n<h1 id=\"三、常用的扩展\"><a href=\"#三、常用的扩展\" class=\"headerlink\" title=\"三、常用的扩展\"></a>三、常用的扩展</h1><table>\n<thead>\n<tr>\n<th>扩展名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>通用的</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Chinese (Simplified) (简体中文)</td>\n<td>中文翻译</td>\n</tr>\n<tr>\n<td>Code Runner</td>\n<td>展开全部代码</td>\n</tr>\n<tr>\n<td>Markdown Preview Enhanced</td>\n<td>Markdown查看</td>\n</tr>\n<tr>\n<td>C++相关</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>C&#x2F;C++</strong></td>\n<td>写C++代码</td>\n</tr>\n<tr>\n<td>C&#x2F;C++ Extension</td>\n<td></td>\n</tr>\n<tr>\n<td>CMake</td>\n<td></td>\n</tr>\n<tr>\n<td>CMake Tools</td>\n<td></td>\n</tr>\n<tr>\n<td>C&#x2F;C++ Extension Pack</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>HTML</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Auto Rename Tag</td>\n<td>自动修改前后标签名</td>\n</tr>\n<tr>\n<td>open in browser</td>\n<td>在浏览器中打开</td>\n</tr>\n<tr>\n<td>CSS Peek</td>\n<td>追踪CSS样式</td>\n</tr>\n<tr>\n<td>HTML CSS Support</td>\n<td>HTML样式支持</td>\n</tr>\n<tr>\n<td><strong>Git</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Git History</td>\n<td>查看git历史提交记录</td>\n</tr>\n<tr>\n<td>GitLens</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>GoLang</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>go</td>\n<td>语法支持</td>\n</tr>\n<tr>\n<td>vscode-proto3</td>\n<td>查看protobuf格式</td>\n</tr>\n<tr>\n<td><strong>Jinja2</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Jinja</td>\n<td>jinja语法支持</td>\n</tr>\n<tr>\n<td><strong>Shell</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>shell-format</td>\n<td>格式化工具</td>\n</tr>\n<tr>\n<td>shellman</td>\n<td>代码提示工具</td>\n</tr>\n<tr>\n<td><strong>远程控制</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Remote - SSH</td>\n<td>远程ssh连接</td>\n</tr>\n<tr>\n<td>Remote - Containers</td>\n<td></td>\n</tr>\n<tr>\n<td>Remote - SSH: Editing Configuration Files</td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"五、配置c-x2F-c-环境\"><a href=\"#五、配置c-x2F-c-环境\" class=\"headerlink\" title=\"五、配置c&#x2F;c++环境\"></a>五、配置c&#x2F;c++环境</h1><ol>\n<li>安装mingw</li>\n<li>ctl+shift+P<br>C&#x2F;C++: Edit Configurations (UI)<br>编译器路径<br>D:\\MinGW\\bin\\gcc.exe</li>\n</ol>\n<h2 id=\"c-调试的原理\"><a href=\"#c-调试的原理\" class=\"headerlink\" title=\"c++调试的原理\"></a>c++调试的原理</h2><ol>\n<li>先使用tasks.json来创建一个任务</li>\n</ol>\n<ul>\n<li>tasks.json文件可以对程序进行编译，对于C++来说，可以使用gcc,g++,make,cmake,shell脚本</li>\n<li>可以先测试task能否正常运行，这一步的测试就是测试程序是否能编译通过</li>\n</ul>\n<ol start=\"2\">\n<li>通过launch.json调用想要使用的任务<br>这是启动vscode的调试功能<br>需要做一些配置<br>再启动gdb调试器来进行调试</li>\n<li>添加c_cpp_properties.json增加C++的语言支持</li>\n</ol>\n<h2 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h2><p>创建一个.vscode文件夹</p>\n<h3 id=\"1-tasks-json\"><a href=\"#1-tasks-json\" class=\"headerlink\" title=\"1.tasks.json\"></a>1.tasks.json</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span></span><br><span class=\"line\">    <span class=\"comment\">// for the documentation about the tasks.json format</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tasks&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;label&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cplusplustest&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">//任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;shell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;command&quot;: &quot;g++ ./123.cpp -o 123 -g -std=c++11&quot;, // 可以使用一行命令的方法，不需要下面添加参数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;g++&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 或者就只写g++,下面添加参数</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;args&quot;: [//编译时候的参数</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;./123.cpp&quot;,    // 想要调试的文件，可以写相对路径也可以写绝对路径</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;-o&quot;,           // 指定生成可执行文件的名称</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;debug.exe&quot;,    // 如果不加后缀名，自动会添加.exe</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;-g&quot;,           // 添加gdb调试选项</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;-std=c++11&quot;    // 使用C++11标准</span></span><br><span class=\"line\">            <span class=\"comment\">// ],</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-g&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;file&#125;&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 自动查找当前执行的文件</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-o&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 设置生成的文件名，可以为中文</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-std=c++11&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"comment\">// &quot;-fexec-charset=GBK&quot; //解决中文乱码问题,还没有遇到过</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;problemMatcher&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"comment\">// &quot;owner&quot;: &quot;cpp&quot;,</span></span><br><span class=\"line\">                <span class=\"comment\">// &quot;fileLocation&quot;: [</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;relative&quot;,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;$&#123;workspaceRoot&#125;&quot;</span></span><br><span class=\"line\">                <span class=\"comment\">// ],</span></span><br><span class=\"line\">                <span class=\"comment\">// &quot;pattern&quot;: &#123;</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;file&quot;: 1,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;line&quot;: 2,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;column&quot;: 3,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;severity&quot;: 4,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;message&quot;: 5</span></span><br><span class=\"line\">                <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 问题分析器,还不太会用</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;group&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;kind&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;build&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;isDefault&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">true</span>   <span class=\"comment\">//表示快捷键Ctrl+Shift+B可以运行该任务</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-launch-json\"><a href=\"#2-launch-json\" class=\"headerlink\" title=\"2.launch.json\"></a>2.launch.json</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用 IntelliSense 了解相关属性。</span></span><br><span class=\"line\">    <span class=\"comment\">// 悬停以查看现有属性的描述。</span></span><br><span class=\"line\">    <span class=\"comment\">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.2.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;preLaunchTask&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cplusplustest&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">//调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;(gdb) Debug&quot;</span><span class=\"punctuation\">,</span>       <span class=\"comment\">//配置文件的名字，可以随便起</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cppdbg&quot;</span><span class=\"punctuation\">,</span>           <span class=\"comment\">//调试的类型，Vscode现在支持很多，我这里主要是C，所以只能是cppdbg</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;request&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;launch&quot;</span><span class=\"punctuation\">,</span>        <span class=\"comment\">//配置文件的请求类型，有launch和attach两种，具体看官方文档</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;targetArchitecture&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;x64&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">//硬件内核架构，为64bit，如图设置</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/123.exe&quot;,   //可执行文件的路径和文件名称</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;program&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">//可执行文件的路径和文件名称</span></span><br><span class=\"line\">            <span class=\"comment\">// 整个路径名中，必须全部是是英文名称才可以进行调试</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>                 <span class=\"comment\">//主函数调用时传入的参数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;stopAtEntry&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">false</span><span class=\"punctuation\">,</span>       <span class=\"comment\">//设为true时程序将暂停在程序入口处</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cwd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;workspaceFolder&#125;/1-Algorithm_test&quot;</span><span class=\"punctuation\">,</span>    <span class=\"comment\">//调试时的工作目录</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;environment&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>          <span class=\"comment\">//不知道干嘛的</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;internalConsoleOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;openOnSessionStart&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;externalConsole&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">false</span><span class=\"punctuation\">,</span>   <span class=\"comment\">//调试时是否显示控制台窗口</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;MIMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gdb&quot;</span><span class=\"punctuation\">,</span>            <span class=\"comment\">//指定连接的调试器，可以省略不写</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;miDebuggerPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/Qt/Qt5.9.9/Tools/mingw530_32/bin/gdb.exe&quot;</span><span class=\"punctuation\">,</span>    <span class=\"comment\">// 在windows调试的时候，需要加上gdb的路径</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;setupCommands&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;为 gdb 启用整齐打印&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;text&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;-enable-pretty-printing&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;ignoreFailures&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">true</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-c-cpp-properties-json\"><a href=\"#3-c-cpp-properties-json\" class=\"headerlink\" title=\"3.c_cpp_properties.json\"></a>3.c_cpp_properties.json</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference</span></span><br><span class=\"line\"><span class=\"comment\">//.vscode文件夹局部的配置c_cpp_properties.json</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Linux&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;includePath&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span>            <span class=\"comment\">// 这个是使用头文件时候vscode查找的路径，如果路径没有包含进来，头文件会有红色波浪线</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 当前工作目录下包含的所有文件</span></span><br><span class=\"line\">                <span class=\"string\">&quot;/vcpkg/x64-linux/installed/x64-linux/include/**&quot;</span><span class=\"punctuation\">,</span>  <span class=\"comment\">// 路径错误或者不存在看起来可以运行</span></span><br><span class=\"line\">                <span class=\"string\">&quot;D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;defines&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"comment\">// 这里定义的头文件在程序中使用的时候，#ifndef的内容不会灰色</span></span><br><span class=\"line\">                <span class=\"string\">&quot;F_OS_LINUX&quot;</span><span class=\"punctuation\">,</span>         </span><br><span class=\"line\">                <span class=\"string\">&quot;_DEBUG&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;UNICODE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;_UNICODE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;LOCAL&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c17&quot;</span><span class=\"punctuation\">,</span>       <span class=\"comment\">// 指定c语言使用的语法版本</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cppStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c++17&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 指定c++使用的语法版本</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;intelliSenseMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;linux-gcc-x64&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 使用智能感知模式(IntelliSense)，映射到特定的体系</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;intelliSenseMode&quot;: &quot;windows-gcc-x86&quot;,   // windows中使用的配置</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;browse&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> <span class=\"comment\">// 浏览选项，主要用在转跳#include文件的时候，可以做一些模糊搜索</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;path&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span>   <span class=\"comment\">// 需要查找的路径</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;limitSymbolsToIncludedHeaders&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">true</span><span class=\"punctuation\">,</span>  <span class=\"comment\">// 如果为true,只解析$&#123;workspaceFolder&#125;中的文件，false还会解析browse中的文件，存疑</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;databaseFilename&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"关于调试的一些疑问\"><a href=\"#关于调试的一些疑问\" class=\"headerlink\" title=\"关于调试的一些疑问\"></a>关于调试的一些疑问</h3><ol>\n<li>使用了C++11的语法，但是C++11的语句，比如auto还是会报错<br>c_cpp_properties.json中添加<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;cStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c17&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;cppStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c++17&quot;</span><span class=\"punctuation\">,</span></span><br></pre></td></tr></table></figure></li>\n<li>使用了外部的库，比如opencv,QThread等库的时候，编译可以通过但是无法转跳<br>没有在include中增加包含库的路径</li>\n</ol>\n<h1 id=\"四、卸载\"><a href=\"#四、卸载\" class=\"headerlink\" title=\"四、卸载\"></a>四、卸载</h1><p>C:\\Users$用户名.vscode<br>C:\\Users$用户名\\AppData\\Roaming\\Code【注】这里的“$用户名”根据自己的用户名而定。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://www.cnblogs.com/LIJIH/p/12533926.html#:~:text=%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85mingw%E8%BD%AF%E4%BB%B6%201.%20%E8%BF%9B%E5%85%A5%E5%AE%98%E7%BD%91%20www.mingw.org%202.%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BDdownloads%203.%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E5%9B%BE%E6%A0%87%204.%E7%82%B9%E5%87%BBinstall%20z,Changes%204.%E7%82%B9%E5%87%BBapply%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%205.%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%9C%A8%E7%82%B9%E5%87%BBclose%E5%85%B3%E9%97%AD%E8%BD%AF%E4%BB%B6%EF%BC%8C%E5%88%B0%E8%BF%99%E9%87%8Cmingw%E5%B0%B1%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E4%BA%86%E3%80%82%20%E4%B8%8B%E9%9D%A2%E5%B0%B1%E6%98%AF%E9%85%8D%E7%BD%AE%20%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%201%E9%80%89%E6%8B%A9%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%EF%BC%8C%E5%8F%B3%E9%94%AE%E9%80%89%E6%8B%A9%E5%B1%9E%E6%80%A7%202.%E9%80%89%E6%8B%A9%E9%AB%98%E7%BA%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%203.%E9%80%89%E6%8B%A9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">mingw安装教程</a><br><a href=\"https://geek-docs.com/vscode/vscode-tutorials/vscode-task-configuration-parameters-and-task-results-analysis.html#:~:text=%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E7%94%B1%20tasks.json%20%E9%87%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%20problemMatcher,%E6%9D%A5%E6%8E%A7%E5%88%B6%E7%9A%84%E3%80%82%20%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%20VS%20Code%20%E5%86%85%E7%BD%AE%E7%9A%84%EF%BC%8C%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%8C%E7%94%9A%E8%87%B3%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E4%B9%A6%E5%86%99%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%99%A8%E6%9D%A5%E5%88%86%E6%9E%90%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E5%85%B6%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%E6%88%96%E8%80%85%E8%AD%A6%E5%91%8A%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%9C%A8%E9%97%AE%E9%A2%98%E9%9D%A2%E6%9D%BF%E4%B8%AD%E3%80%82\">VSCode 任务配置参数及任务结果分析-problemMatcher</a><br>[VSCode配置C&#x2F;C++环境]<a href=\"https://zhuanlan.zhihu.com/p/87864677\">https://zhuanlan.zhihu.com/p/87864677</a><br>[VScode配置c&#x2F;c++环境（无数试错版本）]<a href=\"https://blog.csdn.net/Pretty_Anno/article/details/126978142\">https://blog.csdn.net/Pretty_Anno/article/details/126978142</a><br>[windwos11没有Hyper-V的解决方法]<a href=\"https://www.jianshu.com/p/96aa6eeacb56\">https://www.jianshu.com/p/96aa6eeacb56</a></p>\n","slug":"Environment-Configuration/vscode-install-tutorial","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/09/22/Environment-Configuration/vscode-install-tutorial/","excerpt":"","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"leetcode题目分类","date":"19/09/2022","path":"2022/09/19/Interview-Q&A/leetcode-programe/","text":"字典树(Trie树、前缀树)模板题 实现 Trie (前缀树) 单词替换 添加与搜索单词 - 数据结构设计 键值映射 实现一个魔法字典 前缀和后缀搜索 字符串的前缀分数和 进阶：01字典树 环检测 &amp; 拓扑排序 课程表 课程表 II剑指 Offer II 115. 重建序列 回溯 划分为k个相等的子集 火柴拼正方形 公平分发饼干 思路：1.回溯前的准备2.要回溯什么回溯函数内3.终止条件4.进入和退出怎么搞 动态规划思路： 确定dp数组以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序5. 举例推导dp数组 写代码顺序： 边界条件（最后考虑） 初始化 遍历 递推公式 返回 测试用例的设计边界条件的测试0最大值 功能测试参考资料[详解前缀树「TrieTree 汇总级别整理 🔥🔥🔥」]https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/","raw":"---\ntitle: leetcode题目分类\ndate: 2022-09-19 10:20:27\ntags:\n- 面试\n---\n\n\n## 字典树(Trie树、前缀树)\n### 模板题\n208. 实现 Trie (前缀树)\n648. 单词替换\n\n\n211. 添加与搜索单词 - 数据结构设计\n677. 键值映射\n676. 实现一个魔法字典\n745. 前缀和后缀搜索\n6183. 字符串的前缀分数和\n\n进阶：01字典树\n\n## 环检测 & 拓扑排序\n207. 课程表\n210. 课程表 II\n剑指 Offer II 115. 重建序列\n\n\n## 回溯\n698. 划分为k个相等的子集\n473. 火柴拼正方形\n2305. 公平分发饼干\n\n\n\n思路：\n1.回溯前的准备\n2.要回溯什么\n回溯函数内\n3.终止条件\n4.进入和退出怎么搞\n\n\n\n## 动态规划\n\n\n思路：\n1. 确定dp数组以及下标的含义\n2. 确定递推公式\n3. dp数组如何初始化\n4. 确定遍历顺序\n~~5. 举例推导dp数组~~\n\n写代码顺序：\n\n0. 边界条件（最后考虑）\n1. 初始化\n2. 遍历\n3. 递推公式\n4. 返回\n\n\n\n\n\n\n## 测试用例的设计\n### 边界条件的测试\n0\n最大值\n### 功能测试\n\n# 参考资料\n[详解前缀树「TrieTree 汇总级别整理 🔥🔥🔥」]https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/","content":"<h2 id=\"字典树-Trie树、前缀树\"><a href=\"#字典树-Trie树、前缀树\" class=\"headerlink\" title=\"字典树(Trie树、前缀树)\"></a>字典树(Trie树、前缀树)</h2><h3 id=\"模板题\"><a href=\"#模板题\" class=\"headerlink\" title=\"模板题\"></a>模板题</h3><ol start=\"208\">\n<li><p>实现 Trie (前缀树)</p>\n</li>\n<li><p>单词替换</p>\n</li>\n<li><p>添加与搜索单词 - 数据结构设计</p>\n</li>\n<li><p>键值映射</p>\n</li>\n<li><p>实现一个魔法字典</p>\n</li>\n<li><p>前缀和后缀搜索</p>\n</li>\n<li><p>字符串的前缀分数和</p>\n</li>\n</ol>\n<p>进阶：01字典树</p>\n<h2 id=\"环检测-amp-拓扑排序\"><a href=\"#环检测-amp-拓扑排序\" class=\"headerlink\" title=\"环检测 &amp; 拓扑排序\"></a>环检测 &amp; 拓扑排序</h2><ol start=\"207\">\n<li>课程表</li>\n<li>课程表 II<br>剑指 Offer II 115. 重建序列</li>\n</ol>\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2><ol start=\"698\">\n<li>划分为k个相等的子集</li>\n<li>火柴拼正方形</li>\n<li>公平分发饼干</li>\n</ol>\n<p>思路：<br>1.回溯前的准备<br>2.要回溯什么<br>回溯函数内<br>3.终止条件<br>4.进入和退出怎么搞</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>思路：</p>\n<ol>\n<li>确定dp数组以及下标的含义</li>\n<li>确定递推公式</li>\n<li>dp数组如何初始化</li>\n<li>确定遍历顺序<br><del>5. 举例推导dp数组</del></li>\n</ol>\n<p>写代码顺序：</p>\n<ol start=\"0\">\n<li>边界条件（最后考虑）</li>\n<li>初始化</li>\n<li>遍历</li>\n<li>递推公式</li>\n<li>返回</li>\n</ol>\n<h2 id=\"测试用例的设计\"><a href=\"#测试用例的设计\" class=\"headerlink\" title=\"测试用例的设计\"></a>测试用例的设计</h2><h3 id=\"边界条件的测试\"><a href=\"#边界条件的测试\" class=\"headerlink\" title=\"边界条件的测试\"></a>边界条件的测试</h3><p>0<br>最大值</p>\n<h3 id=\"功能测试\"><a href=\"#功能测试\" class=\"headerlink\" title=\"功能测试\"></a>功能测试</h3><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[详解前缀树「TrieTree 汇总级别整理 🔥🔥🔥」]<a href=\"https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/\">https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/</a></p>\n","slug":"Interview-Q&A/leetcode-programe","updated":"24/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/09/19/Interview-Q&A/leetcode-programe/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"机器学习","date":"16/09/2022","path":"2022/09/16/Course/Machine_learning/","text":"[机器学习开篇之机器学习的分类]https://blog.csdn.net/Lion_Dreams/article/details/125269215[计算机视觉 - 语义分割 （semantic segmentation）]https://blog.csdn.net/baidu_41617231/article/details/107739897","raw":"---\ntitle: 机器学习\ndate: 2022-09-16 16:23:50\ntags:\n- 课程\n---\n\n\n\n\n[机器学习开篇之机器学习的分类]https://blog.csdn.net/Lion_Dreams/article/details/125269215\n[计算机视觉 - 语义分割 （semantic segmentation）]https://blog.csdn.net/baidu_41617231/article/details/107739897","content":"<p>[机器学习开篇之机器学习的分类]<a href=\"https://blog.csdn.net/Lion_Dreams/article/details/125269215\">https://blog.csdn.net/Lion_Dreams/article/details/125269215</a><br>[计算机视觉 - 语义分割 （semantic segmentation）]<a href=\"https://blog.csdn.net/baidu_41617231/article/details/107739897\">https://blog.csdn.net/baidu_41617231/article/details/107739897</a></p>\n","slug":"Course/Machine_learning","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/09/16/Course/Machine_learning/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"实习的感受","date":"15/09/2022","path":"2022/09/15/Reflection/实习的感受/","text":"主要写一写实习的感受，为以后的实习做借鉴，并且对这个事情做一些总结 领导团队服务意识1.给团队设定超过现在能力的目标，但是还是要够一够才能到达 2.团队的领导者要作为团队的服务着，需要找到团队需要解决的问题 每周需要定期开组会，复盘这周完成的情况，这周遇到的问题需要如果去解决作为领导者，需要去协调解决组员的问题并且对这周做的内容，需要有一个拓展性的提高比如现在只能开80路的，但是要求到150路，最后不断努力可以到120路一定需要定时解决问题 完成了什么，现在还有什么问题 从多个角度考虑， 设计一个系统的时候，需要先逼着自己从最大的角度去考虑，需要哪几个方面的东西，然后再去细化如果东西太大，自己想不出来，那就先想到哪个点就做哪一个 如何平衡工作和生活刚刚开始到公司的时候 6-8月份，刚开始的时候无法接受公司里面的高强度工作，那就晚上回家以后多补课， 如何解决公司中学习的知识比较杂乱的情况 平时收集一些零散的东西，到了有大段空闲的时候，可以做总结 如何的最快的熟悉一个领域如何快速学习一门新的技术或者语言是什么，这个怎么用写一些小demo，看公司里面的工程代码找一些当前用到的典型场景，困难的回答，比如go的内存分配 读研之后发现自己和本科有什么区别 如何最快最好的解决一个问题，最好使用英文查询 小公司学不到东西，如何反驳 了解公司用的技术栈，我做的是后端，那我现在做的工作，我做的工作的前面有什么，后面有什么一起来的实习生在做什么，他做的东西我会做么，他做的东西我如何实现 常常保持好奇的心态，我虽然是后端，但是对于前端的技术，对于测试，产品，运维的相关知识，都是可以了解的 你要完成现在手头上的工作，是否会遇到问题，那么遇到问题的时候，比如看到raft算法，这是底层使用的东西，如果是有心去了解，那就会有更多可以发现的东西 如果完成了手头上的工作，可以用什么样的方法优化它 我觉得学不到东西，有着几种情况 你的技术栈，完全覆盖了这个公司，他们干的所有事情，你都可以单挑完成 或者是，你对这个行业，比如说我对销售行业，完全不感兴趣，但是公司里面干的是这个事情，那的确是学不到东西 有很多很多的杂活这个相对是更长的一段时间的感受，比如半年的时间，都是让你在东搞西搞，没有专心与一个技术栈，那这个公司对发展是不好的但是在短期看来，干很多杂事，如果能干好，还是可以提高自己的能力 干一些低技术的工作，自己都会，也是打杂，这就很没有发展前景 怎样快速融入一个项目 搭建环境，docker,k8s 让程序跑起来 了解调试方法 刚开始的起步阶段，最好能找到参考的程序，网络上的，工程里相关的，前辈写的代码 最开始是自己先造一些东西，看看能不能实现功能 再是修改 可以修改程序 最开始先了解一个模块，可以自己造一个独立的模块 然后了解联动的1-3个模块，了解这几个模块之间的相互关系（十分考验代码功底，需要静态查看，能做到不运行代码的情况下能看出程序是怎么运行的） 如果无法让一个程序运行，那就思考自己是哪一步出现了问题 搭建环境，docker,k8s搭建环境的时候遇到了什么问题，如何去解决 让程序跑起来程序中是否出现了错误代码，为什么无法改正，是语法不熟悉，还是这个特殊的用法没有了解到，还是别的计算机基础相关的知识 多从测试角度考虑，需要设计测试用例，对自己写的程序，要有测试的思路，什么情况会发生边界条件好几个程序一起的时候，会不会互相影响 想要提高代码能力，最好的方法，就是去一点一点的把代码写出来，只要自己写过的，能力就能提升只是看视频，提升是很慢的 提高搜索引擎关键词检索的效率 日常学习中，遇到的最大技术挑战是什么，你是如何解决的最大的困难是什么，或者最大的成果是什么，最大的成就感是什么？ 1.问题描述：1）简单介绍这个项目规模、背景，你在这中间充当的角色；2）什么情况下遇到什么样的问题2.你处理这个问题的过程及结果：1）遇到问题你如何思考；2）你如何执行的；3）处理结果如何3.通过处理这个问题，你学到了什么或者说通过这个问题，你看到了你们什么不足，后续动作（采用什么样的方式，在以后的项目中避免再出现这类问题","raw":"---\ntitle: 实习的感受\ndate: 2022-09-15 21:59:20\ntags:\n- 反思\n---\n\n主要写一写实习的感受，为以后的实习做借鉴，并且对这个事情做一些总结\n\n\n\n# 领导团队\n服务意识\n1.给团队设定超过现在能力的目标，但是还是要够一够才能到达\n\n2.团队的领导者要作为团队的服务着，需要找到团队需要解决的问题\n\n\n\n1. 每周需要定期开组会，复盘这周完成的情况，这周遇到的问题\n需要如果去解决\n作为领导者，需要去协调解决组员的问题\n并且对这周做的内容，需要有一个拓展性的提高\n比如现在只能开80路的，但是要求到150路，最后不断努力可以到120路\n**一定需要定时解决问题**\n\n完成了什么，现在还有什么问题\n\n\n2. 从多个角度考虑，\n\n\n3. 设计一个系统的时候，需要先逼着自己从最大的角度去考虑，需要哪几个方面的东西，然后再去细化\n如果东西太大，自己想不出来，那就先想到哪个点就做哪一个\n\n\n\n4. 如何平衡工作和生活\n刚刚开始到公司的时候\n\n\n\n6-8月份，刚开始的时候无法接受公司里面的高强度工作，那就晚上回家以后多补课，\n\n\n\n5. 如何解决公司中学习的知识比较杂乱的情况\n\n平时收集一些零散的东西，到了有大段空闲的时候，可以做总结\n\n\n6. 如何的最快的熟悉一个领域\n如何快速学习一门新的技术或者语言\n是什么，这个怎么用\n写一些小demo，\n看公司里面的工程代码\n找一些当前用到的典型场景，困难的回答，比如go的内存分配\n\n\n7. 读研之后发现自己和本科有什么区别\n\n7. 如何最快最好的解决一个问题，最好使用英文查询\n\n\n\n\n8. 小公司学不到东西，如何反驳\n\n- 1. 了解公司用的技术栈，我做的是后端，那我现在做的工作，我做的工作的前面有什么，后面有什么\n一起来的实习生在做什么，他做的东西我会做么，他做的东西我如何实现\n- 2. 常常保持好奇的心态，我虽然是后端，但是对于前端的技术，对于测试，产品，运维的相关知识，都是可以了解的\n- 3. 你要完成现在手头上的工作，是否会遇到问题，那么遇到问题的时候，比如看到raft算法，这是底层使用的东西，如果是有心去了解，那就会有更多可以发现的东西\n- 4. 如果完成了手头上的工作，可以用什么样的方法优化它\n\n\n\n\n我觉得学不到东西，有着几种情况\n1. 你的技术栈，完全覆盖了这个公司，他们干的所有事情，你都可以单挑完成\n- 或者是，你对这个行业，比如说我对销售行业，完全不感兴趣，但是公司里面干的是这个事情，那的确是学不到东西\n2. 有很多很多的杂活\n这个相对是更长的一段时间的感受，比如半年的时间，都是让你在东搞西搞，没有专心与一个技术栈，那这个公司对发展是不好的\n但是在短期看来，干很多杂事，如果能干好，还是可以提高自己的能力\n3. 干一些低技术的工作，自己都会，也是打杂，这就很没有发展前景\n\n\n\n\n\n\n9. 怎样快速融入一个项目\n\n- 1. 搭建环境，docker,k8s\n- 2. 让程序跑起来\n- 3. 了解调试方法\n- 刚开始的起步阶段，最好能找到参考的程序，网络上的，工程里相关的，前辈写的代码\n- 最开始是自己先造一些东西，看看能不能实现功能\n- 再是修改\n- 4. 可以修改程序\n- 最开始先了解一个模块，可以自己造一个独立的模块\n- 然后了解联动的1-3个模块，了解这几个模块之间的相互关系\n（十分考验代码功底，需要静态查看，能做到不运行代码的情况下能看出程序是怎么运行的）\n\n如果无法让一个程序运行，那就思考自己是哪一步出现了问题\n1. 搭建环境，docker,k8s\n搭建环境的时候遇到了什么问题，如何去解决\n- 2. 让程序跑起来\n程序中是否出现了错误代码，为什么无法改正，是语法不熟悉，还是这个特殊的用法没有了解到，还是别的计算机基础相关的知识\n\n\n\n\n\n\n9. 多从测试角度考虑，需要设计测试用例，对自己写的程序，要有测试的思路，什么情况会发生边界条件\n好几个程序一起的时候，会不会互相影响\n\n\n\n\n\n5. 想要提高代码能力，最好的方法，就是去一点一点的把代码写出来，只要自己写过的，能力就能提升\n只是看视频，提升是很慢的\n\n\n10. 提高搜索引擎关键词检索的效率\n\n\n11. 日常学习中，遇到的最大技术挑战是什么，你是如何解决的\n最大的困难是什么，或者最大的成果是什么，最大的成就感是什么？\n\n\n1.问题描述：1）简单介绍这个项目规模、背景，你在这中间充当的角色；2）什么情况下遇到什么样的问题\n2.你处理这个问题的过程及结果：1）遇到问题你如何思考；2）你如何执行的；3）处理结果如何\n3.通过处理这个问题，你学到了什么或者说通过这个问题，你看到了你们什么不足，后续动作（采用什么样的方式，在以后的项目中避免再出现这类问题\n","content":"<p>主要写一写实习的感受，为以后的实习做借鉴，并且对这个事情做一些总结</p>\n<h1 id=\"领导团队\"><a href=\"#领导团队\" class=\"headerlink\" title=\"领导团队\"></a>领导团队</h1><p>服务意识<br>1.给团队设定超过现在能力的目标，但是还是要够一够才能到达</p>\n<p>2.团队的领导者要作为团队的服务着，需要找到团队需要解决的问题</p>\n<ol>\n<li>每周需要定期开组会，复盘这周完成的情况，这周遇到的问题<br>需要如果去解决<br>作为领导者，需要去协调解决组员的问题<br>并且对这周做的内容，需要有一个拓展性的提高<br>比如现在只能开80路的，但是要求到150路，最后不断努力可以到120路<br><strong>一定需要定时解决问题</strong></li>\n</ol>\n<p>完成了什么，现在还有什么问题</p>\n<ol start=\"2\">\n<li><p>从多个角度考虑，</p>\n</li>\n<li><p>设计一个系统的时候，需要先逼着自己从最大的角度去考虑，需要哪几个方面的东西，然后再去细化<br>如果东西太大，自己想不出来，那就先想到哪个点就做哪一个</p>\n</li>\n<li><p>如何平衡工作和生活<br>刚刚开始到公司的时候</p>\n</li>\n</ol>\n<p>6-8月份，刚开始的时候无法接受公司里面的高强度工作，那就晚上回家以后多补课，</p>\n<ol start=\"5\">\n<li>如何解决公司中学习的知识比较杂乱的情况</li>\n</ol>\n<p>平时收集一些零散的东西，到了有大段空闲的时候，可以做总结</p>\n<ol start=\"6\">\n<li><p>如何的最快的熟悉一个领域<br>如何快速学习一门新的技术或者语言<br>是什么，这个怎么用<br>写一些小demo，<br>看公司里面的工程代码<br>找一些当前用到的典型场景，困难的回答，比如go的内存分配</p>\n</li>\n<li><p>读研之后发现自己和本科有什么区别</p>\n</li>\n<li><p>如何最快最好的解决一个问题，最好使用英文查询</p>\n</li>\n<li><p>小公司学不到东西，如何反驳</p>\n</li>\n</ol>\n<ul>\n<li><ol>\n<li>了解公司用的技术栈，我做的是后端，那我现在做的工作，我做的工作的前面有什么，后面有什么<br>一起来的实习生在做什么，他做的东西我会做么，他做的东西我如何实现</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>常常保持好奇的心态，我虽然是后端，但是对于前端的技术，对于测试，产品，运维的相关知识，都是可以了解的</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>你要完成现在手头上的工作，是否会遇到问题，那么遇到问题的时候，比如看到raft算法，这是底层使用的东西，如果是有心去了解，那就会有更多可以发现的东西</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>如果完成了手头上的工作，可以用什么样的方法优化它</li>\n</ol>\n</li>\n</ul>\n<p>我觉得学不到东西，有着几种情况</p>\n<ol>\n<li>你的技术栈，完全覆盖了这个公司，他们干的所有事情，你都可以单挑完成</li>\n</ol>\n<ul>\n<li>或者是，你对这个行业，比如说我对销售行业，完全不感兴趣，但是公司里面干的是这个事情，那的确是学不到东西</li>\n</ul>\n<ol start=\"2\">\n<li><p>有很多很多的杂活<br>这个相对是更长的一段时间的感受，比如半年的时间，都是让你在东搞西搞，没有专心与一个技术栈，那这个公司对发展是不好的<br>但是在短期看来，干很多杂事，如果能干好，还是可以提高自己的能力</p>\n</li>\n<li><p>干一些低技术的工作，自己都会，也是打杂，这就很没有发展前景</p>\n</li>\n<li><p>怎样快速融入一个项目</p>\n</li>\n</ol>\n<ul>\n<li><ol>\n<li>搭建环境，docker,k8s</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>让程序跑起来</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>了解调试方法</li>\n</ol>\n</li>\n<li>刚开始的起步阶段，最好能找到参考的程序，网络上的，工程里相关的，前辈写的代码</li>\n<li>最开始是自己先造一些东西，看看能不能实现功能</li>\n<li>再是修改</li>\n<li><ol start=\"4\">\n<li>可以修改程序</li>\n</ol>\n</li>\n<li>最开始先了解一个模块，可以自己造一个独立的模块</li>\n<li>然后了解联动的1-3个模块，了解这几个模块之间的相互关系<br>（十分考验代码功底，需要静态查看，能做到不运行代码的情况下能看出程序是怎么运行的）</li>\n</ul>\n<p>如果无法让一个程序运行，那就思考自己是哪一步出现了问题</p>\n<ol>\n<li>搭建环境，docker,k8s<br>搭建环境的时候遇到了什么问题，如何去解决</li>\n</ol>\n<ul>\n<li><ol start=\"2\">\n<li>让程序跑起来<br>程序中是否出现了错误代码，为什么无法改正，是语法不熟悉，还是这个特殊的用法没有了解到，还是别的计算机基础相关的知识</li>\n</ol>\n</li>\n</ul>\n<ol start=\"9\">\n<li><p>多从测试角度考虑，需要设计测试用例，对自己写的程序，要有测试的思路，什么情况会发生边界条件<br>好几个程序一起的时候，会不会互相影响</p>\n</li>\n<li><p>想要提高代码能力，最好的方法，就是去一点一点的把代码写出来，只要自己写过的，能力就能提升<br>只是看视频，提升是很慢的</p>\n</li>\n<li><p>提高搜索引擎关键词检索的效率</p>\n</li>\n<li><p>日常学习中，遇到的最大技术挑战是什么，你是如何解决的<br>最大的困难是什么，或者最大的成果是什么，最大的成就感是什么？</p>\n</li>\n</ol>\n<p>1.问题描述：1）简单介绍这个项目规模、背景，你在这中间充当的角色；2）什么情况下遇到什么样的问题<br>2.你处理这个问题的过程及结果：1）遇到问题你如何思考；2）你如何执行的；3）处理结果如何<br>3.通过处理这个问题，你学到了什么或者说通过这个问题，你看到了你们什么不足，后续动作（采用什么样的方式，在以后的项目中避免再出现这类问题</p>\n","slug":"Reflection/实习的感受","updated":"24/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/09/15/Reflection/%E5%AE%9E%E4%B9%A0%E7%9A%84%E6%84%9F%E5%8F%97/","excerpt":"","categories":[],"tags":[{"name":"反思","slug":"反思","permalink":"http://example.com/tags/%E5%8F%8D%E6%80%9D/"}]},{"title":"小工具的使用","date":"23/08/2022","path":"2022/08/23/Tutorial/小工具的使用/","text":"Navicat12 Mysql可视化查看工具破解的时候需要关闭软件本身 需要在k8s中开放端口修改mysql开放及端口：开放：alias b&#x3D;”kubectl -n namespace” b edit svc mysql -n mysql 加spec-底部type: NodePort # 从ClusterIP改过来修改端口：ports-nodePort:31198 数据库：host&#x3D;[主机名],user&#x3D;[用户名],passwd&#x3D;[密码],db&#x3D;[想要访问的数据库],charset&#x3D;”utf8”,port&#x3D;[使用的端口] host&#x3D;”10.1.0.42”,user&#x3D;”pigg”,passwd&#x3D;”123456”,db&#x3D;”ggip”,charset&#x3D;”utf8”,port&#x3D;31198 查看表的情况”设计表“ 执行mysql语句以后的分析剖析： 1）Opening tables 这个是表示这个SQL拿到这个表的使用权所占用的时间，如果在一个SQL中过长，则有可能表示当前表被锁，被一些其他线程占用，可以查一下当前表的状态。2）Sending data包括两个部分，收集和发送数据。这里的关键是为什么要收集数据，原因在于：mysql使用“索引”完成查询结束后，mysql得到了一堆的行id，如果有的列并不在索引中，mysql需要重新到“数据行”上将需要返回的数据读取出来返回个客户端。如果这部分占用时间过程，有可能是索引问题，或者字段长度过大导致。 gRPC调试工具BloomRPC可以调试utilserver这个特别复杂的服务在调试的时候，需要把包含的文件，还有包含文件的包含文件全部导入 参考文献[使用Navicat分析SQL性能]https://blog.csdn.net/weixin_43416686/article/details/121037223","raw":"---\ntitle: 小工具的使用\ndate: 2022-08-23 15:49:26\ntags:\n- 教程\n---\n\n# Navicat12 Mysql可视化查看工具\n\n破解的时候需要关闭软件本身\n\n需要在k8s中开放端口\n修改mysql开放及端口：\n开放：alias b=\"kubectl -n namespace\"\n         b edit svc mysql -n mysql\n      加spec-底部type: NodePort         # 从ClusterIP改过来\n修改端口：ports-nodePort:31198\n\n数据库：\nhost=[主机名],\nuser=[用户名],\npasswd=[密码],\ndb=[想要访问的数据库],\ncharset=\"utf8\",\nport=[使用的端口]\n\n\n\nhost=\"10.1.0.42\",\nuser=\"pigg\",\npasswd=\"123456\",\ndb=\"ggip\",\ncharset=\"utf8\",\nport=31198\n\n\n## 查看表的情况\n”设计表“\n## 执行mysql语句以后的分析\n剖析：\n\n1）Opening tables 这个是表示这个SQL拿到这个表的使用权所占用的时间，如果在一个SQL中过长，则有可能表示当前表被锁，被一些其他线程占用，可以查一下当前表的状态。\n2）Sending data包括两个部分，收集和发送数据。这里的关键是为什么要收集数据，原因在于：mysql使用“索引”完成查询结束后，mysql得到了一堆的行id，如果有的列并不在索引中，mysql需要重新到“数据行”上将需要返回的数据读取出来返回个客户端。如果这部分占用时间过程，有可能是索引问题，或者字段长度过大导致。\n\n\n# gRPC调试工具\n\nBloomRPC\n可以调试utilserver这个特别复杂的服务\n在调试的时候，需要把包含的文件，还有包含文件的包含文件全部导入\n\n\n# 参考文献\n[使用Navicat分析SQL性能]https://blog.csdn.net/weixin_43416686/article/details/121037223\n\n\n\n\n\n","content":"<h1 id=\"Navicat12-Mysql可视化查看工具\"><a href=\"#Navicat12-Mysql可视化查看工具\" class=\"headerlink\" title=\"Navicat12 Mysql可视化查看工具\"></a>Navicat12 Mysql可视化查看工具</h1><p>破解的时候需要关闭软件本身</p>\n<p>需要在k8s中开放端口<br>修改mysql开放及端口：<br>开放：alias b&#x3D;”kubectl -n namespace”<br>         b edit svc mysql -n mysql<br>      加spec-底部type: NodePort         # 从ClusterIP改过来<br>修改端口：ports-nodePort:31198</p>\n<p>数据库：<br>host&#x3D;[主机名],<br>user&#x3D;[用户名],<br>passwd&#x3D;[密码],<br>db&#x3D;[想要访问的数据库],<br>charset&#x3D;”utf8”,<br>port&#x3D;[使用的端口]</p>\n<p>host&#x3D;”10.1.0.42”,<br>user&#x3D;”pigg”,<br>passwd&#x3D;”123456”,<br>db&#x3D;”ggip”,<br>charset&#x3D;”utf8”,<br>port&#x3D;31198</p>\n<h2 id=\"查看表的情况\"><a href=\"#查看表的情况\" class=\"headerlink\" title=\"查看表的情况\"></a>查看表的情况</h2><p>”设计表“</p>\n<h2 id=\"执行mysql语句以后的分析\"><a href=\"#执行mysql语句以后的分析\" class=\"headerlink\" title=\"执行mysql语句以后的分析\"></a>执行mysql语句以后的分析</h2><p>剖析：</p>\n<p>1）Opening tables 这个是表示这个SQL拿到这个表的使用权所占用的时间，如果在一个SQL中过长，则有可能表示当前表被锁，被一些其他线程占用，可以查一下当前表的状态。<br>2）Sending data包括两个部分，收集和发送数据。这里的关键是为什么要收集数据，原因在于：mysql使用“索引”完成查询结束后，mysql得到了一堆的行id，如果有的列并不在索引中，mysql需要重新到“数据行”上将需要返回的数据读取出来返回个客户端。如果这部分占用时间过程，有可能是索引问题，或者字段长度过大导致。</p>\n<h1 id=\"gRPC调试工具\"><a href=\"#gRPC调试工具\" class=\"headerlink\" title=\"gRPC调试工具\"></a>gRPC调试工具</h1><p>BloomRPC<br>可以调试utilserver这个特别复杂的服务<br>在调试的时候，需要把包含的文件，还有包含文件的包含文件全部导入</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[使用Navicat分析SQL性能]<a href=\"https://blog.csdn.net/weixin_43416686/article/details/121037223\">https://blog.csdn.net/weixin_43416686/article/details/121037223</a></p>\n","slug":"Tutorial/小工具的使用","updated":"26/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/08/23/Tutorial/%E5%B0%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"小工具的使用","date":"23/08/2022","path":"2022/08/23/Tutorial/small_tool/","text":"Navicat12 Mysql可视化查看工具破解的时候需要关闭软件本身 需要在k8s中开放端口修改mysql开放及端口：开放：alias b&#x3D;”kubectl -n namespace” b edit svc mysql -n mysql 加spec-底部type: NodePort # 从ClusterIP改过来修改端口：ports-nodePort:31198 数据库：host&#x3D;[主机名],user&#x3D;[用户名],passwd&#x3D;[密码],db&#x3D;[想要访问的数据库],charset&#x3D;”utf8”,port&#x3D;[使用的端口] host&#x3D;”10.1.0.42”,user&#x3D;”pigg”,passwd&#x3D;”123456”,db&#x3D;”ggip”,charset&#x3D;”utf8”,port&#x3D;31198 查看表的情况”设计表“ 执行mysql语句以后的分析剖析： 1）Opening tables 这个是表示这个SQL拿到这个表的使用权所占用的时间，如果在一个SQL中过长，则有可能表示当前表被锁，被一些其他线程占用，可以查一下当前表的状态。2）Sending data包括两个部分，收集和发送数据。这里的关键是为什么要收集数据，原因在于：mysql使用“索引”完成查询结束后，mysql得到了一堆的行id，如果有的列并不在索引中，mysql需要重新到“数据行”上将需要返回的数据读取出来返回个客户端。如果这部分占用时间过程，有可能是索引问题，或者字段长度过大导致。 gRPC调试工具BloomRPC可以调试utilserver这个特别复杂的服务在调试的时候，需要把包含的文件，还有包含文件的包含文件全部导入 参考文献[使用Navicat分析SQL性能]https://blog.csdn.net/weixin_43416686/article/details/121037223","raw":"---\ntitle: 小工具的使用\ndate: 2022-08-23 15:49:26\ntags:\n- 教程\n---\n\n# Navicat12 Mysql可视化查看工具\n\n破解的时候需要关闭软件本身\n\n需要在k8s中开放端口\n修改mysql开放及端口：\n开放：alias b=\"kubectl -n namespace\"\n         b edit svc mysql -n mysql\n      加spec-底部type: NodePort         # 从ClusterIP改过来\n修改端口：ports-nodePort:31198\n\n数据库：\nhost=[主机名],\nuser=[用户名],\npasswd=[密码],\ndb=[想要访问的数据库],\ncharset=\"utf8\",\nport=[使用的端口]\n\n\n\nhost=\"10.1.0.42\",\nuser=\"pigg\",\npasswd=\"123456\",\ndb=\"ggip\",\ncharset=\"utf8\",\nport=31198\n\n\n## 查看表的情况\n”设计表“\n## 执行mysql语句以后的分析\n剖析：\n\n1）Opening tables 这个是表示这个SQL拿到这个表的使用权所占用的时间，如果在一个SQL中过长，则有可能表示当前表被锁，被一些其他线程占用，可以查一下当前表的状态。\n2）Sending data包括两个部分，收集和发送数据。这里的关键是为什么要收集数据，原因在于：mysql使用“索引”完成查询结束后，mysql得到了一堆的行id，如果有的列并不在索引中，mysql需要重新到“数据行”上将需要返回的数据读取出来返回个客户端。如果这部分占用时间过程，有可能是索引问题，或者字段长度过大导致。\n\n\n# gRPC调试工具\n\nBloomRPC\n可以调试utilserver这个特别复杂的服务\n在调试的时候，需要把包含的文件，还有包含文件的包含文件全部导入\n\n\n# 参考文献\n[使用Navicat分析SQL性能]https://blog.csdn.net/weixin_43416686/article/details/121037223\n\n\n\n\n\n","content":"<h1 id=\"Navicat12-Mysql可视化查看工具\"><a href=\"#Navicat12-Mysql可视化查看工具\" class=\"headerlink\" title=\"Navicat12 Mysql可视化查看工具\"></a>Navicat12 Mysql可视化查看工具</h1><p>破解的时候需要关闭软件本身</p>\n<p>需要在k8s中开放端口<br>修改mysql开放及端口：<br>开放：alias b&#x3D;”kubectl -n namespace”<br>         b edit svc mysql -n mysql<br>      加spec-底部type: NodePort         # 从ClusterIP改过来<br>修改端口：ports-nodePort:31198</p>\n<p>数据库：<br>host&#x3D;[主机名],<br>user&#x3D;[用户名],<br>passwd&#x3D;[密码],<br>db&#x3D;[想要访问的数据库],<br>charset&#x3D;”utf8”,<br>port&#x3D;[使用的端口]</p>\n<p>host&#x3D;”10.1.0.42”,<br>user&#x3D;”pigg”,<br>passwd&#x3D;”123456”,<br>db&#x3D;”ggip”,<br>charset&#x3D;”utf8”,<br>port&#x3D;31198</p>\n<h2 id=\"查看表的情况\"><a href=\"#查看表的情况\" class=\"headerlink\" title=\"查看表的情况\"></a>查看表的情况</h2><p>”设计表“</p>\n<h2 id=\"执行mysql语句以后的分析\"><a href=\"#执行mysql语句以后的分析\" class=\"headerlink\" title=\"执行mysql语句以后的分析\"></a>执行mysql语句以后的分析</h2><p>剖析：</p>\n<p>1）Opening tables 这个是表示这个SQL拿到这个表的使用权所占用的时间，如果在一个SQL中过长，则有可能表示当前表被锁，被一些其他线程占用，可以查一下当前表的状态。<br>2）Sending data包括两个部分，收集和发送数据。这里的关键是为什么要收集数据，原因在于：mysql使用“索引”完成查询结束后，mysql得到了一堆的行id，如果有的列并不在索引中，mysql需要重新到“数据行”上将需要返回的数据读取出来返回个客户端。如果这部分占用时间过程，有可能是索引问题，或者字段长度过大导致。</p>\n<h1 id=\"gRPC调试工具\"><a href=\"#gRPC调试工具\" class=\"headerlink\" title=\"gRPC调试工具\"></a>gRPC调试工具</h1><p>BloomRPC<br>可以调试utilserver这个特别复杂的服务<br>在调试的时候，需要把包含的文件，还有包含文件的包含文件全部导入</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[使用Navicat分析SQL性能]<a href=\"https://blog.csdn.net/weixin_43416686/article/details/121037223\">https://blog.csdn.net/weixin_43416686/article/details/121037223</a></p>\n","slug":"Tutorial/small_tool","updated":"26/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/08/23/Tutorial/small_tool/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"实习中学到的内容","date":"22/08/2022","path":"2022/08/22/Reflection/实习中用到的技术/","text":"实习中学到的新技术2022.3~2022.4 基于 Linux 的 TinyWebServer项目描述:该项目是为学习 Linux 网络编程知识，在 Linux 环境下使用 C++语言开发的轻量级多线程 HTTP服务器，服务器支持一定数量的客户端连接并及时响应，支持客户端访问服务器的图片、视频等资源。主要工作: 1、使用 Socket 实现不同主机之间的通信;2、使用 Epoll 技术实现 I&#x2F;O 多路复用，提高效率;3、使用有限状态机解析 HTTP 请求报文，对 GET 和 POST 请求进行处理4、利用多线程的机制，增加并行服务数量。项目难点: 1、实现线程池，提高吞吐量;2、编写主从状态机对 HTTP 报文进行解析;个人收获: 1、在此项目中，使用 Makefile 进行编译，掌握一门全新的技术;2、对 HTTP 的服务过程以及 TCP 三次握手有了更深的了解﹔3、对于 Socket 通信以及 I&#x2F;0 复用有了一定的理解，对已有知识进行夯实 2021.12~2022.1 杭州大数云智科技有限公司1.通过学习 GitHub 上的开源项目 MotionPlanning，通过 python 实现一些路径规划的算法。。2.使用 Vscode 通过 ssh 连接调试塔克机器人小车，通过 Ubuntu16.04 虚拟机搭载 ROS Melodic ，连接小车，进行激光雷达、双目摄像头和深度相机的 SLAM 建模 2022.6~2022.8 杭州后起智能科技有限公司 1.加强了Git的各种使用方式 自己的全面总结：思想上： 了解了公司的运行流程，互联网公司的组成模式技术上： 语言： 5个go项目4个c++项目,三个都和shell相关3个数据库相关，MySQL5个shell项目，两个重度shellansible,k8s,dockerwsl 新学的技术dockerk8skubectlgrpcgit lfsgo语言 Protocol Buffer序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统结构体标签workpool HTTP 消息首部MIME 类型pocgorm中的事务，redis中事务 并发读写，并发锁sync.Mapredis-cli数据库 TIDB redis 存储 分布式存储GlusterFS TIKV minio linux的VFS内容etcd数据库备份Ansiblecfssl证书jinjacrontab自动执行原型软件axureBloomRPCC++技术 Snowflake算法 消息阻塞队列 对象池 CustomObjectPool ObjectPool GoLang grpc grom prototobuf 消息队列 分布式追踪系统 – Opentracingnavicate mysqlGUI工具nsqlookupd：高性能消息中间件 NSQ 解析NSQ——订阅摘要和推送摘要，日志流中间件消息队列 对一些内容的详细解释k8skubernetes IAAS——基础服务设施 PAAS——平台服务设施 docker——paas的下一代标准 k8s解决集群问题，每个机器里面都有一个docker 容器的集群化，资源管理器 apache——MESOS 分布式资源管理框架 2019 twitter不用了 推特在用，现在在用k8s docker swarm docker母公司 swarm集群 2019-7 阿里云宣布 docker swarm剔除 kubernetes goolgle 10年容器化基础架构 公司里面在用borg 现在用go写了一个borg 特点 轻量级，消耗的资源少 开源 弹性伸缩 负载均衡：IPVS框架 人群 软件工程师 测试、运维、产品经理 需要了解产品底层框架 SAAS raft算法 snap—— wal——日志持久化存储 分布式追踪系统 – OpentracingOpenTracing 于 2016 年 10 月加入 CNCF 基金会，是继 Kubernetes 和 Prometheus 之后，第三个加入 CNCF 的开源项目 可方便开发者在自己的服务中集成一种或多种分布式追踪的实现 Logging &amp; Metrics：可聚合的事件。例如分析某对象存储的 Nginx 日志，统计某段时间内 GET、PUT、DELETE、OPTIONS 操作的总数。 Metrics &amp; Tracing：单个请求中的可计量数据。例如 SQL 执行总时长、gRPC 调用总次数。 Tracing &amp; Logging：请求阶段的标签数据。例如在 Tracing 的信息中标记详细的错误原因。 Logging：ELK，近几年势头最猛的日志分析服务，无须多言。 Metrics：Prometheus，第二个加入 CNCF 的开源项目，非常好用。 Tracing：OpenTracing 和 Jaeger，Jaeger 是 Uber 开源的一个兼容 OpenTracing 标准的分布式追踪服务。目前 Jaeger 也加入了 CNCF。 SaaSSaaS是Software-as-a-Service的缩写名称，意思为软件即服务 Facebook，Twitter， Instagram。 Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting。 PaaS：Platform-as-a-Service（平台即服务）提供给消费者的服务是把客户采用提供的开发语言和工具（例如Java，python, .Net等）开发的或收购的应用程序部署到供应商的云计算基础设施上去。 MySQL，Mangodb，Java，Node.js IaaS： Infrastructure-as-a-Service（基础设施即服务）提供给消费者的服务是对所有计算基础设施的利用，包括处理CPU、内存、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。 NSQNSQ——订阅摘要和推送摘要，日志流中间件 NSQ是Go语言编写的一个开源的实时分布式内存消息队列，其性能十分优异。 分布式实时消息平台 NSQ 是实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。它具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征 适合小型项目使用,用来学习消息队列实现原理、学习 golang channel知识以及如何用 go 来写分布式，为什么说适合小型小型项目使用因为，nsq 如果没有能力进行二次开发的情况存在的问题还是很多的。 档案导出的流程 档案查询——查大顶堆优化mysql 查询的时候，每个项目的内容都非常的大，但是只需要用他们的一部分来排序所以使用大顶堆来进行插入，插入的时候同时完成了排序在需要使用的时候，直接将大顶堆读取出来就可以了 算法稳定性：堆排序是一种不稳定的排序方法。因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况 但是不需要兼顾这个方面，因为出现频率相同的人，随便怎么排在一起都没有关系 档案导出——查多用户，多线程。上下文取消，广播进度，哈希表优化minio 任务背景导出的命名格式为姓名-身份证由于下载的内容十分繁重，总体逻辑，保证单用户只有一个下载任务使用minio存储图片下载的目标数量极大，1000-1W的数量级档案中的人有1000个人，每个的档案，如果被布控的到，会有1-2K照片，每个照片20KB，jpg模式下载的内容分为，档案图，人脸图，场景图 档案导出主函数0.0 数据库初始化，在整个服务初始化的时候完成0.1 获取上下文，打印日志，填写requestid0.2 定义导出需要用到的接口 - 导出主程序接口 - 查询导出任务进度 - 删除导出任务1.验证用户输入是否正确 2.先查询当前任务状态，如果已经有任务在执行，那么直接返回 – 获取的下载目标，在数据库中无法存放数组，用字符串代替 – 如果不是运行中，可能是任务未开始、任务失败、任务成功，都删除一下当前任务 3.在数据库库中插入本次下载的记录4.串联上下文，将上下文信息传递到协程里面， 5.返回开始任务，进度为0%，接口运行结束 调试方法1.postman进行本地接口传入参数调试2.直接放到服务器上的k8s中进行运行，打印日志进行调试 协程中的内容 运行的过程中不停的更新进度的状态，进行进度广播 使用线程池加速下载，线程池里面开线程池？？不可以？？ 8核下载全部轨迹，从135s-&gt;20s 错误处理 使用哈希表，减少摄像头信息的存储 获取想要导出的目标的信息目标的，姓名-身份证如果需要导出的目标是空的，那还是建立一个空文件夹有时候，需要下载的内容过于庞大了，超过了gRPC单次传输的上限，所以就用分页的方法来获取数据，（获取数据调用的别的微服务，那个接口支持分页） 在本地建立需要导出目标的文件夹目录为，随机uuid 找到可执行目录 生成uuid uuid&#x2F;export&#x2F;建立业务文件夹导出的图片是存在minio里面的，从网上下载下来，放在目录里面，压缩打包再上传 对需要下载的每个目标进行下载更具业务需求，分情况讨论下载的过程中，使用base64对图片地址进行解密由于每个目标是独立的任务，所以可以使用线程池进行加速 需要调用其他的微服务，还获取图片数据 对生成的文件进行zip压缩 使用defer删除建立的临时压缩报 filepath.Walk来遍历文件压缩进去 将压缩包上传到minio，将minio的地址存到数据库中 上传中修改了minio存储的ContentDisposition,修改了http下载时候的文件名 档案删除——删查了redis 删除任务中，遇到了无法删除数据库内容的问题查找后发现，删除的时候使用了事务，这个事务里面需要同时删除三个数据库中的数据，但是在有一个删除操作中，删除的量过大的，导致删除终止，整个事务回滚，删除失败需要一次删除25w条数据，每条数据大概4000byte,25W条数据是极限了有一些10W条以下的小数据，删除成功了，但是之前使用的gorm的软删除，改为了直接删除 解决方法：先查询需要删除的数量，如果大于一定数量，就不使用事务，自己分批次删除 这个删除使用了代理模式，分为proxy，work,store三个层次proxy处理一些简单的外部响应，先删除外部的数据库真正的删除放在内部的store中，删除图片，redis,tidb tidb中有一个库的常用键值没有加索引，导致搜索的十分缓慢，所以加上了索引 定时任务使用管道和协程回调函数，来实现一个定时任务对两天前的老数据进行清理 为什么要用redis检测到的人的特征放在redis里面由于需要监控的人非常多，而且人需要存储的特征也非常多，并且总是需要使用到人的特征，所以放到redis里面需要保存轨迹点的数据，内容量很大，并且读写频率很高 [消息队列浅析]https://developer.aliyun.com/article/988780?spm=a2c6h.12873639.article-detail.40.167b2eefaMJqaj&amp;scm=20140722.ID_community@@article@@988780._.ID_community@@article@@988780-OR_rec-V_1[OpenTracing]https://blog.csdn.net/eight_eyes/article/details/117330608 [数据结构 - 堆的应用场景]https://blog.csdn.net/it_lihongmin/article/details/114528779?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=2[堆及堆的具体使用场景]https://www.jianshu.com/p/e8e267879b61","raw":"---\ntitle: 实习中学到的内容\ndate: 2022-08-22 20:02:55\ntags:\n- 反思\n---\n\n\n# 实习中学到的新技术\n\n2022.3~2022.4 基于 Linux 的 TinyWebServer\n项目描述:该项目是为学习 Linux 网络编程知识，在 Linux 环境下使用 C++语言开发的轻量级多线程 HTTP\n服务器，服务器支持一定数量的客户端连接并及时响应，支持客户端访问服务器的图片、视频等资源。\n主要工作: 1、使用 Socket 实现不同主机之间的通信;\n2、使用 Epoll 技术实现 I/O 多路复用，提高效率;\n3、使用有限状态机解析 HTTP 请求报文，对 GET 和 POST 请求进行处理4、利用多线程的机制，增加并行服务数量。\n项目难点: 1、实现线程池，提高吞吐量;\n2、编写主从状态机对 HTTP 报文进行解析;\n个人收获: 1、在此项目中，使用 Makefile 进行编译，掌握一门全新的技术;\n2、对 HTTP 的服务过程以及 TCP 三次握手有了更深的了解﹔\n3、对于 Socket 通信以及 I/0 复用有了一定的理解，对已有知识进行夯实\n\n\n\n2021.12~2022.1 杭州大数云智科技有限公司\n1.通过学习 GitHub 上的开源项目 MotionPlanning，通过 python 实现一些路径规划的算法。。\n2.使用 Vscode 通过 ssh 连接调试塔克机器人小车，通过 Ubuntu16.04 虚拟机搭载 ROS Melodic ，连接\n小车，进行激光雷达、双目摄像头和深度相机的 SLAM 建模\n\n\n2022.6~2022.8 杭州后起智能科技有限公司\n\n1.加强了Git的各种使用方式\n\n自己的全面总结：\n思想上：\n1. 了解了公司的运行流程，互联网公司的组成模式\n技术上：\n2. 语言：\n\n5个go项目\n4个c++项目,三个都和shell相关\n3个数据库相关，MySQL\n5个shell项目，两个重度shell\nansible,k8s,docker\n~~wsl~~\n\n\n\n\n# 新学的技术\n\ndocker\nk8s\nkubectl\ngrpc\ngit lfs\ngo语言\n\nProtocol Buffer\n序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统\n结构体标签\nworkpool\n\nHTTP 消息首部MIME 类型\npoc\ngorm中的事务，redis中事务\n\n\n并发读写，并发锁sync.Map\nredis-cli\n数据库\n    TIDB\n    redis\n\n存储\n    分布式存储GlusterFS\n    TIKV\n    minio\n\nlinux的VFS内容\netcd数据库备份\nAnsible\ncfssl证书\njinja\ncrontab自动执行\n原型软件axure\nBloomRPC\nC++技术\n    Snowflake算法\n    消息阻塞队列\n    对象池\n        CustomObjectPool\n        ObjectPool\n\n## GoLang\n- grpc\n- grom\n- prototobuf\n- 消息队列\n- 分布式追踪系统 -- Opentracing\nnavicate mysqlGUI工具\nnsqlookupd：高性能消息中间件 NSQ 解析\nNSQ——订阅摘要和推送摘要，日志流中间件\n消息队列\n\n\n    \n\n\n# 对一些内容的详细解释\n\n## k8s\n    kubernetes\n    IAAS——基础服务设施\n    PAAS——平台服务设施\n        docker——paas的下一代标准\n        k8s解决集群问题，每个机器里面都有一个docker\n        容器的集群化，资源管理器\n        apache——MESOS\n            分布式资源管理框架\n            2019 twitter不用了\n            推特在用，现在在用k8s\n\n        docker swarm\n            docker母公司\n            swarm集群\n            2019-7\n                阿里云宣布 docker swarm剔除\n\n\n        kubernetes\n            goolgle\n                10年容器化基础架构\n                公司里面在用borg\n                现在用go写了一个borg\n\n            特点\n                轻量级，消耗的资源少\n                开源\n                弹性伸缩\n                负载均衡：IPVS框架\n\n\n        人群\n            软件工程师\n            测试、运维、产品经理\n            需要了解产品底层框架\n\n\n    SAAS\n    raft算法\n    snap——\n    wal——日志持久化存储\n\n## 分布式追踪系统 -- Opentracing\n    OpenTracing 于 2016 年 10 月加入 CNCF 基金会，是继 Kubernetes 和 Prometheus 之后，第三个加入 CNCF 的开源项目\n    可方便开发者在自己的服务中集成一种或多种分布式追踪的实现\n    Logging & Metrics：可聚合的事件。例如分析某对象存储的 Nginx 日志，统计某段时间内\n    GET、PUT、DELETE、OPTIONS 操作的总数。 Metrics & Tracing：单个请求中的可计量数据。例如 SQL\n    执行总时长、gRPC 调用总次数。 Tracing & Logging：请求阶段的标签数据。例如在 Tracing\n    的信息中标记详细的错误原因。\n    Logging：ELK，近几年势头最猛的日志分析服务，无须多言。\n    Metrics：Prometheus，第二个加入 CNCF 的开源项目，非常好用。\n    Tracing：OpenTracing 和 Jaeger，Jaeger 是 Uber 开源的一个兼容 OpenTracing 标准的分布式追踪服务。目前 Jaeger 也加入了 CNCF。\n\n\n# SaaS\nSaaS是Software-as-a-Service的缩写名称，意思为软件即服务\n    Facebook，Twitter，  Instagram。 Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting。\n\nPaaS：Platform-as-a-Service（平台即服务）提供给消费者的服务是把客户采用提供的开发语言和工具（例如Java，python, .Net等）开发的或收购的应用程序部署到供应商的云计算基础设施上去。\n    MySQL，Mangodb，Java，Node.js\n\n IaaS： Infrastructure-as-a-Service（基础设施即服务）提供给消费者的服务是对所有计算基础设施的利用，包括处理CPU、内存、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。\n\n\n# NSQ\nNSQ——订阅摘要和推送摘要，日志流中间件\n    NSQ是Go语言编写的一个开源的实时分布式内存消息队列，其性能十分优异。\n    分布式实时消息平台\n    NSQ 是实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。它具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征\n    适合小型项目使用,用来学习消息队列实现原理、学习 golang channel知识以及如何用 go 来写分布式，为什么说适合小型小型项目使用因为，nsq 如果没有能力进行二次开发的情况存在的问题还是很多的。\n\n\n\n\n\n\n# 档案导出的流程\n\n<!-- # 档案导入——增 -->\n\n# 档案查询——查\n大顶堆\n优化mysql\n\n<!-- 分库分表？ -->\n\n查询的时候，每个项目的内容都非常的大，但是只需要用他们的一部分来排序\n所以使用大顶堆来进行插入，插入的时候同时完成了排序\n在需要使用的时候，直接将大顶堆读取出来就可以了\n\n\n## 算法稳定性：\n堆排序是一种不稳定的排序方法。\n因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，\n因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况\n\n但是不需要兼顾这个方面，因为出现频率相同的人，随便怎么排在一起都没有关系\n\n\n\n# 档案导出——查\n多用户，多线程。上下文取消，广播进度，哈希表优化\nminio\n\n\n## 任务背景\n导出的命名格式为姓名-身份证\n由于下载的内容十分繁重，总体逻辑，保证单用户只有一个下载任务\n使用minio存储图片\n下载的目标数量极大，1000-1W的数量级\n档案中的人有1000个人，每个的档案，如果被布控的到，会有1-2K照片，每个照片20KB，jpg模式\n下载的内容分为，档案图，人脸图，场景图\n## 档案导出主函数\n0.0 数据库初始化，在整个服务初始化的时候完成\n0.1 获取上下文，打印日志，填写requestid\n0.2 定义导出需要用到的接口\n    - 导出主程序接口\n    - 查询导出任务进度\n    - 删除导出任务\n1.验证用户输入是否正确\n\n\n2.先查询当前任务状态，如果已经有任务在执行，那么直接返回\n    -- 获取的下载目标，在数据库中无法存放数组，用字符串代替\n    -- 如果不是运行中，可能是任务未开始、任务失败、任务成功，都删除一下当前任务\n\n3.在数据库库中插入本次下载的记录\n4.串联上下文，将上下文信息传递到协程里面，\n\n5.返回开始任务，进度为0%，接口运行结束\n\n\n# 调试方法\n1.postman进行本地接口传入参数调试\n2.直接放到服务器上的k8s中进行运行，打印日志进行调试\n\n# 协程中的内容\n0. 运行的过程中不停的更新进度的状态，进行进度广播\n0. 使用线程池加速下载，线程池里面开线程池？？不可以？？\n    8核下载全部轨迹，从135s->20s\n0. 错误处理\n0. 使用哈希表，减少摄像头信息的存储\n1. 获取想要导出的目标的信息\n目标的，姓名-身份证\n如果需要导出的目标是空的，那还是建立一个空文件夹\n有时候，需要下载的内容过于庞大了，超过了gRPC单次传输的上限，所以就用分页的方法来获取数据，（获取数据调用的别的微服务，那个接口支持分页）\n2. 在本地建立需要导出目标的文件夹\n目录为，随机uuid\n    - 找到可执行目录\n    - 生成uuid\n    - uuid/export/建立业务文件夹\n导出的图片是存在minio里面的，从网上下载下来，放在目录里面，压缩打包再上传\n3. 对需要下载的每个目标进行下载\n更具业务需求，分情况讨论\n下载的过程中，使用base64对图片地址进行解密\n由于每个目标是独立的任务，所以可以使用线程池进行加速\n    - 需要调用其他的微服务，还获取图片数据\n4. 对生成的文件进行zip压缩\n- 使用defer删除建立的临时压缩报\n- filepath.Walk来遍历文件压缩进去\n5. 将压缩包上传到minio，将minio的地址存到数据库中\n    - 上传中修改了minio存储的ContentDisposition,修改了http下载时候的文件名\n\n\n# 档案删除——删\n查了redis\n\n\n删除任务中，遇到了无法删除数据库内容的问题\n查找后发现，删除的时候使用了事务，这个事务里面需要同时删除三个数据库中的数据，但是在有一个删除操作中，删除的量过大的，导致删除终止，整个事务回滚，删除失败\n需要一次删除25w条数据，每条数据大概4000byte,\n25W条数据是极限了\n有一些10W条以下的小数据，删除成功了，但是之前使用的gorm的软删除，改为了直接删除\n\n解决方法：先查询需要删除的数量，如果大于一定数量，就不使用事务，自己分批次删除\n\n\n这个删除使用了代理模式，分为proxy，work,store三个层次\nproxy处理一些简单的外部响应，先删除外部的数据库\n真正的删除放在内部的store中，删除图片，redis,tidb\n\ntidb中有一个库的常用键值没有加索引，导致搜索的十分缓慢，所以加上了索引\n\n\n\n\n\n### 定时任务\n使用管道和协程回调函数，来实现一个定时任务\n对两天前的老数据进行清理\n\n\n\n# 为什么要用redis\n检测到的人的特征放在redis里面\n由于需要监控的人非常多，而且人需要存储的特征也非常多，并且总是需要使用到人的特征，所以放到redis里面\n需要保存轨迹点的数据，内容量很大，并且读写频率很高\n\n\n\n\n\n\n\n\n\n[消息队列浅析]https://developer.aliyun.com/article/988780?spm=a2c6h.12873639.article-detail.40.167b2eefaMJqaj&scm=20140722.ID_community@@article@@988780._.ID_community@@article@@988780-OR_rec-V_1\n[OpenTracing]https://blog.csdn.net/eight_eyes/article/details/117330608\n\n[数据结构 - 堆的应用场景]https://blog.csdn.net/it_lihongmin/article/details/114528779?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&utm_relevant_index=2\n[堆及堆的具体使用场景]https://www.jianshu.com/p/e8e267879b61\n\n\n","content":"<h1 id=\"实习中学到的新技术\"><a href=\"#实习中学到的新技术\" class=\"headerlink\" title=\"实习中学到的新技术\"></a>实习中学到的新技术</h1><p>2022.3~2022.4 基于 Linux 的 TinyWebServer<br>项目描述:该项目是为学习 Linux 网络编程知识，在 Linux 环境下使用 C++语言开发的轻量级多线程 HTTP<br>服务器，服务器支持一定数量的客户端连接并及时响应，支持客户端访问服务器的图片、视频等资源。<br>主要工作: 1、使用 Socket 实现不同主机之间的通信;<br>2、使用 Epoll 技术实现 I&#x2F;O 多路复用，提高效率;<br>3、使用有限状态机解析 HTTP 请求报文，对 GET 和 POST 请求进行处理4、利用多线程的机制，增加并行服务数量。<br>项目难点: 1、实现线程池，提高吞吐量;<br>2、编写主从状态机对 HTTP 报文进行解析;<br>个人收获: 1、在此项目中，使用 Makefile 进行编译，掌握一门全新的技术;<br>2、对 HTTP 的服务过程以及 TCP 三次握手有了更深的了解﹔<br>3、对于 Socket 通信以及 I&#x2F;0 复用有了一定的理解，对已有知识进行夯实</p>\n<p>2021.12~2022.1 杭州大数云智科技有限公司<br>1.通过学习 GitHub 上的开源项目 MotionPlanning，通过 python 实现一些路径规划的算法。。<br>2.使用 Vscode 通过 ssh 连接调试塔克机器人小车，通过 Ubuntu16.04 虚拟机搭载 ROS Melodic ，连接<br>小车，进行激光雷达、双目摄像头和深度相机的 SLAM 建模</p>\n<p>2022.6~2022.8 杭州后起智能科技有限公司</p>\n<p>1.加强了Git的各种使用方式</p>\n<p>自己的全面总结：<br>思想上：</p>\n<ol>\n<li>了解了公司的运行流程，互联网公司的组成模式<br>技术上：</li>\n<li>语言：</li>\n</ol>\n<p>5个go项目<br>4个c++项目,三个都和shell相关<br>3个数据库相关，MySQL<br>5个shell项目，两个重度shell<br>ansible,k8s,docker<br><del>wsl</del></p>\n<h1 id=\"新学的技术\"><a href=\"#新学的技术\" class=\"headerlink\" title=\"新学的技术\"></a>新学的技术</h1><p>docker<br>k8s<br>kubectl<br>grpc<br>git lfs<br>go语言</p>\n<p>Protocol Buffer<br>序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统<br>结构体标签<br>workpool</p>\n<p>HTTP 消息首部MIME 类型<br>poc<br>gorm中的事务，redis中事务</p>\n<p>并发读写，并发锁sync.Map<br>redis-cli<br>数据库<br>    TIDB<br>    redis</p>\n<p>存储<br>    分布式存储GlusterFS<br>    TIKV<br>    minio</p>\n<p>linux的VFS内容<br>etcd数据库备份<br>Ansible<br>cfssl证书<br>jinja<br>crontab自动执行<br>原型软件axure<br>BloomRPC<br>C++技术<br>    Snowflake算法<br>    消息阻塞队列<br>    对象池<br>        CustomObjectPool<br>        ObjectPool</p>\n<h2 id=\"GoLang\"><a href=\"#GoLang\" class=\"headerlink\" title=\"GoLang\"></a>GoLang</h2><ul>\n<li>grpc</li>\n<li>grom</li>\n<li>prototobuf</li>\n<li>消息队列</li>\n<li>分布式追踪系统 – Opentracing<br>navicate mysqlGUI工具<br>nsqlookupd：高性能消息中间件 NSQ 解析<br>NSQ——订阅摘要和推送摘要，日志流中间件<br>消息队列</li>\n</ul>\n<h1 id=\"对一些内容的详细解释\"><a href=\"#对一些内容的详细解释\" class=\"headerlink\" title=\"对一些内容的详细解释\"></a>对一些内容的详细解释</h1><h2 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h2><pre><code>kubernetes\nIAAS——基础服务设施\nPAAS——平台服务设施\n    docker——paas的下一代标准\n    k8s解决集群问题，每个机器里面都有一个docker\n    容器的集群化，资源管理器\n    apache——MESOS\n        分布式资源管理框架\n        2019 twitter不用了\n        推特在用，现在在用k8s\n\n    docker swarm\n        docker母公司\n        swarm集群\n        2019-7\n            阿里云宣布 docker swarm剔除\n\n\n    kubernetes\n        goolgle\n            10年容器化基础架构\n            公司里面在用borg\n            现在用go写了一个borg\n\n        特点\n            轻量级，消耗的资源少\n            开源\n            弹性伸缩\n            负载均衡：IPVS框架\n\n\n    人群\n        软件工程师\n        测试、运维、产品经理\n        需要了解产品底层框架\n\n\nSAAS\nraft算法\nsnap——\nwal——日志持久化存储\n</code></pre>\n<h2 id=\"分布式追踪系统-–-Opentracing\"><a href=\"#分布式追踪系统-–-Opentracing\" class=\"headerlink\" title=\"分布式追踪系统 – Opentracing\"></a>分布式追踪系统 – Opentracing</h2><pre><code>OpenTracing 于 2016 年 10 月加入 CNCF 基金会，是继 Kubernetes 和 Prometheus 之后，第三个加入 CNCF 的开源项目\n可方便开发者在自己的服务中集成一种或多种分布式追踪的实现\nLogging &amp; Metrics：可聚合的事件。例如分析某对象存储的 Nginx 日志，统计某段时间内\nGET、PUT、DELETE、OPTIONS 操作的总数。 Metrics &amp; Tracing：单个请求中的可计量数据。例如 SQL\n执行总时长、gRPC 调用总次数。 Tracing &amp; Logging：请求阶段的标签数据。例如在 Tracing\n的信息中标记详细的错误原因。\nLogging：ELK，近几年势头最猛的日志分析服务，无须多言。\nMetrics：Prometheus，第二个加入 CNCF 的开源项目，非常好用。\nTracing：OpenTracing 和 Jaeger，Jaeger 是 Uber 开源的一个兼容 OpenTracing 标准的分布式追踪服务。目前 Jaeger 也加入了 CNCF。\n</code></pre>\n<h1 id=\"SaaS\"><a href=\"#SaaS\" class=\"headerlink\" title=\"SaaS\"></a>SaaS</h1><p>SaaS是Software-as-a-Service的缩写名称，意思为软件即服务<br>    Facebook，Twitter，  Instagram。 Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting。</p>\n<p>PaaS：Platform-as-a-Service（平台即服务）提供给消费者的服务是把客户采用提供的开发语言和工具（例如Java，python, .Net等）开发的或收购的应用程序部署到供应商的云计算基础设施上去。<br>    MySQL，Mangodb，Java，Node.js</p>\n<p> IaaS： Infrastructure-as-a-Service（基础设施即服务）提供给消费者的服务是对所有计算基础设施的利用，包括处理CPU、内存、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。</p>\n<h1 id=\"NSQ\"><a href=\"#NSQ\" class=\"headerlink\" title=\"NSQ\"></a>NSQ</h1><p>NSQ——订阅摘要和推送摘要，日志流中间件<br>    NSQ是Go语言编写的一个开源的实时分布式内存消息队列，其性能十分优异。<br>    分布式实时消息平台<br>    NSQ 是实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。它具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征<br>    适合小型项目使用,用来学习消息队列实现原理、学习 golang channel知识以及如何用 go 来写分布式，为什么说适合小型小型项目使用因为，nsq 如果没有能力进行二次开发的情况存在的问题还是很多的。</p>\n<h1 id=\"档案导出的流程\"><a href=\"#档案导出的流程\" class=\"headerlink\" title=\"档案导出的流程\"></a>档案导出的流程</h1><!-- # 档案导入——增 -->\n\n<h1 id=\"档案查询——查\"><a href=\"#档案查询——查\" class=\"headerlink\" title=\"档案查询——查\"></a>档案查询——查</h1><p>大顶堆<br>优化mysql</p>\n<!-- 分库分表？ -->\n\n<p>查询的时候，每个项目的内容都非常的大，但是只需要用他们的一部分来排序<br>所以使用大顶堆来进行插入，插入的时候同时完成了排序<br>在需要使用的时候，直接将大顶堆读取出来就可以了</p>\n<h2 id=\"算法稳定性：\"><a href=\"#算法稳定性：\" class=\"headerlink\" title=\"算法稳定性：\"></a>算法稳定性：</h2><p>堆排序是一种不稳定的排序方法。<br>因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，<br>因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况</p>\n<p>但是不需要兼顾这个方面，因为出现频率相同的人，随便怎么排在一起都没有关系</p>\n<h1 id=\"档案导出——查\"><a href=\"#档案导出——查\" class=\"headerlink\" title=\"档案导出——查\"></a>档案导出——查</h1><p>多用户，多线程。上下文取消，广播进度，哈希表优化<br>minio</p>\n<h2 id=\"任务背景\"><a href=\"#任务背景\" class=\"headerlink\" title=\"任务背景\"></a>任务背景</h2><p>导出的命名格式为姓名-身份证<br>由于下载的内容十分繁重，总体逻辑，保证单用户只有一个下载任务<br>使用minio存储图片<br>下载的目标数量极大，1000-1W的数量级<br>档案中的人有1000个人，每个的档案，如果被布控的到，会有1-2K照片，每个照片20KB，jpg模式<br>下载的内容分为，档案图，人脸图，场景图</p>\n<h2 id=\"档案导出主函数\"><a href=\"#档案导出主函数\" class=\"headerlink\" title=\"档案导出主函数\"></a>档案导出主函数</h2><p>0.0 数据库初始化，在整个服务初始化的时候完成<br>0.1 获取上下文，打印日志，填写requestid<br>0.2 定义导出需要用到的接口<br>    - 导出主程序接口<br>    - 查询导出任务进度<br>    - 删除导出任务<br>1.验证用户输入是否正确</p>\n<p>2.先查询当前任务状态，如果已经有任务在执行，那么直接返回<br>    – 获取的下载目标，在数据库中无法存放数组，用字符串代替<br>    – 如果不是运行中，可能是任务未开始、任务失败、任务成功，都删除一下当前任务</p>\n<p>3.在数据库库中插入本次下载的记录<br>4.串联上下文，将上下文信息传递到协程里面，</p>\n<p>5.返回开始任务，进度为0%，接口运行结束</p>\n<h1 id=\"调试方法\"><a href=\"#调试方法\" class=\"headerlink\" title=\"调试方法\"></a>调试方法</h1><p>1.postman进行本地接口传入参数调试<br>2.直接放到服务器上的k8s中进行运行，打印日志进行调试</p>\n<h1 id=\"协程中的内容\"><a href=\"#协程中的内容\" class=\"headerlink\" title=\"协程中的内容\"></a>协程中的内容</h1><ol start=\"0\">\n<li>运行的过程中不停的更新进度的状态，进行进度广播</li>\n<li>使用线程池加速下载，线程池里面开线程池？？不可以？？<br> 8核下载全部轨迹，从135s-&gt;20s</li>\n<li>错误处理</li>\n<li>使用哈希表，减少摄像头信息的存储</li>\n<li>获取想要导出的目标的信息<br>目标的，姓名-身份证<br>如果需要导出的目标是空的，那还是建立一个空文件夹<br>有时候，需要下载的内容过于庞大了，超过了gRPC单次传输的上限，所以就用分页的方法来获取数据，（获取数据调用的别的微服务，那个接口支持分页）</li>\n<li>在本地建立需要导出目标的文件夹<br>目录为，随机uuid<ul>\n<li>找到可执行目录</li>\n<li>生成uuid</li>\n<li>uuid&#x2F;export&#x2F;建立业务文件夹<br>导出的图片是存在minio里面的，从网上下载下来，放在目录里面，压缩打包再上传</li>\n</ul>\n</li>\n<li>对需要下载的每个目标进行下载<br>更具业务需求，分情况讨论<br>下载的过程中，使用base64对图片地址进行解密<br>由于每个目标是独立的任务，所以可以使用线程池进行加速<ul>\n<li>需要调用其他的微服务，还获取图片数据</li>\n</ul>\n</li>\n<li>对生成的文件进行zip压缩</li>\n</ol>\n<ul>\n<li>使用defer删除建立的临时压缩报</li>\n<li>filepath.Walk来遍历文件压缩进去</li>\n</ul>\n<ol start=\"5\">\n<li>将压缩包上传到minio，将minio的地址存到数据库中<ul>\n<li>上传中修改了minio存储的ContentDisposition,修改了http下载时候的文件名</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"档案删除——删\"><a href=\"#档案删除——删\" class=\"headerlink\" title=\"档案删除——删\"></a>档案删除——删</h1><p>查了redis</p>\n<p>删除任务中，遇到了无法删除数据库内容的问题<br>查找后发现，删除的时候使用了事务，这个事务里面需要同时删除三个数据库中的数据，但是在有一个删除操作中，删除的量过大的，导致删除终止，整个事务回滚，删除失败<br>需要一次删除25w条数据，每条数据大概4000byte,<br>25W条数据是极限了<br>有一些10W条以下的小数据，删除成功了，但是之前使用的gorm的软删除，改为了直接删除</p>\n<p>解决方法：先查询需要删除的数量，如果大于一定数量，就不使用事务，自己分批次删除</p>\n<p>这个删除使用了代理模式，分为proxy，work,store三个层次<br>proxy处理一些简单的外部响应，先删除外部的数据库<br>真正的删除放在内部的store中，删除图片，redis,tidb</p>\n<p>tidb中有一个库的常用键值没有加索引，导致搜索的十分缓慢，所以加上了索引</p>\n<h3 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h3><p>使用管道和协程回调函数，来实现一个定时任务<br>对两天前的老数据进行清理</p>\n<h1 id=\"为什么要用redis\"><a href=\"#为什么要用redis\" class=\"headerlink\" title=\"为什么要用redis\"></a>为什么要用redis</h1><p>检测到的人的特征放在redis里面<br>由于需要监控的人非常多，而且人需要存储的特征也非常多，并且总是需要使用到人的特征，所以放到redis里面<br>需要保存轨迹点的数据，内容量很大，并且读写频率很高</p>\n<p>[消息队列浅析]<a href=\"https://developer.aliyun.com/article/988780?spm=a2c6h.12873639.article-detail.40.167b2eefaMJqaj&amp;scm=20140722.ID_community@@article@@988780._.ID_community@@article@@988780-OR_rec-V_1\">https://developer.aliyun.com/article/988780?spm=a2c6h.12873639.article-detail.40.167b2eefaMJqaj&amp;scm=20140722.ID_community@@article@@988780._.ID_community@@article@@988780-OR_rec-V_1</a><br>[OpenTracing]<a href=\"https://blog.csdn.net/eight_eyes/article/details/117330608\">https://blog.csdn.net/eight_eyes/article/details/117330608</a></p>\n<p>[数据结构 - 堆的应用场景]<a href=\"https://blog.csdn.net/it_lihongmin/article/details/114528779?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=2\">https://blog.csdn.net/it_lihongmin/article/details/114528779?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=2</a><br>[堆及堆的具体使用场景]<a href=\"https://www.jianshu.com/p/e8e267879b61\">https://www.jianshu.com/p/e8e267879b61</a></p>\n","slug":"Reflection/实习中用到的技术","updated":"15/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/08/22/Reflection/%E5%AE%9E%E4%B9%A0%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF/","excerpt":"","categories":[],"tags":[{"name":"反思","slug":"反思","permalink":"http://example.com/tags/%E5%8F%8D%E6%80%9D/"}]},{"title":"文章暂存","date":"16/08/2022","path":"2022/08/16/Article-tmp-storage/","text":"参考文献[CAP理论]https://cloud.tencent.com/developer/article/1860632[CAP 定理的含义- 阮一峰的网络日志]https://www.ruanyifeng.com/blog/2018/07/cap.htmlhttp://erdengk.top/archives/jian-li--mian-shi [软件工程师成长的一个误区]https://www.raychase.net/6965[十大信条]https://about.google/philosophy/","raw":"---\ntitle: 文章暂存\ndate: 2022-08-16 13:35:06\ntags:\n---\n\n\n\n\n\n# 参考文献\n[CAP理论]https://cloud.tencent.com/developer/article/1860632\n[CAP 定理的含义- 阮一峰的网络日志]https://www.ruanyifeng.com/blog/2018/07/cap.html\nhttp://erdengk.top/archives/jian-li--mian-shi\n\n\n\n[软件工程师成长的一个误区]https://www.raychase.net/6965\n[十大信条]https://about.google/philosophy/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[CAP理论]<a href=\"https://cloud.tencent.com/developer/article/1860632\">https://cloud.tencent.com/developer/article/1860632</a><br>[CAP 定理的含义- 阮一峰的网络日志]<a href=\"https://www.ruanyifeng.com/blog/2018/07/cap.html\">https://www.ruanyifeng.com/blog/2018/07/cap.html</a><br><a href=\"http://erdengk.top/archives/jian-li--mian-shi\">http://erdengk.top/archives/jian-li--mian-shi</a></p>\n<p>[软件工程师成长的一个误区]<a href=\"https://www.raychase.net/6965\">https://www.raychase.net/6965</a><br>[十大信条]<a href=\"https://about.google/philosophy/\">https://about.google/philosophy/</a></p>\n","slug":"Article-tmp-storage","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/08/16/Article-tmp-storage/","excerpt":"","categories":[],"tags":[]},{"title":"k8s教程","date":"11/08/2022","path":"2022/08/11/Course/k8s-tutorial/","text":"常见资源namspaceNamespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现多套环境的资源隔离或者多租户的资源隔离 kubectl get namespace kubectl get nc kubectl get rs my-name -n dev -o -wide -n 命名空间-o 查看pod节点详情 查看kubernetes的资源情况：kubectl get ns 查看kubernetes集群状态： kubectl get cs kubectl -n lookonce describe pods&#x2F;web-588rc查看pod的信息 Etcd 数据持久化和复制snap：用于存放快照数据。Etcd 为防止 WAL 文件过多会创建快照，snap 用于存储 Etcd 的快照数据状态。wal：用于存放预写式日志，其最大的作用是记录整个数据变化的全部历程。在 Etcd 中，所有数据的修改在提交前，都要先写入 WAL 中。使用 WAL 进行数据的存储使得 Etcd 拥有故障快速回复和数据回滚这两个重要功能。 删除podkubectl delete pod basic-pd-0 -n tidb-cluster Statefulsetkubectl -n tidb-cluster describe pod basic-pd-0 t edit StatefulSet basic-pd 查看一个pod的状态t describe pods basic-pd-0 重启策略restartPolicy: NeverAlways:容器失效时，自动重启该容器，这也是默认值OnFailure:容器终止运行且退出码不为0时重启Never :不论状态为何，都不重启该容器 钩子函数post startpre stop 钩子处理器支持使用下面三种方式定义动作： Exec命令：在容器内执行一次命令 …… lifecycle: postStart: exec: command: - cat - &#x2F;tmp&#x2F;healthy……TCPSocket：在当前容器尝试访问指定的socket …… lifecycle: postStart: tcpSocket: port: 8080……HTTPGet：在当前容器中向某url发起http请求 …… lifecycle: postStart: httpGet: path: &#x2F; #URI地址 port: 80 #端口号 host: 192.168.5.3 #主机地址 scheme: HTTP #支持的协议，http或者https…… 查看版本kubectl api-versions kubectl api-resources t get endpoints kubectl get pod -A 参考文献[大佬做的笔记]https://www.yuque.com/fairy-era/yg511q/szg74m备份etcd[kubernetes之StatefulSet详解]https://www.cnblogs.com/tylerzhou/p/11027559.html","raw":"---\ntitle: k8s教程\ndate: 2022-08-11 10:15:04\ntags:\n- 课程\n---\n\n\n\n# 常见资源\n## namspace\nNamespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现**多套环境的资源隔离**或者**多租户的资源隔离**\n\n\nkubectl get namespace\n\n\nkubectl get nc\n\n\n\nkubectl get rs my-name -n dev -o -wide \n\n\n-n 命名空间\n-o 查看pod节点详情\n\n# 查看kubernetes的资源情况：\nkubectl get ns\n\n# 查看kubernetes集群状态：\n kubectl get cs\n\nkubectl -n lookonce describe pods/web-588rc\n查看pod的信息\n\n# Etcd 数据持久化和复制\nsnap：用于存放快照数据。Etcd 为防止 WAL 文件过多会创建快照，snap 用于存储 Etcd 的快照数据状态。\nwal：用于存放预写式日志，其最大的作用是记录整个数据变化的全部历程。在 Etcd 中，所有数据的修改在提交前，都要先写入 WAL 中。使用 WAL 进行数据的存储使得 Etcd 拥有故障快速回复和数据回滚这两个重要功能。\n\n# 删除pod\nkubectl delete pod basic-pd-0 -n tidb-cluster\n\n\n# Statefulset\n\nkubectl -n tidb-cluster describe pod basic-pd-0\n\nt edit  StatefulSet basic-pd\n\n# 查看一个pod的状态\nt describe pods basic-pd-0\n\n\n重启策略\nrestartPolicy: Never\nAlways:容器失效时，自动重启该容器，这也是默认值\nOnFailure:容器终止运行且退出码不为0时重启\nNever :不论状态为何，都不重启该容器\n\n\n# 钩子函数\npost start\npre stop\n\n\n钩子处理器支持使用下面三种方式定义动作：\n\nExec命令：在容器内执行一次命令\n\n……\n  lifecycle:\n    postStart: \n      exec:\n        command:\n        - cat\n        - /tmp/healthy\n……\nTCPSocket：在当前容器尝试访问指定的socket\n\n……      \n  lifecycle:\n    postStart:\n      tcpSocket:\n        port: 8080\n……\nHTTPGet：在当前容器中向某url发起http请求\n\n……\n  lifecycle:\n    postStart:\n      httpGet:\n        path: / #URI地址\n        port: 80 #端口号\n        host: 192.168.5.3 #主机地址\n        scheme: HTTP #支持的协议，http或者https\n……\n\n\n# 查看版本\nkubectl api-versions\n\nkubectl api-resources\n\n\n\nt get endpoints\n\n\nkubectl get pod -A\n\n# 参考文献\n[大佬做的笔记]https://www.yuque.com/fairy-era/yg511q/szg74m\n[备份etcd](https://www.cnblogs.com/paul8339/p/15629241.html#:~:text=%E5%A4%87%E4%BB%BD%E6%93%8D%E4%BD%9C%E5%9C%A8etcd%E9%9B%86%E7%BE%A4%E7%9A%84%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E3%80%82%20%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFetcd%20v3%E7%9A%84api%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BB%8E%20k8s%201.13,%E5%BC%80%E5%A7%8B%EF%BC%8Ck8s%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%20v2%20%E7%89%88%E6%9C%AC%E7%9A%84%20etcd%EF%BC%8C%E5%8D%B3k8s%E7%9A%84%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E9%83%BD%E5%AD%98%E5%9C%A8%E4%BA%86v3%E7%89%88%E6%9C%AC%E7%9A%84etcd%E4%B8%AD%E3%80%82%20%E6%95%85%E5%A4%87%E4%BB%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%9F%E5%8F%AA%E5%A4%87%E4%BB%BD%E4%BA%86%E4%BD%BF%E7%94%A8v3%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%EF%BC%8Cv2%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%E6%98%AF%E6%B2%A1%E6%9C%89%E5%81%9A%E5%A4%87%E4%BB%BD%E7%9A%84%E3%80%82)\n[kubernetes之StatefulSet详解]https://www.cnblogs.com/tylerzhou/p/11027559.html\n","content":"<h1 id=\"常见资源\"><a href=\"#常见资源\" class=\"headerlink\" title=\"常见资源\"></a>常见资源</h1><h2 id=\"namspace\"><a href=\"#namspace\" class=\"headerlink\" title=\"namspace\"></a>namspace</h2><p>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现<strong>多套环境的资源隔离</strong>或者<strong>多租户的资源隔离</strong></p>\n<p>kubectl get namespace</p>\n<p>kubectl get nc</p>\n<p>kubectl get rs my-name -n dev -o -wide </p>\n<p>-n 命名空间<br>-o 查看pod节点详情</p>\n<h1 id=\"查看kubernetes的资源情况：\"><a href=\"#查看kubernetes的资源情况：\" class=\"headerlink\" title=\"查看kubernetes的资源情况：\"></a>查看kubernetes的资源情况：</h1><p>kubectl get ns</p>\n<h1 id=\"查看kubernetes集群状态：\"><a href=\"#查看kubernetes集群状态：\" class=\"headerlink\" title=\"查看kubernetes集群状态：\"></a>查看kubernetes集群状态：</h1><p> kubectl get cs</p>\n<p>kubectl -n lookonce describe pods&#x2F;web-588rc<br>查看pod的信息</p>\n<h1 id=\"Etcd-数据持久化和复制\"><a href=\"#Etcd-数据持久化和复制\" class=\"headerlink\" title=\"Etcd 数据持久化和复制\"></a>Etcd 数据持久化和复制</h1><p>snap：用于存放快照数据。Etcd 为防止 WAL 文件过多会创建快照，snap 用于存储 Etcd 的快照数据状态。<br>wal：用于存放预写式日志，其最大的作用是记录整个数据变化的全部历程。在 Etcd 中，所有数据的修改在提交前，都要先写入 WAL 中。使用 WAL 进行数据的存储使得 Etcd 拥有故障快速回复和数据回滚这两个重要功能。</p>\n<h1 id=\"删除pod\"><a href=\"#删除pod\" class=\"headerlink\" title=\"删除pod\"></a>删除pod</h1><p>kubectl delete pod basic-pd-0 -n tidb-cluster</p>\n<h1 id=\"Statefulset\"><a href=\"#Statefulset\" class=\"headerlink\" title=\"Statefulset\"></a>Statefulset</h1><p>kubectl -n tidb-cluster describe pod basic-pd-0</p>\n<p>t edit  StatefulSet basic-pd</p>\n<h1 id=\"查看一个pod的状态\"><a href=\"#查看一个pod的状态\" class=\"headerlink\" title=\"查看一个pod的状态\"></a>查看一个pod的状态</h1><p>t describe pods basic-pd-0</p>\n<p>重启策略<br>restartPolicy: Never<br>Always:容器失效时，自动重启该容器，这也是默认值<br>OnFailure:容器终止运行且退出码不为0时重启<br>Never :不论状态为何，都不重启该容器</p>\n<h1 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h1><p>post start<br>pre stop</p>\n<p>钩子处理器支持使用下面三种方式定义动作：</p>\n<p>Exec命令：在容器内执行一次命令</p>\n<p>……<br>  lifecycle:<br>    postStart:<br>      exec:<br>        command:<br>        - cat<br>        - &#x2F;tmp&#x2F;healthy<br>……<br>TCPSocket：在当前容器尝试访问指定的socket</p>\n<p>……<br>  lifecycle:<br>    postStart:<br>      tcpSocket:<br>        port: 8080<br>……<br>HTTPGet：在当前容器中向某url发起http请求</p>\n<p>……<br>  lifecycle:<br>    postStart:<br>      httpGet:<br>        path: &#x2F; #URI地址<br>        port: 80 #端口号<br>        host: 192.168.5.3 #主机地址<br>        scheme: HTTP #支持的协议，http或者https<br>……</p>\n<h1 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h1><p>kubectl api-versions</p>\n<p>kubectl api-resources</p>\n<p>t get endpoints</p>\n<p>kubectl get pod -A</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[大佬做的笔记]<a href=\"https://www.yuque.com/fairy-era/yg511q/szg74m\">https://www.yuque.com/fairy-era/yg511q/szg74m</a><br><a href=\"https://www.cnblogs.com/paul8339/p/15629241.html#:~:text=%E5%A4%87%E4%BB%BD%E6%93%8D%E4%BD%9C%E5%9C%A8etcd%E9%9B%86%E7%BE%A4%E7%9A%84%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E3%80%82%20%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFetcd%20v3%E7%9A%84api%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BB%8E%20k8s%201.13,%E5%BC%80%E5%A7%8B%EF%BC%8Ck8s%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%20v2%20%E7%89%88%E6%9C%AC%E7%9A%84%20etcd%EF%BC%8C%E5%8D%B3k8s%E7%9A%84%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E9%83%BD%E5%AD%98%E5%9C%A8%E4%BA%86v3%E7%89%88%E6%9C%AC%E7%9A%84etcd%E4%B8%AD%E3%80%82%20%E6%95%85%E5%A4%87%E4%BB%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%9F%E5%8F%AA%E5%A4%87%E4%BB%BD%E4%BA%86%E4%BD%BF%E7%94%A8v3%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%EF%BC%8Cv2%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%E6%98%AF%E6%B2%A1%E6%9C%89%E5%81%9A%E5%A4%87%E4%BB%BD%E7%9A%84%E3%80%82\">备份etcd</a><br>[kubernetes之StatefulSet详解]<a href=\"https://www.cnblogs.com/tylerzhou/p/11027559.html\">https://www.cnblogs.com/tylerzhou/p/11027559.html</a></p>\n","slug":"Course/k8s-tutorial","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/08/11/Course/k8s-tutorial/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"自己用到的脚本","date":"25/07/2022","path":"2022/07/25/Brids-Linux-private-kitchen/my-script/","text":"12345678910echo &quot;统计文件中代码行数&quot;c1=$(find -name &quot;*.cpp&quot; | wc -l)h1=$(find -name &quot;*.h&quot; | wc -l)echo &quot;文件个数：$(expr $&#123;c1&#125; + $&#123;h1&#125;),*.cpp:$&#123;c1&#125;,*.h:$&#123;h1&#125;&quot;c2=$(find -name &quot;*.cpp&quot; | xargs cat | wc -l)h2=$(find -name &quot;*.cpp&quot; | xargs cat | wc -l)echo &quot;总行数：$(expr $&#123;c2&#125; + $&#123;c2&#125;),*.cpp:$&#123;c2&#125;,*.h:$&#123;h2&#125;&quot;c3=$(find -name &quot;*.cpp&quot; | xargs cat | grep -v ^$| wc -l)h3=$(find -name &quot;*.cpp&quot; | xargs cat | grep -v ^$| wc -l)echo &quot;去掉空格行数：$(expr $&#123;c3&#125; + $&#123;c3&#125;),*.cpp:$&#123;c3&#125;,*.h:$&#123;h3&#125;&quot; 12cat &gt; &quot;&quot; &lt;&lt; &#x27;EOF&#x27;加载文件 参考文献[cat &lt;&lt; EOF]https://www.jianshu.com/p/df07d8498fa5","raw":"---\ntitle: 自己用到的脚本\ndate: 2022-07-25 21:03:06\ntags:\n---\n\n```\necho \"统计文件中代码行数\"\nc1=$(find -name \"*.cpp\"  | wc -l)\nh1=$(find -name \"*.h\"  | wc -l)\necho \"文件个数：$(expr ${c1} + ${h1}),*.cpp:${c1},*.h:${h1}\"\nc2=$(find -name \"*.cpp\"  | xargs cat | wc -l)\nh2=$(find -name \"*.cpp\"  | xargs cat | wc -l)\necho \"总行数：$(expr ${c2} + ${c2}),*.cpp:${c2},*.h:${h2}\"\nc3=$(find -name \"*.cpp\"  | xargs cat | grep -v ^$| wc -l)\nh3=$(find -name \"*.cpp\"  | xargs cat | grep -v ^$| wc -l)\necho \"去掉空格行数：$(expr ${c3} + ${c3}),*.cpp:${c3},*.h:${h3}\"\n```\n\n```\ncat > \"\" << 'EOF'\n加载文件\n```\n\n\n# 参考文献\n[cat << EOF]https://www.jianshu.com/p/df07d8498fa5\n","content":"<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo <span class=\"string\">&quot;统计文件中代码行数&quot;</span></span><br><span class=\"line\">c1=<span class=\"constructor\">$(<span class=\"params\">find</span> -<span class=\"params\">name</span> <span class=\"string\">&quot;*.cpp&quot;</span>  | <span class=\"params\">wc</span> -<span class=\"params\">l</span>)</span></span><br><span class=\"line\">h1=<span class=\"constructor\">$(<span class=\"params\">find</span> -<span class=\"params\">name</span> <span class=\"string\">&quot;*.h&quot;</span>  | <span class=\"params\">wc</span> -<span class=\"params\">l</span>)</span></span><br><span class=\"line\">echo <span class=\"string\">&quot;文件个数：$(expr $&#123;c1&#125; + $&#123;h1&#125;),*.cpp:$&#123;c1&#125;,*.h:$&#123;h1&#125;&quot;</span></span><br><span class=\"line\">c2=<span class=\"constructor\">$(<span class=\"params\">find</span> -<span class=\"params\">name</span> <span class=\"string\">&quot;*.cpp&quot;</span>  | <span class=\"params\">xargs</span> <span class=\"params\">cat</span> | <span class=\"params\">wc</span> -<span class=\"params\">l</span>)</span></span><br><span class=\"line\">h2=<span class=\"constructor\">$(<span class=\"params\">find</span> -<span class=\"params\">name</span> <span class=\"string\">&quot;*.cpp&quot;</span>  | <span class=\"params\">xargs</span> <span class=\"params\">cat</span> | <span class=\"params\">wc</span> -<span class=\"params\">l</span>)</span></span><br><span class=\"line\">echo <span class=\"string\">&quot;总行数：$(expr $&#123;c2&#125; + $&#123;c2&#125;),*.cpp:$&#123;c2&#125;,*.h:$&#123;h2&#125;&quot;</span></span><br><span class=\"line\">c3=<span class=\"constructor\">$(<span class=\"params\">find</span> -<span class=\"params\">name</span> <span class=\"string\">&quot;*.cpp&quot;</span>  | <span class=\"params\">xargs</span> <span class=\"params\">cat</span> | <span class=\"params\">grep</span> -<span class=\"params\">v</span> ^$| <span class=\"params\">wc</span> -<span class=\"params\">l</span>)</span></span><br><span class=\"line\">h3=<span class=\"constructor\">$(<span class=\"params\">find</span> -<span class=\"params\">name</span> <span class=\"string\">&quot;*.cpp&quot;</span>  | <span class=\"params\">xargs</span> <span class=\"params\">cat</span> | <span class=\"params\">grep</span> -<span class=\"params\">v</span> ^$| <span class=\"params\">wc</span> -<span class=\"params\">l</span>)</span></span><br><span class=\"line\">echo <span class=\"string\">&quot;去掉空格行数：$(expr $&#123;c3&#125; + $&#123;c3&#125;),*.cpp:$&#123;c3&#125;,*.h:$&#123;h3&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; <span class=\"string\">&quot;&quot;</span> &lt;&lt; <span class=\"string\">&#x27;EOF&#x27;</span></span><br><span class=\"line\">加载文件</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[cat &lt;&lt; EOF]<a href=\"https://www.jianshu.com/p/df07d8498fa5\">https://www.jianshu.com/p/df07d8498fa5</a></p>\n","slug":"Brids-Linux-private-kitchen/my-script","updated":"18/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/07/25/Brids-Linux-private-kitchen/my-script/","excerpt":"","categories":[],"tags":[]},{"title":"做饭相关","date":"25/07/2022","path":"2022/07/25/Others/cooking-knowledge/","text":"可乐鸡翅 鱼香肉丝、糖醋排骨、锅包肉紫菜皮蛋汤虾仁炒蛋青椒塞肉炸茄子 可乐鸡翅的改进步骤一：生姜、料酒，浸泡20分钟步骤二：焯水鸡翅切开树叶、八角、葱，料酒放到水里面煮到没有泡沫出来用冷水还是热水开始煮？？？步骤三：炒出糖色放八角、树叶、料酒、蒜、大葱炒到两面金黄，一直用大火放生抽、老抽、盐（一点）最后放入可乐，小火开始炖，可乐不要太多，要没过鸡翅就可以了，可乐可以分多次加炖20分钟，汤汁烧干汤汁烧干以后，打开锅盖，烧到出泡泡装盘 需要炒出糖色来 没有粘稠的感觉，感觉像是汤 可乐加的有点多 糖醋排骨主材料：排骨辅助材料：葱、大蒜、红尖椒调味料：盐 步骤一：备料 切排骨 放在清水中，放盐、淀粉，用手抓清洗，10min 焯水：冷水，生姜、葱、排骨、料酒不断的捞出泡沫 准备调味料： 料酒 生抽 香醋冰糖、 焯水之后用温水洗干净 步骤二：开始烧5. 排骨放到锅里面，家常做法用油煎，水分炒出来，炒到金黄，拿出来6. 炒糖色，放入冰糖，大火熬化，变成枣红色，开小火，开始冒小泡，放入排骨加入调料，香叶、两个八角、葱段、桂皮7. 把嫩汁炒成糖色，放入料酒，生抽，放醋8. 加入温水或热水，水没过排骨，放入冰糖9. 炖半个小时，小料拿出来，调出香料，开大火收汁，7-8分钟，自然芡10. 汤汁粘稠，放入米醋&#x2F;香醋 红烧茄子基础做法一：主材料：圆茄子辅助材料：葱、大蒜、红尖椒 切掉头，滚刀切块 茄子切好，放在碗里，放盐搅拌，腌制10分钟 调味料 生抽 老抽 白糖 盐 清水 耗油 淀粉 葱、大蒜、尖椒 茄子用手挤出水分，挤干（为了防止吸油）加入淀粉搅拌均匀 先炒（炸）茄子，开大火，油温要高表面焦黄、倒入蒜末，炒出香味倒入汤汁收干汤汁，加入葱花 进阶做法二：主材料：圆茄子次要材料：西红柿、青椒辅助材料：葱、大蒜 前4步相同 开始炒的时候不同5. 用宽油，先开大火炸茄子，炸酥脆以后捞出来6. 油温到7-8成以后，再放进去炸一遍，把青椒也放进去炸7. 炸好以后捞出来，开始烧新的，烧西红柿加入调味料，炒出汁水8. 放入刚刚炸过的茄子 下周计划鱼香肉丝茄子","raw":"---\ntitle: 做饭相关\ndate: 2022-07-25 00:49:09\ntags:\n---\n\n\n\n\n\n可乐鸡翅\n\n\n鱼香肉丝、糖醋排骨、锅包肉\n紫菜皮蛋汤\n虾仁炒蛋\n青椒塞肉\n炸茄子\n\n### 可乐鸡翅的改进\n\n\n步骤一：\n生姜、料酒，浸泡20分钟\n步骤二：\n焯水\n鸡翅切开\n树叶、八角、葱，料酒放到水里面煮到没有泡沫出来\n用冷水还是热水开始煮？？？\n步骤三：\n炒出糖色\n放八角、树叶、料酒、蒜、大葱\n炒到两面金黄，一直用大火\n放生抽、老抽、盐（一点）\n最后放入可乐，小火开始炖，可乐不要太多，要没过鸡翅就可以了，可乐可以分多次加\n炖20分钟，汤汁烧干\n汤汁烧干以后，打开锅盖，烧到出泡泡\n装盘\n\n\n\n\n1. 需要炒出糖色来\n2. 没有粘稠的感觉，感觉像是汤\n3. 可乐加的有点多\n\n### 糖醋排骨\n主材料：排骨\n辅助材料：葱、大蒜、红尖椒\n调味料：盐\n\n步骤一：备料\n1. 切排骨\n2. 放在清水中，放盐、淀粉，用手抓清洗，10min\n3. 焯水：冷水，生姜、葱、排骨、料酒\n不断的捞出泡沫\n4. 准备调味料：\n- 料酒\n- 生抽\n- 香醋\n冰糖、\n5. 焯水之后用温水洗干净\n\n步骤二：开始烧\n5. 排骨放到锅里面，家常做法用油煎，水分炒出来，炒到金黄，拿出来\n6. 炒糖色，放入冰糖，大火熬化，变成枣红色，开小火，开始冒小泡，放入排骨\n加入调料，香叶、两个八角、葱段、桂皮\n7. 把嫩汁炒成糖色，放入料酒，生抽，放醋\n8. 加入温水或热水，水没过排骨，放入冰糖\n9. 炖半个小时，小料拿出来，调出香料，开大火收汁，7-8分钟，自然芡\n10. 汤汁粘稠，放入米醋/香醋\n\n\n### 红烧茄子\n\n#### 基础做法一：\n主材料：圆茄子\n辅助材料：葱、大蒜、红尖椒\n\n1. 切掉头，滚刀切块\n2. 茄子切好，放在碗里，放盐搅拌，腌制10分钟\n3. 调味料\n- 生抽\n- 老抽\n- 白糖\n- 盐   \n- 清水\n- [ ] 耗油\n- [ ] 淀粉\n\n葱、大蒜、尖椒\n\n4. 茄子用手挤出水分，挤干（为了防止吸油）\n加入淀粉搅拌均匀\n\n5. 先炒（炸）茄子，开大火，油温要高\n表面焦黄、倒入蒜末，炒出香味\n倒入汤汁\n收干汤汁，加入葱花\n\n#### 进阶做法二：\n主材料：圆茄子\n次要材料：西红柿、青椒\n辅助材料：葱、大蒜\n\n\n前4步相同\n\n开始炒的时候不同\n5. 用宽油，先开大火炸茄子，炸酥脆以后捞出来\n6. 油温到7-8成以后，再放进去炸一遍，把青椒也放进去炸\n7. 炸好以后捞出来，开始烧新的，烧西红柿\n加入调味料，炒出汁水\n8. 放入刚刚炸过的茄子\n\n\n## 下周计划\n\n鱼香肉丝\n茄子\n\n","content":"<p>可乐鸡翅</p>\n<p>鱼香肉丝、糖醋排骨、锅包肉<br>紫菜皮蛋汤<br>虾仁炒蛋<br>青椒塞肉<br>炸茄子</p>\n<h3 id=\"可乐鸡翅的改进\"><a href=\"#可乐鸡翅的改进\" class=\"headerlink\" title=\"可乐鸡翅的改进\"></a>可乐鸡翅的改进</h3><p>步骤一：<br>生姜、料酒，浸泡20分钟<br>步骤二：<br>焯水<br>鸡翅切开<br>树叶、八角、葱，料酒放到水里面煮到没有泡沫出来<br>用冷水还是热水开始煮？？？<br>步骤三：<br>炒出糖色<br>放八角、树叶、料酒、蒜、大葱<br>炒到两面金黄，一直用大火<br>放生抽、老抽、盐（一点）<br>最后放入可乐，小火开始炖，可乐不要太多，要没过鸡翅就可以了，可乐可以分多次加<br>炖20分钟，汤汁烧干<br>汤汁烧干以后，打开锅盖，烧到出泡泡<br>装盘</p>\n<ol>\n<li>需要炒出糖色来</li>\n<li>没有粘稠的感觉，感觉像是汤</li>\n<li>可乐加的有点多</li>\n</ol>\n<h3 id=\"糖醋排骨\"><a href=\"#糖醋排骨\" class=\"headerlink\" title=\"糖醋排骨\"></a>糖醋排骨</h3><p>主材料：排骨<br>辅助材料：葱、大蒜、红尖椒<br>调味料：盐</p>\n<p>步骤一：备料</p>\n<ol>\n<li>切排骨</li>\n<li>放在清水中，放盐、淀粉，用手抓清洗，10min</li>\n<li>焯水：冷水，生姜、葱、排骨、料酒<br>不断的捞出泡沫</li>\n<li>准备调味料：</li>\n</ol>\n<ul>\n<li>料酒</li>\n<li>生抽</li>\n<li>香醋<br>冰糖、</li>\n</ul>\n<ol start=\"5\">\n<li>焯水之后用温水洗干净</li>\n</ol>\n<p>步骤二：开始烧<br>5. 排骨放到锅里面，家常做法用油煎，水分炒出来，炒到金黄，拿出来<br>6. 炒糖色，放入冰糖，大火熬化，变成枣红色，开小火，开始冒小泡，放入排骨<br>加入调料，香叶、两个八角、葱段、桂皮<br>7. 把嫩汁炒成糖色，放入料酒，生抽，放醋<br>8. 加入温水或热水，水没过排骨，放入冰糖<br>9. 炖半个小时，小料拿出来，调出香料，开大火收汁，7-8分钟，自然芡<br>10. 汤汁粘稠，放入米醋&#x2F;香醋</p>\n<h3 id=\"红烧茄子\"><a href=\"#红烧茄子\" class=\"headerlink\" title=\"红烧茄子\"></a>红烧茄子</h3><h4 id=\"基础做法一：\"><a href=\"#基础做法一：\" class=\"headerlink\" title=\"基础做法一：\"></a>基础做法一：</h4><p>主材料：圆茄子<br>辅助材料：葱、大蒜、红尖椒</p>\n<ol>\n<li>切掉头，滚刀切块</li>\n<li>茄子切好，放在碗里，放盐搅拌，腌制10分钟</li>\n<li>调味料</li>\n</ol>\n<ul>\n<li>生抽</li>\n<li>老抽</li>\n<li>白糖</li>\n<li>盐   </li>\n<li>清水</li>\n<li><input disabled=\"\" type=\"checkbox\"> 耗油</li>\n<li><input disabled=\"\" type=\"checkbox\"> 淀粉</li>\n</ul>\n<p>葱、大蒜、尖椒</p>\n<ol start=\"4\">\n<li><p>茄子用手挤出水分，挤干（为了防止吸油）<br>加入淀粉搅拌均匀</p>\n</li>\n<li><p>先炒（炸）茄子，开大火，油温要高<br>表面焦黄、倒入蒜末，炒出香味<br>倒入汤汁<br>收干汤汁，加入葱花</p>\n</li>\n</ol>\n<h4 id=\"进阶做法二：\"><a href=\"#进阶做法二：\" class=\"headerlink\" title=\"进阶做法二：\"></a>进阶做法二：</h4><p>主材料：圆茄子<br>次要材料：西红柿、青椒<br>辅助材料：葱、大蒜</p>\n<p>前4步相同</p>\n<p>开始炒的时候不同<br>5. 用宽油，先开大火炸茄子，炸酥脆以后捞出来<br>6. 油温到7-8成以后，再放进去炸一遍，把青椒也放进去炸<br>7. 炸好以后捞出来，开始烧新的，烧西红柿<br>加入调味料，炒出汁水<br>8. 放入刚刚炸过的茄子</p>\n<h2 id=\"下周计划\"><a href=\"#下周计划\" class=\"headerlink\" title=\"下周计划\"></a>下周计划</h2><p>鱼香肉丝<br>茄子</p>\n","slug":"Others/cooking-knowledge","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/07/25/Others/cooking-knowledge/","excerpt":"","categories":[],"tags":[]},{"title":"截图工具","date":"25/07/2022","path":"2022/07/25/Project/Screenshot-tool/","text":"需求分析看看市面上的截图工具 QQ截图独立版：https://bbs.pediy.com/thread-271332.htmSnipaste官网：https://zh.snipaste.com/eSearch官网：https://esearch.vercel.app/PicPick官网：https://picpick.app/zh/FastStone Capture官网：https://www.faststone.org/FSCaptureDetail.htmShareX官网：https://getsharex.com/ 自己想要什么功能","raw":"---\ntitle: 截图工具\ndate: 2022-07-25 00:44:29\ntags:\n- 项目\n---\n\n\n# 需求分析\n\n看看市面上的截图工具\n\nQQ截图独立版：https://bbs.pediy.com/thread-271332.htm\nSnipaste官网：https://zh.snipaste.com/\neSearch官网：https://esearch.vercel.app/\nPicPick官网：https://picpick.app/zh/\nFastStone Capture官网：https://www.faststone.org/FSCaptureDetail.htm\nShareX官网：https://getsharex.com/\n\n自己想要什么功能\n\n\n\n\n\n\n","content":"<h1 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h1><p>看看市面上的截图工具</p>\n<p>QQ截图独立版：<a href=\"https://bbs.pediy.com/thread-271332.htm\">https://bbs.pediy.com/thread-271332.htm</a><br>Snipaste官网：<a href=\"https://zh.snipaste.com/\">https://zh.snipaste.com/</a><br>eSearch官网：<a href=\"https://esearch.vercel.app/\">https://esearch.vercel.app/</a><br>PicPick官网：<a href=\"https://picpick.app/zh/\">https://picpick.app/zh/</a><br>FastStone Capture官网：<a href=\"https://www.faststone.org/FSCaptureDetail.htm\">https://www.faststone.org/FSCaptureDetail.htm</a><br>ShareX官网：<a href=\"https://getsharex.com/\">https://getsharex.com/</a></p>\n<p>自己想要什么功能</p>\n","slug":"Project/Screenshot-tool","updated":"19/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/07/25/Project/Screenshot-tool/","excerpt":"","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"webserver","date":"25/07/2022","path":"2022/07/25/Project/webserver/","text":"2022-7-24 task.josn和lanch.json可以跑起来了，可以用vscode远程连接调试 使用cmake进行编译 cmake编译中添加了mysql,可以操作数据库了 2022-7-25 学习了namespace和share_ptr是怎么使用的 2022-7-30 之前发现使用语句，但是日志无法写入fix:使用阻塞队列插入，但是自己还没有实现阻塞队列的内容，导致一直是空实现，就没法写进去了 遗留的问题：单例模式在vscode中如何调试，因为进去就是一个instant()函数了 改进使用vcpkg做包管理cmake中使用vcpkg使用httplib库使用jsoncpp库接口测试方法压力测试方法 epoll_eventEPOLLIN The associated file is available for read(2) operations. EPOLLOUT The associated file is available for write(2) operations. EPOLLRDHUP (since Linux 2.6.17) # 读取到一半连接关闭 # 读关闭 在使用 epoll 时，对端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件。在低于 2.6.17 版本的内核中，这个 epoll 事件一般是 EPOLLIN，即 0x1，代表连接可读。 返回到上层以后，上层读取会EOF，报告错误。 现在增加了这个以后，客户端断开连接，就可以在底层处理了 Stream socket peer closed connection, or shut down writing half of connection. (This flag is especially useful for writing simple code to detect peer shutdown when using Edge Triggered monitoring.) EPOLLERR # EPOLLERR 是服务器这边出错 相关文件描述符上发生错误情况。 这个 当读取结束时，管道的写入结束也会报告事件 已被关闭。 epoll_wait(2) 将始终报告此事件； 它 没有必要在事件中设置它。 Error condition happened on the associated file descriptor. This event is also reported for the write end of a pipe when the read end has been closed. epoll_wait(2) will always report for this event; it is not necessary to set it in events. EPOLLHUP # 读写都关闭 Hang up happened on the associated file descriptor. epoll_wait(2) will always wait for this event; it is not necessary to set it in events. Note that when reading from a channel such as a pipe or a stream socket, this event merely indicates that the peer closed its end of the channel. Subsequent reads from the channel will return 0 (end of file) only after all outstanding data in the channel has been con‐ sumed. 参考文献[日志系统]https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650122657&amp;idx=1&amp;sn=c5ce1d8059c40e4cd6deb42a34f8fe49&amp;chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&amp;scene=21#wechat_redirect[Reactor模型和Proactor模型]https://cloud.tencent.com/developer/article/1488120[Reactor模型]https://www.cnblogs.com/CodeBear/p/12567022.html[epoll 事件之 EPOLLRDHUP]https://yangwenbo.com/articles/epoll-event-epollrdhup.html","raw":"---\ntitle: webserver\ndate: 2022-07-25 00:41:31\ntags:\n- 项目\n---\n\n\n## 2022-7-24\n\n1. task.josn和lanch.json可以跑起来了，可以用vscode远程连接调试\n2. 使用cmake进行编译\n3. cmake编译中添加了mysql,可以操作数据库了\n\n\n## 2022-7-25\n\n1. 学习了namespace和share_ptr是怎么使用的\n\n\n\n# 2022-7-30\n1. 之前发现使用语句，但是日志无法写入\nfix:使用阻塞队列插入，但是自己还没有实现阻塞队列的内容，导致一直是空实现，就没法写进去了\n\n2. 遗留的问题：单例模式在vscode中如何调试，因为进去就是一个instant()函数了\n\n\n\n\n\n# 改进\n使用vcpkg做包管理\ncmake中使用vcpkg\n使用httplib库\n使用jsoncpp库\n接口测试方法\n压力测试方法\n\n\n# epoll_event\n\nEPOLLIN\n        The associated file is available for read(2) operations.\n\nEPOLLOUT\n        The associated file is available for write(2) operations.\n\nEPOLLRDHUP (since Linux 2.6.17) # 读取到一半连接关闭\n        # 读关闭\n        在使用 epoll 时，对端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件。在低于 2.6.17 版本的内核中，这个 epoll 事件一般是 EPOLLIN，即 0x1，代表连接可读。\n        返回到上层以后，上层读取会EOF，报告错误。\n        现在增加了这个以后，客户端断开连接，就可以在底层处理了\n        Stream socket peer closed connection, or shut  down  writing  half  of\n        connection.   (This  flag is especially useful for writing simple code\n        to detect peer shutdown when using Edge Triggered monitoring.)\n\nEPOLLERR\n        # EPOLLERR 是服务器这边出错\n        相关文件描述符上发生错误情况。 这个\n         当读取结束时，管道的写入结束也会报告事件\n         已被关闭。 epoll_wait(2) 将始终报告此事件； 它\n         没有必要在事件中设置它。\n        Error  condition  happened  on  the  associated file descriptor.  This\n        event is also reported for the write end of a pipe when the  read  end\n        has  been closed.  epoll_wait(2) will always report for this event; it\n        is not necessary to set it in events.\n\nEPOLLHUP\n        # 读写都关闭\n        Hang up happened on the  associated  file  descriptor.   epoll_wait(2)\n        will  always  wait  for  this  event; it is not necessary to set it in\n        events.\n\n        Note that when reading from a channel such  as  a  pipe  or  a  stream\n        socket,  this  event  merely indicates that the peer closed its end of\n        the channel.  Subsequent reads from the channel will return 0 (end  of\n        file)  only  after  all  outstanding data in the channel has been con‐\n        sumed.\n\n# 参考文献\n\n[日志系统]https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650122657&idx=1&sn=c5ce1d8059c40e4cd6deb42a34f8fe49&chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&scene=21#wechat_redirect\n[Reactor模型和Proactor模型]https://cloud.tencent.com/developer/article/1488120\n[Reactor模型]https://www.cnblogs.com/CodeBear/p/12567022.html\n[epoll 事件之 EPOLLRDHUP]https://yangwenbo.com/articles/epoll-event-epollrdhup.html\n\n","content":"<h2 id=\"2022-7-24\"><a href=\"#2022-7-24\" class=\"headerlink\" title=\"2022-7-24\"></a>2022-7-24</h2><ol>\n<li>task.josn和lanch.json可以跑起来了，可以用vscode远程连接调试</li>\n<li>使用cmake进行编译</li>\n<li>cmake编译中添加了mysql,可以操作数据库了</li>\n</ol>\n<h2 id=\"2022-7-25\"><a href=\"#2022-7-25\" class=\"headerlink\" title=\"2022-7-25\"></a>2022-7-25</h2><ol>\n<li>学习了namespace和share_ptr是怎么使用的</li>\n</ol>\n<h1 id=\"2022-7-30\"><a href=\"#2022-7-30\" class=\"headerlink\" title=\"2022-7-30\"></a>2022-7-30</h1><ol>\n<li><p>之前发现使用语句，但是日志无法写入<br>fix:使用阻塞队列插入，但是自己还没有实现阻塞队列的内容，导致一直是空实现，就没法写进去了</p>\n</li>\n<li><p>遗留的问题：单例模式在vscode中如何调试，因为进去就是一个instant()函数了</p>\n</li>\n</ol>\n<h1 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h1><p>使用vcpkg做包管理<br>cmake中使用vcpkg<br>使用httplib库<br>使用jsoncpp库<br>接口测试方法<br>压力测试方法</p>\n<h1 id=\"epoll-event\"><a href=\"#epoll-event\" class=\"headerlink\" title=\"epoll_event\"></a>epoll_event</h1><p>EPOLLIN<br>        The associated file is available for read(2) operations.</p>\n<p>EPOLLOUT<br>        The associated file is available for write(2) operations.</p>\n<p>EPOLLRDHUP (since Linux 2.6.17) # 读取到一半连接关闭<br>        # 读关闭<br>        在使用 epoll 时，对端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件。在低于 2.6.17 版本的内核中，这个 epoll 事件一般是 EPOLLIN，即 0x1，代表连接可读。<br>        返回到上层以后，上层读取会EOF，报告错误。<br>        现在增加了这个以后，客户端断开连接，就可以在底层处理了<br>        Stream socket peer closed connection, or shut  down  writing  half  of<br>        connection.   (This  flag is especially useful for writing simple code<br>        to detect peer shutdown when using Edge Triggered monitoring.)</p>\n<p>EPOLLERR<br>        # EPOLLERR 是服务器这边出错<br>        相关文件描述符上发生错误情况。 这个<br>         当读取结束时，管道的写入结束也会报告事件<br>         已被关闭。 epoll_wait(2) 将始终报告此事件； 它<br>         没有必要在事件中设置它。<br>        Error  condition  happened  on  the  associated file descriptor.  This<br>        event is also reported for the write end of a pipe when the  read  end<br>        has  been closed.  epoll_wait(2) will always report for this event; it<br>        is not necessary to set it in events.</p>\n<p>EPOLLHUP<br>        # 读写都关闭<br>        Hang up happened on the  associated  file  descriptor.   epoll_wait(2)<br>        will  always  wait  for  this  event; it is not necessary to set it in<br>        events.</p>\n<pre><code>    Note that when reading from a channel such  as  a  pipe  or  a  stream\n    socket,  this  event  merely indicates that the peer closed its end of\n    the channel.  Subsequent reads from the channel will return 0 (end  of\n    file)  only  after  all  outstanding data in the channel has been con‐\n    sumed.\n</code></pre>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[日志系统]<a href=\"https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650122657&amp;idx=1&amp;sn=c5ce1d8059c40e4cd6deb42a34f8fe49&amp;chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650122657&amp;idx=1&amp;sn=c5ce1d8059c40e4cd6deb42a34f8fe49&amp;chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&amp;scene=21#wechat_redirect</a><br>[Reactor模型和Proactor模型]<a href=\"https://cloud.tencent.com/developer/article/1488120\">https://cloud.tencent.com/developer/article/1488120</a><br>[Reactor模型]<a href=\"https://www.cnblogs.com/CodeBear/p/12567022.html\">https://www.cnblogs.com/CodeBear/p/12567022.html</a><br>[epoll 事件之 EPOLLRDHUP]<a href=\"https://yangwenbo.com/articles/epoll-event-epollrdhup.html\">https://yangwenbo.com/articles/epoll-event-epollrdhup.html</a></p>\n","slug":"Project/webserver","updated":"15/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/07/25/Project/webserver/","excerpt":"","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"Golang 面试","date":"27/06/2022","path":"2022/06/27/Interview-Q&A/Golang-Q&A/","text":"Go实现了两种并发形式第一种是，多线程共享内存。就是C++中实现的并发模型，他们线程间通信都是通过共享内存的方式来进行的。在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问。Go中也实现了传统的线程并发模型。另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。 Go的CSP并发模型，是通过goroutine和channel来实现的。 goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。 GMP模型介绍一下go runtinue使用了一个MPG模型来实现M指的是Machine，一个M直接关联了一个内核线程。所有的G(goroutine)任务最终都会在M上执行。P指的是processor，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。1．代表一个处理器，每个运行的M都必须绑定一个P。P的个数是GOMAXPOCS，最大为256，在程序启动时固定，一般不去修改。2.GOMAXPOCS默认值是当前电脑的核心数，单核CPU就只能设置为1，如果设置&gt;1，在GOMAXPOCS函数中也会被修改为1。3.M和P的个数不一定一样多，M&gt;&#x3D;P，每一个P都会保存本地的G任务队列，另外还有一个全局的G任务队列。G任务队列可以认为线程池中的线程队列。 G指的是Goroutine，代表一个goroutine对象，每次go调用的时候都会创建一个G对象，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。 go rutine调度流程 启动一个goroutine也就是创建一个G对象，然后加入到本地队列或者全局队列中 goroutineฎ按照抢占式进⾏调度，一个goroutine最多执行10ms就会换下一个2. 查找是否有空闲的P如果没有就直接返回如果有，就用系统API创建一个M(线程)3. 由这个刚创建的M循环执行能找到的G任务4. G任务执行的循序先从本地队列找，本地没有找到就从全局队列找，如果还没有找到就去其他P中找5. 所有的G任务的执行是按照go的调用顺序执行的6. 如果一个系统调用或者G任务执行的时间太长，就会一直占用这个线程 slice 底层和扩容defer 应用和底层内存管理垃圾回收熟悉docker，k8s，了解两者基本原理，了解devops实施方案，CICD，服务发现，灰度发布等 语法关键点defer关键字defer和go一样都是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。一般采用如下模式：defer是在return之前执行的。这个在 官方文档中是明确说明了的。要使用defer时不踩坑，最重要的一点就是要明白，return xxx这一条语句并不是一条原子指令!函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html make关键字chan关键字 反射机制 多进程go机制 参考文献[全面的golang教程]http://c.biancheng.net/golang/[defer关键字]https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html[GORM docs]https://gorm.io/zh_CN/docs/index.html","raw":"---\ntitle: Golang 面试\ndate: 2022-06-27 23:29:24\ntags:\n- 面试\n---\n\n\n\nGo实现了两种并发形式\n第一种是，多线程共享内存。就是C++中实现的并发模型，他们线程间通信都是通过共享内存的方式来进行的。在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问。Go中也实现了传统的线程并发模型。\n另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。\n\n\nGo的CSP并发模型，是通过goroutine和channel来实现的。\n\ngoroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。\nchannel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。\n\n\n\n\n# GMP模型介绍一下\ngo runtinue使用了一个MPG模型来实现\nM指的是Machine，一个M直接关联了一个内核线程。所有的G(goroutine)任务最终都会在M上执行。\nP指的是processor，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。\n1．代表一个处理器，每个运行的M都必须绑定一个P。P的个数是GOMAXPOCS，最大为256，在程序启动时固\n定，一般不去修改。\n2.GOMAXPOCS默认值是当前电脑的核心数，单核CPU就只能设置为1，如果设置>1，在GOMAXPOCS函数中\n也会被修改为1。\n3.M和P的个数不一定一样多，M>=P，每一个P都会保存本地的G任务队列，另外还有一个全局的G任务队列。G\n任务队列可以认为线程池中的线程队列。\n\nG指的是Goroutine，代表一个goroutine对象，每次go调用的时候都会创建一个G对象，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。\n\n# go rutine调度流程\n1. 启动一个goroutine\n也就是创建一个G对象，然后加入到本地队列或者全局队列中\n\ngoroutineฎ按照抢占式进⾏调度，一个goroutine最多执行10ms就会换下一个\n2. 查找是否有空闲的P\n如果没有就直接返回\n如果有，就用系统API创建一个M(线程)\n3. 由这个刚创建的M循环执行能找到的G任务\n4. G任务执行的循序\n先从本地队列找，本地没有找到就从全局队列找，如果还没有找到就去其他P中找\n5. 所有的G任务的执行是按照go的调用顺序执行的\n6. 如果一个系统调用或者G任务执行的时间太长，就会一直占用这个线程\n\n\n\n# slice 底层和扩容\n\n# defer 应用和底层\n\n# 内存管理\n\n# 垃圾回收\n\n# \n\n熟悉docker，k8s，了解两者基本原理，了解devops实施方案，CICD，服务发现，灰度发布等\n\n# 语法关键点\n\ndefer关键字\ndefer和go一样都是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。一般采用如下模式：\ndefer是在return之前执行的。这个在 官方文档中是明确说明了的。要使用defer时不踩坑，最重要的一点就是要明白，return xxx这一条语句并不是一条原子指令!\n函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。\ndefer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。\nhttps://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\n\nmake关键字\nchan关键字\n\n反射机制\n\n多进程go机制\n\n\n# 参考文献\n[全面的golang教程]http://c.biancheng.net/golang/\n[defer关键字]https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\n[GORM docs]https://gorm.io/zh_CN/docs/index.html\n\n\n\n","content":"<p>Go实现了两种并发形式<br>第一种是，多线程共享内存。就是C++中实现的并发模型，他们线程间通信都是通过共享内存的方式来进行的。在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问。Go中也实现了传统的线程并发模型。<br>另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。</p>\n<p>Go的CSP并发模型，是通过goroutine和channel来实现的。</p>\n<p>goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。<br>channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。</p>\n<h1 id=\"GMP模型介绍一下\"><a href=\"#GMP模型介绍一下\" class=\"headerlink\" title=\"GMP模型介绍一下\"></a>GMP模型介绍一下</h1><p>go runtinue使用了一个MPG模型来实现<br>M指的是Machine，一个M直接关联了一个内核线程。所有的G(goroutine)任务最终都会在M上执行。<br>P指的是processor，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。<br>1．代表一个处理器，每个运行的M都必须绑定一个P。P的个数是GOMAXPOCS，最大为256，在程序启动时固<br>定，一般不去修改。<br>2.GOMAXPOCS默认值是当前电脑的核心数，单核CPU就只能设置为1，如果设置&gt;1，在GOMAXPOCS函数中<br>也会被修改为1。<br>3.M和P的个数不一定一样多，M&gt;&#x3D;P，每一个P都会保存本地的G任务队列，另外还有一个全局的G任务队列。G<br>任务队列可以认为线程池中的线程队列。</p>\n<p>G指的是Goroutine，代表一个goroutine对象，每次go调用的时候都会创建一个G对象，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。</p>\n<h1 id=\"go-rutine调度流程\"><a href=\"#go-rutine调度流程\" class=\"headerlink\" title=\"go rutine调度流程\"></a>go rutine调度流程</h1><ol>\n<li>启动一个goroutine<br>也就是创建一个G对象，然后加入到本地队列或者全局队列中</li>\n</ol>\n<p>goroutineฎ按照抢占式进⾏调度，一个goroutine最多执行10ms就会换下一个<br>2. 查找是否有空闲的P<br>如果没有就直接返回<br>如果有，就用系统API创建一个M(线程)<br>3. 由这个刚创建的M循环执行能找到的G任务<br>4. G任务执行的循序<br>先从本地队列找，本地没有找到就从全局队列找，如果还没有找到就去其他P中找<br>5. 所有的G任务的执行是按照go的调用顺序执行的<br>6. 如果一个系统调用或者G任务执行的时间太长，就会一直占用这个线程</p>\n<h1 id=\"slice-底层和扩容\"><a href=\"#slice-底层和扩容\" class=\"headerlink\" title=\"slice 底层和扩容\"></a>slice 底层和扩容</h1><h1 id=\"defer-应用和底层\"><a href=\"#defer-应用和底层\" class=\"headerlink\" title=\"defer 应用和底层\"></a>defer 应用和底层</h1><h1 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h1><h1 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h1><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><p>熟悉docker，k8s，了解两者基本原理，了解devops实施方案，CICD，服务发现，灰度发布等</p>\n<h1 id=\"语法关键点\"><a href=\"#语法关键点\" class=\"headerlink\" title=\"语法关键点\"></a>语法关键点</h1><p>defer关键字<br>defer和go一样都是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。一般采用如下模式：<br>defer是在return之前执行的。这个在 官方文档中是明确说明了的。要使用defer时不踩坑，最重要的一点就是要明白，return xxx这一条语句并不是一条原子指令!<br>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。<br>defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。<br><a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a></p>\n<p>make关键字<br>chan关键字</p>\n<p>反射机制</p>\n<p>多进程go机制</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[全面的golang教程]<a href=\"http://c.biancheng.net/golang/\">http://c.biancheng.net/golang/</a><br>[defer关键字]<a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a><br>[GORM docs]<a href=\"https://gorm.io/zh_CN/docs/index.html\">https://gorm.io/zh_CN/docs/index.html</a></p>\n","slug":"Interview-Q&A/Golang-Q&A","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/27/Interview-Q&A/Golang-Q&A/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"百度和谷歌的比较","date":"22/06/2022","path":"2022/06/22/Others/Comparison-of-Baidu-an-Google/","text":"很多人都觉得百度也将就能用，之前我也是这么觉得的，后来能用谷歌以后，才发现区别是这么大，特地开一篇文章来对比谷歌和百度的搜索结果。以前四个页面搜索到为标准，如果还没有找到合适的答案，那么就选择正确的回回答 一、关键词：win11没有hyper-v百度： 百度回答1：看起来是个可以用的回答，但是这个命令的格式有点问题，有中文符号在里面，作为一个小白的话，直接粘贴肯定是没有效果的 百度回答2：怎么还是一样的回答，还是一样的错误格式 百度回答3：还是一样的错误格式 百度回答3：百度自家的内容，这种回答一般情况都是垃圾，这次也还是不知道哪里抄的回答，还是一样的格式错误 百度回答5：终于有了一个靠谱的回答，可以粘贴了 谷歌： 谷歌回答1：第一个回答就直接是格式正确的，并且作者还附上了下载链接，不会用的直接下载就可以，第一个答案就直接解决了 谷歌回答2：一个微软官方的回答，看起来比较靠谱，可以作为第一种无效的试一试的方案 谷歌回答3：又是一个正确的格式的回答，可以直接粘贴解决问题","raw":"---\ntitle: 百度和谷歌的比较\ndate: 2022-06-22 23:22:01\ntags:\n- 其他\n---\n\n\n很多人都觉得百度也将就能用，之前我也是这么觉得的，后来能用谷歌以后，才发现区别是这么大，特地开一篇文章来对比谷歌和百度的搜索结果。\n以前四个页面搜索到为标准，如果还没有找到合适的答案，那么就选择正确的回回答\n\n# 一、关键词：win11没有hyper-v\n百度：\n[![j9IRd1.png](https://s1.ax1x.com/2022/06/22/j9IRd1.png)](https://imgtu.com/i/j9IRd1)\n\n百度回答1：\n看起来是个可以用的回答，但是这个命令的格式有点问题，有中文符号在里面，作为一个小白的话，直接粘贴肯定是没有效果的\n[![j9o00A.png](https://s1.ax1x.com/2022/06/22/j9o00A.png)](https://imgtu.com/i/j9o00A)\n\n百度回答2：\n怎么还是一样的回答，还是一样的错误格式\n[![j9orkt.png](https://s1.ax1x.com/2022/06/22/j9orkt.png)](https://imgtu.com/i/j9orkt)\n\n百度回答3：\n还是一样的错误格式\n[![j9o26g.png](https://s1.ax1x.com/2022/06/22/j9o26g.png)](https://imgtu.com/i/j9o26g)\n\n百度回答3：\n百度自家的内容，这种回答一般情况都是垃圾，这次也还是不知道哪里抄的回答，还是一样的格式错误\n[![j9ostP.png](https://s1.ax1x.com/2022/06/22/j9ostP.png)](https://imgtu.com/i/j9ostP)\n\n百度回答5：\n终于有了一个靠谱的回答，可以粘贴了\n[![j9oBTI.png](https://s1.ax1x.com/2022/06/22/j9oBTI.png)](https://imgtu.com/i/j9oBTI)\n\n谷歌：\n[![j9I2ZR.png](https://s1.ax1x.com/2022/06/22/j9I2ZR.png)](https://imgtu.com/i/j9I2ZR)\n\n谷歌回答1：\n第一个回答就直接是格式正确的，并且作者还附上了下载链接，不会用的直接下载就可以，第一个答案就直接解决了\n[![j9oyff.png](https://s1.ax1x.com/2022/06/22/j9oyff.png)](https://imgtu.com/i/j9oyff)\n\n谷歌回答2：\n一个微软官方的回答，看起来比较靠谱，可以作为第一种无效的试一试的方案\n[![j9ocp8.png](https://s1.ax1x.com/2022/06/22/j9ocp8.png)](https://imgtu.com/i/j9ocp8)\n\n谷歌回答3：\n又是一个正确的格式的回答，可以直接粘贴解决问题\n[![j9og1S.png](https://s1.ax1x.com/2022/06/22/j9og1S.png)](https://imgtu.com/i/j9og1S)","content":"<p>很多人都觉得百度也将就能用，之前我也是这么觉得的，后来能用谷歌以后，才发现区别是这么大，特地开一篇文章来对比谷歌和百度的搜索结果。<br>以前四个页面搜索到为标准，如果还没有找到合适的答案，那么就选择正确的回回答</p>\n<h1 id=\"一、关键词：win11没有hyper-v\"><a href=\"#一、关键词：win11没有hyper-v\" class=\"headerlink\" title=\"一、关键词：win11没有hyper-v\"></a>一、关键词：win11没有hyper-v</h1><p>百度：<br><a href=\"https://imgtu.com/i/j9IRd1\"><img src=\"https://s1.ax1x.com/2022/06/22/j9IRd1.png\" alt=\"j9IRd1.png\"></a></p>\n<p>百度回答1：<br>看起来是个可以用的回答，但是这个命令的格式有点问题，有中文符号在里面，作为一个小白的话，直接粘贴肯定是没有效果的<br><a href=\"https://imgtu.com/i/j9o00A\"><img src=\"https://s1.ax1x.com/2022/06/22/j9o00A.png\" alt=\"j9o00A.png\"></a></p>\n<p>百度回答2：<br>怎么还是一样的回答，还是一样的错误格式<br><a href=\"https://imgtu.com/i/j9orkt\"><img src=\"https://s1.ax1x.com/2022/06/22/j9orkt.png\" alt=\"j9orkt.png\"></a></p>\n<p>百度回答3：<br>还是一样的错误格式<br><a href=\"https://imgtu.com/i/j9o26g\"><img src=\"https://s1.ax1x.com/2022/06/22/j9o26g.png\" alt=\"j9o26g.png\"></a></p>\n<p>百度回答3：<br>百度自家的内容，这种回答一般情况都是垃圾，这次也还是不知道哪里抄的回答，还是一样的格式错误<br><a href=\"https://imgtu.com/i/j9ostP\"><img src=\"https://s1.ax1x.com/2022/06/22/j9ostP.png\" alt=\"j9ostP.png\"></a></p>\n<p>百度回答5：<br>终于有了一个靠谱的回答，可以粘贴了<br><a href=\"https://imgtu.com/i/j9oBTI\"><img src=\"https://s1.ax1x.com/2022/06/22/j9oBTI.png\" alt=\"j9oBTI.png\"></a></p>\n<p>谷歌：<br><a href=\"https://imgtu.com/i/j9I2ZR\"><img src=\"https://s1.ax1x.com/2022/06/22/j9I2ZR.png\" alt=\"j9I2ZR.png\"></a></p>\n<p>谷歌回答1：<br>第一个回答就直接是格式正确的，并且作者还附上了下载链接，不会用的直接下载就可以，第一个答案就直接解决了<br><a href=\"https://imgtu.com/i/j9oyff\"><img src=\"https://s1.ax1x.com/2022/06/22/j9oyff.png\" alt=\"j9oyff.png\"></a></p>\n<p>谷歌回答2：<br>一个微软官方的回答，看起来比较靠谱，可以作为第一种无效的试一试的方案<br><a href=\"https://imgtu.com/i/j9ocp8\"><img src=\"https://s1.ax1x.com/2022/06/22/j9ocp8.png\" alt=\"j9ocp8.png\"></a></p>\n<p>谷歌回答3：<br>又是一个正确的格式的回答，可以直接粘贴解决问题<br><a href=\"https://imgtu.com/i/j9og1S\"><img src=\"https://s1.ax1x.com/2022/06/22/j9og1S.png\" alt=\"j9og1S.png\"></a></p>\n","slug":"Others/Comparison-of-Baidu-an-Google","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/22/Others/Comparison-of-Baidu-an-Google/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"docker安装教程","date":"22/06/2022","path":"2022/06/22/Environment-Configuration/docker-Installation-tutorial/","text":"在windows中安装docker desktop win11家庭版，没有开启hyper-v功能选项在桌面新建txt文件，复制下面代码，然后改名hyper-v.cmd，管理员方式执行 12345pushd &quot;%~dp0&quot;dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\\servicing\\Packages\\%%i&quot;del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 右键开始图标-&gt;应用和功能-&gt;左侧应用-&gt;可选功能-&gt;更多windows功能-&gt;hyper-v开启 参考文献[windwos11没有Hyper-V的解决方法]https://www.jianshu.com/p/96aa6eeacb56","raw":"---\ntitle: docker安装教程\ndate: 2022-06-22 23:16:36\ntags:\n- 环境配置\n---\n\n在windows中安装docker desktop\n\nwin11家庭版，没有开启hyper-v功能选项\n在桌面新建txt文件，复制下面代码，然后改名hyper-v.cmd，**管理员方式**执行\n```\npushd \"%~dp0\"\ndir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum >hyper-v.txt\nfor /f %%i in ('findstr /i . hyper-v.txt 2^>nul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\"\ndel hyper-v.txt\nDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL\n```\n右键开始图标->应用和功能->左侧应用->可选功能->更多windows功能->hyper-v开启\n\n\n\n\n\n# 参考文献\n\n[windwos11没有Hyper-V的解决方法]https://www.jianshu.com/p/96aa6eeacb56\n\n\n\n","content":"<p>在windows中安装docker desktop</p>\n<p>win11家庭版，没有开启hyper-v功能选项<br>在桌面新建txt文件，复制下面代码，然后改名hyper-v.cmd，<strong>管理员方式</strong>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">pushd</span> <span class=\"string\">&quot;%~dp0&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span> /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class=\"line\"><span class=\"keyword\">for</span> /f %%i <span class=\"keyword\">in</span> (<span class=\"string\">&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;</span>) <span class=\"keyword\">do</span> dism /online /norestart /add-package:<span class=\"string\">&quot;%SystemRoot%\\servicing\\Packages\\%%i&quot;</span></span><br><span class=\"line\">del hyper-v.txt</span><br><span class=\"line\">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure>\n<p>右键开始图标-&gt;应用和功能-&gt;左侧应用-&gt;可选功能-&gt;更多windows功能-&gt;hyper-v开启</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[windwos11没有Hyper-V的解决方法]<a href=\"https://www.jianshu.com/p/96aa6eeacb56\">https://www.jianshu.com/p/96aa6eeacb56</a></p>\n","slug":"Environment-Configuration/docker-Installation-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/22/Environment-Configuration/docker-Installation-tutorial/","excerpt":"","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Golang 语法","date":"21/06/2022","path":"2022/06/21/Grammar/Golang-Grammar/","text":"实习中用到的技术点常用的框架minio分布式存储gRPCGORMcontext包context上下文包解析 go 1.7以后才支持 用在协程里面 控制并发两种方式 使用 WaitGroup 使用Context 通用场景，多个goroutine执行同一件事情 主动通知停止channel + select 如果有多个goroutine,或者goroutine里面又有goroutine 需要使用context控制 client -&gt; server#1 -&gt; server#2请求 req应答 res 用户中间中断请求，那么中间的资源全部浪费了，当用户切断的时候，能马上停止 ctx :&#x3D; context.Backgroud() context.WithCancle(ctx)d 参考文献[语法介绍]https://www.topgoer.com/[Golang 的 time.Now() 给你的是什么时间？]https://www.jianshu.com/p/896cc3f4ee82","raw":"---\ntitle: Golang 语法\ndate: 2022-06-21 00:03:01\ntags:\n- 语法\n---\n\n\n\n# 实习中用到的技术点\n\n\n\n# 常用的框架\n\n## minio分布式存储\n\n## gRPC\n\n## GORM\n\n# context包\ncontext上下文包解析\n\ngo 1.7以后才支持\n\n用在协程里面\n\n控制并发两种方式\n\t使用 WaitGroup\n\t使用Context\n\n通用场景，多个goroutine执行同一件事情\n\n主动通知停止\nchannel + select\n\n如果有多个goroutine,或者goroutine里面又有goroutine\n\n需要使用context控制\n\n\nclient -> server#1 -> server#2\n请求 req\n应答 res\n\n用户中间中断请求，那么中间的资源全部浪费了，当用户切断的时候，能马上停止\n\n\nctx := context.Backgroud()\n\ncontext.WithCancle(ctx)d\n\n\n# 参考文献\n\n[语法介绍]https://www.topgoer.com/\n[Golang 的 time.Now() 给你的是什么时间？]https://www.jianshu.com/p/896cc3f4ee82","content":"<h1 id=\"实习中用到的技术点\"><a href=\"#实习中用到的技术点\" class=\"headerlink\" title=\"实习中用到的技术点\"></a>实习中用到的技术点</h1><h1 id=\"常用的框架\"><a href=\"#常用的框架\" class=\"headerlink\" title=\"常用的框架\"></a>常用的框架</h1><h2 id=\"minio分布式存储\"><a href=\"#minio分布式存储\" class=\"headerlink\" title=\"minio分布式存储\"></a>minio分布式存储</h2><h2 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h2><h2 id=\"GORM\"><a href=\"#GORM\" class=\"headerlink\" title=\"GORM\"></a>GORM</h2><h1 id=\"context包\"><a href=\"#context包\" class=\"headerlink\" title=\"context包\"></a>context包</h1><p>context上下文包解析</p>\n<p>go 1.7以后才支持</p>\n<p>用在协程里面</p>\n<p>控制并发两种方式<br>    使用 WaitGroup<br>    使用Context</p>\n<p>通用场景，多个goroutine执行同一件事情</p>\n<p>主动通知停止<br>channel + select</p>\n<p>如果有多个goroutine,或者goroutine里面又有goroutine</p>\n<p>需要使用context控制</p>\n<p>client -&gt; server#1 -&gt; server#2<br>请求 req<br>应答 res</p>\n<p>用户中间中断请求，那么中间的资源全部浪费了，当用户切断的时候，能马上停止</p>\n<p>ctx :&#x3D; context.Backgroud()</p>\n<p>context.WithCancle(ctx)d</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[语法介绍]<a href=\"https://www.topgoer.com/\">https://www.topgoer.com/</a><br>[Golang 的 time.Now() 给你的是什么时间？]<a href=\"https://www.jianshu.com/p/896cc3f4ee82\">https://www.jianshu.com/p/896cc3f4ee82</a></p>\n","slug":"Grammar/Golang-Grammar","updated":"26/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/21/Grammar/Golang-Grammar/","excerpt":"","categories":[],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"实习内容","date":"19/06/2022","path":"2022/06/19/Reflection/Intern-Log/","text":"2022.6.13-6.19 本周的工作内容，周一安装环境，了解docker周二了解docker，可以把docker的镜像跑起来周三出现了巨大问题，程序一直没有弄明白，也没有问别人周四还是在做周三做的事情，而且效率很底下周五完成任务，得到了新的任务 总结和反思：1.当自己有问题解决不了的，分析问题的原因，来自自己，还是来自别人，接下来，我解决这个问题，需要寻求别人的帮助，还是自己去找方法解决2.下午后半段的工作效率不高，在中午的时候，以3:00区分，规划一下下午的3点前后的任务。在3:00的时候应该对自己当前的工作状况进行反思，看一下现在自己状态好不好，设计一下接下来干什么3.当自己程序看不懂的时候，很大情况下是自己知识点的欠缺，需要去补足，先把东西学会，再去做东西，效率会更高4.应该一直做同一个工作，不要总是换来换去 需要加强的：构建docker镜像的能力，只是会用docker命令，还是没有具体了解docker内部的情况 202.6.20-6.24本周内容：周一熟悉gorm,gRPC，看代码，还没有跑起来周二得到需求，分析需求，搭调试环境，学postman周三实现导出名字和身份证周四读取图片，不会连接轨迹服务器周五花了一天的时间连接轨迹服务器，终于连上了 不足的：1.遇到业务上无法解决的问题，应该及时的提问2.写业务的时候，可以先构思需要的函数的输入输出是什么，然后把每个子函数都写好，然后再去写内容（封装的思想）3.对一个新语言的不熟悉，就是要手打代码段一点一点的多敲才能熟悉，不要总是粘贴4.大佬写的代码总是能一气呵成，修改比较少，自己的代码就是需要反复的修改，所以特别慢，并且这次是新语言，新框架，而且要用数据库，所以写起来，试错的时间更加长了5.总结一下：语法不熟悉、对业务的把控能力很弱、对代码的把控能力很弱（不知道要怎么开这些函数） postman 的问题如果实际的proto没有更新，但是自己在发送框里面写了内容，实际上是没有发出去的 思考和总结 思考一个问题，准备开发一个项目的时候，考虑的方式应该是”先大后小再大“以档案导出为例来说明 先大——先从最大的角度考利，档案导出需要什么样的接口，导出的时候会会遇到什么样的问题，先确定最主要的三个接口，导出档案，查询进度，删除档案但是也不用特别的大，要有范围，给一定的总体的布局时间 后小——真正开始写项目了，就需要落到细节处理，思考这个具体的功能应该如何实现， 全部写完以后，从头到尾开始审查，这个项目现在还有什么问题，需要怎么去解决比如全都写完以后做错误处理4）交给测试 参考文献[mysql和sqlserver删除指定条数的数据记录，mysql delete limit和sqlserver delete top]https://blog.csdn.net/guangmo0123/article/details/109353553[mysql 中数据表 DATA_LENGTH &amp; INDEX_LENGTH]http://dbaselife.com/project-7/doc-1112/[mySQL 数据类型]https://www.runoob.com/mysql/mysql-data-types.html [Amazon S3]https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax[mysql 官方文档]https://www.mysqlzh.com/doc/65.html[mysql 中 创建索引很慢，怎么解决]https://www.debugease.com/mysql/282296.html[TIDB 的书]https://book.tidb.io/[从一个简单的Delete删数据场景谈TiDB数据库开发规范的重要性]https://zhuanlan.zhihu.com/p/427227246","raw":"---\ntitle: 实习内容\ndate: 2022-06-19 23:43:01\ntags:\n- 反思\n---\n\n2022.6.13-6.19\n\n本周的工作内容，\n周一安装环境，了解docker\n周二了解docker，可以把docker的镜像跑起来\n周三出现了巨大问题，程序一直没有弄明白，也没有问别人\n周四还是在做周三做的事情，而且效率很底下\n周五完成任务，得到了新的任务\n\n总结和反思：\n1.当自己有问题解决不了的，分析问题的原因，来自自己，还是来自别人，接下来，我解决这个问题，需要寻求别人的帮助，还是自己去找方法解决\n2.下午后半段的工作效率不高，在中午的时候，以3:00区分，规划一下下午的3点前后的任务。\n在3:00的时候应该对自己当前的工作状况进行反思，看一下现在自己状态好不好，设计一下接下来干什么\n3.当自己程序看不懂的时候，很大情况下是自己知识点的欠缺，需要去补足，先把东西学会，再去做东西，效率会更高\n4.应该一直做同一个工作，不要总是换来换去\n\n\n需要加强的：\n构建docker镜像的能力，只是会用docker命令，还是没有具体了解docker内部的情况\n\n\n202.6.20-6.24\n本周内容：\n周一熟悉gorm,gRPC，看代码，还没有跑起来\n周二得到需求，分析需求，搭调试环境，学postman\n周三实现导出名字和身份证\n周四读取图片，不会连接轨迹服务器\n周五花了一天的时间连接轨迹服务器，终于连上了\n\n不足的：\n1.遇到业务上无法解决的问题，应该及时的提问\n2.写业务的时候，可以先构思需要的函数的输入输出是什么，然后把每个子函数都写好，然后再去写内容（封装的思想）\n3.对一个新语言的不熟悉，就是要手打代码段一点一点的多敲才能熟悉，不要总是粘贴\n4.大佬写的代码总是能一气呵成，修改比较少，自己的代码就是需要反复的修改，所以特别慢，并且这次是新语言，新框架，而且要用数据库，所以写起来，试错的时间更加长了\n5.总结一下：语法不熟悉、对业务的把控能力很弱、对代码的把控能力很弱（不知道要怎么开这些函数）\n\n\n\n# postman 的问题\n如果实际的proto没有更新，但是自己在发送框里面写了内容，实际上是没有发出去的\n\n\n\n# 思考和总结\n1. 思考一个问题，准备开发一个项目的时候，考虑的方式应该是”先大后小再大“\n以档案导出为例来说明\n1) 先大——先从最大的角度考利，档案导出需要什么样的接口，导出的时候会会遇到什么样的问题，先确定最主要的三个接口，导出档案，查询进度，删除档案\n但是也不用特别的大，要有范围，给一定的总体的布局时间\n2) 后小——真正开始写项目了，就需要落到细节处理，思考这个具体的功能应该如何实现，\n3) 全部写完以后，从头到尾开始审查，这个项目现在还有什么问题，需要怎么去解决\n比如全都写完以后做错误处理\n4）交给测试\n\n\n\n\n# 参考文献\n[mysql和sqlserver删除指定条数的数据记录，mysql delete limit和sqlserver delete top]https://blog.csdn.net/guangmo0123/article/details/109353553\n[mysql 中数据表 DATA_LENGTH & INDEX_LENGTH]http://dbaselife.com/project-7/doc-1112/\n[mySQL 数据类型]https://www.runoob.com/mysql/mysql-data-types.html\n\n[Amazon S3]https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax\n[mysql 官方文档]https://www.mysqlzh.com/doc/65.html\n[mysql 中 创建索引很慢，怎么解决]https://www.debugease.com/mysql/282296.html\n[TIDB 的书]https://book.tidb.io/\n[从一个简单的Delete删数据场景谈TiDB数据库开发规范的重要性]https://zhuanlan.zhihu.com/p/427227246\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>2022.6.13-6.19</p>\n<p>本周的工作内容，<br>周一安装环境，了解docker<br>周二了解docker，可以把docker的镜像跑起来<br>周三出现了巨大问题，程序一直没有弄明白，也没有问别人<br>周四还是在做周三做的事情，而且效率很底下<br>周五完成任务，得到了新的任务</p>\n<p>总结和反思：<br>1.当自己有问题解决不了的，分析问题的原因，来自自己，还是来自别人，接下来，我解决这个问题，需要寻求别人的帮助，还是自己去找方法解决<br>2.下午后半段的工作效率不高，在中午的时候，以3:00区分，规划一下下午的3点前后的任务。<br>在3:00的时候应该对自己当前的工作状况进行反思，看一下现在自己状态好不好，设计一下接下来干什么<br>3.当自己程序看不懂的时候，很大情况下是自己知识点的欠缺，需要去补足，先把东西学会，再去做东西，效率会更高<br>4.应该一直做同一个工作，不要总是换来换去</p>\n<p>需要加强的：<br>构建docker镜像的能力，只是会用docker命令，还是没有具体了解docker内部的情况</p>\n<p>202.6.20-6.24<br>本周内容：<br>周一熟悉gorm,gRPC，看代码，还没有跑起来<br>周二得到需求，分析需求，搭调试环境，学postman<br>周三实现导出名字和身份证<br>周四读取图片，不会连接轨迹服务器<br>周五花了一天的时间连接轨迹服务器，终于连上了</p>\n<p>不足的：<br>1.遇到业务上无法解决的问题，应该及时的提问<br>2.写业务的时候，可以先构思需要的函数的输入输出是什么，然后把每个子函数都写好，然后再去写内容（封装的思想）<br>3.对一个新语言的不熟悉，就是要手打代码段一点一点的多敲才能熟悉，不要总是粘贴<br>4.大佬写的代码总是能一气呵成，修改比较少，自己的代码就是需要反复的修改，所以特别慢，并且这次是新语言，新框架，而且要用数据库，所以写起来，试错的时间更加长了<br>5.总结一下：语法不熟悉、对业务的把控能力很弱、对代码的把控能力很弱（不知道要怎么开这些函数）</p>\n<h1 id=\"postman-的问题\"><a href=\"#postman-的问题\" class=\"headerlink\" title=\"postman 的问题\"></a>postman 的问题</h1><p>如果实际的proto没有更新，但是自己在发送框里面写了内容，实际上是没有发出去的</p>\n<h1 id=\"思考和总结\"><a href=\"#思考和总结\" class=\"headerlink\" title=\"思考和总结\"></a>思考和总结</h1><ol>\n<li>思考一个问题，准备开发一个项目的时候，考虑的方式应该是”先大后小再大“<br>以档案导出为例来说明</li>\n</ol>\n<ol>\n<li>先大——先从最大的角度考利，档案导出需要什么样的接口，导出的时候会会遇到什么样的问题，先确定最主要的三个接口，导出档案，查询进度，删除档案<br>但是也不用特别的大，要有范围，给一定的总体的布局时间</li>\n<li>后小——真正开始写项目了，就需要落到细节处理，思考这个具体的功能应该如何实现，</li>\n<li>全部写完以后，从头到尾开始审查，这个项目现在还有什么问题，需要怎么去解决<br>比如全都写完以后做错误处理<br>4）交给测试</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[mysql和sqlserver删除指定条数的数据记录，mysql delete limit和sqlserver delete top]<a href=\"https://blog.csdn.net/guangmo0123/article/details/109353553\">https://blog.csdn.net/guangmo0123/article/details/109353553</a><br>[mysql 中数据表 DATA_LENGTH &amp; INDEX_LENGTH]<a href=\"http://dbaselife.com/project-7/doc-1112/\">http://dbaselife.com/project-7/doc-1112/</a><br>[mySQL 数据类型]<a href=\"https://www.runoob.com/mysql/mysql-data-types.html\">https://www.runoob.com/mysql/mysql-data-types.html</a></p>\n<p>[Amazon S3]<a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax\">https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax</a><br>[mysql 官方文档]<a href=\"https://www.mysqlzh.com/doc/65.html\">https://www.mysqlzh.com/doc/65.html</a><br>[mysql 中 创建索引很慢，怎么解决]<a href=\"https://www.debugease.com/mysql/282296.html\">https://www.debugease.com/mysql/282296.html</a><br>[TIDB 的书]<a href=\"https://book.tidb.io/\">https://book.tidb.io/</a><br>[从一个简单的Delete删数据场景谈TiDB数据库开发规范的重要性]<a href=\"https://zhuanlan.zhihu.com/p/427227246\">https://zhuanlan.zhihu.com/p/427227246</a></p>\n","slug":"Reflection/Intern-Log","updated":"22/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/19/Reflection/Intern-Log/","excerpt":"","categories":[],"tags":[{"name":"反思","slug":"反思","permalink":"http://example.com/tags/%E5%8F%8D%E6%80%9D/"}]},{"title":"docker 教程","date":"19/06/2022","path":"2022/06/19/Course/docker-tutorial/","text":"docker 安装教程一、docker 镜像命令镜像查看docker images -a #列出本地所有的镜像docker images -q #只显示镜像IDdocker images –digests #显示镜像的摘要信息docker images –no-trunc #显示完整的镜像信息 NAME #名称DESCRIPTION #描述STARS #点赞，关注度，类似GitHubOFFICIAL #是否官方AUTOMATED #是否自动构建 请确认输入了正确的用户名和密码。 镜像下载docker pull tomcat #从Docker Hub上下载tomcat镜像，默认是最新版本。等价于：docker pull tomcat:latestdocker pull tomcat:8 # 选择指定版本下载 镜像运行此时从镜像变成了容器docker run 镜像名docker run 镜像名:Tag –name&#x3D;”nginx-lb”: 为容器指定一个名称；-P：随机映射 -P后不能指定参数，随机选一个对外端口映射出去-p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -p 8888:6379 -p 8888:6379 解析 将容器内部的 6379端口与docker 宿主机（docker装在哪太服务器 那台服务器 就是其数组机）8888 端口进行映射 那通过外部访问宿主机8888端口 即可访问到 docker 容器 6379 端口了-d: 后台运行容器，并返回容器ID；-i: 以交互模式运行容器，通常与 -t 同时使用；-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –privileged 大约在0.6版，privileged被引入docker。 使用该参数，container内的root拥有真正的root权限。 否则，container内的root只是外部的一个普通用户权限。 privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。 甚至允许你在docker容器中启动docker容器 docker run -it –privileged -v D:\\test:&#x2F;output -d -p 8010:22 -p 50001:50051 -p 50002:50052 -p 50005:55555 e9e8789a3024 docker run -it –name&#x3D;”u1” -v $PWD:&#x2F;myapp ubuntu:latest &#x2F;bin&#x2F;bash 在端口映射以后，需要测试一下映射是否成功ssh &#114;&#x6f;&#111;&#x74;&#64;&#49;&#50;&#x37;&#x2e;&#x30;&#x2e;&#x30;&#46;&#49; -p 8010 镜像删除docker rmi java#强制删除(删除正在运行的镜像，注：以后台方式运行的不能被强制删除)docker rmi -f java#多个镜像删除，不同镜像间以空格间隔docker rmi -f java tomcat nginx#删除本地全部镜像docker rmi -f $(docker images -q) 二、docker 容器命令查看容器查看正在运行容器列表docker ps查看所有容器 —–包含正在运行 和已停止的docker ps -a 停止容器docker stop 容器名&#x2F;容器ID 进入容器docker exec -it 容器名&#x2F;容器ID &#x2F;bin&#x2F;bashdocker exec -it test01 &#x2F;bin&#x2F;bash 启动容器docker start 容器ID&#x2F;容器名docker start t1 删除容器#删除一个容器docker rm -f 容器名&#x2F;容器ID#删除多个容器 空格隔开要删除的容器名或容器IDdocker rm -f 容器名&#x2F;容器ID 容器名&#x2F;容器ID 容器名&#x2F;容器ID#删除全部容器docker rm -f $(docker ps -aq) 查看容器端口映射docker port [容器名]需要这个容器被启动，才能查看到他的端口映射情况 参考资料[Ubuntu20.04安装docker]https://blog.csdn.net/m0_59092234/article/details/123816391#:~:text=Ubuntu20.04%20%E5%AE%89%E8%A3%85Docker%201859%20%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%201%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E5%BA%93%E6%BA%90%20sudo%20apt-get%20update,2%E3%80%81%E7%84%B6%20%E5%90%8E%20%E7%9B%B4%E6%8E%A5%20sudo%20apt%20install%20docker.io%20%2F3%E3%80%82[docker hub]https://hub.docker.com/","raw":"---\ntitle: docker 教程\ndate: 2022-06-19 23:39:25\ntags:\n- 课程\n---\n\n\n# docker 安装教程\n\n# 一、docker 镜像命令\n\n## 镜像查看\ndocker images -a            #列出本地所有的镜像\ndocker images -q            #只显示镜像ID\ndocker images --digests     #显示镜像的摘要信息\ndocker images --no-trunc    #显示完整的镜像信息\n\nNAME            #名称\nDESCRIPTION     #描述\nSTARS           #点赞，关注度，类似GitHub\nOFFICIAL        #是否官方\nAUTOMATED       #是否自动构建 请确认输入了正确的用户名和密码。\n\n## 镜像下载\ndocker pull tomcat      #从Docker Hub上下载tomcat镜像，默认是最新版本。等价于：docker pull tomcat:latest\ndocker pull tomcat:8  # 选择指定版本下载\n\n## 镜像运行\n此时从镜像变成了容器\ndocker run 镜像名\ndocker run 镜像名:Tag\n\n--name=\"nginx-lb\": 为容器指定一个名称；\n-P：随机映射\n    -P后不能指定参数，随机选一个对外端口映射出去\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n    -p 8888:6379\n    -p 8888:6379 解析 将容器内部的 6379端口与docker 宿主机（docker装在哪太服务器 那台服务器 就是其数组机）8888 端口进行映射 那通过外部访问宿主机8888端口 即可访问到 docker 容器 6379 端口了\n-d: 后台运行容器，并返回容器ID；\n-i: 以交互模式运行容器，通常与 -t 同时使用；\n-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n --privileged\n    大约在0.6版，privileged被引入docker。\n    使用该参数，container内的root拥有真正的root权限。\n    否则，container内的root只是外部的一个普通用户权限。\n    privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。\n    甚至允许你在docker容器中启动docker容器\n\ndocker run -it --privileged -v D:\\test\\:/output -d -p 8010:22 -p 50001:50051 -p 50002:50052 -p 50005:55555 e9e8789a3024\n\ndocker run -it --name=\"u1\" -v $PWD:/myapp ubuntu:latest /bin/bash\n\n在端口映射以后，需要测试一下映射是否成功\nssh root@127.0.0.1 -p 8010\n\n## 镜像删除\ndocker rmi java\n#强制删除(删除正在运行的镜像，注：以后台方式运行的不能被强制删除)\ndocker rmi -f java\n#多个镜像删除，不同镜像间以空格间隔\ndocker rmi -f java tomcat nginx\n#删除本地全部镜像\ndocker rmi -f $(docker images -q)\n\n# 二、docker 容器命令\n\n## 查看容器\n查看正在运行容器列表\ndocker ps\n查看所有容器 -----包含正在运行 和已停止的\ndocker ps -a\n\n\n## 停止容器\ndocker stop 容器名/容器ID\n\n## 进入容器\ndocker exec -it 容器名/容器ID /bin/bash\ndocker exec -it test01 /bin/bash\n\n## 启动容器\ndocker start 容器ID/容器名\ndocker start t1\n\n\n## 删除容器\n#删除一个容器\ndocker rm -f 容器名/容器ID\n#删除多个容器 空格隔开要删除的容器名或容器ID\ndocker rm -f 容器名/容器ID 容器名/容器ID 容器名/容器ID\n#删除全部容器\ndocker rm -f $(docker ps -aq)\n\n## 查看容器端口映射\n\ndocker port [容器名]\n需要这个容器被启动，才能查看到他的端口映射情况\n\n\n\n# 参考资料\n[Ubuntu20.04安装docker]https://blog.csdn.net/m0_59092234/article/details/123816391#:~:text=Ubuntu20.04%20%E5%AE%89%E8%A3%85Docker%201859%20%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%201%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E5%BA%93%E6%BA%90%20sudo%20apt-get%20update,2%E3%80%81%E7%84%B6%20%E5%90%8E%20%E7%9B%B4%E6%8E%A5%20sudo%20apt%20install%20docker.io%20%2F3%E3%80%82\n[docker hub]https://hub.docker.com/\n\n\n","content":"<h1 id=\"docker-安装教程\"><a href=\"#docker-安装教程\" class=\"headerlink\" title=\"docker 安装教程\"></a>docker 安装教程</h1><h1 id=\"一、docker-镜像命令\"><a href=\"#一、docker-镜像命令\" class=\"headerlink\" title=\"一、docker 镜像命令\"></a>一、docker 镜像命令</h1><h2 id=\"镜像查看\"><a href=\"#镜像查看\" class=\"headerlink\" title=\"镜像查看\"></a>镜像查看</h2><p>docker images -a            #列出本地所有的镜像<br>docker images -q            #只显示镜像ID<br>docker images –digests     #显示镜像的摘要信息<br>docker images –no-trunc    #显示完整的镜像信息</p>\n<p>NAME            #名称<br>DESCRIPTION     #描述<br>STARS           #点赞，关注度，类似GitHub<br>OFFICIAL        #是否官方<br>AUTOMATED       #是否自动构建 请确认输入了正确的用户名和密码。</p>\n<h2 id=\"镜像下载\"><a href=\"#镜像下载\" class=\"headerlink\" title=\"镜像下载\"></a>镜像下载</h2><p>docker pull tomcat      #从Docker Hub上下载tomcat镜像，默认是最新版本。等价于：docker pull tomcat:latest<br>docker pull tomcat:8  # 选择指定版本下载</p>\n<h2 id=\"镜像运行\"><a href=\"#镜像运行\" class=\"headerlink\" title=\"镜像运行\"></a>镜像运行</h2><p>此时从镜像变成了容器<br>docker run 镜像名<br>docker run 镜像名:Tag</p>\n<p>–name&#x3D;”nginx-lb”: 为容器指定一个名称；<br>-P：随机映射<br>    -P后不能指定参数，随机选一个对外端口映射出去<br>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>    -p 8888:6379<br>    -p 8888:6379 解析 将容器内部的 6379端口与docker 宿主机（docker装在哪太服务器 那台服务器 就是其数组机）8888 端口进行映射 那通过外部访问宿主机8888端口 即可访问到 docker 容器 6379 端口了<br>-d: 后台运行容器，并返回容器ID；<br>-i: 以交互模式运行容器，通常与 -t 同时使用；<br>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br> –privileged<br>    大约在0.6版，privileged被引入docker。<br>    使用该参数，container内的root拥有真正的root权限。<br>    否则，container内的root只是外部的一个普通用户权限。<br>    privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。<br>    甚至允许你在docker容器中启动docker容器</p>\n<p>docker run -it –privileged -v D:\\test:&#x2F;output -d -p 8010:22 -p 50001:50051 -p 50002:50052 -p 50005:55555 e9e8789a3024</p>\n<p>docker run -it –name&#x3D;”u1” -v $PWD:&#x2F;myapp ubuntu:latest &#x2F;bin&#x2F;bash</p>\n<p>在端口映射以后，需要测试一下映射是否成功<br>ssh <a href=\"mailto:&#114;&#x6f;&#111;&#x74;&#64;&#49;&#50;&#x37;&#x2e;&#x30;&#x2e;&#x30;&#46;&#49;\">&#114;&#x6f;&#111;&#x74;&#64;&#49;&#50;&#x37;&#x2e;&#x30;&#x2e;&#x30;&#46;&#49;</a> -p 8010</p>\n<h2 id=\"镜像删除\"><a href=\"#镜像删除\" class=\"headerlink\" title=\"镜像删除\"></a>镜像删除</h2><p>docker rmi java<br>#强制删除(删除正在运行的镜像，注：以后台方式运行的不能被强制删除)<br>docker rmi -f java<br>#多个镜像删除，不同镜像间以空格间隔<br>docker rmi -f java tomcat nginx<br>#删除本地全部镜像<br>docker rmi -f $(docker images -q)</p>\n<h1 id=\"二、docker-容器命令\"><a href=\"#二、docker-容器命令\" class=\"headerlink\" title=\"二、docker 容器命令\"></a>二、docker 容器命令</h1><h2 id=\"查看容器\"><a href=\"#查看容器\" class=\"headerlink\" title=\"查看容器\"></a>查看容器</h2><p>查看正在运行容器列表<br>docker ps<br>查看所有容器 —–包含正在运行 和已停止的<br>docker ps -a</p>\n<h2 id=\"停止容器\"><a href=\"#停止容器\" class=\"headerlink\" title=\"停止容器\"></a>停止容器</h2><p>docker stop 容器名&#x2F;容器ID</p>\n<h2 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h2><p>docker exec -it 容器名&#x2F;容器ID &#x2F;bin&#x2F;bash<br>docker exec -it test01 &#x2F;bin&#x2F;bash</p>\n<h2 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h2><p>docker start 容器ID&#x2F;容器名<br>docker start t1</p>\n<h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><p>#删除一个容器<br>docker rm -f 容器名&#x2F;容器ID<br>#删除多个容器 空格隔开要删除的容器名或容器ID<br>docker rm -f 容器名&#x2F;容器ID 容器名&#x2F;容器ID 容器名&#x2F;容器ID<br>#删除全部容器<br>docker rm -f $(docker ps -aq)</p>\n<h2 id=\"查看容器端口映射\"><a href=\"#查看容器端口映射\" class=\"headerlink\" title=\"查看容器端口映射\"></a>查看容器端口映射</h2><p>docker port [容器名]<br>需要这个容器被启动，才能查看到他的端口映射情况</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[Ubuntu20.04安装docker]<a href=\"https://blog.csdn.net/m0_59092234/article/details/123816391#:~:text=Ubuntu20.04%20%E5%AE%89%E8%A3%85Docker%201859%20%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%201%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E5%BA%93%E6%BA%90%20sudo%20apt-get%20update,2%E3%80%81%E7%84%B6%20%E5%90%8E%20%E7%9B%B4%E6%8E%A5%20sudo%20apt%20install%20docker.io%20%2F3%E3%80%82\">https://blog.csdn.net/m0_59092234/article/details/123816391#:~:text=Ubuntu20.04%20%E5%AE%89%E8%A3%85Docker%201859%20%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%201%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E5%BA%93%E6%BA%90%20sudo%20apt-get%20update,2%E3%80%81%E7%84%B6%20%E5%90%8E%20%E7%9B%B4%E6%8E%A5%20sudo%20apt%20install%20docker.io%20%2F3%E3%80%82</a><br>[docker hub]<a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></p>\n","slug":"Course/docker-tutorial","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/19/Course/docker-tutorial/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"mudduo-ch01","date":"25/05/2022","path":"2022/05/25/Linux-Network-Programming/ChenShuo-muduo/mudduo-ch01/","text":"仅仅只能在linux下运行 第一步muduo采用CMake为build systemCMake的安装如下：（CMake最好不低于2.8版，CentOS 6自带的2.6版也能用，但是无法自动识别Protobuf库） 12sudo apt-get install cmakesudo apt-get install g++ 第二步muduo依赖于Boost，Boost的安装如下 1sudo apt-get install libboost-dev libboost-test-dev 安装出现问题 123E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 5865 (unattended-upgr)N: Be aware that removing the lock file is not a solution and may break your system.E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it? 解决方法： 123sudo rm /var/lib/dpkg/lock-frontendsudo rm /var/lib/dpkg/locksudo rm /var/cache/apt/archives/lock 第三步（可选）muduo有三个非必须的依赖库（curl、c-ares DNS、Google Protobuf）如果安装了这三个库，cmake会自动多编译一些示例安装方法如下： 12sudo apt-get install libcurl4-openssl-dev libc-ares-devsudo apt-get install protobuf-compiler libprotobuf-dev 第四步：下载muduo源码包1git clone https://github.com/chenshuo/muduo.git 第五步：编译muduo1234# 下载完成之后进入muduo根目录cd muduo# 编译muduo库和它自带的例子./build.sh -j2 编译完成之后：会在muduo源码根路径的上一级路径下生成一个build目录（下面全文我们以..&#x2F;build表示）生成的可执行文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;bin静态文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;lib 第六步：安装muduo库1./build.sh install muduo头文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;include目录下库文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;lib目录下以便muduo-protorpc和muduo-udns等库使用 参考文献陈硕的博客 https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html陈硕的csdn https://blog.csdn.net/Solstice?type=blog陈硕的课程主页 http://chenshuo.com/practical-network-programming/相关的代码仓库：http://github.com/chenshuo/muduohttp://github.com/chenshuo/recipeshttp://github.com/chenshuo/muduo-protorpchttp://github.com/chenshuo/muduo-examples-in-go如何安装 https://www.365seal.com/y/elnWyG1GVr.htmlmake编译源码时-j的作用 https://blog.csdn.net/JeekMrc/article/details/118332252安装boost的问题 https://zhuanlan.zhihu.com/p/126538251","raw":"---\ntitle: mudduo-ch01\ndate: 2022-05-25 21:15:34\ntags:\n---\n\n仅仅只能在linux下运行\n## 第一步\nmuduo采用CMake为build system\nCMake的安装如下：（CMake最好不低于2.8版，CentOS 6自带的2.6版也能用，但是无法自动识别Protobuf库）\n```\nsudo apt-get install cmake\nsudo apt-get install g++\n```\n## 第二步\nmuduo依赖于Boost，Boost的安装如下\n```\nsudo apt-get install libboost-dev libboost-test-dev\n```\n安装出现问题\n```\nE: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 5865 (unattended-upgr)\nN: Be aware that removing the lock file is not a solution and may break your system.\nE: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?\n```\n解决方法：\n```\nsudo rm /var/lib/dpkg/lock-frontend\nsudo rm /var/lib/dpkg/lock\nsudo rm /var/cache/apt/archives/lock\n```\n## 第三步（可选）\nmuduo有三个非必须的依赖库（curl、c-ares DNS、Google Protobuf）如果安装了这三个库，cmake会自动多编译一些示例\n安装方法如下：\n```\nsudo apt-get install libcurl4-openssl-dev libc-ares-dev\nsudo apt-get install protobuf-compiler libprotobuf-dev\n```\n\n## 第四步：下载muduo源码包\n```\ngit clone https://github.com/chenshuo/muduo.git\n```\n\n## 第五步：编译muduo\n```\n# 下载完成之后进入muduo根目录\ncd muduo\n# 编译muduo库和它自带的例子\n./build.sh -j2\n```\n编译完成之后：\n会在muduo源码根路径的上一级路径下生成一个build目录（下面全文我们以../build表示）\n生成的可执行文件位于：../build/release-cpp11/bin\n静态文件位于：../build/release-cpp11/lib\n\n## 第六步：安装muduo库\n```\n./build.sh install\n```\nmuduo头文件安装在../build/release-install-cpp11/include目录下\n库文件安装在../build/release-install-cpp11/lib目录下\n以便muduo-protorpc和muduo-udns等库使用\n\n# 参考文献\n陈硕的博客 https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html\n陈硕的csdn https://blog.csdn.net/Solstice?type=blog\n陈硕的课程主页 http://chenshuo.com/practical-network-programming/\n相关的代码仓库：\nhttp://github.com/chenshuo/muduo\nhttp://github.com/chenshuo/recipes\nhttp://github.com/chenshuo/muduo-protorpc\nhttp://github.com/chenshuo/muduo-examples-in-go\n如何安装 https://www.365seal.com/y/elnWyG1GVr.html\nmake编译源码时-j的作用 https://blog.csdn.net/JeekMrc/article/details/118332252\n安装boost的问题 https://zhuanlan.zhihu.com/p/126538251\n\n\n\n","content":"<p>仅仅只能在linux下运行</p>\n<h2 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h2><p>muduo采用CMake为build system<br>CMake的安装如下：（CMake最好不低于2.8版，CentOS 6自带的2.6版也能用，但是无法自动识别Protobuf库）</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install cmake</span><br><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install g++</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h2><p>muduo依赖于Boost，Boost的安装如下</p>\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install libboost-<span class=\"built_in\">dev</span> libboost-test-<span class=\"built_in\">dev</span></span><br></pre></td></tr></table></figure>\n<p>安装出现问题</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E: Could <span class=\"keyword\">not</span> <span class=\"keyword\">get</span> <span class=\"keyword\">lock</span> /<span class=\"keyword\">var</span>/lib/dpkg/<span class=\"keyword\">lock</span>-frontend. It <span class=\"keyword\">is</span> held <span class=\"keyword\">by</span> process <span class=\"number\">5865</span> (unattended-upgr)</span><br><span class=\"line\">N: Be aware that removing the <span class=\"keyword\">lock</span> file <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> a solution <span class=\"keyword\">and</span> may <span class=\"keyword\">break</span> your system.</span><br><span class=\"line\">E: <span class=\"function\">Unable to acquire the dpkg frontend <span class=\"title\">lock</span> (<span class=\"params\">/<span class=\"keyword\">var</span>/lib/dpkg/<span class=\"keyword\">lock</span>-frontend</span>), <span class=\"keyword\">is</span> another process <span class=\"keyword\">using</span> it?</span></span><br></pre></td></tr></table></figure>\n<p>解决方法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm <span class=\"regexp\">/var/</span>lib<span class=\"regexp\">/dpkg/</span>lock-frontend</span><br><span class=\"line\">sudo rm <span class=\"regexp\">/var/</span>lib<span class=\"regexp\">/dpkg/</span>lock</span><br><span class=\"line\">sudo rm <span class=\"regexp\">/var/</span>cache<span class=\"regexp\">/apt/</span>archives/lock</span><br></pre></td></tr></table></figure>\n<h2 id=\"第三步（可选）\"><a href=\"#第三步（可选）\" class=\"headerlink\" title=\"第三步（可选）\"></a>第三步（可选）</h2><p>muduo有三个非必须的依赖库（curl、c-ares DNS、Google Protobuf）如果安装了这三个库，cmake会自动多编译一些示例<br>安装方法如下：</p>\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install libcurl4-openssl-<span class=\"built_in\">dev</span> libc-ares-<span class=\"built_in\">dev</span></span><br><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install protobuf-compiler libprotobuf-<span class=\"built_in\">dev</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第四步：下载muduo源码包\"><a href=\"#第四步：下载muduo源码包\" class=\"headerlink\" title=\"第四步：下载muduo源码包\"></a>第四步：下载muduo源码包</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:<span class=\"regexp\">//gi</span>thub.com<span class=\"regexp\">/chenshuo/mu</span>duo.git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第五步：编译muduo\"><a href=\"#第五步：编译muduo\" class=\"headerlink\" title=\"第五步：编译muduo\"></a>第五步：编译muduo</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载完成之后进入muduo根目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> muduo</span><br><span class=\"line\"><span class=\"comment\"># 编译muduo库和它自带的例子</span></span><br><span class=\"line\">./build.sh -j2</span><br></pre></td></tr></table></figure>\n<p>编译完成之后：<br>会在muduo源码根路径的上一级路径下生成一个build目录（下面全文我们以..&#x2F;build表示）<br>生成的可执行文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;bin<br>静态文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;lib</p>\n<h2 id=\"第六步：安装muduo库\"><a href=\"#第六步：安装muduo库\" class=\"headerlink\" title=\"第六步：安装muduo库\"></a>第六步：安装muduo库</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./build.sh install</span><br></pre></td></tr></table></figure>\n<p>muduo头文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;include目录下<br>库文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;lib目录下<br>以便muduo-protorpc和muduo-udns等库使用</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>陈硕的博客 <a href=\"https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html\">https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html</a><br>陈硕的csdn <a href=\"https://blog.csdn.net/Solstice?type=blog\">https://blog.csdn.net/Solstice?type=blog</a><br>陈硕的课程主页 <a href=\"http://chenshuo.com/practical-network-programming/\">http://chenshuo.com/practical-network-programming/</a><br>相关的代码仓库：<br><a href=\"http://github.com/chenshuo/muduo\">http://github.com/chenshuo/muduo</a><br><a href=\"http://github.com/chenshuo/recipes\">http://github.com/chenshuo/recipes</a><br><a href=\"http://github.com/chenshuo/muduo-protorpc\">http://github.com/chenshuo/muduo-protorpc</a><br><a href=\"http://github.com/chenshuo/muduo-examples-in-go\">http://github.com/chenshuo/muduo-examples-in-go</a><br>如何安装 <a href=\"https://www.365seal.com/y/elnWyG1GVr.html\">https://www.365seal.com/y/elnWyG1GVr.html</a><br>make编译源码时-j的作用 <a href=\"https://blog.csdn.net/JeekMrc/article/details/118332252\">https://blog.csdn.net/JeekMrc/article/details/118332252</a><br>安装boost的问题 <a href=\"https://zhuanlan.zhihu.com/p/126538251\">https://zhuanlan.zhihu.com/p/126538251</a></p>\n","slug":"Linux-Network-Programming/ChenShuo-muduo/mudduo-ch01","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/05/25/Linux-Network-Programming/ChenShuo-muduo/mudduo-ch01/","excerpt":"","categories":[],"tags":[]},{"title":"软件工程","date":"17/05/2022","path":"2022/05/17/Course/Software-Engineering/","text":"需求工程怎么开会？开会如何组织？开会内容肯定是最重要的，但是在会议内容之外，组织方面要注意什么一定需要有会议日程，会议记录agenda:过去的开会：几点开会，大概要商量几件时期改进后的开会：几点开会，本次有几个议题，第一个议题讨论多少分钟，第二个讨论多久，每个讨论多久，总会议时间多久方便别人对自己的安排facilitator:(会议主持人)顾客主持，自己主持，仲裁主持主持人的作用：按照会议日程，每个议题讨论多久，就讨论多久，时间到了要切换到下一个议题，不论是否讨论出结果或者时间快到了，一个议题最多讨论30分钟，20分钟过去了，我们要加快出结果如果讨论时间不够，就说明agenda给错了，会议组织人没有做好充分的准备，时间到了也要切换掉，下次再讨论一个人一直在啰嗦，没有说到点子上，主持人要过去打断一下，让他简短一下definition mechanism:(工作台)有一个工具，可以让大家讨论的时候把东西记录下来会议的时候，给每个人发一个纸和笔会议时候有个投影、或者黑板，有人要发表意见的时候，可以在黑板上写两句 学生的开会：发个QQ消息，把人聚集过来，人反正都来了，也不知道要具体说什么，反正就是说这个项目相关的事情组长想到哪里说到哪里，大家也都是想到哪里，说到哪里产生一个会议纪要 Quality Function Deployment(QFD)把顾客想要的东西，转换成技术员可以理解的需求以客户满意度最大化去做所有的事情(Maximize customer satisfaction)需要弄清楚客户满意度是什么步骤：1.把要做的每一个功能搞清楚，并且给每个功能一个值，这个功能对客户来说有多少价值2.确定目标和事件3.确定输入输出4.价值分析，对每个需求进行一个打分，对打分进行分类NomalExpectedExciting需求依次递减，一定得先把Nomal做好，Expected能做就做Exciting有余力再做，看对面钱给的够不够了 不能本末倒置的做，做个手机，地图，导航，相册，都很好用，但是打电话不好用，这就是QFD做的不好 需求分析阶段需要给客户提供的：1.可行性分析报告2.系统涵盖的范围是什么样子的3.每个人的通讯方式4.技术环境5.有什么功能，有什么特殊的限制 谈判1.达成双赢目标自己胜利的条件是确定的，但是客户的胜利条件是不确定的，或者说自己是不清楚的2.如果一方占不到便宜，项目失败的可能会很大如果谈判的时候客户比较傻，被自己占到了便宜，但是事后也会有很大的麻烦3.站在对方的角度想，他为什么要做这件事ex:出国留学时候的答辩：1.每个人都说“我很想获得这个机会”2.但是自己很拉，成绩很差，那学院为什么会同意你出去留学，你出去留学，没法双赢 谈判注意事项；1.谈判不是辩论，不是要说服对方，谈判是妥协的艺术2.谈判是一种策略，给对方营造出不得不接受的情景充分了解对手，了解对方的需求，了解对方的长处和弱点，设计谈判的策略，先说什么，后说什么，把哪件事情谈判到什么程度直接方法：比较直爽，比较不好，上来就一杆子插到底，说我的底线就在这里，上来就谈崩了3.少说，多听可能说的很啰嗦，但是要仔细的听，可能会有弦外之音，可能会透露出本来不想透露出的信息没必要告诉别人过多的信息，尽量从别人的只言片语中得到尽可能多的信息4.站在对方的角度想，对他有什么好处5.不要人身攻击，不要翻旧账，就事论事，对事不对人6.说出去的话，就要去做到谈判的时候，自己抛出的每一个条件，就划线了，这自己就要做得到随时准备好，自己说的这个话，可能作为一条线被画下来7.谈判结束后，看看有没有漏掉什么东西，有什么不一致的地方 需求模型设计模型","raw":"---\ntitle: 软件工程\ndate: 2022-05-17 12:13:07\ntags:\n- 课程\n---\n\n\n\n# 需求工程\n\n\n## 怎么开会？\n开会如何组织？\n开会内容肯定是最重要的，但是在会议内容之外，组织方面要注意什么\n一定需要有会议日程，会议记录\nagenda:\n过去的开会：几点开会，大概要商量几件时期\n改进后的开会：几点开会，本次有几个议题，第一个议题讨论多少分钟，第二个讨论多久，每个讨论多久，总会议时间多久\n方便别人对自己的安排\nfacilitator:(会议主持人)\n顾客主持，自己主持，仲裁主持\n主持人的作用：按照会议日程，每个议题讨论多久，就讨论多久，时间到了要切换到下一个议题，不论是否讨论出结果\n或者时间快到了，一个议题最多讨论30分钟，20分钟过去了，我们要加快出结果\n如果讨论时间不够，就说明agenda给错了，会议组织人没有做好充分的准备，时间到了也要切换掉，下次再讨论\n一个人一直在啰嗦，没有说到点子上，主持人要过去打断一下，让他简短一下\ndefinition mechanism:(工作台)\n有一个工具，可以让大家讨论的时候把东西记录下来\n会议的时候，给每个人发一个纸和笔\n会议时候有个投影、或者黑板，有人要发表意见的时候，可以在黑板上写两句\n\n学生的开会：\n发个QQ消息，把人聚集过来，人反正都来了，也不知道要具体说什么，反正就是说这个项目相关的事情\n组长想到哪里说到哪里，大家也都是想到哪里，说到哪里\n产生一个会议纪要\n\n\nQuality Function Deployment(QFD)\n把顾客想要的东西，转换成技术员可以理解的需求\n以客户满意度最大化去做所有的事情(Maximize customer satisfaction)\n需要弄清楚客户满意度是什么\n步骤：\n1.把要做的每一个功能搞清楚，并且给每个功能一个值，这个功能对客户来说有多少价值\n2.确定目标和事件\n3.确定输入输出\n4.价值分析，对每个需求进行一个打分，对打分进行分类\nNomal\nExpected\nExciting\n需求依次递减，一定得先把Nomal做好，Expected能做就做\nExciting有余力再做，看对面钱给的够不够了\n\n不能本末倒置的做，做个手机，地图，导航，相册，都很好用，但是打电话不好用，这就是QFD做的不好\n\n需求分析阶段需要给客户提供的：\n1.可行性分析报告\n2.系统涵盖的范围是什么样子的\n3.每个人的通讯方式\n4.技术环境\n5.有什么功能，有什么特殊的限制\n\n\n\n\n\n\n\n# 谈判\n1.达成双赢目标\n自己胜利的条件是确定的，但是客户的胜利条件是不确定的，或者说自己是不清楚的\n2.如果一方占不到便宜，项目失败的可能会很大\n如果谈判的时候客户比较傻，被自己占到了便宜，但是事后也会有很大的麻烦\n3.站在对方的角度想，他为什么要做这件事\nex:\n出国留学时候的答辩：\n1.每个人都说“我很想获得这个机会”\n2.但是自己很拉，成绩很差，那学院为什么会同意你出去留学，你出去留学，没法双赢\n\n谈判注意事项；\n1.谈判不是辩论，不是要说服对方，谈判是妥协的艺术\n2.谈判是一种策略，给对方营造出不得不接受的情景\n充分了解对手，了解对方的需求，了解对方的长处和弱点，设计谈判的策略，先说什么，后说什么，把哪件事情谈判到什么程度\n直接方法：比较直爽，比较不好，上来就一杆子插到底，说我的底线就在这里，上来就谈崩了\n3.少说，多听\n可能说的很啰嗦，但是要仔细的听，可能会有弦外之音，可能会透露出本来不想透露出的信息\n没必要告诉别人过多的信息，尽量从别人的只言片语中得到尽可能多的信息\n4.站在对方的角度想，对他有什么好处\n5.不要人身攻击，不要翻旧账，就事论事，对事不对人\n6.说出去的话，就要去做到\n谈判的时候，自己抛出的每一个条件，就划线了，这自己就要做得到\n随时准备好，自己说的这个话，可能作为一条线被画下来\n7.谈判结束后，看看有没有漏掉什么东西，有什么不一致的地方\n\n\n\n\n\n# 需求模型\n\n\n# 设计模型\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"需求工程\"><a href=\"#需求工程\" class=\"headerlink\" title=\"需求工程\"></a>需求工程</h1><h2 id=\"怎么开会？\"><a href=\"#怎么开会？\" class=\"headerlink\" title=\"怎么开会？\"></a>怎么开会？</h2><p>开会如何组织？<br>开会内容肯定是最重要的，但是在会议内容之外，组织方面要注意什么<br>一定需要有会议日程，会议记录<br>agenda:<br>过去的开会：几点开会，大概要商量几件时期<br>改进后的开会：几点开会，本次有几个议题，第一个议题讨论多少分钟，第二个讨论多久，每个讨论多久，总会议时间多久<br>方便别人对自己的安排<br>facilitator:(会议主持人)<br>顾客主持，自己主持，仲裁主持<br>主持人的作用：按照会议日程，每个议题讨论多久，就讨论多久，时间到了要切换到下一个议题，不论是否讨论出结果<br>或者时间快到了，一个议题最多讨论30分钟，20分钟过去了，我们要加快出结果<br>如果讨论时间不够，就说明agenda给错了，会议组织人没有做好充分的准备，时间到了也要切换掉，下次再讨论<br>一个人一直在啰嗦，没有说到点子上，主持人要过去打断一下，让他简短一下<br>definition mechanism:(工作台)<br>有一个工具，可以让大家讨论的时候把东西记录下来<br>会议的时候，给每个人发一个纸和笔<br>会议时候有个投影、或者黑板，有人要发表意见的时候，可以在黑板上写两句</p>\n<p>学生的开会：<br>发个QQ消息，把人聚集过来，人反正都来了，也不知道要具体说什么，反正就是说这个项目相关的事情<br>组长想到哪里说到哪里，大家也都是想到哪里，说到哪里<br>产生一个会议纪要</p>\n<p>Quality Function Deployment(QFD)<br>把顾客想要的东西，转换成技术员可以理解的需求<br>以客户满意度最大化去做所有的事情(Maximize customer satisfaction)<br>需要弄清楚客户满意度是什么<br>步骤：<br>1.把要做的每一个功能搞清楚，并且给每个功能一个值，这个功能对客户来说有多少价值<br>2.确定目标和事件<br>3.确定输入输出<br>4.价值分析，对每个需求进行一个打分，对打分进行分类<br>Nomal<br>Expected<br>Exciting<br>需求依次递减，一定得先把Nomal做好，Expected能做就做<br>Exciting有余力再做，看对面钱给的够不够了</p>\n<p>不能本末倒置的做，做个手机，地图，导航，相册，都很好用，但是打电话不好用，这就是QFD做的不好</p>\n<p>需求分析阶段需要给客户提供的：<br>1.可行性分析报告<br>2.系统涵盖的范围是什么样子的<br>3.每个人的通讯方式<br>4.技术环境<br>5.有什么功能，有什么特殊的限制</p>\n<h1 id=\"谈判\"><a href=\"#谈判\" class=\"headerlink\" title=\"谈判\"></a>谈判</h1><p>1.达成双赢目标<br>自己胜利的条件是确定的，但是客户的胜利条件是不确定的，或者说自己是不清楚的<br>2.如果一方占不到便宜，项目失败的可能会很大<br>如果谈判的时候客户比较傻，被自己占到了便宜，但是事后也会有很大的麻烦<br>3.站在对方的角度想，他为什么要做这件事<br>ex:<br>出国留学时候的答辩：<br>1.每个人都说“我很想获得这个机会”<br>2.但是自己很拉，成绩很差，那学院为什么会同意你出去留学，你出去留学，没法双赢</p>\n<p>谈判注意事项；<br>1.谈判不是辩论，不是要说服对方，谈判是妥协的艺术<br>2.谈判是一种策略，给对方营造出不得不接受的情景<br>充分了解对手，了解对方的需求，了解对方的长处和弱点，设计谈判的策略，先说什么，后说什么，把哪件事情谈判到什么程度<br>直接方法：比较直爽，比较不好，上来就一杆子插到底，说我的底线就在这里，上来就谈崩了<br>3.少说，多听<br>可能说的很啰嗦，但是要仔细的听，可能会有弦外之音，可能会透露出本来不想透露出的信息<br>没必要告诉别人过多的信息，尽量从别人的只言片语中得到尽可能多的信息<br>4.站在对方的角度想，对他有什么好处<br>5.不要人身攻击，不要翻旧账，就事论事，对事不对人<br>6.说出去的话，就要去做到<br>谈判的时候，自己抛出的每一个条件，就划线了，这自己就要做得到<br>随时准备好，自己说的这个话，可能作为一条线被画下来<br>7.谈判结束后，看看有没有漏掉什么东西，有什么不一致的地方</p>\n<h1 id=\"需求模型\"><a href=\"#需求模型\" class=\"headerlink\" title=\"需求模型\"></a>需求模型</h1><h1 id=\"设计模型\"><a href=\"#设计模型\" class=\"headerlink\" title=\"设计模型\"></a>设计模型</h1>","slug":"Course/Software-Engineering","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/05/17/Course/Software-Engineering/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"设计模式学习","date":"15/05/2022","path":"2022/05/15/Course/Design-Patterns/","text":"面向对象的设计原则，五个SOLID指代了面向对象编程和面向对象设计的五个基本原则 名称 缩写 全称 解释 单一职责原则 SRP Single Responsibility Principle 每个类的职责单一 开闭原则 OCP Open Closed Principle 类的改动，增加代码是好的，修改源代码是不好的 里氏替换原则 LSP Liskov Substitution Principle 多态 接口隔离原则 ISP Interface Segregation Principle 接口隔离 依赖倒置原则 DIP Dependence Inversion Principle 依赖抽象接口 —— —— —— —— 迪米特法则 LoD Law of Demeter 一个对象应当对其他对象少了解 组合&#x2F;聚合复用原则 CRP Composite&#x2F;Aggregate Reuse Principle 继承不好，组合好的 总体原则：高聚合，低耦合 6.迪米特法则解释：去公司找人修电脑，不应该去找某个具体的小李、小张来修，应该抽象出一个接口类，IT部门，找IT部门修，用抽象接口再去对接实际的类，不然找小张解决不了问题，找小李解决不了问题。结论：迪米特法则强调了类之间的松耦合关系，类之间的耦合越松，越有利于复用。 简单工厂模式概述：本来每个类都需要new出来，现在是通过一个工厂来创建 优点：1.客户端和具体实现类解耦2.对于某些对象创建过程比较复杂情况，我们不用考虑这些了 缺点：1.简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则2.这个类职责过重，这个类发生问题，会影响很多实用这个工厂的模块 使用场景：1.工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中个的业务逻辑太过复杂。2.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。解释：用在不需要关心创建过程，读取什么文件，什么什么的，就想要用这个类比如创建过程很复杂，但是我只是想用这个类，那我就用这个简单工厂创建一下就行，具体的创建过程都放在工厂里面 工厂模式概述：对于每一个类，都对应一个具体创建的工厂类，然后再定义一个抽象工厂作为接口简单工厂模式 + “开闭原则” &#x3D; 工厂方法模式 优点：1.不需要记住具体类名，甚至连具体参数都不用记忆（因为用的是抽象的工厂接口）2.实现了对象创建和使用的分离。3.系统的可扩展性也就变得非常好，无需修改接口和原类。（符合开闭原则） 缺点：1.增加系统中类的个数，复杂度和理解度增加。2.增加了系统的抽象性和理解难度。 适用场景1.客户端不知道它所需要的对象的类。2.抽象工厂类通过其子类来指定创建哪个对象。 参考文献https://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482","raw":"---\ntitle: 设计模式学习\ndate: 2022-05-15 15:08:04\ntags:\n- 课程\n---\n\n# 面向对象的设计原则，五个\nSOLID指代了**面向对象编程**和**面向对象设计**的五个基本原则\n| 名称 | 缩写 | 全称 | 解释 |\n| ------ | ------ | ------ |------ |\n|单一职责原则       |SRP        |Single Responsibility Principle        |每个类的职责单一|\n|**开闭原则**          |OCP       |Open Closed Principle               |类的改动，增加代码是好的，修改源代码是不好的|\n|里氏替换原则       |LSP        |Liskov Substitution Principle       |多态|\n|接口隔离原则\t    |ISP        |Interface Segregation Principle    |接口隔离|\n|**依赖倒置原则**\t    |DIP        |Dependence Inversion Principle   |依赖抽象接口|\n| ------ | ------ | ------ |------ |\n|迪米特法则         |LoD        |Law of Demeter                         |一个对象应当对其他对象少了解|\n|组合/聚合复用原则   |CRP   |Composite/Aggregate Reuse Principle            |继承不好，组合好的|\n\n总体原则：高聚合，低耦合\n\n\n# 6.迪米特法则\n解释：\n去公司找人修电脑，不应该去找某个具体的小李、小张来修，应该抽象出一个接口类，IT部门，找IT部门修，用抽象接口再去对接实际的类，不然找小张解决不了问题，找小李解决不了问题。\n结论：迪米特法则强调了类之间的松耦合关系，类之间的耦合越松，越有利于复用。\n\n\n\n# 简单工厂模式\n## 概述：\n本来每个类都需要new出来，现在是通过一个工厂来创建\n## 优点：\n1.客户端和具体实现类解耦\n2.对于某些对象创建过程比较复杂情况，我们不用考虑这些了\n## 缺点：\n1.简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则\n2.这个类职责过重，这个类发生问题，会影响很多实用这个工厂的模块\n## 使用场景：\n1.工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中个的业务逻辑太过复杂。\n2.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。\n**解释**：用在不需要关心创建过程，读取什么文件，什么什么的，就想要用这个类\n比如创建过程很复杂，但是我只是想用这个类，那我就用这个简单工厂创建一下就行，具体的创建过程都放在工厂里面\n\n\n\n\n\n# 工厂模式\n## 概述：\n对于每一个类，都对应一个具体创建的工厂类，然后再定义一个抽象工厂作为接口\n简单工厂模式 + “开闭原则” = 工厂方法模式\n## 优点：\n1.不需要记住具体类名，甚至连具体参数都不用记忆（因为用的是抽象的工厂接口）\n2.实现了对象创建和使用的分离。\n3.系统的可扩展性也就变得非常好，无需修改接口和原类。（符合开闭原则）\n## 缺点：\n1.增加系统中类的个数，复杂度和理解度增加。\n2.增加了系统的抽象性和理解难度。\n## 适用场景\n1.客户端不知道它所需要的对象的类。\n2.抽象工厂类通过其子类来指定创建哪个对象。\n\n\n\n# 参考文献\nhttps://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"面向对象的设计原则，五个\"><a href=\"#面向对象的设计原则，五个\" class=\"headerlink\" title=\"面向对象的设计原则，五个\"></a>面向对象的设计原则，五个</h1><p>SOLID指代了<strong>面向对象编程</strong>和<strong>面向对象设计</strong>的五个基本原则</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>缩写</th>\n<th>全称</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单一职责原则</td>\n<td>SRP</td>\n<td>Single Responsibility Principle</td>\n<td>每个类的职责单一</td>\n</tr>\n<tr>\n<td><strong>开闭原则</strong></td>\n<td>OCP</td>\n<td>Open Closed Principle</td>\n<td>类的改动，增加代码是好的，修改源代码是不好的</td>\n</tr>\n<tr>\n<td>里氏替换原则</td>\n<td>LSP</td>\n<td>Liskov Substitution Principle</td>\n<td>多态</td>\n</tr>\n<tr>\n<td>接口隔离原则</td>\n<td>ISP</td>\n<td>Interface Segregation Principle</td>\n<td>接口隔离</td>\n</tr>\n<tr>\n<td><strong>依赖倒置原则</strong></td>\n<td>DIP</td>\n<td>Dependence Inversion Principle</td>\n<td>依赖抽象接口</td>\n</tr>\n<tr>\n<td>——</td>\n<td>——</td>\n<td>——</td>\n<td>——</td>\n</tr>\n<tr>\n<td>迪米特法则</td>\n<td>LoD</td>\n<td>Law of Demeter</td>\n<td>一个对象应当对其他对象少了解</td>\n</tr>\n<tr>\n<td>组合&#x2F;聚合复用原则</td>\n<td>CRP</td>\n<td>Composite&#x2F;Aggregate Reuse Principle</td>\n<td>继承不好，组合好的</td>\n</tr>\n</tbody></table>\n<p>总体原则：高聚合，低耦合</p>\n<h1 id=\"6-迪米特法则\"><a href=\"#6-迪米特法则\" class=\"headerlink\" title=\"6.迪米特法则\"></a>6.迪米特法则</h1><p>解释：<br>去公司找人修电脑，不应该去找某个具体的小李、小张来修，应该抽象出一个接口类，IT部门，找IT部门修，用抽象接口再去对接实际的类，不然找小张解决不了问题，找小李解决不了问题。<br>结论：迪米特法则强调了类之间的松耦合关系，类之间的耦合越松，越有利于复用。</p>\n<h1 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h1><h2 id=\"概述：\"><a href=\"#概述：\" class=\"headerlink\" title=\"概述：\"></a>概述：</h2><p>本来每个类都需要new出来，现在是通过一个工厂来创建</p>\n<h2 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>1.客户端和具体实现类解耦<br>2.对于某些对象创建过程比较复杂情况，我们不用考虑这些了</p>\n<h2 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>1.简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则<br>2.这个类职责过重，这个类发生问题，会影响很多实用这个工厂的模块</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>1.工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中个的业务逻辑太过复杂。<br>2.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。<br><strong>解释</strong>：用在不需要关心创建过程，读取什么文件，什么什么的，就想要用这个类<br>比如创建过程很复杂，但是我只是想用这个类，那我就用这个简单工厂创建一下就行，具体的创建过程都放在工厂里面</p>\n<h1 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h1><h2 id=\"概述：-1\"><a href=\"#概述：-1\" class=\"headerlink\" title=\"概述：\"></a>概述：</h2><p>对于每一个类，都对应一个具体创建的工厂类，然后再定义一个抽象工厂作为接口<br>简单工厂模式 + “开闭原则” &#x3D; 工厂方法模式</p>\n<h2 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>1.不需要记住具体类名，甚至连具体参数都不用记忆（因为用的是抽象的工厂接口）<br>2.实现了对象创建和使用的分离。<br>3.系统的可扩展性也就变得非常好，无需修改接口和原类。（符合开闭原则）</p>\n<h2 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>1.增加系统中类的个数，复杂度和理解度增加。<br>2.增加了系统的抽象性和理解难度。</p>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>1.客户端不知道它所需要的对象的类。<br>2.抽象工厂类通过其子类来指定创建哪个对象。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482\">https://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482</a></p>\n","slug":"Course/Design-Patterns","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/05/15/Course/Design-Patterns/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"PPT制作要点","date":"23/04/2022","path":"2022/04/23/Others/PPT-production-points/","text":"以“除草智能装备及机器人”为题目，制作一个PPT 构思： 首先接到一个做PPT的需求 思考从哪几个方面开始写注意：由于是刚刚接触到这个题目，一般是十分的陌生，所以第一个任务就是找出哪几个点去写，但是一般情况下，刚刚提出的都是有问题的但是一定要找到几个要点，先提出来，再后面的不断思考中，会不断改进，自然就会优化了 举例： 发展现状 机械介绍 算法介绍 未来展望 写一个大纲主要内容：大的点，2-3条每个大点里面找要展开来讲的点，3-4条 举例： 发展现状 农田割草机 技术情况 市场情况 国内 国外 机械介绍 有什么 算法介绍 路径规划 点到点 全覆盖 未来展望 ROS、SLAM 多机器人 不规则地块 开始制作： 确定主题颜色，从要讲述的东西中，选取2-3个主题颜色 从头开始对每个点进行扩充，查找图片和相关资料，多找GIF先把内容都填充到PPT中，不用考虑排版差不多半天，比如19:00-22:00这么长时间，可以完成对个大点内容的填充 设计每个页面的排版将页面精简，从大段文字中提取出主要内容这个步骤完成后，主要内容已经制作完成了 设计动画：7. 给每个页面加上动画设计每个段落之间的逻辑关系 反复看整个PPT的演示效果 自己复述，设计改怎么表述 PPT设计要点： 减少大段文字的出现，大段文字总结成小标题，或者小标题配和一小段文字 必须出现一小段文字，用红字加粗主要内容 空荡荡的字放在那里很空虚，最后放一个背景框 给小标题加上一条线 没有边框的图标，柱状图，饼图，用框框框起来 纯白的背景很单调，后面添加一半的纯色背景 能用图片代替文字就尽量用图片代替 动画要点 强调重点的时候，不止用红框框 图片+扩展图形放大凸显 放大镜凸显 后面加阴影，前面放大 增加时间轴的表现形式 设计封面的时候，用动画将主要要讲述的物体突出 红圈，用轮子效果 半透明形状","raw":"---\ntitle: PPT制作要点\ndate: 2022-04-23 16:34:57\ntags:\n    - 其他\n---\n\n\n以“除草智能装备及机器人”为题目，制作一个PPT\n\n构思：\n1. 首先接到一个做PPT的需求\n\n2. 思考从哪几个方面开始写\n注意：由于是刚刚接触到这个题目，一般是十分的陌生，所以第一个任务就是找出哪几个点去写，但是一般情况下，刚刚提出的都是有问题的\n但是一定要找到几个要点，先提出来，再后面的不断思考中，会不断改进，自然就会优化了\n\n举例：\n- 发展现状\n- 机械介绍\n- 算法介绍\n- 未来展望\n\n3. 写一个大纲\n主要内容：\n大的点，2-3条\n每个大点里面找要展开来讲的点，3-4条\n\n举例：\n- 发展现状\n    - 农田割草机\n    - 技术情况\n    - 市场情况\n    - 国内\n    - 国外\n- 机械介绍\n    - 有什么\n- 算法介绍\n    - 路径规划\n    - 点到点\n    - 全覆盖\n- 未来展望\n    - ROS、SLAM\n    - 多机器人\n    - 不规则地块\n------------------------------------------------------\n开始制作：\n\n4. 确定主题颜色，从要讲述的东西中，选取2-3个主题颜色\n\n\n5. 从头开始\n对每个点进行扩充，查找图片和相关资料，多找GIF\n先把内容都填充到PPT中，不用考虑排版\n差不多半天，比如19:00-22:00这么长时间，可以完成对个大点内容的填充\n\n6. 设计每个页面的排版\n将页面精简，从大段文字中提取出主要内容\n这个步骤完成后，主要内容已经制作完成了\n\n------------------------------------------------------\n\n设计动画：\n7. 给每个页面加上动画\n设计每个段落之间的逻辑关系\n\n\n8. 反复看整个PPT的演示效果\n\n------------------------------------------------------\n\n自己复述，设计改怎么表述\n\n\n\n\n\n\n\n\n\n\n------------------------------------------------------\nPPT设计要点：\n1. 减少大段文字的出现，大段文字总结成小标题，或者小标题配和一小段文字\n2. 必须出现一小段文字，用红字加粗主要内容\n3. 空荡荡的字放在那里很空虚，最后放一个背景框\n4. 给小标题加上一条线\n5. 没有边框的图标，柱状图，饼图，用框框框起来\n6. 纯白的背景很单调，后面添加一半的纯色背景\n7. 能用图片代替文字就尽量用图片代替\n\n动画要点\n1. 强调重点的时候，不止用红框框\n    - 图片+扩展图形放大凸显\n    - 放大镜凸显\n    - 后面加阴影，前面放大\n2. 增加时间轴的表现形式\n3. 设计封面的时候，用动画将主要要讲述的物体突出\n4. 红圈，用轮子效果\n5. 半透明形状\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>以“除草智能装备及机器人”为题目，制作一个PPT</p>\n<p>构思：</p>\n<ol>\n<li><p>首先接到一个做PPT的需求</p>\n</li>\n<li><p>思考从哪几个方面开始写<br>注意：由于是刚刚接触到这个题目，一般是十分的陌生，所以第一个任务就是找出哪几个点去写，但是一般情况下，刚刚提出的都是有问题的<br>但是一定要找到几个要点，先提出来，再后面的不断思考中，会不断改进，自然就会优化了</p>\n</li>\n</ol>\n<p>举例：</p>\n<ul>\n<li>发展现状</li>\n<li>机械介绍</li>\n<li>算法介绍</li>\n<li>未来展望</li>\n</ul>\n<ol start=\"3\">\n<li>写一个大纲<br>主要内容：<br>大的点，2-3条<br>每个大点里面找要展开来讲的点，3-4条</li>\n</ol>\n<p>举例：</p>\n<ul>\n<li>发展现状<ul>\n<li>农田割草机</li>\n<li>技术情况</li>\n<li>市场情况</li>\n<li>国内</li>\n<li>国外</li>\n</ul>\n</li>\n<li>机械介绍<ul>\n<li>有什么</li>\n</ul>\n</li>\n<li>算法介绍<ul>\n<li>路径规划</li>\n<li>点到点</li>\n<li>全覆盖</li>\n</ul>\n</li>\n<li>未来展望<ul>\n<li>ROS、SLAM</li>\n<li>多机器人</li>\n<li>不规则地块</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>开始制作：</p>\n<ol start=\"4\">\n<li><p>确定主题颜色，从要讲述的东西中，选取2-3个主题颜色</p>\n</li>\n<li><p>从头开始<br>对每个点进行扩充，查找图片和相关资料，多找GIF<br>先把内容都填充到PPT中，不用考虑排版<br>差不多半天，比如19:00-22:00这么长时间，可以完成对个大点内容的填充</p>\n</li>\n<li><p>设计每个页面的排版<br>将页面精简，从大段文字中提取出主要内容<br>这个步骤完成后，主要内容已经制作完成了</p>\n</li>\n</ol>\n<hr>\n<p>设计动画：<br>7. 给每个页面加上动画<br>设计每个段落之间的逻辑关系</p>\n<ol start=\"8\">\n<li>反复看整个PPT的演示效果</li>\n</ol>\n<hr>\n<p>自己复述，设计改怎么表述</p>\n<hr>\n<p>PPT设计要点：</p>\n<ol>\n<li>减少大段文字的出现，大段文字总结成小标题，或者小标题配和一小段文字</li>\n<li>必须出现一小段文字，用红字加粗主要内容</li>\n<li>空荡荡的字放在那里很空虚，最后放一个背景框</li>\n<li>给小标题加上一条线</li>\n<li>没有边框的图标，柱状图，饼图，用框框框起来</li>\n<li>纯白的背景很单调，后面添加一半的纯色背景</li>\n<li>能用图片代替文字就尽量用图片代替</li>\n</ol>\n<p>动画要点</p>\n<ol>\n<li>强调重点的时候，不止用红框框<ul>\n<li>图片+扩展图形放大凸显</li>\n<li>放大镜凸显</li>\n<li>后面加阴影，前面放大</li>\n</ul>\n</li>\n<li>增加时间轴的表现形式</li>\n<li>设计封面的时候，用动画将主要要讲述的物体突出</li>\n<li>红圈，用轮子效果</li>\n<li>半透明形状</li>\n</ol>\n","slug":"Others/PPT-production-points","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/23/Others/PPT-production-points/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"算法","date":"19/04/2022","path":"2022/04/19/Interview-Q&A/Algorithm/","text":"前缀和 一维前缀和 二维前缀和 第一题就是基本的读入字符串排序，忘记细节了。 第二题是读入一01串，对应的下标为士兵的能力，0代表攻击士兵，1代表防守士兵，找到一个分割点，使得左侧攻击士兵和右侧防御士兵差的绝对值最小。这题直接用一个求和数组记录遍历就能过。 第三题是给定一个数组，删掉下标不为质数的值，然后合并起来循环操作，求最后一个数。这题是能找到规律，在某个区间的答案会是一个定值。直接暴力解了。 第四题是给多个环形链表的部分（可以重叠），把他们串起来然后切开形成最小字典序。这题主要是记录一下链表顺序，正逆比较一下就可以 第五题买股票进阶版，给定本金，每天都可以买入卖出1笔，而且可以手里留存多笔股票，求最大利润。这题不太会做，暴力DFS做的只过了50，蹲个大佬 做了4个半，最近一个月才开始补算法，难点的题就做不出来了，以及我是用python写的，可能时间复杂度要求和C++比会有些差别 作者：Powter链接：https://leetcode-cn.com/circle/discuss/aWwMc8/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 参考资料 前缀和 https://blog.csdn.net/m0_46201544/article/details/122371482 前缀异或 https://blog.csdn.net/weixin_50248461/article/details/117045421 Codeforces游玩攻略 https://www.luogu.com.cn/blog/ezoixx130/codeforces-tutorial Codeforces快速精通 https://www.luogu.com.cn/blog/ezoixx130/codeforces-advanced-tutorial ACM-高精度模板(综合篇) https://blog.csdn.net/u013615904/article/details/43373601 C++ lambda表达式与函数对象 https://www.jianshu.com/p/d686ad9de817 https://codeforces.com/blog/entry/66715 https://codeforces.com/blog/entry/66909","raw":"---\ntitle: 算法\ndate: 2022-04-19 15:03:57\ntags:\n- 面试\n---\n\n\n[![不同算法的时间复杂度](https://s1.ax1x.com/2022/04/19/LBSN8S.png)](https://imgtu.com/i/LBSN8S)\n\n\n\n前缀和\n\n一维前缀和\n\n二维前缀和\n\n\n第一题就是基本的读入字符串排序，忘记细节了。\n\n第二题是读入一01串，对应的下标为士兵的能力，0代表攻击士兵，1代表防守士兵，找到一个分割点，使得左侧攻击士兵和右侧防御士兵差的绝对值最小。这题直接用一个求和数组记录遍历就能过。\n\n第三题是给定一个数组，删掉下标不为质数的值，然后合并起来循环操作，求最后一个数。这题是能找到规律，在某个区间的答案会是一个定值。直接暴力解了。\n\n第四题是给多个环形链表的部分（可以重叠），把他们串起来然后切开形成最小字典序。这题主要是记录一下链表顺序，正逆比较一下就可以\n\n第五题买股票进阶版，给定本金，每天都可以买入卖出1笔，而且可以手里留存多笔股票，求最大利润。这题不太会做，暴力DFS做的只过了50，蹲个大佬\n\n做了4个半，最近一个月才开始补算法，难点的题就做不出来了，以及我是用python写的，可能时间复杂度要求和C++比会有些差别\n\n作者：Powter\n链接：https://leetcode-cn.com/circle/discuss/aWwMc8/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n# 参考资料\n- **前缀和**  https://blog.csdn.net/m0_46201544/article/details/122371482\n- **前缀异或** https://blog.csdn.net/weixin_50248461/article/details/117045421\n- **Codeforces游玩攻略** https://www.luogu.com.cn/blog/ezoixx130/codeforces-tutorial\n- **Codeforces快速精通** https://www.luogu.com.cn/blog/ezoixx130/codeforces-advanced-tutorial\n- **ACM-高精度模板(综合篇)** https://blog.csdn.net/u013615904/article/details/43373601\n\n- **C++ lambda表达式与函数对象** https://www.jianshu.com/p/d686ad9de817\n\n- https://codeforces.com/blog/entry/66715\n- https://codeforces.com/blog/entry/66909","content":"<p><a href=\"https://imgtu.com/i/LBSN8S\"><img src=\"https://s1.ax1x.com/2022/04/19/LBSN8S.png\" alt=\"不同算法的时间复杂度\"></a></p>\n<p>前缀和</p>\n<p>一维前缀和</p>\n<p>二维前缀和</p>\n<p>第一题就是基本的读入字符串排序，忘记细节了。</p>\n<p>第二题是读入一01串，对应的下标为士兵的能力，0代表攻击士兵，1代表防守士兵，找到一个分割点，使得左侧攻击士兵和右侧防御士兵差的绝对值最小。这题直接用一个求和数组记录遍历就能过。</p>\n<p>第三题是给定一个数组，删掉下标不为质数的值，然后合并起来循环操作，求最后一个数。这题是能找到规律，在某个区间的答案会是一个定值。直接暴力解了。</p>\n<p>第四题是给多个环形链表的部分（可以重叠），把他们串起来然后切开形成最小字典序。这题主要是记录一下链表顺序，正逆比较一下就可以</p>\n<p>第五题买股票进阶版，给定本金，每天都可以买入卖出1笔，而且可以手里留存多笔股票，求最大利润。这题不太会做，暴力DFS做的只过了50，蹲个大佬</p>\n<p>做了4个半，最近一个月才开始补算法，难点的题就做不出来了，以及我是用python写的，可能时间复杂度要求和C++比会有些差别</p>\n<p>作者：Powter<br>链接：<a href=\"https://leetcode-cn.com/circle/discuss/aWwMc8/\">https://leetcode-cn.com/circle/discuss/aWwMc8/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><p><strong>前缀和</strong>  <a href=\"https://blog.csdn.net/m0_46201544/article/details/122371482\">https://blog.csdn.net/m0_46201544/article/details/122371482</a></p>\n</li>\n<li><p><strong>前缀异或</strong> <a href=\"https://blog.csdn.net/weixin_50248461/article/details/117045421\">https://blog.csdn.net/weixin_50248461/article/details/117045421</a></p>\n</li>\n<li><p><strong>Codeforces游玩攻略</strong> <a href=\"https://www.luogu.com.cn/blog/ezoixx130/codeforces-tutorial\">https://www.luogu.com.cn/blog/ezoixx130/codeforces-tutorial</a></p>\n</li>\n<li><p><strong>Codeforces快速精通</strong> <a href=\"https://www.luogu.com.cn/blog/ezoixx130/codeforces-advanced-tutorial\">https://www.luogu.com.cn/blog/ezoixx130/codeforces-advanced-tutorial</a></p>\n</li>\n<li><p><strong>ACM-高精度模板(综合篇)</strong> <a href=\"https://blog.csdn.net/u013615904/article/details/43373601\">https://blog.csdn.net/u013615904/article/details/43373601</a></p>\n</li>\n<li><p><strong>C++ lambda表达式与函数对象</strong> <a href=\"https://www.jianshu.com/p/d686ad9de817\">https://www.jianshu.com/p/d686ad9de817</a></p>\n</li>\n<li><p><a href=\"https://codeforces.com/blog/entry/66715\">https://codeforces.com/blog/entry/66715</a></p>\n</li>\n<li><p><a href=\"https://codeforces.com/blog/entry/66909\">https://codeforces.com/blog/entry/66909</a></p>\n</li>\n</ul>\n","slug":"Interview-Q&A/Algorithm","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/19/Interview-Q&A/Algorithm/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"数据结构","date":"19/04/2022","path":"2022/04/19/Interview-Q&A/data-structure/","text":"","raw":"---\ntitle: 数据结构\ndate: 2022-04-19 14:57:24\ntags:\n- 面试\n---\n\n","content":"","slug":"Interview-Q&A/data-structure","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/19/Interview-Q&A/data-structure/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"makefile 教程","date":"05/04/2022","path":"2022/04/05/Tutorial/linux-dev-env/makefile-tutorial/","text":"自动化变量 说明 $* 表示目标文件的名称，不包含目标文件的扩展名 $+ 也是所有依赖目标的集合,这些依赖文件用空格分开，按照出现的先后为顺序，只是它不去除重复的依赖目标 $&lt; 规则中的第一个相关文件名 $? 规则中日期新于目标的所有相关文件的列表，以空格分割 $@ 规则的目标所对应的文件名 $^ 规则中所有相关文件的列表，以空格分割 $(@D) 目标文件的目录部分 $(@F) 目标文件的文件名部分 常用变量 说明 默认值 AR 归档维护程序 ar AS 汇编程序 as CPP c预处理程序 cpp CC c编译程序 cc CXX c++编译程序 g++ RM 文件删除程序 rm -f ARFLAGS 传给归档维护程序的标志 rv ASFLAGS 传给汇编程序的标志 无默认值 CFLAGS 传给c编译程序的标志 无默认值 CPPFLAGS 传给c预处理程序的标志 无默认值 CXXFLAGS 传给c++编译器的标志 无默认值 LDFLAGS 传给链接程序（ld）的标志 无默认值 模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为5）。 如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下： %.o : %.c markdown中的函数 获取匹配模式的文件名 wildcardsrc &#x3D; $(wildcard *.c) 模式替换函数 patsubst 循环函数 foreach 参考文献https://blog.csdn.net/yi412/article/details/69941791https://blog.csdn.net/marc07/article/details/62885868","raw":"---\ntitle: makefile 教程\ndate: 2022-04-05 20:34:26\ntags:\n- 教程\n---\n\n\n\n|自动化变量                        |   说明|\n| ------ | ------ |\n|$*                             |表示目标文件的名称，不包含目标文件的扩展名|\n|$+                                |也是所有依赖目标的集合,这些依赖文件用空格分开，按照出现的先后为顺序，只是它不去除重复的依赖目标|\n|$<                            |  规则中的第一个相关文件名|\n|$?                            |  规则中日期新于目标的所有相关文件的列表，以空格分割|\n|$@                            |  规则的目标所对应的文件名|\n|$^                            |  规则中所有相关文件的列表，以空格分割|\n|$(@D)                          | 目标文件的目录部分|\n|$(@F)                         |  目标文件的文件名部分|\n\n\n\n\n|常用变量                            | 说明  |默认值\n| ------ | ------ |------ |\n|AR                              | 归档维护程序         |ar  |\n|AS                              | 汇编程序             |as  |\n|CPP                            |  c预处理程序          |cpp  |\n|CC                              |   c编译程序          |cc  |\n|CXX                              |   c++编译程序          |g++  |                        \n|RM                              | 文件删除程序         |rm -f  |\n|ARFLAGS                         |  传给归档维护程序的标志|rv  |\n|ASFLAGS                         | 传给汇编程序的标志   |无默认值  |\n|CFLAGS                          | 传给c编译程序的标志  |无默认值  |\n|CPPFLAGS                        | 传给c预处理程序的标志    |无默认值  |\n|CXXFLAGS                        |  传给c++编译器的标志     |无默认值|\n|LDFLAGS                         |传给链接程序（ld）的标志|无默认值  |\n\n\n\n模式规则中，至少在规则的目标定义中要包含\"%\"，否则，就是一般的规则。目标中的\"%\"定义表示对文件名的匹配，\"%\"表示长度任意的非空字符串。例如：\"%.c\"表示以\".c\"结尾的文件名（文件名的长度至少为3），而\"s.%.c\"则表示以\"s.\"开头，\".c\"结尾的文件名（文件名的长度至少为5）。\n\n如果\"%\"定义在目标中，那么，目标中的\"%\"的值决定了依赖目标中的\"%\"的值，也就是说，目标中的模式的\"%\"决定了依赖目标中\"%\"的样子。例如有一个模式规则如下：\n    %.o : %.c \n\n\nmarkdown中的函数\n\n\n获取匹配模式的文件名 wildcard\nsrc = $(wildcard *.c)\n\n模式替换函数 patsubst\n\n\n循环函数 foreach\n\n\n\n\n\n\n\n\n# 参考文献\nhttps://blog.csdn.net/yi412/article/details/69941791\nhttps://blog.csdn.net/marc07/article/details/62885868\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<table>\n<thead>\n<tr>\n<th>自动化变量</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$*</td>\n<td>表示目标文件的名称，不包含目标文件的扩展名</td>\n</tr>\n<tr>\n<td>$+</td>\n<td>也是所有依赖目标的集合,这些依赖文件用空格分开，按照出现的先后为顺序，只是它不去除重复的依赖目标</td>\n</tr>\n<tr>\n<td>$&lt;</td>\n<td>规则中的第一个相关文件名</td>\n</tr>\n<tr>\n<td>$?</td>\n<td>规则中日期新于目标的所有相关文件的列表，以空格分割</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>规则的目标所对应的文件名</td>\n</tr>\n<tr>\n<td>$^</td>\n<td>规则中所有相关文件的列表，以空格分割</td>\n</tr>\n<tr>\n<td>$(@D)</td>\n<td>目标文件的目录部分</td>\n</tr>\n<tr>\n<td>$(@F)</td>\n<td>目标文件的文件名部分</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>常用变量</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AR</td>\n<td>归档维护程序</td>\n<td>ar</td>\n</tr>\n<tr>\n<td>AS</td>\n<td>汇编程序</td>\n<td>as</td>\n</tr>\n<tr>\n<td>CPP</td>\n<td>c预处理程序</td>\n<td>cpp</td>\n</tr>\n<tr>\n<td>CC</td>\n<td>c编译程序</td>\n<td>cc</td>\n</tr>\n<tr>\n<td>CXX</td>\n<td>c++编译程序</td>\n<td>g++</td>\n</tr>\n<tr>\n<td>RM</td>\n<td>文件删除程序</td>\n<td>rm -f</td>\n</tr>\n<tr>\n<td>ARFLAGS</td>\n<td>传给归档维护程序的标志</td>\n<td>rv</td>\n</tr>\n<tr>\n<td>ASFLAGS</td>\n<td>传给汇编程序的标志</td>\n<td>无默认值</td>\n</tr>\n<tr>\n<td>CFLAGS</td>\n<td>传给c编译程序的标志</td>\n<td>无默认值</td>\n</tr>\n<tr>\n<td>CPPFLAGS</td>\n<td>传给c预处理程序的标志</td>\n<td>无默认值</td>\n</tr>\n<tr>\n<td>CXXFLAGS</td>\n<td>传给c++编译器的标志</td>\n<td>无默认值</td>\n</tr>\n<tr>\n<td>LDFLAGS</td>\n<td>传给链接程序（ld）的标志</td>\n<td>无默认值</td>\n</tr>\n</tbody></table>\n<p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为5）。</p>\n<p>如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：<br>    %.o : %.c </p>\n<p>markdown中的函数</p>\n<p>获取匹配模式的文件名 wildcard<br>src &#x3D; $(wildcard *.c)</p>\n<p>模式替换函数 patsubst</p>\n<p>循环函数 foreach</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://blog.csdn.net/yi412/article/details/69941791\">https://blog.csdn.net/yi412/article/details/69941791</a><br><a href=\"https://blog.csdn.net/marc07/article/details/62885868\">https://blog.csdn.net/marc07/article/details/62885868</a></p>\n","slug":"Tutorial/linux-dev-env/makefile-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/05/Tutorial/linux-dev-env/makefile-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"vscode 教程","date":"05/04/2022","path":"2022/04/05/Tutorial/vscode-tutorial/","text":"代码里的左侧颜色标识:红色，未加入版本控制; (刚clone到本地)绿色，已经加入版本控制暂未提交; (新增部分)蓝色，加入版本控制，已提交，有改动； (修改部分)白色，加入版本控制，已提交，无改动；灰色：版本控制已忽略文件。 git文件标识:M: 文件的内容被修改了U: 文件没有被合并(你需要完成合并才能进行提交)D: 删除的一个文件 A: 增加的文件.C: 文件的一个新拷贝.R: 文件名被修改了。T: 文件的类型被修改了。X: 未知状态 使用VSCode远程调试linux 准备工作1234apt-get updateapt-get install sudoapt-get install vimpasswd # 修改密码 安装opensshapt-get install openssh-serverapt-get install openssh-client 修改ssh配置文件sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_configPermitRootLogin yes（默认为#PermitRootLogin prohibit-password）前面的#号要放开 启动服务&#x2F;etc&#x2F;init.d&#x2F;ssh restart 连接测试ssh user@[ip] -p [端口]ssh &#117;&#x73;&#x65;&#x72;&#x40;&#x31;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#x2e;&#48;&#x2e;&#x33; -p 22 vscode配置123Host 192.168.0.3 HostName 192.168.0.3 User username 使用VSCode远程调试linux中的容器 需要把容器的端口映射出来 容器内的ssh修改需要把root登录打开sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_configPermitRootLogin yes重启，连接测试，可以连接 12345Host 15.1.0.89 # 显示的名字 HostName 15.1.0.89 User root Port 38529 # 使用的端口号 IdentityFile ~\\.ssh\\id_rsa 快捷键 快捷键 功能 ctl + k + 0 快速收缩全部代码 ctl + k + j 展开全部代码 ctl + shift + [ 收缩当前代码 ctl + shift + ] 展开当前代码 alt + left 向后 alt + left 向前 ctl + g 跳到指定行 ctl + b 关闭左侧栏 ctl + j 关闭下面栏 ctl + K + T 换主题颜色 一些设置C++不报错C_Cpp.errorSquiggles 前端使用的插件快捷键开头按输入!,自动填充基础内容 代码滚动时候进行附着sticky scroll打开以后会把函数名进行附着 参考文献[在VScode中，代码提示左边的图标各自代表的含义]https://blog.csdn.net/qq_42838904/article/details/108222619[Sticky Scroll in vscode]https://dev.to/this-is-learning/sticky-scroll-in-vscode-44h2","raw":"---\ntitle: vscode 教程\ndate: 2022-04-05 20:33:12\ntags:\n- 教程\n---\n# 代码里的左侧颜色标识:\n\n红色，未加入版本控制; (刚clone到本地)\n绿色，已经加入版本控制暂未提交; (新增部分)\n蓝色，加入版本控制，已提交，有改动； (修改部分)\n白色，加入版本控制，已提交，无改动；\n灰色：版本控制已忽略文件。\n\ngit文件标识:\nM: 文件的内容被修改了\nU: 文件没有被合并(你需要完成合并才能进行提交)\nD: 删除的一个文件\n\nA: 增加的文件.\nC: 文件的一个新拷贝.\nR: 文件名被修改了。\nT: 文件的类型被修改了。\nX: 未知状态\n\n# 使用VSCode远程调试linux\n\n1. 准备工作\n```\napt-get update\napt-get install sudo\napt-get install vim\npasswd # 修改密码\n```\n2. 安装openssh\napt-get install openssh-server\napt-get install openssh-client\n3. 修改ssh配置文件 \nsudo vi /etc/ssh/sshd_config\nPermitRootLogin yes \n（默认为#PermitRootLogin prohibit-password）前面的#号要放开\n4. 启动服务\n/etc/init.d/ssh restart\n5. 连接测试\nssh user@[ip] -p [端口]\nssh user@192.168.0.3 -p 22\n6. vscode配置\n```\nHost 192.168.0.3\n  HostName 192.168.0.3\n  User username\n```\n\n\n# 使用VSCode远程调试linux中的容器\n\n1. 需要把容器的端口映射出来\n\n容器内的ssh修改需要把root登录打开\nsudo vi /etc/ssh/sshd_config\nPermitRootLogin yes \n重启，连接测试，可以连接\n\n```\nHost 15.1.0.89      # 显示的名字\n  HostName 15.1.0.89\n  User root\n  Port 38529        # 使用的端口号\n  IdentityFile ~\\.ssh\\id_rsa\n```\n\n# 快捷键\n\n| 快捷键 | 功能 | \n| :----: | :----: | \n| ctl + k + 0 | 快速收缩全部代码 | \n| ctl + k + j | 展开全部代码 | \n| ctl + shift + [ | 收缩当前代码 | \n| ctl + shift + ] | 展开当前代码 | \n| alt + left | 向后 | \n| alt + left | 向前 | \n| ctl + g | 跳到指定行 | \n| ctl + b | 关闭左侧栏 | \n| ctl + j | 关闭下面栏 | \n| ctl + K + T | 换主题颜色 | \n\n# 一些设置\nC++不报错\nC_Cpp.errorSquiggles\n\n# 前端使用的插件\n\n快捷键\n开头按输入!,自动填充基础内容\n\n\n# 代码滚动时候进行附着\nsticky scroll\n打开以后会把函数名进行附着\n\n# 参考文献\n\n\n[在VScode中，代码提示左边的图标各自代表的含义]https://blog.csdn.net/qq_42838904/article/details/108222619\n[Sticky Scroll in vscode]https://dev.to/this-is-learning/sticky-scroll-in-vscode-44h2","content":"<h1 id=\"代码里的左侧颜色标识\"><a href=\"#代码里的左侧颜色标识\" class=\"headerlink\" title=\"代码里的左侧颜色标识:\"></a>代码里的左侧颜色标识:</h1><p>红色，未加入版本控制; (刚clone到本地)<br>绿色，已经加入版本控制暂未提交; (新增部分)<br>蓝色，加入版本控制，已提交，有改动； (修改部分)<br>白色，加入版本控制，已提交，无改动；<br>灰色：版本控制已忽略文件。</p>\n<p>git文件标识:<br>M: 文件的内容被修改了<br>U: 文件没有被合并(你需要完成合并才能进行提交)<br>D: 删除的一个文件</p>\n<p>A: 增加的文件.<br>C: 文件的一个新拷贝.<br>R: 文件名被修改了。<br>T: 文件的类型被修改了。<br>X: 未知状态</p>\n<h1 id=\"使用VSCode远程调试linux\"><a href=\"#使用VSCode远程调试linux\" class=\"headerlink\" title=\"使用VSCode远程调试linux\"></a>使用VSCode远程调试linux</h1><ol>\n<li>准备工作<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-<span class=\"built_in\">get</span> update</span><br><span class=\"line\">apt-<span class=\"built_in\">get</span> install sudo</span><br><span class=\"line\">apt-<span class=\"built_in\">get</span> install vim</span><br><span class=\"line\">passwd # 修改密码</span><br></pre></td></tr></table></figure></li>\n<li>安装openssh<br>apt-get install openssh-server<br>apt-get install openssh-client</li>\n<li>修改ssh配置文件<br>sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>PermitRootLogin yes<br>（默认为#PermitRootLogin prohibit-password）前面的#号要放开</li>\n<li>启动服务<br>&#x2F;etc&#x2F;init.d&#x2F;ssh restart</li>\n<li>连接测试<br>ssh user@[ip] -p [端口]<br>ssh <a href=\"mailto:&#117;&#x73;&#x65;&#x72;&#x40;&#x31;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#x2e;&#48;&#x2e;&#x33;\">&#117;&#x73;&#x65;&#x72;&#x40;&#x31;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#x2e;&#48;&#x2e;&#x33;</a> -p 22</li>\n<li>vscode配置<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host <span class=\"number\">192.168</span>.<span class=\"number\">0.3</span></span><br><span class=\"line\">  HostName <span class=\"number\">192.168</span>.<span class=\"number\">0.3</span></span><br><span class=\"line\">  <span class=\"keyword\">User</span> <span class=\"title\">username</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"使用VSCode远程调试linux中的容器\"><a href=\"#使用VSCode远程调试linux中的容器\" class=\"headerlink\" title=\"使用VSCode远程调试linux中的容器\"></a>使用VSCode远程调试linux中的容器</h1><ol>\n<li>需要把容器的端口映射出来</li>\n</ol>\n<p>容器内的ssh修改需要把root登录打开<br>sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>PermitRootLogin yes<br>重启，连接测试，可以连接</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host <span class=\"number\">15.1</span>.<span class=\"number\">0.89</span>      <span class=\"comment\"># 显示的名字</span></span><br><span class=\"line\">  HostName <span class=\"number\">15.1</span>.<span class=\"number\">0.89</span></span><br><span class=\"line\">  <span class=\"keyword\">User</span> <span class=\"title\">root</span></span><br><span class=\"line\">  Port <span class=\"number\">38529</span>        <span class=\"comment\"># 使用的端口号</span></span><br><span class=\"line\">  IdentityFile ~\\.ssh\\id_rsa</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h1><table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ctl + k + 0</td>\n<td align=\"center\">快速收缩全部代码</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + k + j</td>\n<td align=\"center\">展开全部代码</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + shift + [</td>\n<td align=\"center\">收缩当前代码</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + shift + ]</td>\n<td align=\"center\">展开当前代码</td>\n</tr>\n<tr>\n<td align=\"center\">alt + left</td>\n<td align=\"center\">向后</td>\n</tr>\n<tr>\n<td align=\"center\">alt + left</td>\n<td align=\"center\">向前</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + g</td>\n<td align=\"center\">跳到指定行</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + b</td>\n<td align=\"center\">关闭左侧栏</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + j</td>\n<td align=\"center\">关闭下面栏</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + K + T</td>\n<td align=\"center\">换主题颜色</td>\n</tr>\n</tbody></table>\n<h1 id=\"一些设置\"><a href=\"#一些设置\" class=\"headerlink\" title=\"一些设置\"></a>一些设置</h1><p>C++不报错<br>C_Cpp.errorSquiggles</p>\n<h1 id=\"前端使用的插件\"><a href=\"#前端使用的插件\" class=\"headerlink\" title=\"前端使用的插件\"></a>前端使用的插件</h1><p>快捷键<br>开头按输入!,自动填充基础内容</p>\n<h1 id=\"代码滚动时候进行附着\"><a href=\"#代码滚动时候进行附着\" class=\"headerlink\" title=\"代码滚动时候进行附着\"></a>代码滚动时候进行附着</h1><p>sticky scroll<br>打开以后会把函数名进行附着</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[在VScode中，代码提示左边的图标各自代表的含义]<a href=\"https://blog.csdn.net/qq_42838904/article/details/108222619\">https://blog.csdn.net/qq_42838904/article/details/108222619</a><br>[Sticky Scroll in vscode]<a href=\"https://dev.to/this-is-learning/sticky-scroll-in-vscode-44h2\">https://dev.to/this-is-learning/sticky-scroll-in-vscode-44h2</a></p>\n","slug":"Tutorial/vscode-tutorial","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/05/Tutorial/vscode-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"day07-项目","date":"03/04/2022","path":"2022/04/03/Linux-Network-Programming/Heima-Network-Programming/day07-Project/","text":"学习目标:1介绍一下项目的整体功能2介绍html语法3介绍http协议–请求协议和响应协议4介绍开发web服务器的整体流程5根据开发流程编写初级版本的web服务器 通过案例演示联想到的知识点:1开发网络服务器:多路IO复用技术:epoll select poll多进程或者多线程第三方库:libevent库2熟悉http协议请求协议应答协议3使用的协议有http协议+TCP协议TCP协议:建立连接的三次握手，连接建立完成后接着是数据传输web服务器:首先解析浏览器发来的请求数据，得到请求的文件名; 若文件存在 判断文件类型:若是普通文件，则发送文件内容给浏览器; 若是目录文件，则发送文件列表|若文件不存在，则发送一个错误页给浏览器;","raw":"---\ntitle: day07-项目\ndate: 2022-04-03 15:51:39\ntags:\n- Linux网络编程\n---\n\n学习目标:\n1介绍一下项目的整体功能\n2介绍html语法\n3介绍http协议--请求协议和响应协议\n4介绍开发web服务器的整体流程\n5根据开发流程编写初级版本的web服务器\n\n\n通过案例演示联想到的知识点:\n1开发网络服务器:\n多路IO复用技术:epoll select poll\n多进程或者多线程\n第三方库:libevent库\n2熟悉http协议\n请求协议\n应答协议\n3使用的协议有http协议+TCP协议\nTCP协议:建立连接的三次握手，连接建立完成后接着是数据传输\nweb服务器:首先解析浏览器发来的请求数据，得到请求的文件名;\n\n若文件存在\n    判断文件类型:若是普通文件，则发送文件内容给浏览器;\n                若是目录文件，则发送文件列表|\n若文件不存在，则发送一个错误页给浏览器;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>学习目标:<br>1介绍一下项目的整体功能<br>2介绍html语法<br>3介绍http协议–请求协议和响应协议<br>4介绍开发web服务器的整体流程<br>5根据开发流程编写初级版本的web服务器</p>\n<p>通过案例演示联想到的知识点:<br>1开发网络服务器:<br>多路IO复用技术:epoll select poll<br>多进程或者多线程<br>第三方库:libevent库<br>2熟悉http协议<br>请求协议<br>应答协议<br>3使用的协议有http协议+TCP协议<br>TCP协议:建立连接的三次握手，连接建立完成后接着是数据传输<br>web服务器:首先解析浏览器发来的请求数据，得到请求的文件名;</p>\n<p>若文件存在<br>    判断文件类型:若是普通文件，则发送文件内容给浏览器;<br>                若是目录文件，则发送文件列表|<br>若文件不存在，则发送一个错误页给浏览器;</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day07-Project","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/03/Linux-Network-Programming/Heima-Network-Programming/day07-Project/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day06-libevent","date":"03/04/2022","path":"2022/04/03/Linux-Network-Programming/Heima-Network-Programming/day06-libevent/","text":"描述什么是 libevent并掌握如何安装掌握event_base的作用和使用方法熟练掌握libevent库中的事件循环掌握event事件的使用方法掌握bufferevent的工作方式掌握使用libevent实现tcp服务器端流程掌握使用Libevent实现tcp客户端流程 libevent介绍1事件驱动，高性能，轻量级，专注于网络，只能用于网络服务端开发2源代码精炼，易读3跨平台4支持多种I&#x2F;o多路复用技术，如epoll select poll等5支持I&#x2F;O和信号等事件 登录官方网站: http://libevent.org，查看相关信息libevent源码下载主要分2个大版本: 1.4.x系列较为早期版本，适合源码学习 2.x系列，较新的版本，代码量比1.4 版本多很多，功能也更完善。 libevent的核心实现:在linux上，其实质就是epoll.反应堆.libevent,是事件驱动, epoll反应堆也是事件驱动，当要监测的事件发生的时候，就会调用事件对应的回调函数，执行相应操作．特别提醒:事件回调函数是由用户开发的，但是不是由用户显示去调用的，而是由libevent,去调用的.回调函数是自己写的","raw":"---\ntitle: day06-libevent\ndate: 2022-04-03 15:20:48\ntags:\n- Linux网络编程\n---\n\n\n\n\n\n\n\n\n\n\n\n\n描述什么是 libevent并掌握如何安装\n掌握event_base的作用和使用方法\n熟练掌握libevent库中的事件循环\n掌握event事件的使用方法\n掌握bufferevent的工作方式\n掌握使用libevent实现tcp服务器端流程\n掌握使用Libevent实现tcp客户端流程\n\n\n\n\nlibevent介绍\n1事件驱动，高性能，轻量级，专注于网络，只能用于网络服务端开发\n2源代码精炼，易读\n3跨平台\n4支持多种I/o多路复用技术，如epoll select poll等\n5支持I/O和信号等事件\n\n\n登录官方网站: http://libevent.org，查看相关信息\nlibevent源码下载主要分2个大版本:\n1. 1.4.x系列较为早期版本，适合源码学习\n2. 2.x系列，较新的版本，代码量比1.4 版本多很多，功能也更完善。\n\nlibevent的核心实现:\n在linux上，其实质就是epoll.反应堆.\nlibevent,是事件驱动, epoll反应堆也是事件驱动，当要监测的事件发生的时候，就会调用事件对应的回调函数，执行相应操作．特别提醒:事件回调函数是由用户开发的，但是不是由用户显示去调用的，而是由libevent,去调用的.\n回调函数是自己写的\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>描述什么是 libevent并掌握如何安装<br>掌握event_base的作用和使用方法<br>熟练掌握libevent库中的事件循环<br>掌握event事件的使用方法<br>掌握bufferevent的工作方式<br>掌握使用libevent实现tcp服务器端流程<br>掌握使用Libevent实现tcp客户端流程</p>\n<p>libevent介绍<br>1事件驱动，高性能，轻量级，专注于网络，只能用于网络服务端开发<br>2源代码精炼，易读<br>3跨平台<br>4支持多种I&#x2F;o多路复用技术，如epoll select poll等<br>5支持I&#x2F;O和信号等事件</p>\n<p>登录官方网站: <a href=\"http://libevent.org,查看相关信息/\">http://libevent.org，查看相关信息</a><br>libevent源码下载主要分2个大版本:</p>\n<ol>\n<li>1.4.x系列较为早期版本，适合源码学习</li>\n<li>2.x系列，较新的版本，代码量比1.4 版本多很多，功能也更完善。</li>\n</ol>\n<p>libevent的核心实现:<br>在linux上，其实质就是epoll.反应堆.<br>libevent,是事件驱动, epoll反应堆也是事件驱动，当要监测的事件发生的时候，就会调用事件对应的回调函数，执行相应操作．特别提醒:事件回调函数是由用户开发的，但是不是由用户显示去调用的，而是由libevent,去调用的.<br>回调函数是自己写的</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day06-libevent","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/03/Linux-Network-Programming/Heima-Network-Programming/day06-libevent/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day04-epoll函数","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day04-epoll/","text":"1了解poll函数2熟练使用epoll多路IO模型3了解epoll ET&#x2F;LT触发模式并实现4理解epoll,边缘非阻塞模式并实现5了解epoll反应堆模型设计思想6能看懂epoll反应堆模型的实现代码 pollpoll是介于select与epoll之间的模型，实际开发的过程中用的比较少和select相比没有本质的改变 linux下epollUNIX只能用select int poll(struct pollfd *fds, nfds_t nfds, int timeout);函数说明:跟select类似，委托内核监控可读，可写，异常事件函数参数: 1234567891011121314151617181920fds:一个struct pollfd结构体数组的首地址struct pollfd &#123; int fd; //要监控的文件描述符，如果fd为-1表示内核不再监控 short events; //输入参数，表示告诉内核要监控的事件，读事件，写事件,异常事件 short revents; ;//输出参数，表示内核告诉应用程序有哪些文件描述符有事件发生&#125;;events/revents: POLLIN:可读事件 POLLOUT:可写事件 POLLERR:异常事件nfds:告诉内核监控的范围，具体是:数组下标的最大值+1timedout: =0:不阻塞，立刻返回 -1:表示一直阻塞,直到有事件发生 &gt;0:表示阻塞时长，在时长范围内若有事件发生会立刻返回; 如果超过了时长也会立刻返回函数返回值: &gt;0:发生变化的文件描述符的个数 =0:没有文件描述符发生变化 -1:表示异常 说明:1 当poll函数返回的时候，结构体当中的fd,和events没有发生变化，究竞有没有事件发生由revents.来判断，所以poll是请求和返回分离.2 struct pollfd结构体中的fd成员若赋值为-1，则poll不会监控.3相对于select, poll没有本质上的改变;但是poll可以突破1024的限制.在&#x2F;proc&#x2F;svs&#x2F;fs&#x2F;file-max查看一个进程可以打开的socket描述符上限.如果需要可以修改配置文件:&#x2F;etc&#x2F;security&#x2F;limits.confs加入如下配置信息，然后重启终端即可生效. soft nofile 1024 hard nofile 10000osoft和 hard分别表示ulimit命令可以修改的最小限制和最大限制 多路I0-epoll将检测文件描述符的变化委托给内核去处理，然后内核将发生变化的文件描述符对应的事件返回给应用程序。linux下编程，肯定用这个了告诉有几个发生了变化，精准的告诉哪个有变化epoll底层实现用的红黑二叉树，也就是平衡二叉树 int epoll_create(int size); 函数说明: 创建一棵epoll树,返回一个树根节点 函数参数:size:必须传一个大于0的数 返回值:返回个文件描述符,这个文件描述符就表示epoll树的树根节点. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);函数说明:将fd上epoll树,从树上删除和修改函数参数: epfd: epoll树的树根节点 op: EPOLL_CTL_ADD:上树操作 EPOLL_CTL_MOD:修改 EPOLL_CTL_DEL:从树上删除节点 fd:要操作的文件描述符event: Event.exents: EPOLLIN:可读事件 EPOLLOUT:可写事件 EPOLLERR:异常事件 typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64; &#125; epoll_data_t; struct epoll_event &#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ &#125;; Struct epoll_exent ev; ex.events &#x3D; EPOLLIN; ex.data.fd &#x3D; fd; epoll_ctl(epfd, EPOLL_CTL_ADD, fd,&amp;ey); int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);有返回了，就说明一定有事件发生了 函数说明:委托内核监控epoll树的事件节点函数参数: epfd: epoll树根节点 events:传出参数,结构体数组 maxevents: events数组大小 timeout: -1:表示阻塞 0:表示不阻塞 &gt;0:表示阻塞超时时长 epoll_wait返回的数组中的事件节点的值不会修改,是当时上epoll树的时候设置的值. 进阶epoll介绍epoll的两种工作模式 水平触发:高电平代表1只要缓冲区中有数据，就一直通知边缘触发:电平有变化就代表1缓冲区中有数据只会通知一次，之后再有数据才会通知.()若是读数据的时候没有读完，则剩余的数据不会再通知，直到有新的数据到来边缘非阻塞模式:提高效率 epoll的LT和ET模式:1 epoll默认情况下是LT模式，在这种模式下，若读数据一次性没有读完，缓冲区中还有可读数据，则epoll_wait还会再次通知2若将epoll设置为ET模式，若读数据的时候一次性没有读完，则epoll_wait不再通知,直到下次有新的数据发来． 思考:1在ET模式下，如何在epoll_wait返回一次的情况下读完数据循环读数据,直到读完数据,但是读完数据之后会阻塞.2若能够一次性读完还需要设置什么?将通信文件描述符设置为非阻塞模式 epoll反应堆typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64;} epoll_data_t; struct epoll_event { uint32_t events; &#x2F;* Epoll events &#x2F; epoll_data_t data; &#x2F; User data variable *&#x2F;};触发了一个事件，产生了一连串的反应epoll反应堆实际上是应用了c++的封装思想,—个事件的产生会触发一系列连锁反应,事件产生之后最终调用的是回调函数.将数据和操作数据的方法封装到了一个类里面","raw":"---\ntitle: day04-epoll函数\ndate: 2022-04-02 19:39:01\ntags:\n- Linux网络编程\n---\n\n\n1了解poll函数\n2熟练使用epoll多路IO模型\n3了解epoll ET/LT触发模式并实现\n4理解epoll,边缘非阻塞模式并实现\n5了解epoll反应堆模型设计思想\n6能看懂epoll反应堆模型的实现代码\n\n\n# poll\npoll是介于select与epoll之间的模型，实际开发的过程中用的比较少\n和select相比没有本质的改变\n\nlinux下epoll\nUNIX只能用select\n\n\n int poll(struct pollfd *fds, nfds_t nfds, int timeout);\n函数说明:跟select类似，委托内核监控可读，可写，异常事件函数\n参数:\n```\n    fds:一个struct pollfd结构体数组的首地址\n    struct pollfd {\n        int   fd;         //要监控的文件描述符，如果fd为-1表示内核不再监控\n        short events;     //输入参数，表示告诉内核要监控的事件，读事件，写事件,异常事件\n        short revents;    ;//输出参数，表示内核告诉应用程序有哪些文件描述符有事件发生\n    };\n    events/revents:\n        POLLIN:可读事件\n        POLLOUT:可写事件\n        POLLERR:异常事件\n    nfds:告诉内核监控的范围，具体是:数组下标的最大值+1\n    timedout:\n        =0:不阻塞，立刻返回\n        -1:表示一直阻塞,直到有事件发生\n        >0:表示阻塞时长，在时长范围内若有事件发生会立刻返回;\n        如果超过了时长也会立刻返回\n    函数返回值:\n        >0:发生变化的文件描述符的个数\n        =0:没有文件描述符发生变化\n        -1:表示异常\n```\n说明:\n1 当poll函数返回的时候，结构体当中的fd,和events没有发生变化，究竞有没有事件发生由revents.来判断，所以poll是请求和返回分离.\n2 struct pollfd结构体中的fd成员若赋值为-1，则poll不会监控.\n3相对于select, poll没有本质上的改变;但是poll可以突破1024的限制.\n在/proc/svs/fs/file-max查看一个进程可以打开的socket描述符上限.\n如果需要可以修改配置文件:/etc/security/limits.conf\ns\n加入如下配置信息，然后重启终端即可生效.\n* soft nofile 1024\n* hard nofile 10000o\nsoft和 hard分别表示ulimit命令可以修改的最小限制和最大限制\n\n\n\n# 多路I0-epoll\n\n将检测文件描述符的变化委托给内核去处理，然后内核将发生变化的文件描述符对应的事件返回给应用程序。\nlinux下编程，肯定用这个了\n告诉有几个发生了变化，精准的告诉哪个有变化\nepoll底层实现用的红黑二叉树，也就是平衡二叉树\n\n\n int epoll_create(int size);\n 函数说明:\n 创建一棵epoll树,返回一个树根节点\n 函数参数:\nsize:必须传一个大于0的数\n  返回值:\n返回个文件描述符,这个文件描述符就表示epoll树的树根节点.\n\n\n\n int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n函数说明:将fd上epoll树,从树上删除和修改\n函数参数:\n    epfd: epoll树的树根节点\n    op:\n        EPOLL_CTL_ADD:上树操作\n        EPOLL_CTL_MOD:修改\n        EPOLL_CTL_DEL:从树上删除节点\n        fd:要操作的文件描述符\nevent:\n    Event.exents:\n    EPOLLIN:可读事件\n    EPOLLOUT:可写事件\n    EPOLLERR:异常事件\n\n    typedef union epoll_data {\n        void        *ptr;\n        int          fd;\n        uint32_t     u32;\n        uint64_t     u64;\n    } epoll_data_t;\n\n    struct epoll_event {\n        uint32_t     events;      /* Epoll events */\n        epoll_data_t data;        /* User data variable */\n    };\n\n Struct epoll_exent ev;\n ex.events = EPOLLIN;\n ex.data.fd = fd;\n epoll_ctl(epfd, EPOLL_CTL_ADD, fd,&ey);\n   \n\n\n\n int epoll_wait(int epfd, struct epoll_event *events,\n                      int maxevents, int timeout);\n有返回了，就说明一定有事件发生了\n\n函数说明:委托内核监控epoll树的事件节点\n函数参数:\n    epfd: epoll树根节点\n    events:传出参数,结构体数组\n    maxevents: events数组大小\n    timeout:\n        -1:表示阻塞\n        0:表示不阻塞\n        >0:表示阻塞超时时长\n\nepoll_wait返回的数组中的事件节点的值不会修改,是当时上epoll树的时候设置的值.\n\n\n\n\n# 进阶epoll\n\n介绍epoll的两种工作模式\n\n水平触发:高电平代表1\n只要缓冲区中有数据，就一直通知\n边缘触发:电平有变化就代表1\n缓冲区中有数据只会通知一次，之后再有数据才会通知.()若是读数据的时候没有读完，则剩余的数据不会再通知，直到有新的数据到来\n边缘非阻塞模式:提高效率\n\nepoll的LT和ET模式:\n1 epoll默认情况下是LT模式，在这种模式下，若读数据一次性没有读完，\n缓冲区中还有可读数据，则epoll_wait还会再次通知\n2若将epoll设置为ET模式，若读数据的时候一次性没有读完，则epoll_wait不再通知,\n直到下次有新的数据发来．\n\n思考:\n1在ET模式下，如何在epoll_wait返回一次的情况下读完数据\n循环读数据,直到读完数据,但是读完数据之后会阻塞.\n2若能够一次性读完还需要设置什么?\n将通信文件描述符设置为非阻塞模式\n\n\n# epoll反应堆\n\ntypedef union epoll_data {\n    void        *ptr;\n    int          fd;\n    uint32_t     u32;\n    uint64_t     u64;\n} epoll_data_t;\n\nstruct epoll_event {\n    uint32_t     events;      /* Epoll events */\n    epoll_data_t data;        /* User data variable */\n};\n触发了一个事件，产生了一连串的反应\nepoll反应堆实际上是应用了c++的封装思想,—个事件的产生会触发一系列连锁反应,事件产生之后最终调用的是回调函数.\n将数据和操作数据的方法封装到了一个类里面\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>1了解poll函数<br>2熟练使用epoll多路IO模型<br>3了解epoll ET&#x2F;LT触发模式并实现<br>4理解epoll,边缘非阻塞模式并实现<br>5了解epoll反应堆模型设计思想<br>6能看懂epoll反应堆模型的实现代码</p>\n<h1 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h1><p>poll是介于select与epoll之间的模型，实际开发的过程中用的比较少<br>和select相比没有本质的改变</p>\n<p>linux下epoll<br>UNIX只能用select</p>\n<p> int poll(struct pollfd *fds, nfds_t nfds, int timeout);<br>函数说明:跟select类似，委托内核监控可读，可写，异常事件函数<br>参数:</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">fds:</span>一个struct pollfd结构体数组的首地址</span><br><span class=\"line\">struct <span class=\"title class_\">pollfd</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    int   <span class=\"attr\">fd</span><span class=\"punctuation\">;</span>         <span class=\"comment\">//要监控的文件描述符，如果fd为-1表示内核不再监控</span></span><br><span class=\"line\">    short <span class=\"attr\">events</span><span class=\"punctuation\">;</span>     <span class=\"comment\">//输入参数，表示告诉内核要监控的事件，读事件，写事件,异常事件</span></span><br><span class=\"line\">    short <span class=\"attr\">revents</span><span class=\"punctuation\">;</span>    <span class=\"punctuation\">;</span><span class=\"comment\">//输出参数，表示内核告诉应用程序有哪些文件描述符有事件发生</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;;</span></span><br><span class=\"line\">events/revents:</span><br><span class=\"line\"><span class=\"symbol\">    POLLIN:</span>可读事件</span><br><span class=\"line\"><span class=\"symbol\">    POLLOUT:</span>可写事件</span><br><span class=\"line\"><span class=\"symbol\">    POLLERR:</span>异常事件</span><br><span class=\"line\"><span class=\"symbol\">nfds:</span>告诉内核监控的范围，具体是:数组下标的最大值+<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"symbol\">timedout:</span></span><br><span class=\"line\">    =<span class=\"number\">0</span>:不阻塞，立刻返回</span><br><span class=\"line\">    <span class=\"number\">-1</span>:表示一直阻塞,直到有事件发生</span><br><span class=\"line\">    &gt;<span class=\"number\">0</span>:表示阻塞时长，在时长范围内若有事件发生会立刻返回<span class=\"punctuation\">;</span></span><br><span class=\"line\">    如果超过了时长也会立刻返回</span><br><span class=\"line\">函数返回值:</span><br><span class=\"line\">    &gt;<span class=\"number\">0</span>:发生变化的文件描述符的个数</span><br><span class=\"line\">    =<span class=\"number\">0</span>:没有文件描述符发生变化</span><br><span class=\"line\">    <span class=\"number\">-1</span>:表示异常</span><br></pre></td></tr></table></figure>\n<p>说明:<br>1 当poll函数返回的时候，结构体当中的fd,和events没有发生变化，究竞有没有事件发生由revents.来判断，所以poll是请求和返回分离.<br>2 struct pollfd结构体中的fd成员若赋值为-1，则poll不会监控.<br>3相对于select, poll没有本质上的改变;但是poll可以突破1024的限制.<br>在&#x2F;proc&#x2F;svs&#x2F;fs&#x2F;file-max查看一个进程可以打开的socket描述符上限.<br>如果需要可以修改配置文件:&#x2F;etc&#x2F;security&#x2F;limits.conf<br>s<br>加入如下配置信息，然后重启终端即可生效.</p>\n<ul>\n<li>soft nofile 1024</li>\n<li>hard nofile 10000o<br>soft和 hard分别表示ulimit命令可以修改的最小限制和最大限制</li>\n</ul>\n<h1 id=\"多路I0-epoll\"><a href=\"#多路I0-epoll\" class=\"headerlink\" title=\"多路I0-epoll\"></a>多路I0-epoll</h1><p>将检测文件描述符的变化委托给内核去处理，然后内核将发生变化的文件描述符对应的事件返回给应用程序。<br>linux下编程，肯定用这个了<br>告诉有几个发生了变化，精准的告诉哪个有变化<br>epoll底层实现用的红黑二叉树，也就是平衡二叉树</p>\n<p> int epoll_create(int size);<br> 函数说明:<br> 创建一棵epoll树,返回一个树根节点<br> 函数参数:<br>size:必须传一个大于0的数<br>  返回值:<br>返回个文件描述符,这个文件描述符就表示epoll树的树根节点.</p>\n<p> int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<br>函数说明:将fd上epoll树,从树上删除和修改<br>函数参数:<br>    epfd: epoll树的树根节点<br>    op:<br>        EPOLL_CTL_ADD:上树操作<br>        EPOLL_CTL_MOD:修改<br>        EPOLL_CTL_DEL:从树上删除节点<br>        fd:要操作的文件描述符<br>event:<br>    Event.exents:<br>    EPOLLIN:可读事件<br>    EPOLLOUT:可写事件<br>    EPOLLERR:异常事件</p>\n<pre><code>typedef union epoll_data &#123;\n    void        *ptr;\n    int          fd;\n    uint32_t     u32;\n    uint64_t     u64;\n&#125; epoll_data_t;\n\nstruct epoll_event &#123;\n    uint32_t     events;      /* Epoll events */\n    epoll_data_t data;        /* User data variable */\n&#125;;\n</code></pre>\n<p> Struct epoll_exent ev;<br> ex.events &#x3D; EPOLLIN;<br> ex.data.fd &#x3D; fd;<br> epoll_ctl(epfd, EPOLL_CTL_ADD, fd,&amp;ey);</p>\n<p> int epoll_wait(int epfd, struct epoll_event *events,<br>                      int maxevents, int timeout);<br>有返回了，就说明一定有事件发生了</p>\n<p>函数说明:委托内核监控epoll树的事件节点<br>函数参数:<br>    epfd: epoll树根节点<br>    events:传出参数,结构体数组<br>    maxevents: events数组大小<br>    timeout:<br>        -1:表示阻塞<br>        0:表示不阻塞<br>        &gt;0:表示阻塞超时时长</p>\n<p>epoll_wait返回的数组中的事件节点的值不会修改,是当时上epoll树的时候设置的值.</p>\n<h1 id=\"进阶epoll\"><a href=\"#进阶epoll\" class=\"headerlink\" title=\"进阶epoll\"></a>进阶epoll</h1><p>介绍epoll的两种工作模式</p>\n<p>水平触发:高电平代表1<br>只要缓冲区中有数据，就一直通知<br>边缘触发:电平有变化就代表1<br>缓冲区中有数据只会通知一次，之后再有数据才会通知.()若是读数据的时候没有读完，则剩余的数据不会再通知，直到有新的数据到来<br>边缘非阻塞模式:提高效率</p>\n<p>epoll的LT和ET模式:<br>1 epoll默认情况下是LT模式，在这种模式下，若读数据一次性没有读完，<br>缓冲区中还有可读数据，则epoll_wait还会再次通知<br>2若将epoll设置为ET模式，若读数据的时候一次性没有读完，则epoll_wait不再通知,<br>直到下次有新的数据发来．</p>\n<p>思考:<br>1在ET模式下，如何在epoll_wait返回一次的情况下读完数据<br>循环读数据,直到读完数据,但是读完数据之后会阻塞.<br>2若能够一次性读完还需要设置什么?<br>将通信文件描述符设置为非阻塞模式</p>\n<h1 id=\"epoll反应堆\"><a href=\"#epoll反应堆\" class=\"headerlink\" title=\"epoll反应堆\"></a>epoll反应堆</h1><p>typedef union epoll_data {<br>    void        *ptr;<br>    int          fd;<br>    uint32_t     u32;<br>    uint64_t     u64;<br>} epoll_data_t;</p>\n<p>struct epoll_event {<br>    uint32_t     events;      &#x2F;* Epoll events <em>&#x2F;<br>    epoll_data_t data;        &#x2F;</em> User data variable *&#x2F;<br>};<br>触发了一个事件，产生了一连串的反应<br>epoll反应堆实际上是应用了c++的封装思想,—个事件的产生会触发一系列连锁反应,事件产生之后最终调用的是回调函数.<br>将数据和操作数据的方法封装到了一个类里面</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day04-epoll","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day04-epoll/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day02-多进程多线程","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day02-multi-process-multi-thread/","text":"掌握三次握手建立连接过程掌握四次握手关闭连接的过程掌握滑动窗口的概念掌握错误处理函数封装实现多进程并发服务器实现多线程并发服务器 函数封装的思想-处理异常情况结合man-page和errno进行封装.在封装的时候起名可以把第一个函数名的字母大写，如 socket可以封装成Socket,这样可以按shif+K进行搜索, shift+k搜索函数说明的时候不区分大小写,使用man page也可以查看, man page对大小写不区分. 真正的程序，是看不到socket,bind,listen这种函数，一般都集成好了，一个函数能实现好几个功能 像accept,read这样的能够引起阻塞的函数，若被信号打断，由于信号的优先级较高，会优先处理信号，信号处理完成后，会使accept或者read 解除阻塞，然后返回,此时返回值为-1，设置 errno&#x3D;EINTR;errno&#x3D;ECONNABORTED表示连接被打断,异常. errno宏:在&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h 文件中包含了errno所有的宏和对应的错误描述信息. 通过man errno查看 高并发服务器如何支持多个客户端—支持多并发的服务器由于accept 和read函数都会阻塞，如当read的时候，不能调用accept接受新的连接，当accept阻塞等待的时候不能read读数据.第一种方案:使用多进程，可以让父进程接受新连接，让子进程处理与客户端通信思路:让父进程accept接受新连接，然后fork子进程，让子进程处理通信，子进程处理完成后退出，父进程使用SIGCHLD信号回收子进程. 代码实现:第二种方案:使用多线程，让主线程接受新连接，让子线程处理与客户端通信;使用多线程要将线程设置为分离属性，让线程在退出之后自己回收资源.","raw":"---\ntitle: day02-多进程多线程\ndate: 2022-04-02 17:05:42\ntags:\n- Linux网络编程\n---\n\n\n\n\n掌握三次握手建立连接过程\n掌握四次握手关闭连接的过程\n掌握滑动窗口的概念\n掌握错误处理函数封装\n实现多进程并发服务器\n实现多线程并发服务器\n\n\n\n函数封装的思想-处理异常情况\n结合man-page和errno进行封装.\n在封装的时候起名可以把第一个函数名的字母大写，如 socket可以封装成Socket,这样可以按shif+K进行搜索, shift+k搜索函数说明的时候不区分大小写,使用man page也可以查看, man page对大小写不区分.\n\n真正的程序，是看不到socket,bind,listen这种函数，一般都集成好了，一个函数能实现好几个功能\n\n\n像accept,read这样的能够引起阻塞的函数，若被信号打断，由于信号的优先级较高，会优先处理信号，信号处理完成后，会使accept或者read 解除阻塞，然后返回,此时返回值为-1，设置 errno=EINTR;\nerrno=ECONNABORTED表示连接被打断,异常.\n\nerrno宏:\n在/usr/include/asm-generic/errno.h 文件中包含了errno所有的宏和对应的错误描述信息.\n\n通过man errno查看\n\n\n\n# 高并发服务器\n如何支持多个客户端---支持多并发的服务器\n由于accept 和read函数都会阻塞，如当read的时候，不能调用accept接受新的连接，当accept阻塞等待的时候不能read读数据.\n第一种方案:使用多进程，可以让父进程接受新连接，让子进程处理与客户端通信\n思路:让父进程accept接受新连接，然后fork子进程，让子进程处理通信，子进程处理完成后退出，父进程使用SIGCHLD信号回收子进程.\n\n代码实现:\n第二种方案:使用多线程，让主线程接受新连接，让子线程处理与客户端通信;使用多线程要将线程设置为分离属性，让线程在退出之后自己回收资源.\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>掌握三次握手建立连接过程<br>掌握四次握手关闭连接的过程<br>掌握滑动窗口的概念<br>掌握错误处理函数封装<br>实现多进程并发服务器<br>实现多线程并发服务器</p>\n<p>函数封装的思想-处理异常情况<br>结合man-page和errno进行封装.<br>在封装的时候起名可以把第一个函数名的字母大写，如 socket可以封装成Socket,这样可以按shif+K进行搜索, shift+k搜索函数说明的时候不区分大小写,使用man page也可以查看, man page对大小写不区分.</p>\n<p>真正的程序，是看不到socket,bind,listen这种函数，一般都集成好了，一个函数能实现好几个功能</p>\n<p>像accept,read这样的能够引起阻塞的函数，若被信号打断，由于信号的优先级较高，会优先处理信号，信号处理完成后，会使accept或者read 解除阻塞，然后返回,此时返回值为-1，设置 errno&#x3D;EINTR;<br>errno&#x3D;ECONNABORTED表示连接被打断,异常.</p>\n<p>errno宏:<br>在&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h 文件中包含了errno所有的宏和对应的错误描述信息.</p>\n<p>通过man errno查看</p>\n<h1 id=\"高并发服务器\"><a href=\"#高并发服务器\" class=\"headerlink\" title=\"高并发服务器\"></a>高并发服务器</h1><p>如何支持多个客户端—支持多并发的服务器<br>由于accept 和read函数都会阻塞，如当read的时候，不能调用accept接受新的连接，当accept阻塞等待的时候不能read读数据.<br>第一种方案:使用多进程，可以让父进程接受新连接，让子进程处理与客户端通信<br>思路:让父进程accept接受新连接，然后fork子进程，让子进程处理通信，子进程处理完成后退出，父进程使用SIGCHLD信号回收子进程.</p>\n<p>代码实现:<br>第二种方案:使用多线程，让主线程接受新连接，让子线程处理与客户端通信;使用多线程要将线程设置为分离属性，让线程在退出之后自己回收资源.</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day02-multi-process-multi-thread","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day02-multi-process-multi-thread/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day01-一个服务器","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day01-first-sever/","text":"熟练掌握TCP状态转换图熟练掌握端口复用的方法了解半关闭的概念和实现方式了解多路I0转接模型熟练掌握select函数的使用熟练使用fd_set相关函数的使用能够编写select多路IO转接模型的代码","raw":"---\ntitle: day01-一个服务器\ndate: 2022-04-02 17:05:36\ntags:\n- Linux网络编程\n---\n\n\n\n\n熟练掌握TCP状态转换图\n熟练掌握端口复用的方法\n了解半关闭的概念和实现方式\n了解多路I0转接模型\n熟练掌握select函数的使用\n熟练使用fd_set相关函数的使用\n能够编写select多路IO转接模型的代码\n\n\n\n\n\n","content":"<p>熟练掌握TCP状态转换图<br>熟练掌握端口复用的方法<br>了解半关闭的概念和实现方式<br>了解多路I0转接模型<br>熟练掌握select函数的使用<br>熟练使用fd_set相关函数的使用<br>能够编写select多路IO转接模型的代码</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day01-first-sever","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day01-first-sever/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day03-select函数","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day03-select/","text":"熟练掌握TCP状态转换图熟练掌握端口复用的方法了解半关闭的概念和实现方式了解多路I0转接模型熟练掌握select函数的使用熟练使用fd_set相关函数的使用能够编写select多路IO转接模型的代码 端口复用解决端口复用的问题: bind error: Address already in use，发生这种情况是在服务端主动关闭连接以后，接着立刻启动就会报这种错误. int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); setsockopt(lfd, SOL_SOCKETPSO_REUSEADDR,&amp;opt, sizeof(int));setsockopt(lfd , SOL_SOCKET,SO_REUSEPORT,&amp;opt, sizeof(int)); UNIX高级环境编程这个函数写在socket之后，bind前 高并发服务器模型–select一个进程支持多个客户端 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);函数作用:委托内核监控可读,可写,异常事件 函数参数:nfds:，输入参数,告诉内核要监控文件描述符的范围,一般取值为最大文件描述符+1readfds:-输入参数:告诉内核要监控哪些文件描述符-输出参数:内核告诉应用程序哪些文件描述符有变化writefds:-输入参数:告诉内核要监控哪些文件描述符-输出参数:内核告诉应用程序哪些文件描述符有变化Exceptfds:输入输出参数,一般表示异常事件Timeout:超时时间:NULL:表示永久阻塞,直到有事件发生0:表示不阻塞,不管有没有事件发生,都会立刻返回 0:表示阻塞的时长,若没有超过时长,则一直阻塞;若在时长内,有事件发生,则立刻返回,若超过时长,则立刻返回返回值:成功返回发生变化的文件描述符个数. fd_set set;void FD_CLR(int fd, fd_set *set);说明:从set集合中清除fdint FD_ISSET(int fd, fd_set *set);说明:判断fd是否在set集合中void FD_SET(int fd, fd_set *set);说明:将fd添加到set集合中void FD_ZERO(fd_set *set);说明:清空文件描述符集 关于select的思考:问题:如果有效的文件描述符比较少，会使循环的次数太多.解决办法:可以将有效的文件描述符放到一个数组当中，这样遍历效率就高了. 代码优化方向:1将通信文件描述符保存到一个整形数组中，使用一个变量记录数组中最大元素的下标.2如果数组中有无效的文件描述符，直接跳过 select优点:1一个进程可以支持多个客户端2 select支持跨平台 select缺点:1代码编写困难2会涉及到用户区到内核区的来回拷贝3当客户端多个连接，但少数活跃的情况, select效率较低例如:作为极端的一种情况,3-1023文件描述符全部打开，但是只有1023有发送数据, select就显得效率低下4最大支持1024个客户端连接select最大支持1024个客户端连接不是有文件描述符表最多可以支持1024个文件描述符限制的，需是由FD_SETSIZE&#x3D;1024限制的. FD_SETSIZE&#x3D;1024 fd_set使用了该宏，当然可以修改内核，然后再重新编译内核，一般不建议这么做. 作业:编写代码，让 select监控标准输入，监控网络，如果标准输入有数据就写入网络，如果网络有数据就读出网络数据，然后打印到标准输出.注意: select不仅可以监控socket文件描述符，也可以监视标准输","raw":"---\ntitle: day03-select函数\ndate: 2022-04-02 17:02:00\ntags:\n- Linux网络编程\n---\n\n\n熟练掌握TCP状态转换图\n熟练掌握端口复用的方法\n了解半关闭的概念和实现方式\n了解多路I0转接模型\n熟练掌握select函数的使用\n熟练使用fd_set相关函数的使用\n能够编写select多路IO转接模型的代码\n\n\n\n# 端口复用\n解决端口复用的问题: bind error: Address already in use，发生这种情况是在服务端主动关闭连接以后，接着立刻启动就会报这种错误.\n int setsockopt(int sockfd, int level, int optname,\n                      const void *optval, socklen_t optlen);\n\nsetsockopt(lfd, SOL_SOCKETPSO_REUSEADDR,&opt, sizeof(int));\nsetsockopt(lfd , SOL_SOCKET,SO_REUSEPORT,&opt, sizeof(int));\n\nUNIX高级环境编程\n这个函数写在socket之后，bind前\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 高并发服务器模型--select\n\n一个进程支持多个客户端\n\n int select(int nfds, fd_set *readfds, fd_set *writefds,\n                  fd_set *exceptfds, struct timeval *timeout);\n函数作用:\n委托内核监控可读,可写,异常事件\n\n函数参数:\nnfds:，输入参数,告诉内核要监控文件描述符的范围,一般取值为最大文件描述符+1\nreadfds:\n-输入参数:告诉内核要监控哪些文件描述符\n-输出参数:内核告诉应用程序哪些文件描述符有变化\nwritefds:\n-输入参数:告诉内核要监控哪些文件描述符\n-输出参数:内核告诉应用程序哪些文件描述符有变化\nExceptfds:\n输入输出参数,一般表示异常事件\nTimeout:\n超时时间:\nNULL:表示永久阻塞,直到有事件发生\n0:表示不阻塞,不管有没有事件发生,都会立刻返回\n>0:表示阻塞的时长,若没有超过时长,则一直阻塞;\n若在时长内,有事件发生,则立刻返回,\n若超过时长,则立刻返回\n返回值:\n成功返回发生变化的文件描述符个数.\n\n\n\n\nfd_set set;\nvoid FD_CLR(int fd, fd_set *set);\n说明:从set集合中清除fd\nint FD_ISSET(int fd, fd_set *set);\n说明:判断fd是否在set集合中\nvoid FD_SET(int fd, fd_set *set);\n说明:将fd添加到set集合中\nvoid FD_ZERO(fd_set *set);\n说明:清空文件描述符集\n\n\n\n关于select的思考:\n问题:如果有效的文件描述符比较少，会使循环的次数太多.\n解决办法:可以将有效的文件描述符放到一个数组当中，这样遍历效率就高了.\n\n\n代码优化方向:\n1将通信文件描述符保存到一个整形数组中，使用一个变量记录数组中最大元素的下标.\n2如果数组中有无效的文件描述符，直接跳过\n\n\n\nselect优点:\n1一个进程可以支持多个客户端\n2 select支持跨平台\n\nselect缺点:\n1代码编写困难\n2会涉及到用户区到内核区的来回拷贝\n3当客户端多个连接，但少数活跃的情况, select效率较低\n例如:作为极端的一种情况,3-1023文件描述符全部打开，但是只有1023有发送数据, select就显得效率低下\n4最大支持1024个客户端连接\nselect最大支持1024个客户端连接不是有文件描述符表最多可以支持1024个文件描述符限制的，需是由FD_SETSIZE=1024限制的.\n\nFD_SETSIZE=1024 fd_set使用了该宏，当然可以修改内核，然后再重新编译内核，一般不建议这么做.\n\n作业:\n编写代码，让 select监控标准输入，监控网络，如果标准输入有数据就写入网络，如果网络有数据就读出网络数据，然后打印到标准输出.\n注意: select不仅可以监控socket文件描述符，也可以监视标准输\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>熟练掌握TCP状态转换图<br>熟练掌握端口复用的方法<br>了解半关闭的概念和实现方式<br>了解多路I0转接模型<br>熟练掌握select函数的使用<br>熟练使用fd_set相关函数的使用<br>能够编写select多路IO转接模型的代码</p>\n<h1 id=\"端口复用\"><a href=\"#端口复用\" class=\"headerlink\" title=\"端口复用\"></a>端口复用</h1><p>解决端口复用的问题: bind error: Address already in use，发生这种情况是在服务端主动关闭连接以后，接着立刻启动就会报这种错误.<br> int setsockopt(int sockfd, int level, int optname,<br>                      const void *optval, socklen_t optlen);</p>\n<p>setsockopt(lfd, SOL_SOCKETPSO_REUSEADDR,&amp;opt, sizeof(int));<br>setsockopt(lfd , SOL_SOCKET,SO_REUSEPORT,&amp;opt, sizeof(int));</p>\n<p>UNIX高级环境编程<br>这个函数写在socket之后，bind前</p>\n<h1 id=\"高并发服务器模型–select\"><a href=\"#高并发服务器模型–select\" class=\"headerlink\" title=\"高并发服务器模型–select\"></a>高并发服务器模型–select</h1><p>一个进程支持多个客户端</p>\n<p> int select(int nfds, fd_set *readfds, fd_set *writefds,<br>                  fd_set *exceptfds, struct timeval *timeout);<br>函数作用:<br>委托内核监控可读,可写,异常事件</p>\n<p>函数参数:<br>nfds:，输入参数,告诉内核要监控文件描述符的范围,一般取值为最大文件描述符+1<br>readfds:<br>-输入参数:告诉内核要监控哪些文件描述符<br>-输出参数:内核告诉应用程序哪些文件描述符有变化<br>writefds:<br>-输入参数:告诉内核要监控哪些文件描述符<br>-输出参数:内核告诉应用程序哪些文件描述符有变化<br>Exceptfds:<br>输入输出参数,一般表示异常事件<br>Timeout:<br>超时时间:<br>NULL:表示永久阻塞,直到有事件发生<br>0:表示不阻塞,不管有没有事件发生,都会立刻返回</p>\n<blockquote>\n<p>0:表示阻塞的时长,若没有超过时长,则一直阻塞;<br>若在时长内,有事件发生,则立刻返回,<br>若超过时长,则立刻返回<br>返回值:<br>成功返回发生变化的文件描述符个数.</p>\n</blockquote>\n<p>fd_set set;<br>void FD_CLR(int fd, fd_set *set);<br>说明:从set集合中清除fd<br>int FD_ISSET(int fd, fd_set *set);<br>说明:判断fd是否在set集合中<br>void FD_SET(int fd, fd_set *set);<br>说明:将fd添加到set集合中<br>void FD_ZERO(fd_set *set);<br>说明:清空文件描述符集</p>\n<p>关于select的思考:<br>问题:如果有效的文件描述符比较少，会使循环的次数太多.<br>解决办法:可以将有效的文件描述符放到一个数组当中，这样遍历效率就高了.</p>\n<p>代码优化方向:<br>1将通信文件描述符保存到一个整形数组中，使用一个变量记录数组中最大元素的下标.<br>2如果数组中有无效的文件描述符，直接跳过</p>\n<p>select优点:<br>1一个进程可以支持多个客户端<br>2 select支持跨平台</p>\n<p>select缺点:<br>1代码编写困难<br>2会涉及到用户区到内核区的来回拷贝<br>3当客户端多个连接，但少数活跃的情况, select效率较低<br>例如:作为极端的一种情况,3-1023文件描述符全部打开，但是只有1023有发送数据, select就显得效率低下<br>4最大支持1024个客户端连接<br>select最大支持1024个客户端连接不是有文件描述符表最多可以支持1024个文件描述符限制的，需是由FD_SETSIZE&#x3D;1024限制的.</p>\n<p>FD_SETSIZE&#x3D;1024 fd_set使用了该宏，当然可以修改内核，然后再重新编译内核，一般不建议这么做.</p>\n<p>作业:<br>编写代码，让 select监控标准输入，监控网络，如果标准输入有数据就写入网络，如果网络有数据就读出网络数据，然后打印到标准输出.<br>注意: select不仅可以监控socket文件描述符，也可以监视标准输</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day03-select","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day03-select/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day05-线程池","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day05-Thread-Pool/","text":"什么是线程池? 是一个抽象的概念,若干个线程组合到一起,形成线程池. 为什么需要线程池?多线程版服务器一个客户端就需要创建一个线程!若客户端太多，显然不太合适. 什么时候需要创建线程池呢?简单的说，如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了。如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池了。实现的时候类似于生产者和消费者 线程池和任务池:任务池相当于共享资源，所以需要使用互斥锁，当任务池中没有任务的时候需要让线程阻塞，所以需要使用条件变量. 线程相关函数:1 pthread_create2 pthread_detachpthread_attr_t attr;pthread_attr_initpthread_attr_setdetachstate3 pthread_exit 涉及到共享资源:(主线程和各个子线程共享任务池)互斥锁相关函数:pthread_mutex_t mutex;pthread_mutex_initpthread_mutex_lock&#x2F;unlockpthread_mutex_destroy 能够是线程引起阻塞的函数:若任务池已满,主线程应该阻塞等待子线程处理任务,此时主线程需要阻塞等待若任务池空了，子线程应该阻塞等待,等待主线程往任务池中添加任务;pthread_cond_waitpthread_cond_signal 子线程负责从任务池冲获取任务,每一个任务有一个回调函数每王个回调函数执行下同操作.","raw":"---\ntitle: day05-线程池\ndate: 2022-04-02 17:01:50\ntags:\n- Linux网络编程\n---\n\n什么是线程池?\n    是一个抽象的概念,若干个线程组合到一起,形成线程池.\n\n为什么需要线程池?\n多线程版服务器一个客户端就需要创建一个线程!若客户端太多，显然不太合适.\n\n什么时候需要创建线程池呢?\n简单的说，如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了。如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池了。\n实现的时候类似于生产者和消费者\n\n\n线程池和任务池:\n任务池相当于共享资源，所以需要使用互斥锁，当任务池中没有任务的时候需要让线程阻塞，所以需要使用条件变量.\n\n\n线程相关函数:\n1 pthread_create\n2 pthread_detach\npthread_attr_t attr;\npthread_attr_init\npthread_attr_setdetachstate\n3 pthread_exit\n\n涉及到共享资源:(主线程和各个子线程共享任务池)\n互斥锁相关函数:\npthread_mutex_t mutex;\npthread_mutex_init\npthread_mutex_lock/unlock\npthread_mutex_destroy\n\n能够是线程引起阻塞的函数:\n若任务池已满,主线程应该阻塞等待子线程处理任务,此时主线程需要阻塞等待\n若任务池空了，子线程应该阻塞等待,等待主线程往任务池中添加任务;\npthread_cond_wait\npthread_cond_signal\n\n\n子线程负责从任务池冲获取任务,每一个任务有一个回调函数每王个回调函数执行下同操作.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>什么是线程池?<br>    是一个抽象的概念,若干个线程组合到一起,形成线程池.</p>\n<p>为什么需要线程池?<br>多线程版服务器一个客户端就需要创建一个线程!若客户端太多，显然不太合适.</p>\n<p>什么时候需要创建线程池呢?<br>简单的说，如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了。如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池了。<br>实现的时候类似于生产者和消费者</p>\n<p>线程池和任务池:<br>任务池相当于共享资源，所以需要使用互斥锁，当任务池中没有任务的时候需要让线程阻塞，所以需要使用条件变量.</p>\n<p>线程相关函数:<br>1 pthread_create<br>2 pthread_detach<br>pthread_attr_t attr;<br>pthread_attr_init<br>pthread_attr_setdetachstate<br>3 pthread_exit</p>\n<p>涉及到共享资源:(主线程和各个子线程共享任务池)<br>互斥锁相关函数:<br>pthread_mutex_t mutex;<br>pthread_mutex_init<br>pthread_mutex_lock&#x2F;unlock<br>pthread_mutex_destroy</p>\n<p>能够是线程引起阻塞的函数:<br>若任务池已满,主线程应该阻塞等待子线程处理任务,此时主线程需要阻塞等待<br>若任务池空了，子线程应该阻塞等待,等待主线程往任务池中添加任务;<br>pthread_cond_wait<br>pthread_cond_signal</p>\n<p>子线程负责从任务池冲获取任务,每一个任务有一个回调函数每王个回调函数执行下同操作.</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day05-Thread-Pool","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day05-Thread-Pool/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Part10 认识与学习bash","date":"31/03/2022","path":"2022/03/31/Brids-Linux-private-kitchen/Part10-know-bash/","text":"10.5 数据流重定向标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ； 1&gt; ：以覆盖的方法将『正确的数据』输出到指定的文件或装置上；1&gt;&gt;：以累加的方法将『正确的数据』输出到指定的文件或装置上；2&gt; ：以覆盖的方法将『错误的数据』输出到指定的文件或装置上；2&gt;&gt;：以累加的方法将『错误的数据』输出到指定的文件或装置上； &#x2F;dev&#x2F;null 垃圾桶黑洞装置与特殊写法 常见命令daily.log 2&gt;&amp;1 &amp; 2&gt;&amp;1 &amp;最后的&amp;表示把条命令放到后台执行 2&gt;&amp;1 命令下达情况 说明cmd1 &amp;&amp; cmd2 1. 若 cmd1 运行完毕且正确运行($?&#x3D;0)，则开始运行 cmd2。 2. 若 cmd1 运行完毕且为错误 ($?≠0)，则 cmd2 不运行。cmd1 || cmd2 1. 若 cmd1 运行完毕且正确运行($?&#x3D;0)，则 cmd2 不运行。 2. 若 cmd1 运行完毕且为错误 ($?≠0)，则开始运行 cmd2。 测试 &#x2F;tmp&#x2F;abc 是否存在，若不存在则予以创建，若存在就不作任何事情ls &#x2F;tmp&#x2F;abc || mkdir &#x2F;tmp&#x2F;abc &amp;&amp; touch &#x2F;tmp&#x2F;abc&#x2F;hehe ls &#x2F;tmp&#x2F;abc &amp;&amp; touch &#x2F;tmp&#x2F;abc&#x2F;hehe 10.6 管道命令提取命令cut 将一行信息当中取出想要的对同一行的数据进行分解，难以处理多个空格相连的情况cut -d’分隔字符’ -f fields 选项 含义 -d 后面接分隔字符。与 -f 一起使用； -f 取出第几段的意思 -c 以字符 (characters) 的单位取出固定字符区间； grep 分析一行信息，提取整行grep [-acinv] [–color&#x3D;auto] ‘搜寻字符串’ filename 选项 含义 -a 将 binary 文件以 text 文件的方式搜寻数据 -c 计算找到 ‘搜寻字符串’ 的次数 -i 忽略大小写的不同，所以大小写视为相同 -n 顺便输出行号 -v 反向选择 –color&#x3D;auto 可以将找到的关键词部分加上颜色 排序命令sort进行排序sort [-fbMnrtuk] [file or stdin] 选项 含义 -f 忽略大小写的差异，例如 A 与 a 视为编码相同 -b 忽略最前面的空格符部分 -M 以月份的名字来排序，例如 JAN, DEC 等等的排序方法 -n 使用『纯数字』进行排序(默认是以文字型态来排序的) -r 反向排序,原来是从小到大，-r后从大到小 -u 就是 uniq ，相同的数据中，仅出现一行代表 -t 分隔符，默认是用 [tab] 键来分隔 -k 以那个区间 (field) 来进行排序的意思 12345678910111213141516171819202122sort11011121322034sort -n # 如果不加n，就是用字典序排序了12341011121320sort -rn sort -t &#x27;:&#x27; # 用冒号分割 uniq将重复的数据列出一行显示uniq [-ic] 选项 含义 -i 忽略大小写字符的不同行 -c 进行计数 1uniq -c | sort -rn | head -n 5 # 找到次数最多的几个 wcwc [-lwm] 选项 含义 -l 仅列出行 -w 仅列出多少字(英文单字) -m 多少字符 1cat /etc/passwd | wc -l # 目前你的账号文件中有多少个账号时 参考文献[Linux Shell &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;含义]https://www.silenceboy.com/2019/04/01/Linux-Shell-dev-null-2-1-%E5%90%AB%E4%B9%89/index.html[深入理解Linux shell中2&gt;&amp;1的含义(全网最全，看完就懂)]https://segmentfault.com/a/1190000040086046","raw":"---\ntitle: Part10 认识与学习bash\ndate: 2022-03-31 15:06:08\ntags:\n- 鸟哥的Linux私房菜\n---\n\n\n\n# 10.5 数据流重定向\n\n标准输入　　(stdin) ：代码为 0 ，使用 < 或 << ；\n标准输出　　(stdout)：代码为 1 ，使用 > 或 >> ；\n标准错误输出(stderr)：代码为 2 ，使用 2> 或 2>> ；\n\n1> ：以覆盖的方法将『正确的数据』输出到指定的文件或装置上；\n1>>：以累加的方法将『正确的数据』输出到指定的文件或装置上；\n2> ：以覆盖的方法将『错误的数据』输出到指定的文件或装置上；\n2>>：以累加的方法将『错误的数据』输出到指定的文件或装置上；\n\n/dev/null 垃圾桶黑洞装置与特殊写法\n\n常见命令\ndaily.log 2>&1 &\n\n2>&1 &\n最后的&表示把条命令放到后台执行\n\n2>&1\n\n----\n\n命令下达情况\t说明\ncmd1 && cmd2\t1. 若 cmd1 运行完毕且正确运行($?=0)，则开始运行 cmd2。<br> 2. 若 cmd1 运行完毕且为错误 ($?≠0)，则 cmd2 不运行。\ncmd1 || cmd2\t1. 若 cmd1 运行完毕且正确运行($?=0)，则 cmd2 不运行。<br> 2. 若 cmd1 运行完毕且为错误 ($?≠0)，则开始运行 cmd2。\n\n---\n\n测试 /tmp/abc 是否存在，若不存在则予以创建，若存在就不作任何事情\nls /tmp/abc || mkdir /tmp/abc && touch /tmp/abc/hehe\n\nls /tmp/abc && touch /tmp/abc/hehe\n\n# 10.6 管道命令\n\n## 提取命令\n### cut 将一行信息当中取出想要的\n对同一行的数据进行分解，难以处理多个空格相连的情况\ncut -d'分隔字符' -f fields\n\n|选项 | 含义|\n|---|---|\n|-d  |后面接分隔字符。与 -f 一起使用；|\n|-f  |取出第几段的意思|\n|-c  |以字符 (characters) 的单位取出固定字符区间；|\n\n\n### grep     分析一行信息，提取整行\ngrep [-acinv] [--color=auto] '搜寻字符串' filename\n\n|选项 | 含义|\n| ------ | ------ | \n|-a |将 binary 文件以 text 文件的方式搜寻数据|\n|-c |计算找到 '搜寻字符串' 的次数|\n|-i |忽略大小写的不同，所以大小写视为相同|\n|-n |顺便输出行号|\n|-v |反向选择|\n|--color=auto |可以将找到的关键词部分加上颜色|\n\n## 排序命令\n\n### sort\n进行排序\nsort [-fbMnrtuk] [file or stdin]\n\n|选项 | 含义|\n| ------ | ------ | \n|-f  |忽略大小写的差异，例如 A 与 a 视为编码相同|\n|-b  |忽略最前面的空格符部分|\n|-M  |以月份的名字来排序，例如 JAN, DEC 等等的排序方法|\n|-n  |使用『纯数字』进行排序(默认是以文字型态来排序的)|\n|-r  |反向排序,原来是从小到大，-r后从大到小|\n|-u  |就是 uniq ，相同的数据中，仅出现一行代表|\n|-t  |分隔符，默认是用 [tab] 键来分隔|\n|-k  |以那个区间 (field) 来进行排序的意思|\n\n```\nsort\n1\n10\n11\n12\n13\n2\n20\n3\n4\nsort -n # 如果不加n，就是用字典序排序了\n1\n2\n3\n4\n10\n11\n12\n13\n20\nsort -rn    \nsort -t ':'  # 用冒号分割\n```\n\n### uniq\n将重复的数据列出一行显示\nuniq [-ic]\n\n| 选项 | 含义 | \n| ------ | ------ | \n| -i | 忽略大小写字符的不同行 | \n| -c | 进行计数 |\n\n```\nuniq -c | sort -rn | head -n 5  # 找到次数最多的几个\n```\n\n### wc\nwc [-lwm]\n\n| 选项 | 含义 | \n| ------ | ------ | \n| -l | 仅列出行 | \n| -w  | 仅列出多少字(英文单字) |\n| -m  | 多少字符 |\n\n```\ncat /etc/passwd | wc -l   # 目前你的账号文件中有多少个账号时\n```\n\n\n\n\n\n\n# 参考文献\n\n[Linux Shell >/dev/null 2>&1 &含义]https://www.silenceboy.com/2019/04/01/Linux-Shell-dev-null-2-1-%E5%90%AB%E4%B9%89/index.html\n[深入理解Linux shell中2>&1的含义(全网最全，看完就懂)]https://segmentfault.com/a/1190000040086046\n\n\n\n\n\n","content":"<h1 id=\"10-5-数据流重定向\"><a href=\"#10-5-数据流重定向\" class=\"headerlink\" title=\"10.5 数据流重定向\"></a>10.5 数据流重定向</h1><p>标准输入　　(stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；<br>标准输出　　(stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；<br>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</p>\n<p>1&gt; ：以覆盖的方法将『正确的数据』输出到指定的文件或装置上；<br>1&gt;&gt;：以累加的方法将『正确的数据』输出到指定的文件或装置上；<br>2&gt; ：以覆盖的方法将『错误的数据』输出到指定的文件或装置上；<br>2&gt;&gt;：以累加的方法将『错误的数据』输出到指定的文件或装置上；</p>\n<p>&#x2F;dev&#x2F;null 垃圾桶黑洞装置与特殊写法</p>\n<p>常见命令<br>daily.log 2&gt;&amp;1 &amp;</p>\n<p>2&gt;&amp;1 &amp;<br>最后的&amp;表示把条命令放到后台执行</p>\n<p>2&gt;&amp;1</p>\n<hr>\n<p>命令下达情况\t说明<br>cmd1 &amp;&amp; cmd2\t1. 若 cmd1 运行完毕且正确运行($?&#x3D;0)，则开始运行 cmd2。<br> 2. 若 cmd1 运行完毕且为错误 ($?≠0)，则 cmd2 不运行。<br>cmd1 || cmd2\t1. 若 cmd1 运行完毕且正确运行($?&#x3D;0)，则 cmd2 不运行。<br> 2. 若 cmd1 运行完毕且为错误 ($?≠0)，则开始运行 cmd2。</p>\n<hr>\n<p>测试 &#x2F;tmp&#x2F;abc 是否存在，若不存在则予以创建，若存在就不作任何事情<br>ls &#x2F;tmp&#x2F;abc || mkdir &#x2F;tmp&#x2F;abc &amp;&amp; touch &#x2F;tmp&#x2F;abc&#x2F;hehe</p>\n<p>ls &#x2F;tmp&#x2F;abc &amp;&amp; touch &#x2F;tmp&#x2F;abc&#x2F;hehe</p>\n<h1 id=\"10-6-管道命令\"><a href=\"#10-6-管道命令\" class=\"headerlink\" title=\"10.6 管道命令\"></a>10.6 管道命令</h1><h2 id=\"提取命令\"><a href=\"#提取命令\" class=\"headerlink\" title=\"提取命令\"></a>提取命令</h2><h3 id=\"cut-将一行信息当中取出想要的\"><a href=\"#cut-将一行信息当中取出想要的\" class=\"headerlink\" title=\"cut 将一行信息当中取出想要的\"></a>cut 将一行信息当中取出想要的</h3><p>对同一行的数据进行分解，难以处理多个空格相连的情况<br>cut -d’分隔字符’ -f fields</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-d</td>\n<td>后面接分隔字符。与 -f 一起使用；</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>取出第几段的意思</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>以字符 (characters) 的单位取出固定字符区间；</td>\n</tr>\n</tbody></table>\n<h3 id=\"grep-分析一行信息，提取整行\"><a href=\"#grep-分析一行信息，提取整行\" class=\"headerlink\" title=\"grep     分析一行信息，提取整行\"></a>grep     分析一行信息，提取整行</h3><p>grep [-acinv] [–color&#x3D;auto] ‘搜寻字符串’ filename</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a</td>\n<td>将 binary 文件以 text 文件的方式搜寻数据</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>计算找到 ‘搜寻字符串’ 的次数</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>忽略大小写的不同，所以大小写视为相同</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>顺便输出行号</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>反向选择</td>\n</tr>\n<tr>\n<td>–color&#x3D;auto</td>\n<td>可以将找到的关键词部分加上颜色</td>\n</tr>\n</tbody></table>\n<h2 id=\"排序命令\"><a href=\"#排序命令\" class=\"headerlink\" title=\"排序命令\"></a>排序命令</h2><h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p>进行排序<br>sort [-fbMnrtuk] [file or stdin]</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-f</td>\n<td>忽略大小写的差异，例如 A 与 a 视为编码相同</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>忽略最前面的空格符部分</td>\n</tr>\n<tr>\n<td>-M</td>\n<td>以月份的名字来排序，例如 JAN, DEC 等等的排序方法</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>使用『纯数字』进行排序(默认是以文字型态来排序的)</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>反向排序,原来是从小到大，-r后从大到小</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>就是 uniq ，相同的数据中，仅出现一行代表</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>分隔符，默认是用 [tab] 键来分隔</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>以那个区间 (field) 来进行排序的意思</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span></span><br><span class=\"line\">1</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">2</span><br><span class=\"line\">20</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\"><span class=\"built_in\">sort</span> -n <span class=\"comment\"># 如果不加n，就是用字典序排序了</span></span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">20</span><br><span class=\"line\"><span class=\"built_in\">sort</span> -rn    </span><br><span class=\"line\"><span class=\"built_in\">sort</span> -t <span class=\"string\">&#x27;:&#x27;</span>  <span class=\"comment\"># 用冒号分割</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"uniq\"><a href=\"#uniq\" class=\"headerlink\" title=\"uniq\"></a>uniq</h3><p>将重复的数据列出一行显示<br>uniq [-ic]</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-i</td>\n<td>忽略大小写字符的不同行</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>进行计数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">uniq</span> -c | <span class=\"built_in\">sort</span> -rn | <span class=\"built_in\">head</span> -n 5  <span class=\"comment\"># 找到次数最多的几个</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"wc\"><a href=\"#wc\" class=\"headerlink\" title=\"wc\"></a>wc</h3><p>wc [-lwm]</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-l</td>\n<td>仅列出行</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>仅列出多少字(英文单字)</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>多少字符</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /etc/passwd | <span class=\"built_in\">wc</span> -l   <span class=\"comment\"># 目前你的账号文件中有多少个账号时</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[Linux Shell &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;含义]<a href=\"https://www.silenceboy.com/2019/04/01/Linux-Shell-dev-null-2-1-%E5%90%AB%E4%B9%89/index.html\">https://www.silenceboy.com/2019/04/01/Linux-Shell-dev-null-2-1-%E5%90%AB%E4%B9%89/index.html</a><br>[深入理解Linux shell中2&gt;&amp;1的含义(全网最全，看完就懂)]<a href=\"https://segmentfault.com/a/1190000040086046\">https://segmentfault.com/a/1190000040086046</a></p>\n","slug":"Brids-Linux-private-kitchen/Part10-know-bash","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/31/Brids-Linux-private-kitchen/Part10-know-bash/","excerpt":"","categories":[],"tags":[{"name":"鸟哥的Linux私房菜","slug":"鸟哥的Linux私房菜","permalink":"http://example.com/tags/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"}]},{"title":"Part6 Linux文件与目录系统","date":"29/03/2022","path":"2022/03/29/Brids-Linux-private-kitchen/Part6-Linux-file-and-directory-system/","text":"6.5命令的文件与查找6.5.1脚本文件的查找whichwhich [-a] command选项或参数：-a ：将所有由 PATH 目录中可以找到的命令均列出，而不止第一个被找到的命令名称 which ifconfig 文件查找whereis在特定的目录中查找文件whereis [-bmsu] 文件或目录名 选项 含义 -b 只找 binary 格式的文件 -m 只找在说明档 manual 路径下的文件 -s 只找 source 来源文件 -u 搜寻不在上述三个项目当中的其他特殊文件 locatelocate [-ir] keyword 选项 含义 -i 忽略大小写的差异 -r 后面可接正规表示法的显示方式 findfind [PATH] [option] [action]选项与参数： 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明-mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的文件；-mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的文件档名；-mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的文件档名。-newer file ：file 为一个存在的文件，列出比 file 还要新的文件档名 与使用者或群组名称有关的参数：-uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在 &#x2F;etc&#x2F;passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。-gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在 &#x2F;etc&#x2F;group，相关的介绍我们会第四篇说明～-user name ：name 为使用者帐号名称喔！例如 dmtsai-group name：name 为群组名称喔，例如 users ；-nouser ：寻找文件的拥有者不存在 &#x2F;etc&#x2F;passwd 的人！-nogroup ：寻找文件的拥有群组不存在於 &#x2F;etc&#x2F;group 的文件！ 当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者， 这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。 与文件权限及名称有关的参数：-name filename：搜寻文件名称为 filename 的文件； find . -name “*.log” -size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的文件。这个 SIZE 的规格有： c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是『 -size +50k 』-type TYPE ：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 (f), 装置文件 (b, c), 目录 (d), 连结档 (l), socket (s), 及 FIFO (p) 等属性。-perm mode ：搜寻文件权限『刚好等於』 mode 的文件，这个 mode 为类似 chmod 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！-perm -mode ：搜寻文件权限『必须要全部囊括 mode 的权限』的文件，举例来说， 我们要搜寻 -rwxr–r– ，亦即 0744 的文件，使用 -perm -0744， 当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来， 因为 -rwsr-xr-x 的属性已经囊括了 -rwxr–r– 的属性了。-perm +mode ：搜寻文件权限『包含任一 mode 的权限』的文件，举例来说，我们搜寻 -rwxr-xr-x ，亦即 -perm +755 时，但一个文件属性为 -rw——- 也会被列出来，因为他有 -rw…. 的属性存在！ 额外可进行的动作：-exec command ：command 为其他命令，-exec 后面可再接额外的命令来处理搜寻到 的结果。-print ：将结果列印到萤幕上，这个动作是默认动作！","raw":"---\ntitle: Part6 Linux文件与目录系统\ndate: 2022-03-29 22:16:54\ntags:\n- 鸟哥的Linux私房菜\n---\n\n\n\n\n# 6.5命令的文件与查找\n\n## 6.5.1脚本文件的查找\n\n### which\nwhich [-a] command\n选项或参数：\n-a ：将所有由 PATH 目录中可以找到的命令均列出，而不止第一个被找到的命令名称\n\nwhich ifconfig\n\n\n## 文件查找\n\n### whereis\n**在特定的目录中查找文件**\nwhereis [-bmsu] 文件或目录名\n\n|选项 | 含义|\n|---|---|\n|-b    |只找 binary 格式的文件|\n|-m    |只找在说明档 manual 路径下的文件|\n|-s    |只找 source 来源文件|\n|-u    |搜寻不在上述三个项目当中的其他特殊文件|\n\n### locate\nlocate [-ir] keyword\n\n|选项 | 含义|\n|---|---|\n|-i  |忽略大小写的差异|\n|-r  |后面可接正规表示法的显示方式|\n\n\n### find\nfind [PATH] [option] [action]\n选项与参数：\n1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明\n   -mtime  n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的文件；\n   -mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的文件档名；\n   -mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的文件档名。\n   -newer file ：file 为一个存在的文件，列出比 file 还要新的文件档名\n\n2. 与使用者或群组名称有关的参数：\n-uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在\n        /etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。\n-gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在\n        /etc/group，相关的介绍我们会第四篇说明～\n-user name ：name 为使用者帐号名称喔！例如 dmtsai \n-group name：name 为群组名称喔，例如 users ；\n-nouser    ：寻找文件的拥有者不存在 /etc/passwd 的人！\n-nogroup   ：寻找文件的拥有群组不存在於 /etc/group 的文件！\n            当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，\n            这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。\n\n\n3. 与文件权限及名称有关的参数：\n   -name filename：搜寻文件名称为 filename 的文件；\n   \n   find . -name \"*.log\"\n\n   -size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的文件。这个 SIZE 的规格有：\n                   c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB\n                   还要大的文件，就是『 -size +50k 』\n   -type TYPE    ：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 (f),\n                   装置文件 (b, c), 目录 (d), 连结档 (l), socket (s), \n                   及 FIFO (p) 等属性。\n   -perm mode  ：搜寻文件权限『刚好等於』 mode 的文件，这个 mode 为类似 chmod\n                 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！\n   -perm -mode ：搜寻文件权限『必须要全部囊括 mode 的权限』的文件，举例来说，\n                 我们要搜寻 -rwxr--r-- ，亦即 0744 的文件，使用 -perm -0744，\n                 当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，\n                 因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。\n   -perm +mode ：搜寻文件权限『包含任一 mode 的权限』的文件，举例来说，我们搜寻\n                 -rwxr-xr-x ，亦即 -perm +755 时，但一个文件属性为 -rw-------\n                 也会被列出来，因为他有 -rw.... 的属性存在！\n\n4. 额外可进行的动作：\n   -exec command ：command 为其他命令，-exec 后面可再接额外的命令来处理搜寻到\n                   的结果。\n   -print        ：将结果列印到萤幕上，这个动作是默认动作！","content":"<h1 id=\"6-5命令的文件与查找\"><a href=\"#6-5命令的文件与查找\" class=\"headerlink\" title=\"6.5命令的文件与查找\"></a>6.5命令的文件与查找</h1><h2 id=\"6-5-1脚本文件的查找\"><a href=\"#6-5-1脚本文件的查找\" class=\"headerlink\" title=\"6.5.1脚本文件的查找\"></a>6.5.1脚本文件的查找</h2><h3 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h3><p>which [-a] command<br>选项或参数：<br>-a ：将所有由 PATH 目录中可以找到的命令均列出，而不止第一个被找到的命令名称</p>\n<p>which ifconfig</p>\n<h2 id=\"文件查找\"><a href=\"#文件查找\" class=\"headerlink\" title=\"文件查找\"></a>文件查找</h2><h3 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h3><p><strong>在特定的目录中查找文件</strong><br>whereis [-bmsu] 文件或目录名</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-b</td>\n<td>只找 binary 格式的文件</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>只找在说明档 manual 路径下的文件</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>只找 source 来源文件</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>搜寻不在上述三个项目当中的其他特殊文件</td>\n</tr>\n</tbody></table>\n<h3 id=\"locate\"><a href=\"#locate\" class=\"headerlink\" title=\"locate\"></a>locate</h3><p>locate [-ir] keyword</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-i</td>\n<td>忽略大小写的差异</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>后面可接正规表示法的显示方式</td>\n</tr>\n</tbody></table>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p>find [PATH] [option] [action]<br>选项与参数：</p>\n<ol>\n<li><p>与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明<br>-mtime  n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的文件；<br>-mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的文件档名；<br>-mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的文件档名。<br>-newer file ：file 为一个存在的文件，列出比 file 还要新的文件档名</p>\n</li>\n<li><p>与使用者或群组名称有关的参数：<br>-uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在<br> &#x2F;etc&#x2F;passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。<br>-gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在<br> &#x2F;etc&#x2F;group，相关的介绍我们会第四篇说明～<br>-user name ：name 为使用者帐号名称喔！例如 dmtsai<br>-group name：name 为群组名称喔，例如 users ；<br>-nouser    ：寻找文件的拥有者不存在 &#x2F;etc&#x2F;passwd 的人！<br>-nogroup   ：寻找文件的拥有群组不存在於 &#x2F;etc&#x2F;group 的文件！<br>     当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，<br>     这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。</p>\n</li>\n<li><p>与文件权限及名称有关的参数：<br>-name filename：搜寻文件名称为 filename 的文件；</p>\n<p>find . -name “*.log”</p>\n<p>-size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的文件。这个 SIZE 的规格有：<br>            c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB<br>            还要大的文件，就是『 -size +50k 』<br>-type TYPE    ：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 (f),<br>            装置文件 (b, c), 目录 (d), 连结档 (l), socket (s),<br>            及 FIFO (p) 等属性。<br>-perm mode  ：搜寻文件权限『刚好等於』 mode 的文件，这个 mode 为类似 chmod<br>          的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！<br>-perm -mode ：搜寻文件权限『必须要全部囊括 mode 的权限』的文件，举例来说，<br>          我们要搜寻 -rwxr–r– ，亦即 0744 的文件，使用 -perm -0744，<br>          当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，<br>          因为 -rwsr-xr-x 的属性已经囊括了 -rwxr–r– 的属性了。<br>-perm +mode ：搜寻文件权限『包含任一 mode 的权限』的文件，举例来说，我们搜寻<br>          -rwxr-xr-x ，亦即 -perm +755 时，但一个文件属性为 -rw——-<br>          也会被列出来，因为他有 -rw…. 的属性存在！</p>\n</li>\n<li><p>额外可进行的动作：<br>-exec command ：command 为其他命令，-exec 后面可再接额外的命令来处理搜寻到<br>            的结果。<br>-print        ：将结果列印到萤幕上，这个动作是默认动作！</p>\n</li>\n</ol>\n","slug":"Brids-Linux-private-kitchen/Part6-Linux-file-and-directory-system","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/29/Brids-Linux-private-kitchen/Part6-Linux-file-and-directory-system/","excerpt":"","categories":[],"tags":[{"name":"鸟哥的Linux私房菜","slug":"鸟哥的Linux私房菜","permalink":"http://example.com/tags/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"}]},{"title":"shell 教程","date":"26/03/2022","path":"2022/03/26/Tutorial/shell-tutorial/","text":"ans_yn.sh: 2: [: missing ]代码中的 ] 方括号内部必须要有个空格， [ “${yn}” &#x3D;&#x3D; “Y” -o “${yn}” &#x3D;&#x3D; “y”] 改成 [ “${yn}” &#x3D;&#x3D; “Y” -o “${yn}” &#x3D;&#x3D; “y” ] 即可ans_yn.sh: 2: [: y: unexpected operator 后来发现，因为ubuntu默认的sh是连接到dash的,又因为dash跟bash的不兼容所以出错了.执行时可以把sh换成bash文件名.sh来执行.成功.dash是什么东西,查了一下,应该也是一种shell,貌似用户对它的诟病颇多。修改sh默认连接到bash的一种方法： sudo dpkg-reconfigure dash选择no即可. [ -d DIR ] 如果 FILE 存在且是一个目录则为真。[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真； https://blog.csdn.net/liuqiyao_01/article/details/41551075","raw":"---\ntitle: shell 教程\ndate: 2022-03-26 14:21:04\ntags:\n- 教程\n---\n\nans_yn.sh: 2: [: missing ]\n代码中的 ] 方括号内部必须要有个空格， [ \"${yn}\" == \"Y\" -o \"${yn}\" == \"y\"] 改成  [ \"${yn}\" == \"Y\" -o \"${yn}\" == \"y\" ] 即可\nans_yn.sh: 2: [: y: unexpected operator\n\n\n后来发现，因为ubuntu默认的sh是连接到dash的,又因为dash跟bash的不兼容所以出错了.执行时可以把sh换成bash文件名.sh来执行.成功.dash是什么东西,查了一下,应该也是一种shell,貌似用户对它的诟病颇多。\n修改sh默认连接到bash的一种方法：\n\n\nsudo dpkg-reconfigure dash\n选择no即可.\n\n\n\n[ -d DIR ] 如果 FILE 存在且是一个目录则为真。\n[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；\n\n\n\n\nhttps://blog.csdn.net/liuqiyao_01/article/details/41551075","content":"<p>ans_yn.sh: 2: [: missing ]<br>代码中的 ] 方括号内部必须要有个空格， [ “${yn}” &#x3D;&#x3D; “Y” -o “${yn}” &#x3D;&#x3D; “y”] 改成  [ “${yn}” &#x3D;&#x3D; “Y” -o “${yn}” &#x3D;&#x3D; “y” ] 即可<br>ans_yn.sh: 2: [: y: unexpected operator</p>\n<p>后来发现，因为ubuntu默认的sh是连接到dash的,又因为dash跟bash的不兼容所以出错了.执行时可以把sh换成bash文件名.sh来执行.成功.dash是什么东西,查了一下,应该也是一种shell,貌似用户对它的诟病颇多。<br>修改sh默认连接到bash的一种方法：</p>\n<p>sudo dpkg-reconfigure dash<br>选择no即可.</p>\n<p>[ -d DIR ] 如果 FILE 存在且是一个目录则为真。<br>[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；</p>\n<p><a href=\"https://blog.csdn.net/liuqiyao_01/article/details/41551075\">https://blog.csdn.net/liuqiyao_01/article/details/41551075</a></p>\n","slug":"Tutorial/shell-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/26/Tutorial/shell-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"设计模式题目","date":"19/03/2022","path":"2022/03/19/Interview-Q&A/Design-Patterns-Q&A/","text":"传输对象模式 当我们要一次从客户端到服务器传递具有多个属性的数据时，使用此模式 传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。 业务对象（Business Object） - 为传输对象填充数据的业务服务。传输对象（Transfer Object） - 简单的 POJO，只有设置&#x2F;获取属性的方法。客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。 以下哪种模式使用简单对象并采用逐步方法来构建复杂对象？ 建造者模式A、 桥接模式 B、 建造者模式 C、 过滤器模式 D、 适配器模式 Adapter class&#x2F;object 适配器模式可以进行接口转化 意图：将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适用性：你想使用一个已经存在的类，而它的接口不符合你的需求。你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 类适配器和对象适配器 这里列举一个c++ STL中的适配器例子，这是只是简单模型，想要深入请看STL源码剖析这里target：Sequenceadaptee是：deque而被实现的适配器是queue和stack 解释器模式（Interpreter Pattern）解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 (1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 (2) 一些重复出现的问题可以用一种简单的语言来进行表达。 (3) 一个语言的文法较为简单。 (4) 执行效率不是关键问题。（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。 优点:(1) 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 (2) 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 (3) 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。 (4) 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。 缺点:(1) 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 (2) 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦 实现： 尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。实现方式基本同Composite模式。重构成本：高。 参考文献：https://blog.csdn.net/chenxun_2010/article/details/48383571https://blog.csdn.net/llg070401046/article/details/73323934","raw":"---\ntitle: 设计模式题目\ndate: 2022-03-19 15:28:21\ntags:\n- 面试\n---\n\n\n\n\n\n\n\n\n\n\n\n\n2. 传输对象模式\n\n当我们要一次从客户端到服务器传递具有多个属性的数据时，使用此模式\n\n传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。\n服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。\n对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。\n\n业务对象（Business Object） - 为传输对象填充数据的业务服务。\n传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法。\n客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。\n\n\n\n3. 以下哪种模式使用简单对象并采用逐步方法来构建复杂对象？  建造者模式\nA、\t桥接模式\t\nB、\t建造者模式\t\nC、\t过滤器模式\t\nD、\t适配器模式\n\n\n\n## Adapter class/object 适配器模式\n**可以进行接口转化**\n- 意图：\n将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n- 适用性：\n你想使用一个已经存在的类，而它的接口不符合你的需求。\n你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。\n（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。\n\n\n类适配器和对象适配器\n\n这里列举一个c++ STL中的适配器例子，这是只是简单模型，想要深入请看STL源码剖析\n这里target：Sequence\nadaptee是：deque\n而被实现的适配器是queue和stack\n\n\n# 解释器模式（Interpreter Pattern）\n\n解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。\n\n(1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。\n\n(2)  一些重复出现的问题可以用一种简单的语言来进行表达。\n\n(3) 一个语言的文法较为简单。\n\n(4) 执行效率不是关键问题。（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。\n\n### 优点:\n\n\n(1) 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。\n\n(2) 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。\n\n(3) 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。\n\n(4) 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。\n\n### 缺点:\n(1) 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。\n\n(2) 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦\n\n\n实现： 尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。实现方式基本同Composite模式。\n重构成本：高。\n\n\n\n# 参考文献：\n\nhttps://blog.csdn.net/chenxun_2010/article/details/48383571\nhttps://blog.csdn.net/llg070401046/article/details/73323934\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<ol start=\"2\">\n<li>传输对象模式</li>\n</ol>\n<p>当我们要一次从客户端到服务器传递具有多个属性的数据时，使用此模式</p>\n<p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。<br>服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。<br>对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。</p>\n<p>业务对象（Business Object） - 为传输对象填充数据的业务服务。<br>传输对象（Transfer Object） - 简单的 POJO，只有设置&#x2F;获取属性的方法。<br>客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。</p>\n<ol start=\"3\">\n<li>以下哪种模式使用简单对象并采用逐步方法来构建复杂对象？  建造者模式<br>A、\t桥接模式\t<br>B、\t建造者模式\t<br>C、\t过滤器模式\t<br>D、\t适配器模式</li>\n</ol>\n<h2 id=\"Adapter-class-x2F-object-适配器模式\"><a href=\"#Adapter-class-x2F-object-适配器模式\" class=\"headerlink\" title=\"Adapter class&#x2F;object 适配器模式\"></a>Adapter class&#x2F;object 适配器模式</h2><p><strong>可以进行接口转化</strong></p>\n<ul>\n<li>意图：<br>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>\n<li>适用性：<br>你想使用一个已经存在的类，而它的接口不符合你的需求。<br>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。<br>（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>\n</ul>\n<p>类适配器和对象适配器</p>\n<p>这里列举一个c++ STL中的适配器例子，这是只是简单模型，想要深入请看STL源码剖析<br>这里target：Sequence<br>adaptee是：deque<br>而被实现的适配器是queue和stack</p>\n<h1 id=\"解释器模式（Interpreter-Pattern）\"><a href=\"#解释器模式（Interpreter-Pattern）\" class=\"headerlink\" title=\"解释器模式（Interpreter Pattern）\"></a>解释器模式（Interpreter Pattern）</h1><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p>\n<p>(1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</p>\n<p>(2)  一些重复出现的问题可以用一种简单的语言来进行表达。</p>\n<p>(3) 一个语言的文法较为简单。</p>\n<p>(4) 执行效率不是关键问题。（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><p>(1) 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</p>\n<p>(2) 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p>\n<p>(3) 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。</p>\n<p>(4) 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h3><p>(1) 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。</p>\n<p>(2) 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦</p>\n<p>实现： 尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。实现方式基本同Composite模式。<br>重构成本：高。</p>\n<h1 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h1><p><a href=\"https://blog.csdn.net/chenxun_2010/article/details/48383571\">https://blog.csdn.net/chenxun_2010/article/details/48383571</a><br><a href=\"https://blog.csdn.net/llg070401046/article/details/73323934\">https://blog.csdn.net/llg070401046/article/details/73323934</a></p>\n","slug":"Interview-Q&A/Design-Patterns-Q&A","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/19/Interview-Q&A/Design-Patterns-Q&A/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"C++题目","date":"19/03/2022","path":"2022/03/19/Interview-Q&A/Cplusplus-Q&A/","text":"字节数目64位机器bool: sizeof(1)char: sizeof(1)int: sizeof(4)short: sizeof(2)short int: sizeof(2)long: sizeof(4)long int: sizeof(4)long long: sizeof(8)float: sizeof(4)double: sizeof(8) 1. 结构体的第一个成员永远放在结构体起始位置偏移量为0的地址处。 2. 第二个成员开始，总是放在偏移量为对齐数整数倍的地址处。 对齐数 == 编译器默认的对齐数 与 变量自身大小的较小值 (vs的默认值为8) 3. 结构体的总大小必须是各成员的对齐数中最大对齐数的整数倍。 将一个运算符重载为友元函数时，如果其参数表中只有一个参数，则说明该运算符是( )。 A、 后置一元运算符 B、 前置一元运算符 C、 其他选项都可能 D、 二元运算符 前置一元运算符 若用一个大小为8的数组来实现循环队列,且当前队尾Rear和队首Front的值分别为0和5,当从队列中删除一个元素,再加入三个元素后，Rear和Front的值分别为 出队时，front&#x3D;(front+1)%MAXSIZE,rear不变，所以front&#x3D;6入队时，rear&#x3D;(rear+1)%MAXSIZE,front不变，所以rear&#x3D;3; 3和6 KMP算法模式串”abababcbcabcadaba”的next数组为（ ） 关于解决NPC问题的方法有（ ） A、 启发式算法得到的解可以保证解的好坏 B、 乱数算法在某些特定的情况下能够给快速求解 C、 启发式算法在很很多时候能给产生理性的解 D、 近似算法可以快速发现一定差距内的解 ACD NPC问题及其解决方法（回溯法、动态规划、贪心法、深度优先遍历） NP问题(Non-deterministic Polynomial )：多项式复杂程度的非确定性问题，这些问题无法根据公式直接地计算出来。比如，找大质数的问题（有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的）；再比如，大的合数分解质因数的问题（有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式）。 NPC问题(Non-deterministic Polynomial complete)：NP完全问题，可以这么认为，这种问题只有把解域里面的所有可能都穷举了之后才能得出答案，这样的问题是NP里面最难，但是这样算法的复杂程度，是指数关系。一般说来，如果要证明一个问题是NPC问题的话，可以拿已经是NPC问题的一个问题经过多项式时间的变化变成所需要证明的问题，那么所要证明的问题就是一个NPC问题了。NPC问题是一个问题族，如果里面任意一个问题有了多项式的解，即找到一个算法，那么所有的问题都可以有多项式的解。 著名的NPC问题： 背包问题（Knapsack problem）：01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2……Wn，与之相对应的价值为V1,V2……Vn。求出获得最大价值的方案。 旅行商问题（Traveling Saleman Problem，TSP），该问题是在寻求单一旅行者由起点出发，通过所有给定的需求点之后，最后再回到原点的最小路径成本。 哈密顿路径问题（Hamiltonian path problem）与哈密顿环路问题（Hamiltonian cycle problem）为旅行推销员问题的特殊案例。哈密顿图：由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次。 欧拉回路（从图的某一个顶点出发，图中每条边走且仅走一次，最后回到出发点；如果这样的回路存在，则称之为欧拉回路。）与欧拉路径（从图的某一个顶点出发，图中每条边走且仅走一次，最后到达某一个点；如果这样的路径存在，则称之为欧拉路径。） 无向图欧拉回路存在条件：所有顶点的度数均为偶数。无向图欧拉路径存在条件：至多有两个顶点的度数为奇数，其他顶点的度数均为偶数。有向图欧拉回路存在条件：所有顶点的入度和出度相等。有向图欧拉路径存在条件：至多有两个顶点的入度和出度绝对值差1（若有两个这样的顶点，则必须其中一个出度大于入度，另一个入度大于出度）,其他顶点的入度与出度相等。 Peterson算法 Peterson算法是一个实现互斥锁的并发程序设计算法，可以控制两个进程访问一个共享的单用户资源而不发生访问冲突。Gary L. Peterson于1981年提出此算法[1] 参考文献：https://blog.51cto.com/danlove/2049403 360的抽奖 https://wtaufpziv.github.io/2020/03/24/360%E7%9A%84%E6%8A%BD%E5%A5%96/","raw":"---\ntitle: C++题目\ndate: 2022-03-19 14:46:04\ntags:\n- 面试\n---\n\n\n字节数目\n64位机器\nbool:\t\tsizeof(1)\nchar:\t\tsizeof(1)\nint:\t\tsizeof(4)\nshort:\t\tsizeof(2)\nshort int:\tsizeof(2)\nlong:\t\tsizeof(4)\nlong int:\tsizeof(4)\nlong long:\tsizeof(8)\nfloat:\t\tsizeof(4)\ndouble:\t\tsizeof(8)\n\n\t1. 结构体的第一个成员永远放在结构体起始位置偏移量为0的地址处。\n\t2. 第二个成员开始，总是放在偏移量为对齐数整数倍的地址处。\n\t对齐数 == 编译器默认的对齐数 与 变量自身大小的较小值 (vs的默认值为8)\n\t3. 结构体的总大小必须是各成员的对齐数中最大对齐数的整数倍。\n\n\t\n1. 将一个运算符重载为友元函数时，如果其参数表中只有一个参数，则说明该运算符是(    )。\n\nA、\t后置一元运算符\t\nB、\t前置一元运算符\t\nC、\t其他选项都可能\t\nD、\t二元运算符\n\n\t前置一元运算符\n\n\n\n3. 若用一个大小为8的数组来实现循环队列,且当前队尾Rear和队首Front的值分别为0和5,当从队列中删除一个元素,再加入三个元素后，Rear和Front的值分别为\n\n出队时，front=(front+1)%MAXSIZE,rear不变，所以front=6\n入队时，rear=(rear+1)%MAXSIZE,front不变，所以rear=3;\n\n3和6\n\n4. KMP算法模式串\"abababcbcabcadaba\"的next数组为（      ）\n\n\n5. 关于解决NPC问题的方法有（    ）\n\nA、\t启发式算法得到的解可以保证解的好坏\t\nB、\t乱数算法在某些特定的情况下能够给快速求解\t\nC、\t启发式算法在很很多时候能给产生理性的解\t\nD、\t近似算法可以快速发现一定差距内的解\n\nACD\n\nNPC问题及其解决方法（回溯法、动态规划、贪心法、深度优先遍历）\n\nNP问题(Non-deterministic Polynomial )：多项式复杂程度的非确定性问题，这些问题无法根据公式直接地计算出来。比如，找大质数的问题（有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的）；再比如，大的合数分解质因数的问题（有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式）。\n\nNPC问题(Non-deterministic Polynomial complete)：NP完全问题，可以这么认为，这种问题只有把解域里面的所有可能都穷举了之后才能得出答案，这样的问题是NP里面最难，但是这样算法的复杂程度，是指数关系。一般说来，如果要证明一个问题是NPC问题的话，可以拿已经是NPC问题的一个问题经过多项式时间的变化变成所需要证明的问题，那么所要证明的问题就是一个NPC问题了。NPC问题是一个问题族，如果里面任意一个问题有了多项式的解，即找到一个算法，那么所有的问题都可以有多项式的解。\n\n著名的NPC问题：\n\n背包问题（Knapsack problem）：01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2……Wn，与之相对应的价值为V1,V2……Vn。求出获得最大价值的方案。\n\n旅行商问题（Traveling Saleman Problem，TSP），该问题是在寻求单一旅行者由起点出发，通过所有给定的需求点之后，最后再回到原点的最小路径成本。\n\n哈密顿路径问题（Hamiltonian path problem）与哈密顿环路问题（Hamiltonian cycle problem）为旅行推销员问题的特殊案例。哈密顿图：由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次。\n\n欧拉回路（从图的某一个顶点出发，图中每条边走且仅走一次，最后回到出发点；如果这样的回路存在，则称之为欧拉回路。）与欧拉路径（从图的某一个顶点出发，图中每条边走且仅走一次，最后到达某一个点；如果这样的路径存在，则称之为欧拉路径。）\n\n无向图欧拉回路存在条件：所有顶点的度数均为偶数。\n无向图欧拉路径存在条件：至多有两个顶点的度数为奇数，其他顶点的度数均为偶数。\n有向图欧拉回路存在条件：所有顶点的入度和出度相等。\n有向图欧拉路径存在条件：至多有两个顶点的入度和出度绝对值差1（若有两个这样的顶点，则必须其中一个出度大于入度，另一个入度大于出度）,其他顶点的入度与出度相等。\n\n\n\n\n6. Peterson算法\n\nPeterson算法是一个实现互斥锁的并发程序设计算法，可以控制两个进程访问一个共享的单用户资源而不发生访问冲突。Gary L. Peterson于1981年提出此算法[1] \n\n\n\n\n\n\n\n\n\n# 参考文献：\n\nhttps://blog.51cto.com/danlove/2049403\n\n360的抽奖  https://wtaufpziv.github.io/2020/03/24/360%E7%9A%84%E6%8A%BD%E5%A5%96/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>字节数目<br>64位机器<br>bool:\t\tsizeof(1)<br>char:\t\tsizeof(1)<br>int:\t\tsizeof(4)<br>short:\t\tsizeof(2)<br>short int:\tsizeof(2)<br>long:\t\tsizeof(4)<br>long int:\tsizeof(4)<br>long long:\tsizeof(8)<br>float:\t\tsizeof(4)<br>double:\t\tsizeof(8)</p>\n<pre><code>1. 结构体的第一个成员永远放在结构体起始位置偏移量为0的地址处。\n2. 第二个成员开始，总是放在偏移量为对齐数整数倍的地址处。\n对齐数 == 编译器默认的对齐数 与 变量自身大小的较小值 (vs的默认值为8)\n3. 结构体的总大小必须是各成员的对齐数中最大对齐数的整数倍。\n</code></pre>\n<ol>\n<li>将一个运算符重载为友元函数时，如果其参数表中只有一个参数，则说明该运算符是(    )。</li>\n</ol>\n<p>A、\t后置一元运算符\t<br>B、\t前置一元运算符\t<br>C、\t其他选项都可能\t<br>D、\t二元运算符</p>\n<pre><code>前置一元运算符\n</code></pre>\n<ol start=\"3\">\n<li>若用一个大小为8的数组来实现循环队列,且当前队尾Rear和队首Front的值分别为0和5,当从队列中删除一个元素,再加入三个元素后，Rear和Front的值分别为</li>\n</ol>\n<p>出队时，front&#x3D;(front+1)%MAXSIZE,rear不变，所以front&#x3D;6<br>入队时，rear&#x3D;(rear+1)%MAXSIZE,front不变，所以rear&#x3D;3;</p>\n<p>3和6</p>\n<ol start=\"4\">\n<li><p>KMP算法模式串”abababcbcabcadaba”的next数组为（      ）</p>\n</li>\n<li><p>关于解决NPC问题的方法有（    ）</p>\n</li>\n</ol>\n<p>A、\t启发式算法得到的解可以保证解的好坏\t<br>B、\t乱数算法在某些特定的情况下能够给快速求解\t<br>C、\t启发式算法在很很多时候能给产生理性的解\t<br>D、\t近似算法可以快速发现一定差距内的解</p>\n<p>ACD</p>\n<p>NPC问题及其解决方法（回溯法、动态规划、贪心法、深度优先遍历）</p>\n<p>NP问题(Non-deterministic Polynomial )：多项式复杂程度的非确定性问题，这些问题无法根据公式直接地计算出来。比如，找大质数的问题（有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的）；再比如，大的合数分解质因数的问题（有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式）。</p>\n<p>NPC问题(Non-deterministic Polynomial complete)：NP完全问题，可以这么认为，这种问题只有把解域里面的所有可能都穷举了之后才能得出答案，这样的问题是NP里面最难，但是这样算法的复杂程度，是指数关系。一般说来，如果要证明一个问题是NPC问题的话，可以拿已经是NPC问题的一个问题经过多项式时间的变化变成所需要证明的问题，那么所要证明的问题就是一个NPC问题了。NPC问题是一个问题族，如果里面任意一个问题有了多项式的解，即找到一个算法，那么所有的问题都可以有多项式的解。</p>\n<p>著名的NPC问题：</p>\n<p>背包问题（Knapsack problem）：01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2……Wn，与之相对应的价值为V1,V2……Vn。求出获得最大价值的方案。</p>\n<p>旅行商问题（Traveling Saleman Problem，TSP），该问题是在寻求单一旅行者由起点出发，通过所有给定的需求点之后，最后再回到原点的最小路径成本。</p>\n<p>哈密顿路径问题（Hamiltonian path problem）与哈密顿环路问题（Hamiltonian cycle problem）为旅行推销员问题的特殊案例。哈密顿图：由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次。</p>\n<p>欧拉回路（从图的某一个顶点出发，图中每条边走且仅走一次，最后回到出发点；如果这样的回路存在，则称之为欧拉回路。）与欧拉路径（从图的某一个顶点出发，图中每条边走且仅走一次，最后到达某一个点；如果这样的路径存在，则称之为欧拉路径。）</p>\n<p>无向图欧拉回路存在条件：所有顶点的度数均为偶数。<br>无向图欧拉路径存在条件：至多有两个顶点的度数为奇数，其他顶点的度数均为偶数。<br>有向图欧拉回路存在条件：所有顶点的入度和出度相等。<br>有向图欧拉路径存在条件：至多有两个顶点的入度和出度绝对值差1（若有两个这样的顶点，则必须其中一个出度大于入度，另一个入度大于出度）,其他顶点的入度与出度相等。</p>\n<ol start=\"6\">\n<li>Peterson算法</li>\n</ol>\n<p>Peterson算法是一个实现互斥锁的并发程序设计算法，可以控制两个进程访问一个共享的单用户资源而不发生访问冲突。Gary L. Peterson于1981年提出此算法[1] </p>\n<h1 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h1><p><a href=\"https://blog.51cto.com/danlove/2049403\">https://blog.51cto.com/danlove/2049403</a></p>\n<p>360的抽奖  <a href=\"https://wtaufpziv.github.io/2020/03/24/360%E7%9A%84%E6%8A%BD%E5%A5%96/\">https://wtaufpziv.github.io/2020/03/24/360%E7%9A%84%E6%8A%BD%E5%A5%96/</a></p>\n","slug":"Interview-Q&A/Cplusplus-Q&A","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/19/Interview-Q&A/Cplusplus-Q&A/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"git 教程","date":"16/03/2022","path":"2022/03/16/Tutorial/Git-tutorial/","text":"linux环境下下载 git clone [ssh地址]直接克隆代码 git clone -b [分支名字] [ssh地址]需要克隆这个代码的一个分支 linux环境下提交 git initgit初始化输出： 1Initialized empty Git repository in /home/yzx/network/.git/ git add .提交所有的内容输出：无 git status查看当前提交的状态 1234567891011On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: ch04/4-2-1-getpid.c new file: ch04/4-2-2-fork.c new file: ch04/4-2-3-system.c new file: ch04/4-2-4-ececve.c new file: ch04/4-4-1-pthread.c new file: ch04/a.out git commit -m &quot;ch04&quot;提交到远程仓库git commit 规范指南Commit message 的格式 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; type用于说明 commit 的类别，只允许使用下面7个标识。feat：新功能（feature）fix&#x2F;to：修补bug fix：产生 diff 并自动修复此问题。适合于一次提交直接修复问题 to：只产生 diff不 自动修复此问题。适合于多次提交。最终修复问题提交时使用 fixdocs：仅仅修改了文档（documentation）style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑refactor：代码重构，没有加新功能或者修复 bug（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：改变构建流程、或者增加依赖库、工具等revert：回滚到上一个版本merge：代码合并sync：同步主线或分支的Bug scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subjectsubject是 commit 目的的简短描述，不超过50个字符。 BodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 git remote add origin git@github.com:gtoo8888/linux-network.git正常输出：无 报错： fatal: remote origin already exists. 解决： git remote -v 查看远程的仓库有什么 输出： origin &#x67;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;:gtoo8888&#x2F;linux-network.git (fetch) origin &#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#109;:gtoo8888&#x2F;linux-network.git (push) git remote rm origin 移除远程的仓库 输出：无 git remote add origin &#x67;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#109;:gtoo8888&#x2F;linux-network.git 再次使用指令 git push origin master步骤5操作过一次以后，下一次就不需要了 输出： 123456789101112Enumerating objects: 9, done.Counting objects: 100% (9/9), done.Delta compression using up to 2 threadsCompressing objects: 100% (8/8), done.Writing objects: 100% (9/9), 3.65 KiB | 1.21 MiB/s, done.Total 9 (delta 0), reused 0 (delta 0)remote:remote: Create a pull request for &#x27;master&#x27; on GitHub by visiting:remote: https://github.com/gtoo8888/linux-network/pull/new/masterremote:To github.com:gtoo8888/linux-network.git * [new branch] master -&gt; master 报错：error: src refspec main does not match anyerror: failed to push some refs to ‘&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#46;&#99;&#x6f;&#109;:gtoo8888&#x2F;linux-network.git’报错原因：本地文件与github上的文件有冲突本地需要提交的文件中存在空文件本地的origin和remote origin&#x2F;master 没有建立关联解决方法：git push origin main发现仓库中主要分支叫做master修改后就好了 生成ssh秘钥git config –global user.name “XXX”git config –global user.email “XXX” 1.生成公钥：git命令：ssh-keygen -m [密钥格式] -t [密钥类型] -C[密钥注解] 1234ssh-keygen -m PEM -t ed25519 -C &quot;ujm456@126.com&quot;ssh-keygen -m PEM -t ed25519 -C &quot;your.email@example.com&quot; // 创建新的 SSH 私钥与公钥秘钥对，输入你的邮箱作为标签Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 推荐使用默认地址Enter passphrase (empty for no passphrase): // 此处直接回车即可；若设置密码，则每次使用 SSH 方式推送代码时都会要求输入密码 成功之后显示： 1234Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your.email@example.com 2.添加公钥windows地址为（C:\\Users\\you.ssh）linux地址为（&#x2F;home&#x2F;user&#x2F;.ssh&#x2F;id_ed25519）linux地址为（&#x2F;root&#x2F;.ssh&#x2F;id_ed25519）打开上文中生成的秘钥对的地址（默认地址通常为 ~&#x2F;.ssh&#x2F;）找到后缀为 pub 的公钥文件，使用 cat 命令输出所有内容并复制。 3.尝试使用ssh连接githubssh -T &#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;ssh -T &#x67;&#x69;&#116;&#x40;&#101;&#46;&#99;&#x6f;&#100;&#105;&#110;&#103;&#46;&#110;&#x65;&#116; 一些git的命令git LFS技术可以用来存放大文件 git lfs pull –allgit lfs pull checkoutgit checkout – bin&#x2F;test_tool.sh 放弃工作区中全部的修改git checkout . 放弃工作区中某个文件的修改：git checkout – filename git submodule当我们的项目很大很复杂的时候，需要将各个模块文件进行抽离，以此来降低项目文件之间的耦合程度。（当然你项目不大不复杂也可以使用，看个人喜好啦！！！）这个时候就可以使用git submodule来对项目文件进行抽离，最终使抽离出来的文件可以单独成为一个git仓库。这样做的好处是整个主项目对抽离出来的子项目（子模块）有依赖关系，却又并不关心子项目（子模块）的内部开发流程细节。 1234git submodule init# 初始化子项目git submodule update# 对子项目获取远程项目中最新的状态 git rmgit rm –cached git rm –cached test直接写要删除的文件或者文件夹名字就可以删除之后把自己需要的文件加上git add .git commit -m “”git push git rm -r –cached ..gitignore不生效 git configgit config –list列出git的所有配置 git配置中的CRLF、LF、CRCRLF: Carriage-Return Line-Feed的缩写，意思是回车换行，即\\r\\n;LF: Line-Feed的缩写,意思是换行，即\\n;CR: Carriage-Return的缩写，回车，即\\r;进阶当我们敲击回车键(Enter)时，操作系统会插入不可见的字符表示换行，不同的操作系统插入不同Windows: 插入\\r\\n,回车换行；Linux\\Unix: 插入\\n,换行；MacOS: 插入\\r，回车； git config –global core.autocrlf input AutoCRLF提交时转换为LF，检出时转换为CRLFgit config –global core.autocrlf true提交时转换为LF，检出时不转换git config –global core.autocrlf input提交检出均不转换如果下windows下下载的文件，需要映射到linux中去，不用总是手动改变编码 git branch查看当前所在分支 git branch -r查看远程有哪些分支 git branch -v显示当前分支的详细信息 git branch -d feat-0728删除本地创建的分支 git resetgit reset HEAD 恢复已经add的提交git reset HEAD test.cpp指定文件恢复 git reset HEAD^ 回退所有内容到上一个版本git reset HEAD^ hello.php 回退 hello.php 文件的版本到上一个版本 git 高级技术git log1234567891011git log --pretty=format:&#x27;%h: %s&#x27;d27f636: test:15e54dd6f: test:rebase 12db794d8: test:11ee8c5a3: test:rebase5a30601: test:308089a1: test:24a82470: test:146480b8: feat:增加了链接7035791: feat:init2544c56: Initial commit 只显示一行，详细的git log –pretty&#x3D;oneline只显示一行git log –oneline显示图形界面git log –graph git rebase步骤一：git rebase -i [startPonit] [endPoint]一般不使用endPointgit rebase -i ee8c5a3(ee8c5a3,d27f636](test:rebase,test:15]步骤二：接下来进入图形界面p 选择s 放弃步骤二：图形界面2注释掉不想要提交的:wq退出 如果需要rebase已经push的commit需要在提交的时候直接git push -f强制交上去，就会刷新掉之前的提交 修改最后一次提交的注释git commit –amend git stsh 暂存暂存命令git stash save “暂存的备注”直接执行git stash也可以达到暂存的目的，但是连续多次暂存后容易让人混淆哪次暂存了哪些代码 查看暂存记录git stash list取回暂存代码git stash pop取消【取消暂存代码】 git reset –hard git gc在当前存储库中运行许多内务处理任务，例如压缩文件修订（以减少磁盘空间并提高性能）并移除可能由之前git add调用创建的不可达对象。 鼓励用户在每个存储库中定期运行此任务，以保持良好的磁盘空间利用率和良好的操作性能。 git-gc - 清理不必要的文件并优化本地存储库 Git是如何存储对象的 Git 中存在两种对象 - 松散对象(loose object) 和 打包对象(packed object) . git gc 为了定时的对文件进行打包松散对象存储的文件，一个很大的文件1G的文件，改动一行，那依然会有一个1G的副本保存下来所以需要将松散对象打包为打包对象用来节约存储空间 关闭自动打包的原理是：如果有大文件包含在文件夹中，并且需要经常改动，那么就需要打开gc机制但是正常情况下，提交的都是几KB的小文件，源代码之类的，空间占用的很好，关闭git gc机制，还可以更好的溯源文件变化情况 问题：git gc以后，会消失一些什么信息？ git reflog如果使用git reset –herd HEAD^回退了版本，会出现amend的未来提交可以使用reflog查看到，并且回退到未来的版本 参考文献[GIT在线练习平台]https://learngitbranching.js.org/?locale=zh_CNhttps://blog.csdn.net/ajianyingxiaoqinghan/article/details/70544159https://blog.csdn.net/u014361280/article/details/109703556[git submodule]https://blog.csdn.net/weixin_44901565/article/details/123086226[git配置中的CRLF、LF、CR]https://blog.csdn.net/u013037336/article/details/121541008[git commit -m约定式提交]https://www.conventionalcommits.org/zh-hans/v1.0.0/[白色箭头]https://blog.csdn.net/bowenlaw/article/details/124594664[git commit 规范指南]https://blog.csdn.net/qq_41662115/article/details/99759645[.gitignore基础规则]https://www.cnblogs.com/kevingrace/p/5690241.html[git rebase]https://blog.csdn.net/small_white_123/article/details/121563248[git reset HEAD 用法]https://blog.csdn.net/wangkai6666/article/details/120810363[英文git教程网站]https://www.atlassian.com/git[git commit –amend]https://blog.csdn.net/xiaoyulike/article/details/119176756[git - 执行 git clone 时 “Filtering content”是什么意思？]https://www.coder.work/article/1531074[为什么要管理git gc自动垃圾回收(英文)]https://donatstudios.com/yagni-git-gc[为什么要git gc]https://www.cnblogs.com/ayseeing/p/4226471.html[Git是如何存储对象的]https://blog.csdn.net/hudashi/article/details/7669477[10.4 Git 内部原理 - 包文件]https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%8C%85%E6%96%87%E4%BB%B6[Git是如何存储对象的- 7. 原理解析- [ Git Community Book 中文版 …]https://www.shouce.ren/api/view/a/9924[git 版本回退]https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192[【学了就忘】Git操作 — 51.git reflog命令]https://www.jianshu.com/p/7e4cef3863e7[Good First Issue]https://goodfirstissue.dev/language/cplusplus/","raw":"---\ntitle: git 教程\ndate: 2022-03-16 21:56:51\ntags:\n- 教程\n---\n\n# linux环境下下载\n1. ```git clone [ssh地址]```\n直接克隆代码\n\n2. ```git clone -b [分支名字] [ssh地址]```\n需要克隆这个代码的一个分支\n\n\n# linux环境下提交\n1. ```git init```\ngit初始化\n输出：\n```\nInitialized empty Git repository in /home/yzx/network/.git/\n```\n2. ```git add .```\n提交所有的内容\n输出：\n无\n3. ```git status```\n查看当前提交的状态\n```\nOn branch master\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n        new file:   ch04/4-2-1-getpid.c\n        new file:   ch04/4-2-2-fork.c\n        new file:   ch04/4-2-3-system.c\n        new file:   ch04/4-2-4-ececve.c\n        new file:   ch04/4-4-1-pthread.c\n        new file:   ch04/a.out\n```\n\n4. ```git commit -m \"ch04\"```\n提交到远程仓库\ngit commit 规范指南\nCommit message 的格式\n```\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n```\n### type\n用于说明 commit 的类别，只允许使用下面7个标识。\nfeat：新功能（feature）\nfix/to：修补bug\n  - fix：产生 diff 并自动修复此问题。适合于一次提交直接修复问题\n  - to：只产生 diff不 自动修复此问题。适合于多次提交。最终修复问题提交时使用 fix\ndocs：仅仅修改了文档（documentation）\nstyle： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑\nrefactor：代码重构，没有加新功能或者修复 bug（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：改变构建流程、或者增加依赖库、工具等\nrevert：回滚到上一个版本\nmerge：代码合并\nsync：同步主线或分支的Bug\n\n\n### scope\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n### subject\nsubject是 commit 目的的简短描述，不超过50个字符。\n### Body\nBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。\n\n\n5. ```git remote add origin git@github.com:gtoo8888/linux-network.git```\n正常输出：\n无</br>\n\n- 报错：\n- fatal: remote origin already exists.\n- - 解决：\n- 1. git remote -v 查看远程的仓库有什么\n- - 输出：\n- - origin  git@github.com:gtoo8888/linux-network.git (fetch)\n- - origin  git@github.com:gtoo8888/linux-network.git (push)\n- 2. git remote rm origin 移除远程的仓库\n- - 输出：无\n- 3. git remote add origin git@github.com:gtoo8888/linux-network.git 再次使用指令\n\n6. ```git push origin master```\n步骤5操作过一次以后，下一次就不需要了\n\n输出：\n```\nEnumerating objects: 9, done.\nCounting objects: 100% (9/9), done.\nDelta compression using up to 2 threads\nCompressing objects: 100% (8/8), done.\nWriting objects: 100% (9/9), 3.65 KiB | 1.21 MiB/s, done.\nTotal 9 (delta 0), reused 0 (delta 0)\nremote:\nremote: Create a pull request for 'master' on GitHub by visiting:\nremote:      https://github.com/gtoo8888/linux-network/pull/new/master\nremote:\nTo github.com:gtoo8888/linux-network.git\n * [new branch]      master -> master\n```\n报错：\nerror: src refspec main does not match any\nerror: failed to push some refs to 'git@github.com:gtoo8888/linux-network.git'\n报错原因：\n本地文件与github上的文件有冲突\n本地需要提交的文件中存在空文件\n本地的origin和remote origin/master 没有建立关联\n解决方法：\ngit push origin main\n发现仓库中主要分支叫做master修改后就好了\n\n# 生成ssh秘钥\ngit config --global user.name \"XXX\"\ngit config --global user.email \"XXX\"\n## 1.生成公钥：\ngit命令：ssh-keygen  -m [密钥格式]  -t [密钥类型]  -C[密钥注解] \n```\nssh-keygen -m PEM -t ed25519 -C \"ujm456@126.com\"\nssh-keygen -m PEM -t ed25519 -C \"your.email@example.com\" // 创建新的 SSH 私钥与公钥秘钥对，输入你的邮箱作为标签\nEnter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 推荐使用默认地址\nEnter passphrase (empty for no passphrase): // 此处直接回车即可；若设置密码，则每次使用 SSH 方式推送代码时都会要求输入密码\n```\n成功之后显示：\n```\nYour identification has been saved in /Users/you/.ssh/id_rsa.\n# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.\n# The key fingerprint is:\n# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your.email@example.com\n```\n## 2.添加公钥\nwindows地址为（C:\\Users\\you\\.ssh）\nlinux地址为（/home/user/.ssh/id_ed25519）\nlinux地址为（/root/.ssh/id_ed25519）\n打开上文中生成的秘钥对的地址（默认地址通常为 ~/.ssh/）找到后缀为 pub 的公钥文件，使用 cat 命令输出所有内容并复制。\n\n## 3.尝试使用ssh连接github\nssh -T git@github.com\nssh -T git@e.coding.net\n\n# 一些git的命令\n\n## git LFS技术\n可以用来存放大文件\n\ngit lfs pull --all\ngit lfs pull\n\n\n## checkout\ngit checkout -- bin/test_tool.sh\n\n放弃工作区中全部的修改\ngit checkout .\n\n放弃工作区中某个文件的修改：\ngit checkout -- filename\n\n\n## git submodule\n当我们的项目很大很复杂的时候，需要将各个模块文件进行抽离，以此来降低项目文件之间的耦合程度。（当然你项目不大不复杂也可以使用，看个人喜好啦！！！）这个时候就可以使用git submodule来对项目文件进行抽离，最终使抽离出来的文件可以单独成为一个git仓库。这样做的好处是整个主项目对抽离出来的子项目（子模块）有依赖关系，却又并不关心子项目（子模块）的内部开发流程细节。\n\n```\ngit submodule init\n# 初始化子项目\ngit submodule update\n# 对子项目获取远程项目中最新的状态\n```\n# git rm \ngit rm --cached <File Name>\ngit rm --cached test\n<File Name>直接写要删除的文件或者文件夹名字就可以\n删除之后把自己需要的文件加上\ngit add .\ngit commit -m \"\"\ngit push \n\n\ngit rm -r --cached .\n.gitignore不生效\n\n\n# git config\ngit config --list\n列出git的所有配置\n\ngit配置中的CRLF、LF、CR\nCRLF: Carriage-Return Line-Feed的缩写，意思是回车换行，即\\r\\n;\nLF: Line-Feed的缩写,意思是换行，即\\n;\nCR: Carriage-Return的缩写，回车，即\\r;\n进阶\n当我们敲击回车键(Enter)时，操作系统会插入不可见的字符表示换行，不同的操作系统插入不同\nWindows: 插入\\r\\n,回车换行；\nLinux\\Unix: 插入\\n,换行；\nMacOS: 插入\\r，回车；\n\n\ngit config --global core.autocrlf input\n\nAutoCRLF\n提交时转换为LF，检出时转换为CRLF\ngit config --global core.autocrlf true\n提交时转换为LF，检出时不转换\ngit config --global core.autocrlf input\n提交检出均不转换\n如果下windows下下载的文件，需要映射到linux中去，不用总是手动改变编码\n\n\n# git branch\n查看当前所在分支 \n\n```git branch -r```\n查看远程有哪些分支\n\n```git branch -v```\n显示当前分支的详细信息\n\n```git branch -d feat-0728```\n删除本地创建的分支\n\n# git reset\n```git reset HEAD ```\n恢复已经add的提交\n```git reset HEAD test.cpp```\n指定文件恢复\n\n\n```git reset HEAD^ ```           \n回退所有内容到上一个版本  \n```git reset HEAD^ hello.php  ```    \n回退 hello.php 文件的版本到上一个版本  \n\n\n\n# git 高级技术\n\n## git log\n\n```\ngit log --pretty=format:'%h: %s'\nd27f636: test:15\ne54dd6f: test:rebase 12\ndb794d8: test:11\nee8c5a3: test:rebase\n5a30601: test:3\n08089a1: test:2\n4a82470: test:1\n46480b8: feat:增加了链接\n7035791: feat:init\n2544c56: Initial commit\n```\n\n只显示一行，详细的\ngit log --pretty=oneline\n只显示一行\ngit log --oneline\n显示图形界面\ngit log --graph\n## git rebase\n\n步骤一：\ngit rebase -i [startPonit] [endPoint]\n一般不使用endPoint\ngit rebase -i ee8c5a3\n(ee8c5a3,d27f636]\n(test:rebase,test:15]\n步骤二：\n接下来进入图形界面\np 选择\ns 放弃\n步骤二：\n图形界面2\n注释掉不想要提交的\n:wq退出\n\n\n如果需要rebase已经push的commit\n需要在提交的时候直接git push -f强制交上去，就会刷新掉之前的提交\n\n# 修改最后一次提交的注释\n\ngit commit --amend \n\n# git stsh 暂存\n暂存命令\ngit stash save \"暂存的备注\"\n直接执行git stash也可以达到暂存的目的，但是连续多次暂存后容易让人混淆哪次暂存了哪些代码\n\n查看暂存记录\ngit stash list\n取回暂存代码\ngit stash pop\n取消【取消暂存代码】\n\ngit reset --hard\n\n# git gc\n\n在当前存储库中运行许多内务处理任务，例如压缩文件修订（以减少磁盘空间并提高性能）\n并移除可能由之前git add调用创建的不可达对象。\n\n鼓励用户在每个存储库中定期运行此任务，以保持良好的磁盘空间利用率和良好的操作性能。\n\ngit-gc  - 清理不必要的文件并优化本地存储库\n\nGit是如何存储对象的\n\nGit 中存在两种对象 -  松散对象(loose object) 和 打包对象(packed object) .\n\ngit gc 为了定时的对文件进行打包\n松散对象存储的文件，一个很大的文件1G的文件，改动一行，那依然会有一个1G的副本保存下来\n所以需要将松散对象打包为打包对象用来节约存储空间\n\n关闭自动打包的原理是：\n如果有大文件包含在文件夹中，并且需要经常改动，那么就需要打开gc机制\n但是正常情况下，提交的都是几KB的小文件，源代码之类的，空间占用的很好，关闭git gc机制，还可以更好的溯源文件变化情况\n\n问题：\ngit gc以后，会消失一些什么信息？\n\n# git reflog\n\n如果使用git reset --herd HEAD^回退了版本，会出现amend的未来提交\n可以使用reflog查看到，并且回退到未来的版本\n\n# 参考文献\n[GIT在线练习平台]https://learngitbranching.js.org/?locale=zh_CN\nhttps://blog.csdn.net/ajianyingxiaoqinghan/article/details/70544159\nhttps://blog.csdn.net/u014361280/article/details/109703556\n[git submodule]https://blog.csdn.net/weixin_44901565/article/details/123086226\n[git配置中的CRLF、LF、CR]https://blog.csdn.net/u013037336/article/details/121541008\n[git commit -m约定式提交]https://www.conventionalcommits.org/zh-hans/v1.0.0/\n[白色箭头]https://blog.csdn.net/bowenlaw/article/details/124594664\n[git commit 规范指南]https://blog.csdn.net/qq_41662115/article/details/99759645\n[.gitignore基础规则]https://www.cnblogs.com/kevingrace/p/5690241.html\n[git rebase]https://blog.csdn.net/small_white_123/article/details/121563248\n[git reset HEAD 用法]https://blog.csdn.net/wangkai6666/article/details/120810363\n[英文git教程网站]https://www.atlassian.com/git\n[git commit --amend]https://blog.csdn.net/xiaoyulike/article/details/119176756\n[git - 执行 git clone 时 \"Filtering content\"是什么意思？]https://www.coder.work/article/1531074\n[为什么要管理git gc自动垃圾回收(英文)]https://donatstudios.com/yagni-git-gc\n[为什么要git gc]https://www.cnblogs.com/ayseeing/p/4226471.html\n[Git是如何存储对象的]https://blog.csdn.net/hudashi/article/details/7669477\n[10.4 Git 内部原理 - 包文件]https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%8C%85%E6%96%87%E4%BB%B6\n[Git是如何存储对象的- 7. 原理解析- [ Git Community Book 中文版 ...]https://www.shouce.ren/api/view/a/9924\n[git 版本回退]https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192\n[【学了就忘】Git操作 — 51.git reflog命令]https://www.jianshu.com/p/7e4cef3863e7\n[Good First Issue]https://goodfirstissue.dev/language/cplusplus/","content":"<h1 id=\"linux环境下下载\"><a href=\"#linux环境下下载\" class=\"headerlink\" title=\"linux环境下下载\"></a>linux环境下下载</h1><ol>\n<li><p><code>git clone [ssh地址]</code><br>直接克隆代码</p>\n</li>\n<li><p><code>git clone -b [分支名字] [ssh地址]</code><br>需要克隆这个代码的一个分支</p>\n</li>\n</ol>\n<h1 id=\"linux环境下提交\"><a href=\"#linux环境下提交\" class=\"headerlink\" title=\"linux环境下提交\"></a>linux环境下提交</h1><ol>\n<li><p><code>git init</code><br>git初始化<br>输出：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Initialized empty Git repository <span class=\"keyword\">in</span> <span class=\"regexp\">/home/y</span>zx<span class=\"regexp\">/network/</span>.git/</span><br></pre></td></tr></table></figure></li>\n<li><p><code>git add .</code><br>提交所有的内容<br>输出：<br>无</p>\n</li>\n<li><p><code>git status</code><br>查看当前提交的状态</p>\n<figure class=\"highlight vhdl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">On</span> branch master</span><br><span class=\"line\">No commits yet</span><br><span class=\"line\"></span><br><span class=\"line\">Changes <span class=\"keyword\">to</span> be committed:</span><br><span class=\"line\">  (<span class=\"keyword\">use</span> <span class=\"string\">&quot;git rm --cached &lt;file&gt;...&quot;</span> <span class=\"keyword\">to</span> unstage)</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">2</span>-<span class=\"number\">1</span>-getpid.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">2</span>-<span class=\"number\">2</span>-fork.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">2</span>-<span class=\"number\">3</span>-system.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">2</span>-<span class=\"number\">4</span>-ececve.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">4</span>-<span class=\"number\">1</span>-pthread.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/a.<span class=\"keyword\">out</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>git commit -m &quot;ch04&quot;</code><br>提交到远程仓库<br>git commit 规范指南<br>Commit message 的格式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>(<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>): <span class=\"tag\">&lt;<span class=\"name\">subject</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">BLANK</span> <span class=\"attr\">LINE</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">BLANK</span> <span class=\"attr\">LINE</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h3><p>用于说明 commit 的类别，只允许使用下面7个标识。<br>feat：新功能（feature）<br>fix&#x2F;to：修补bug</p>\n<ul>\n<li>fix：产生 diff 并自动修复此问题。适合于一次提交直接修复问题</li>\n<li>to：只产生 diff不 自动修复此问题。适合于多次提交。最终修复问题提交时使用 fix<br>docs：仅仅修改了文档（documentation）<br>style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑<br>refactor：代码重构，没有加新功能或者修复 bug（即不是新增功能，也不是修改bug的代码变动）<br>test：增加测试<br>chore：改变构建流程、或者增加依赖库、工具等<br>revert：回滚到上一个版本<br>merge：代码合并<br>sync：同步主线或分支的Bug</li>\n</ul>\n<h3 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"scope\"></a>scope</h3><p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>\n<h3 id=\"subject\"><a href=\"#subject\" class=\"headerlink\" title=\"subject\"></a>subject</h3><p>subject是 commit 目的的简短描述，不超过50个字符。</p>\n<h3 id=\"Body\"><a href=\"#Body\" class=\"headerlink\" title=\"Body\"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p>\n<ol start=\"5\">\n<li><code>git remote add origin git@github.com:gtoo8888/linux-network.git</code><br>正常输出：<br>无</br></li>\n</ol>\n<ul>\n<li>报错：</li>\n<li>fatal: remote origin already exists.</li>\n<li><ul>\n<li>解决：</li>\n</ul>\n</li>\n<li><ol>\n<li>git remote -v 查看远程的仓库有什么</li>\n</ol>\n</li>\n<li><ul>\n<li>输出：</li>\n</ul>\n</li>\n<li><ul>\n<li>origin  <a href=\"mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;\">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;</a>:gtoo8888&#x2F;linux-network.git (fetch)</li>\n</ul>\n</li>\n<li><ul>\n<li>origin  <a href=\"mailto:&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#109;\">&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#109;</a>:gtoo8888&#x2F;linux-network.git (push)</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>git remote rm origin 移除远程的仓库</li>\n</ol>\n</li>\n<li><ul>\n<li>输出：无</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>git remote add origin <a href=\"mailto:&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#109;\">&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a>:gtoo8888&#x2F;linux-network.git 再次使用指令</li>\n</ol>\n</li>\n</ul>\n<ol start=\"6\">\n<li><code>git push origin master</code><br>步骤5操作过一次以后，下一次就不需要了</li>\n</ol>\n<p>输出：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enumerating objects: <span class=\"number\">9</span>, done.</span><br><span class=\"line\">Counting objects: <span class=\"number\">100</span>% (<span class=\"number\">9</span>/<span class=\"number\">9</span>), done.</span><br><span class=\"line\">Delta compression using up to <span class=\"number\">2</span> threads</span><br><span class=\"line\">Compressing objects: <span class=\"number\">100</span>% (<span class=\"number\">8</span>/<span class=\"number\">8</span>), done.</span><br><span class=\"line\">Writing objects: <span class=\"number\">100</span>% (<span class=\"number\">9</span><span class=\"regexp\">/9), 3.65 KiB | 1.21 MiB/</span>s, done.</span><br><span class=\"line\">Total <span class=\"number\">9</span> (delta <span class=\"number\">0</span>), reused <span class=\"number\">0</span> (delta <span class=\"number\">0</span>)</span><br><span class=\"line\">remote:</span><br><span class=\"line\">remote: Create a pull request <span class=\"keyword\">for</span> <span class=\"string\">&#x27;master&#x27;</span> on GitHub by visiting:</span><br><span class=\"line\">remote:      https:<span class=\"regexp\">//gi</span>thub.com<span class=\"regexp\">/gtoo8888/</span>linux-network<span class=\"regexp\">/pull/</span>new/master</span><br><span class=\"line\">remote:</span><br><span class=\"line\">To github.com:gtoo8888/linux-network.git</span><br><span class=\"line\"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure>\n<p>报错：<br>error: src refspec main does not match any<br>error: failed to push some refs to ‘<a href=\"mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#46;&#99;&#x6f;&#109;\">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#46;&#99;&#x6f;&#109;</a>:gtoo8888&#x2F;linux-network.git’<br>报错原因：<br>本地文件与github上的文件有冲突<br>本地需要提交的文件中存在空文件<br>本地的origin和remote origin&#x2F;master 没有建立关联<br>解决方法：<br>git push origin main<br>发现仓库中主要分支叫做master修改后就好了</p>\n<h1 id=\"生成ssh秘钥\"><a href=\"#生成ssh秘钥\" class=\"headerlink\" title=\"生成ssh秘钥\"></a>生成ssh秘钥</h1><p>git config –global user.name “XXX”<br>git config –global user.email “XXX”</p>\n<h2 id=\"1-生成公钥：\"><a href=\"#1-生成公钥：\" class=\"headerlink\" title=\"1.生成公钥：\"></a>1.生成公钥：</h2><p>git命令：ssh-keygen  -m [密钥格式]  -t [密钥类型]  -C[密钥注解] </p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -m PEM -t ed25519 -C <span class=\"string\">&quot;ujm456@126.com&quot;</span></span><br><span class=\"line\">ssh-keygen -m PEM -t ed25519 -C <span class=\"string\">&quot;your.email@example.com&quot;</span> <span class=\"regexp\">//</span> 创建新的 SSH 私钥与公钥秘钥对，输入你的邮箱作为标签</span><br><span class=\"line\">Enter file <span class=\"keyword\">in</span> which to save the key (<span class=\"regexp\">/Users/y</span>ou<span class=\"regexp\">/.ssh/i</span>d_rsa): [Press enter] <span class=\"regexp\">//</span> 推荐使用默认地址</span><br><span class=\"line\">Enter passphrase (empty <span class=\"keyword\">for</span> no passphrase): <span class=\"regexp\">//</span> 此处直接回车即可；若设置密码，则每次使用 SSH 方式推送代码时都会要求输入密码</span><br></pre></td></tr></table></figure>\n<p>成功之后显示：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your identification has been saved <span class=\"keyword\">in</span> <span class=\"regexp\">/Users/y</span>ou<span class=\"regexp\">/.ssh/i</span>d_rsa.</span><br><span class=\"line\"><span class=\"comment\"># Your public key has been saved in /Users/you/.ssh/id_rsa.pub.</span></span><br><span class=\"line\"><span class=\"comment\"># The key fingerprint is:</span></span><br><span class=\"line\"><span class=\"comment\"># 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your.email@example.com</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-添加公钥\"><a href=\"#2-添加公钥\" class=\"headerlink\" title=\"2.添加公钥\"></a>2.添加公钥</h2><p>windows地址为（C:\\Users\\you.ssh）<br>linux地址为（&#x2F;home&#x2F;user&#x2F;.ssh&#x2F;id_ed25519）<br>linux地址为（&#x2F;root&#x2F;.ssh&#x2F;id_ed25519）<br>打开上文中生成的秘钥对的地址（默认地址通常为 ~&#x2F;.ssh&#x2F;）找到后缀为 pub 的公钥文件，使用 cat 命令输出所有内容并复制。</p>\n<h2 id=\"3-尝试使用ssh连接github\"><a href=\"#3-尝试使用ssh连接github\" class=\"headerlink\" title=\"3.尝试使用ssh连接github\"></a>3.尝试使用ssh连接github</h2><p>ssh -T <a href=\"mailto:&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;\">&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;</a><br>ssh -T <a href=\"mailto:&#x67;&#x69;&#116;&#x40;&#101;&#46;&#99;&#x6f;&#100;&#105;&#110;&#103;&#46;&#110;&#x65;&#116;\">&#x67;&#x69;&#116;&#x40;&#101;&#46;&#99;&#x6f;&#100;&#105;&#110;&#103;&#46;&#110;&#x65;&#116;</a></p>\n<h1 id=\"一些git的命令\"><a href=\"#一些git的命令\" class=\"headerlink\" title=\"一些git的命令\"></a>一些git的命令</h1><h2 id=\"git-LFS技术\"><a href=\"#git-LFS技术\" class=\"headerlink\" title=\"git LFS技术\"></a>git LFS技术</h2><p>可以用来存放大文件</p>\n<p>git lfs pull –all<br>git lfs pull</p>\n<h2 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h2><p>git checkout – bin&#x2F;test_tool.sh</p>\n<p>放弃工作区中全部的修改<br>git checkout .</p>\n<p>放弃工作区中某个文件的修改：<br>git checkout – filename</p>\n<h2 id=\"git-submodule\"><a href=\"#git-submodule\" class=\"headerlink\" title=\"git submodule\"></a>git submodule</h2><p>当我们的项目很大很复杂的时候，需要将各个模块文件进行抽离，以此来降低项目文件之间的耦合程度。（当然你项目不大不复杂也可以使用，看个人喜好啦！！！）这个时候就可以使用git submodule来对项目文件进行抽离，最终使抽离出来的文件可以单独成为一个git仓库。这样做的好处是整个主项目对抽离出来的子项目（子模块）有依赖关系，却又并不关心子项目（子模块）的内部开发流程细节。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">submodule </span>init</span><br><span class=\"line\"><span class=\"comment\"># 初始化子项目</span></span><br><span class=\"line\">git <span class=\"keyword\">submodule </span>update</span><br><span class=\"line\"><span class=\"comment\"># 对子项目获取远程项目中最新的状态</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h1><p>git rm –cached <File Name><br>git rm –cached test<br><File Name>直接写要删除的文件或者文件夹名字就可以<br>删除之后把自己需要的文件加上<br>git add .<br>git commit -m “”<br>git push </p>\n<p>git rm -r –cached .<br>.gitignore不生效</p>\n<h1 id=\"git-config\"><a href=\"#git-config\" class=\"headerlink\" title=\"git config\"></a>git config</h1><p>git config –list<br>列出git的所有配置</p>\n<p>git配置中的CRLF、LF、CR<br>CRLF: Carriage-Return Line-Feed的缩写，意思是回车换行，即\\r\\n;<br>LF: Line-Feed的缩写,意思是换行，即\\n;<br>CR: Carriage-Return的缩写，回车，即\\r;<br>进阶<br>当我们敲击回车键(Enter)时，操作系统会插入不可见的字符表示换行，不同的操作系统插入不同<br>Windows: 插入\\r\\n,回车换行；<br>Linux\\Unix: 插入\\n,换行；<br>MacOS: 插入\\r，回车；</p>\n<p>git config –global core.autocrlf input</p>\n<p>AutoCRLF<br>提交时转换为LF，检出时转换为CRLF<br>git config –global core.autocrlf true<br>提交时转换为LF，检出时不转换<br>git config –global core.autocrlf input<br>提交检出均不转换<br>如果下windows下下载的文件，需要映射到linux中去，不用总是手动改变编码</p>\n<h1 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h1><p>查看当前所在分支 </p>\n<p><code>git branch -r</code><br>查看远程有哪些分支</p>\n<p><code>git branch -v</code><br>显示当前分支的详细信息</p>\n<p><code>git branch -d feat-0728</code><br>删除本地创建的分支</p>\n<h1 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h1><p><code>git reset HEAD </code><br>恢复已经add的提交<br><code>git reset HEAD test.cpp</code><br>指定文件恢复</p>\n<p><code>git reset HEAD^ </code><br>回退所有内容到上一个版本<br><code>git reset HEAD^ hello.php  </code><br>回退 hello.php 文件的版本到上一个版本  </p>\n<h1 id=\"git-高级技术\"><a href=\"#git-高级技术\" class=\"headerlink\" title=\"git 高级技术\"></a>git 高级技术</h1><h2 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h2><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --pretty=format:&#x27;%h: <span class=\"built_in\">%s</span>&#x27;</span><br><span class=\"line\">d27f636: test:<span class=\"number\">15</span></span><br><span class=\"line\">e54dd6f: test:rebase <span class=\"number\">12</span></span><br><span class=\"line\">db794d8: test:<span class=\"number\">11</span></span><br><span class=\"line\">ee8c5a3: test:rebase</span><br><span class=\"line\">5a30601: test:<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">08089a1</span>: test:<span class=\"number\">2</span></span><br><span class=\"line\">4a82470: test:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">46480b8</span>: feat:增加了链接</span><br><span class=\"line\"><span class=\"number\">7035791</span>: feat:init</span><br><span class=\"line\">2544c56: Initial commit</span><br></pre></td></tr></table></figure>\n\n<p>只显示一行，详细的<br>git log –pretty&#x3D;oneline<br>只显示一行<br>git log –oneline<br>显示图形界面<br>git log –graph</p>\n<h2 id=\"git-rebase\"><a href=\"#git-rebase\" class=\"headerlink\" title=\"git rebase\"></a>git rebase</h2><p>步骤一：<br>git rebase -i [startPonit] [endPoint]<br>一般不使用endPoint<br>git rebase -i ee8c5a3<br>(ee8c5a3,d27f636]<br>(test:rebase,test:15]<br>步骤二：<br>接下来进入图形界面<br>p 选择<br>s 放弃<br>步骤二：<br>图形界面2<br>注释掉不想要提交的<br>:wq退出</p>\n<p>如果需要rebase已经push的commit<br>需要在提交的时候直接git push -f强制交上去，就会刷新掉之前的提交</p>\n<h1 id=\"修改最后一次提交的注释\"><a href=\"#修改最后一次提交的注释\" class=\"headerlink\" title=\"修改最后一次提交的注释\"></a>修改最后一次提交的注释</h1><p>git commit –amend </p>\n<h1 id=\"git-stsh-暂存\"><a href=\"#git-stsh-暂存\" class=\"headerlink\" title=\"git stsh 暂存\"></a>git stsh 暂存</h1><p>暂存命令<br>git stash save “暂存的备注”<br>直接执行git stash也可以达到暂存的目的，但是连续多次暂存后容易让人混淆哪次暂存了哪些代码</p>\n<p>查看暂存记录<br>git stash list<br>取回暂存代码<br>git stash pop<br>取消【取消暂存代码】</p>\n<p>git reset –hard</p>\n<h1 id=\"git-gc\"><a href=\"#git-gc\" class=\"headerlink\" title=\"git gc\"></a>git gc</h1><p>在当前存储库中运行许多内务处理任务，例如压缩文件修订（以减少磁盘空间并提高性能）<br>并移除可能由之前git add调用创建的不可达对象。</p>\n<p>鼓励用户在每个存储库中定期运行此任务，以保持良好的磁盘空间利用率和良好的操作性能。</p>\n<p>git-gc  - 清理不必要的文件并优化本地存储库</p>\n<p>Git是如何存储对象的</p>\n<p>Git 中存在两种对象 -  松散对象(loose object) 和 打包对象(packed object) .</p>\n<p>git gc 为了定时的对文件进行打包<br>松散对象存储的文件，一个很大的文件1G的文件，改动一行，那依然会有一个1G的副本保存下来<br>所以需要将松散对象打包为打包对象用来节约存储空间</p>\n<p>关闭自动打包的原理是：<br>如果有大文件包含在文件夹中，并且需要经常改动，那么就需要打开gc机制<br>但是正常情况下，提交的都是几KB的小文件，源代码之类的，空间占用的很好，关闭git gc机制，还可以更好的溯源文件变化情况</p>\n<p>问题：<br>git gc以后，会消失一些什么信息？</p>\n<h1 id=\"git-reflog\"><a href=\"#git-reflog\" class=\"headerlink\" title=\"git reflog\"></a>git reflog</h1><p>如果使用git reset –herd HEAD^回退了版本，会出现amend的未来提交<br>可以使用reflog查看到，并且回退到未来的版本</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[GIT在线练习平台]<a href=\"https://learngitbranching.js.org/?locale=zh_CN\">https://learngitbranching.js.org/?locale=zh_CN</a><br><a href=\"https://blog.csdn.net/ajianyingxiaoqinghan/article/details/70544159\">https://blog.csdn.net/ajianyingxiaoqinghan/article/details/70544159</a><br><a href=\"https://blog.csdn.net/u014361280/article/details/109703556\">https://blog.csdn.net/u014361280/article/details/109703556</a><br>[git submodule]<a href=\"https://blog.csdn.net/weixin_44901565/article/details/123086226\">https://blog.csdn.net/weixin_44901565/article/details/123086226</a><br>[git配置中的CRLF、LF、CR]<a href=\"https://blog.csdn.net/u013037336/article/details/121541008\">https://blog.csdn.net/u013037336/article/details/121541008</a><br>[git commit -m约定式提交]<a href=\"https://www.conventionalcommits.org/zh-hans/v1.0.0/\">https://www.conventionalcommits.org/zh-hans/v1.0.0/</a><br>[白色箭头]<a href=\"https://blog.csdn.net/bowenlaw/article/details/124594664\">https://blog.csdn.net/bowenlaw/article/details/124594664</a><br>[git commit 规范指南]<a href=\"https://blog.csdn.net/qq_41662115/article/details/99759645\">https://blog.csdn.net/qq_41662115/article/details/99759645</a><br>[.gitignore基础规则]<a href=\"https://www.cnblogs.com/kevingrace/p/5690241.html\">https://www.cnblogs.com/kevingrace/p/5690241.html</a><br>[git rebase]<a href=\"https://blog.csdn.net/small_white_123/article/details/121563248\">https://blog.csdn.net/small_white_123/article/details/121563248</a><br>[git reset HEAD 用法]<a href=\"https://blog.csdn.net/wangkai6666/article/details/120810363\">https://blog.csdn.net/wangkai6666/article/details/120810363</a><br>[英文git教程网站]<a href=\"https://www.atlassian.com/git\">https://www.atlassian.com/git</a><br>[git commit –amend]<a href=\"https://blog.csdn.net/xiaoyulike/article/details/119176756\">https://blog.csdn.net/xiaoyulike/article/details/119176756</a><br>[git - 执行 git clone 时 “Filtering content”是什么意思？]<a href=\"https://www.coder.work/article/1531074\">https://www.coder.work/article/1531074</a><br>[为什么要管理git gc自动垃圾回收(英文)]<a href=\"https://donatstudios.com/yagni-git-gc\">https://donatstudios.com/yagni-git-gc</a><br>[为什么要git gc]<a href=\"https://www.cnblogs.com/ayseeing/p/4226471.html\">https://www.cnblogs.com/ayseeing/p/4226471.html</a><br>[Git是如何存储对象的]<a href=\"https://blog.csdn.net/hudashi/article/details/7669477\">https://blog.csdn.net/hudashi/article/details/7669477</a><br>[10.4 Git 内部原理 - 包文件]<a href=\"https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%8C%85%E6%96%87%E4%BB%B6\">https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%8C%85%E6%96%87%E4%BB%B6</a><br>[Git是如何存储对象的- 7. 原理解析- [ Git Community Book 中文版 …]<a href=\"https://www.shouce.ren/api/view/a/9924\">https://www.shouce.ren/api/view/a/9924</a><br>[git 版本回退]<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192\">https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192</a><br>[【学了就忘】Git操作 — 51.git reflog命令]<a href=\"https://www.jianshu.com/p/7e4cef3863e7\">https://www.jianshu.com/p/7e4cef3863e7</a><br>[Good First Issue]<a href=\"https://goodfirstissue.dev/language/cplusplus/\">https://goodfirstissue.dev/language/cplusplus/</a></p>\n","slug":"Tutorial/Git-tutorial","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/16/Tutorial/Git-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"linux网络编程","date":"16/03/2022","path":"2022/03/16/Linux-Network-Programming/Linux-Network-Programming/","text":"用man pthread没有相应的解释sudo apt-get install glibc-doc sudo apt-get install manpages-posix-dev man -k pthread sudo apt-get install mysql-server service mysql start启动mysql &#x2F;&#x2F; 建立yourdb库create database yourdb; &#x2F;&#x2F;创建user表USE yourdb;CREATE TABLE user( username char(50) NULL, passwd char(50) NULL)ENGINE&#x3D;InnoDB; &#x2F;&#x2F; 添加数据INSERT INTO user(username, passwd) VALUES(‘name’, ‘passwd’); show databases;显示数据库 use demo_test;连接数据库 查看当前使用的数据库：mysql&gt; select database(); 查看表show tables; 获取表结构desc user; 查询表中的数据mysql&gt; select * from user;","raw":"---\ntitle: linux网络编程\ndate: 2022-03-16 21:45:13\ntags:\n- Linux网络编程\n---\n\n用man pthread没有相应的解释\nsudo apt-get install glibc-doc\n\nsudo apt-get install manpages-posix-dev\n\nman -k pthread \n\n\n\nsudo apt-get install mysql-server\n\n\n\nservice mysql start启动mysql\n\n\n// 建立yourdb库\ncreate database yourdb;\n\n//创建user表\nUSE yourdb;\nCREATE TABLE user(\n    username char(50) NULL,\n    passwd char(50) NULL\n)ENGINE=InnoDB;\n\n// 添加数据\nINSERT INTO user(username, passwd) VALUES('name', 'passwd');\n\n\nshow databases;\n显示数据库\n\nuse demo_test;\n连接数据库\n\n查看当前使用的数据库：\nmysql> select database();\n\n查看表\nshow tables;\n\n获取表结构\ndesc user;\n\n查询表中的数据\nmysql> select * from user;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>用man pthread没有相应的解释<br>sudo apt-get install glibc-doc</p>\n<p>sudo apt-get install manpages-posix-dev</p>\n<p>man -k pthread </p>\n<p>sudo apt-get install mysql-server</p>\n<p>service mysql start启动mysql</p>\n<p>&#x2F;&#x2F; 建立yourdb库<br>create database yourdb;</p>\n<p>&#x2F;&#x2F;创建user表<br>USE yourdb;<br>CREATE TABLE user(<br>    username char(50) NULL,<br>    passwd char(50) NULL<br>)ENGINE&#x3D;InnoDB;</p>\n<p>&#x2F;&#x2F; 添加数据<br>INSERT INTO user(username, passwd) VALUES(‘name’, ‘passwd’);</p>\n<p>show databases;<br>显示数据库</p>\n<p>use demo_test;<br>连接数据库</p>\n<p>查看当前使用的数据库：<br>mysql&gt; select database();</p>\n<p>查看表<br>show tables;</p>\n<p>获取表结构<br>desc user;</p>\n<p>查询表中的数据<br>mysql&gt; select * from user;</p>\n","slug":"Linux-Network-Programming/Linux-Network-Programming","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/16/Linux-Network-Programming/Linux-Network-Programming/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Part7 磁盘与文件系统管理","date":"12/03/2022","path":"2022/03/12/Brids-Linux-private-kitchen/Part7-Disk-and-file-system-management/","text":"xfs_info 观察XFS文件系统df df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。 dudu （英文全拼：disk usage）命令用于显示目录或文件的大小。 -h或–human-readable 以K，M，G为单位，提高信息的可读性-s或–summarize 仅显示总计 du -h显示指定文件夹大小du -h .ssh&#x2F;当前文件夹的总大小du -sh ln 硬链接lsblk 列出所有磁盘列表blkid 列出设备的UUID等参数UUID 全局唯一标识符 parted 列出磁盘分区表类型与分区信息gdisk GPT分区fdisk MBR分区mountmknod压缩与解压tar-x 对 tar 包做解打包操作。-z：压缩和解压缩 “.tar.gz” 格式；-j：压缩和解压缩 “.tar.bz2”格式。-C 目录 指定解打包位置。-v 显示解打包的具体过程。-f 指定要解压的 tar 包的包名。 -zxvf 解压解压、解包、显示过程 指定解压名字 tar zcvf FileName.tar.gz DirName","raw":"---\ntitle: Part7 磁盘与文件系统管理\ndate: 2022-03-12 21:27:18\ntags:\n- 鸟哥的Linux私房菜\n---\n\n# xfs_info 观察XFS文件系统\n\n# df\n df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。\n\n# du\ndu （英文全拼：disk usage）命令用于显示目录或文件的大小。\n\n-h或--human-readable 以K，M，G为单位，提高信息的可读性\n-s或--summarize 仅显示总计\n\ndu -h \n显示指定文件夹大小\ndu -h .ssh/\n当前文件夹的总大小\ndu -sh\n\n# ln 硬链接\n\n\n# lsblk 列出所有磁盘列表\n\n# blkid 列出设备的UUID等参数\nUUID 全局唯一标识符\n\n# parted 列出磁盘分区表类型与分区信息\n\n# gdisk GPT分区\n\n# fdisk MBR分区\n\n\n# mount\n\n# mknod\n\n\n\n# 压缩与解压tar\n-x\t对 tar 包做解打包操作。\n-z：压缩和解压缩 \".tar.gz\" 格式；\n-j：压缩和解压缩 \".tar.bz2\"格式。\n-C 目录\t指定解打包位置。\n-v\t显示解打包的具体过程。\n-f\t指定要解压的 tar 包的包名。\n\n-zxvf 解压\n解压、解包、显示过程 指定解压名字\n\ntar zcvf FileName.tar.gz DirName","content":"<h1 id=\"xfs-info-观察XFS文件系统\"><a href=\"#xfs-info-观察XFS文件系统\" class=\"headerlink\" title=\"xfs_info 观察XFS文件系统\"></a>xfs_info 观察XFS文件系统</h1><h1 id=\"df\"><a href=\"#df\" class=\"headerlink\" title=\"df\"></a>df</h1><p> df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。</p>\n<h1 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h1><p>du （英文全拼：disk usage）命令用于显示目录或文件的大小。</p>\n<p>-h或–human-readable 以K，M，G为单位，提高信息的可读性<br>-s或–summarize 仅显示总计</p>\n<p>du -h<br>显示指定文件夹大小<br>du -h .ssh&#x2F;<br>当前文件夹的总大小<br>du -sh</p>\n<h1 id=\"ln-硬链接\"><a href=\"#ln-硬链接\" class=\"headerlink\" title=\"ln 硬链接\"></a>ln 硬链接</h1><h1 id=\"lsblk-列出所有磁盘列表\"><a href=\"#lsblk-列出所有磁盘列表\" class=\"headerlink\" title=\"lsblk 列出所有磁盘列表\"></a>lsblk 列出所有磁盘列表</h1><h1 id=\"blkid-列出设备的UUID等参数\"><a href=\"#blkid-列出设备的UUID等参数\" class=\"headerlink\" title=\"blkid 列出设备的UUID等参数\"></a>blkid 列出设备的UUID等参数</h1><p>UUID 全局唯一标识符</p>\n<h1 id=\"parted-列出磁盘分区表类型与分区信息\"><a href=\"#parted-列出磁盘分区表类型与分区信息\" class=\"headerlink\" title=\"parted 列出磁盘分区表类型与分区信息\"></a>parted 列出磁盘分区表类型与分区信息</h1><h1 id=\"gdisk-GPT分区\"><a href=\"#gdisk-GPT分区\" class=\"headerlink\" title=\"gdisk GPT分区\"></a>gdisk GPT分区</h1><h1 id=\"fdisk-MBR分区\"><a href=\"#fdisk-MBR分区\" class=\"headerlink\" title=\"fdisk MBR分区\"></a>fdisk MBR分区</h1><h1 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h1><h1 id=\"mknod\"><a href=\"#mknod\" class=\"headerlink\" title=\"mknod\"></a>mknod</h1><h1 id=\"压缩与解压tar\"><a href=\"#压缩与解压tar\" class=\"headerlink\" title=\"压缩与解压tar\"></a>压缩与解压tar</h1><p>-x\t对 tar 包做解打包操作。<br>-z：压缩和解压缩 “.tar.gz” 格式；<br>-j：压缩和解压缩 “.tar.bz2”格式。<br>-C 目录\t指定解打包位置。<br>-v\t显示解打包的具体过程。<br>-f\t指定要解压的 tar 包的包名。</p>\n<p>-zxvf 解压<br>解压、解包、显示过程 指定解压名字</p>\n<p>tar zcvf FileName.tar.gz DirName</p>\n","slug":"Brids-Linux-private-kitchen/Part7-Disk-and-file-system-management","updated":"16/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/12/Brids-Linux-private-kitchen/Part7-Disk-and-file-system-management/","excerpt":"","categories":[],"tags":[{"name":"鸟哥的Linux私房菜","slug":"鸟哥的Linux私房菜","permalink":"http://example.com/tags/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"}]},{"title":"gcc 教程","date":"11/03/2022","path":"2022/03/11/Tutorial/linux-dev-env/GCC-tutorial/","text":"GCC介绍 GCC 原名为 GNU C语言编译器（GNU C Compiler） GCC（GNU Compiler Collection， GNU编译器套件）是由 GNU 开发的编程语言译器。 GNU 编译器套件包括 C、 C++、 Objective-C、 Java、 Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++， libgcj等） GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数-std=c99 启动 GCC 时，编译器支持 C99 标准。 安装命令 sudo apt install gcc g++ （版本 &gt; 4.8.5） 查看版本 gcc&#x2F;g++ -v&#x2F;–version 语言流程高级语言编译汇编语言汇编机器语言运行计算机 GCC工作流程源代码(预处理)-&gt;预处理后源代码(编译器)-&gt;汇编代码(汇编器)-&gt;目标代码(链接器)-&gt;可执行程序.h.c.cpp.i.s.exe.out gcc 和 g++ 的区别gcc 和 g++都是GNU(组织)的一个编译器 误区一： gcc 只能编译 c 代码， g++ 只能编译 c++ 代码。两者都可以，请注意： 误区二： gcc 不会定义 __cplusplus 宏，而 g++ 会 误区三：编译只能用 gcc，链接只能用 g++ GCC常用参数选项 输出 说明 文件名 没有指令 a.out -E 预处理指定的源文件，不进行编译 被导入到标准输出流（也就是显示器）gcc -E test.c -o 7.i -S 编译指定的源文件，但是不进行汇编，生成汇编文件 原文件名.s -c 编译、汇编指定的源文件，生成目标文件，但是不进行链接 原文件名.o -o [file1] [file2] [file2] 将文件 file2 编译成可执行文件 file1 -o [file1] 生成指定文件名file1 将main.c和string.c编译成一个执行文件gcc -o test mian.c string.c 指令 说明 -I directory 指定 include 包含文件的搜索目录 — — -g 在编译的时候，生成调试信息，该程序可以被调试器调试 -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -O n n的取值范围： 0~3,编译器的优化选项的4个级别 -O 0表示没有优化， -O 1为缺省值， -O 3优化级别最高 -l 在程序编译的时候，指定使用的库 -L 指定编译的时候，搜索的库的路径。 -fPIC&#x2F;fpic 生成与位置无关的代码 -shared 生成共享目标文件，通常用在建立共享库时 -std 指定C方言，如:-std&#x3D;c++11， gcc默认的方言是GNU C 库文件 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。 库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。 库的好处： 1.代码保密 2.方便部署和分发 静态库的制作 命名规则： Linux : libxxx.a lib : 前缀（固定） xxx : 库的名字，自己起 .a : 后缀（固定） Windows : libxxx.lib 静态库的制作： gcc 获得 .o 文件 将 .o 文件打包，使用 ar 工具（archive） ar rcs libxxx.a xxx.o xxx.o r – 将文件插入备存文件中 c – 建立备存文件 s – 索引 参考资料：https://www.nowcoder.com/courses/cover/live/504[100个gdb小技巧]https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html","raw":"---\ntitle: gcc 教程\ndate: 2022-03-11 14:11:23\ntags:\n- 教程\n---\n\n\n# GCC介绍\n\n- GCC 原名为 GNU C语言编译器（GNU C Compiler）\n- GCC（GNU Compiler Collection， GNU编译器套件）是由 GNU 开发的编程语言\n译器。 GNU 编译器套件包括 C、 C++、 Objective-C、 Java、 Ada 和 Go 语言前\n端，也包括了这些语言的库（如 libstdc++， libgcj等）\n- GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行\n选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数\n`-std=c99` 启动 GCC 时，编译器支持 C99 标准。\n- 安装命令 sudo apt install gcc g++ （版本 > 4.8.5）\n- 查看版本 gcc/g++ -v/--version\n\n# 语言流程\n\n高级语言\n编译\n汇编语言\n汇编\n机器语言\n运行\n计算机\n\n# GCC工作流程\n\n源代码(预处理)->预处理后源代码(编译器)->汇编代码(汇编器)->目标代码(链接器)->可执行程序\n.h.c.cpp\n.i\n.s\n.exe.out\n\n# gcc 和 g++ 的区别\ngcc 和 g++都是GNU(组织)的一个编译器\n- 误区一： gcc 只能编译 c 代码， g++ 只能编译 c++ 代码。两者都可以，请注意：\n- 误区二： gcc 不会定义 __cplusplus 宏，而 g++ 会\n- 误区三：编译只能用 gcc，链接只能用 g++\n\n\n# GCC常用参数选项\n\n|输出| 说明|文件名|\n|---|---|---|\n||没有指令|a.out|\n|-E |预处理指定的源文件，不进行编译|被导入到标准输出流（也就是显示器）</br>gcc -E test.c -o 7.i|\n|-S |编译指定的源文件，但是不进行汇编，生成汇编文件|原文件名.s|\n|-c |编译、汇编指定的源文件，生成目标文件，但是不进行链接|原文件名.o|\n|-o [file1] [file2] [file2] | 将文件 file2 编译成可执行文件 file1|\n|-o [file1] |生成指定文件名file1|\n\n将main.c和string.c编译成一个执行文件\ngcc -o test mian.c string.c\n\n|指令| 说明|\n|---|---|\n|-I |directory 指定 include 包含文件的搜索目录|\n|---|---|\n|-g |在编译的时候，生成调试信息，该程序可以被调试器调试|\n|-D |在程序编译的时候，指定一个宏|\n|-w |不生成任何警告信息|\n|-Wall| 生成所有警告信息|\n|-O n|n的取值范围： 0~3,编译器的优化选项的4个级别</br> -O 0表示没有优化， -O 1为缺省值， -O 3优化级别最高|\n|-l |在程序编译的时候，指定使用的库|\n|-L |指定编译的时候，搜索的库的路径。|\n|-fPIC/fpic |生成与位置无关的代码|\n|-shared |生成共享目标文件，通常用在建立共享库时|\n|-std |指定C方言，如:-std=c++11， gcc默认的方言是GNU C|\n\n\n# 库文件\n\n- 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。\n- 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。\n- 库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。\n- 库的好处： 1.代码保密 2.方便部署和分发\n\n# 静态库的制作\n\n- 命名规则：\n    - Linux : libxxx.a\n    - lib : 前缀（固定）\n    - xxx : 库的名字，自己起\n    - .a : 后缀（固定）\n- Windows : libxxx.lib\n\n- 静态库的制作：\n- gcc 获得 .o 文件\n- 将 .o 文件打包，使用 ar 工具（archive）\n    - ar rcs libxxx.a xxx.o xxx.o\n        - r – 将文件插入备存文件中\n        - c – 建立备存文件\n        - s – 索引\n\n\n\n\n\n\n\n# 参考资料：\nhttps://www.nowcoder.com/courses/cover/live/504\n[100个gdb小技巧]https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html\n","content":"<h1 id=\"GCC介绍\"><a href=\"#GCC介绍\" class=\"headerlink\" title=\"GCC介绍\"></a>GCC介绍</h1><ul>\n<li>GCC 原名为 GNU C语言编译器（GNU C Compiler）</li>\n<li>GCC（GNU Compiler Collection， GNU编译器套件）是由 GNU 开发的编程语言<br>译器。 GNU 编译器套件包括 C、 C++、 Objective-C、 Java、 Ada 和 Go 语言前<br>端，也包括了这些语言的库（如 libstdc++， libgcj等）</li>\n<li>GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行<br>选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数<br><code>-std=c99</code> 启动 GCC 时，编译器支持 C99 标准。</li>\n<li>安装命令 sudo apt install gcc g++ （版本 &gt; 4.8.5）</li>\n<li>查看版本 gcc&#x2F;g++ -v&#x2F;–version</li>\n</ul>\n<h1 id=\"语言流程\"><a href=\"#语言流程\" class=\"headerlink\" title=\"语言流程\"></a>语言流程</h1><p>高级语言<br>编译<br>汇编语言<br>汇编<br>机器语言<br>运行<br>计算机</p>\n<h1 id=\"GCC工作流程\"><a href=\"#GCC工作流程\" class=\"headerlink\" title=\"GCC工作流程\"></a>GCC工作流程</h1><p>源代码(预处理)-&gt;预处理后源代码(编译器)-&gt;汇编代码(汇编器)-&gt;目标代码(链接器)-&gt;可执行程序<br>.h.c.cpp<br>.i<br>.s<br>.exe.out</p>\n<h1 id=\"gcc-和-g-的区别\"><a href=\"#gcc-和-g-的区别\" class=\"headerlink\" title=\"gcc 和 g++ 的区别\"></a>gcc 和 g++ 的区别</h1><p>gcc 和 g++都是GNU(组织)的一个编译器</p>\n<ul>\n<li>误区一： gcc 只能编译 c 代码， g++ 只能编译 c++ 代码。两者都可以，请注意：</li>\n<li>误区二： gcc 不会定义 __cplusplus 宏，而 g++ 会</li>\n<li>误区三：编译只能用 gcc，链接只能用 g++</li>\n</ul>\n<h1 id=\"GCC常用参数选项\"><a href=\"#GCC常用参数选项\" class=\"headerlink\" title=\"GCC常用参数选项\"></a>GCC常用参数选项</h1><table>\n<thead>\n<tr>\n<th>输出</th>\n<th>说明</th>\n<th>文件名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>没有指令</td>\n<td>a.out</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>预处理指定的源文件，不进行编译</td>\n<td>被导入到标准输出流（也就是显示器）</br>gcc -E test.c -o 7.i</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>编译指定的源文件，但是不进行汇编，生成汇编文件</td>\n<td>原文件名.s</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>编译、汇编指定的源文件，生成目标文件，但是不进行链接</td>\n<td>原文件名.o</td>\n</tr>\n<tr>\n<td>-o [file1] [file2] [file2]</td>\n<td>将文件 file2 编译成可执行文件 file1</td>\n<td></td>\n</tr>\n<tr>\n<td>-o [file1]</td>\n<td>生成指定文件名file1</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>将main.c和string.c编译成一个执行文件<br>gcc -o test mian.c string.c</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-I</td>\n<td>directory 指定 include 包含文件的搜索目录</td>\n</tr>\n<tr>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td>-g</td>\n<td>在编译的时候，生成调试信息，该程序可以被调试器调试</td>\n</tr>\n<tr>\n<td>-D</td>\n<td>在程序编译的时候，指定一个宏</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>不生成任何警告信息</td>\n</tr>\n<tr>\n<td>-Wall</td>\n<td>生成所有警告信息</td>\n</tr>\n<tr>\n<td>-O n</td>\n<td>n的取值范围： 0~3,编译器的优化选项的4个级别</br> -O 0表示没有优化， -O 1为缺省值， -O 3优化级别最高</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>在程序编译的时候，指定使用的库</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>指定编译的时候，搜索的库的路径。</td>\n</tr>\n<tr>\n<td>-fPIC&#x2F;fpic</td>\n<td>生成与位置无关的代码</td>\n</tr>\n<tr>\n<td>-shared</td>\n<td>生成共享目标文件，通常用在建立共享库时</td>\n</tr>\n<tr>\n<td>-std</td>\n<td>指定C方言，如:-std&#x3D;c++11， gcc默认的方言是GNU C</td>\n</tr>\n</tbody></table>\n<h1 id=\"库文件\"><a href=\"#库文件\" class=\"headerlink\" title=\"库文件\"></a>库文件</h1><ul>\n<li>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。</li>\n<li>库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。</li>\n<li>库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</li>\n<li>库的好处： 1.代码保密 2.方便部署和分发</li>\n</ul>\n<h1 id=\"静态库的制作\"><a href=\"#静态库的制作\" class=\"headerlink\" title=\"静态库的制作\"></a>静态库的制作</h1><ul>\n<li><p>命名规则：</p>\n<ul>\n<li>Linux : libxxx.a</li>\n<li>lib : 前缀（固定）</li>\n<li>xxx : 库的名字，自己起</li>\n<li>.a : 后缀（固定）</li>\n</ul>\n</li>\n<li><p>Windows : libxxx.lib</p>\n</li>\n<li><p>静态库的制作：</p>\n</li>\n<li><p>gcc 获得 .o 文件</p>\n</li>\n<li><p>将 .o 文件打包，使用 ar 工具（archive）</p>\n<ul>\n<li>ar rcs libxxx.a xxx.o xxx.o<ul>\n<li>r – 将文件插入备存文件中</li>\n<li>c – 建立备存文件</li>\n<li>s – 索引</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><p><a href=\"https://www.nowcoder.com/courses/cover/live/504\">https://www.nowcoder.com/courses/cover/live/504</a><br>[100个gdb小技巧]<a href=\"https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html\">https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html</a></p>\n","slug":"Tutorial/linux-dev-env/GCC-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/11/Tutorial/linux-dev-env/GCC-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Cpluspulus 语法","date":"08/03/2022","path":"2022/03/08/Grammar/Cpluspulus-Grammar/","text":"不会的知识点的罗列C++11std::threadC++11中加入了&lt;thread&gt;头文件，此头文件主要声明了std::thread线程类 std::mutexC++11中新增了&lt;mutex&gt;，它是C++标准程序库中的一个头文件，定义了C++11标准中的一些互斥访问的类与方法等 explicitexplicit构造函数是用来防止隐式转换的 noexcept从C++11开始，我们能看到很多代码当中都有关键字noexcept。比如下面就是std::initializer_list的默认构造函数，其中使用了noexcept。 constexpr initializer_list() noexcept : _M_array(0), _M_len(0) &#123; &#125; 该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。 Snowflake 雪花算法分布式系统中ID生成方案，比较简单的是UUID（Universally Unique Identifier，通用唯一识别码），但是其存在两个明显的弊端：一、UUID是128位的，长度过长；二、UUID是完全随机的，无法生成递增有序的UUID。而现在流行的基于 Snowflake 雪花算法的ID生成方案就可以很好的解决了UUID存在的这两个问题 numeric_limitsnumeric_limits::max ()是函数，返回编译器允许的 double 型数 最大值。类似的 numeric_limits::max () 返回 编译器允许的 int 型数 最大值。需包含头文件 #include imits是STL提供的头文件（包含numeric_limits模板类），limit.h是C语言提供的头文件（包含一些宏定义） std::lock_guardlock_guard锁守卫是一个管理mutex对象的对象，使其始终处于锁定状态。在构造时，mutex对象被调用线程锁定，在销毁时，mutex被解锁。这是最简单的锁，作为一个自动持续时间的对象，它的作用特别大，可以持续到上下文结束。通过这种方式，它可以保证mutex对象在发生异常时被正确解锁。但请注意，lock_guard对象并不以任何方式管理mutex对象的寿命：mutex对象的持续时间至少应延长到锁定它的lock_guard被破坏为止。程序在std::lock_guard生命周期内加锁和解锁，其中加锁和解锁分别在构造函数和析构函数中完成，具体如何我们看下std::lock_guard的构造函数和析构函数。 cv::gpu::GpuMatstd::movestd::enable_shared_from_this在类的内部获取自己的 shared_ptr 这件事情而存在的。 std::chrono::durationstd::chrono::duration(下文简称duration)是标准库中用来代表时间段的一个类模板 std::unique_lock功能比std::unique_group更多 std::condition_variable condition_variable是一个类，搭配互斥量mutex来用， C++171.语法糖结构化绑定模板参数推导constexpr if在编译时期就可以判断是否要用这个分支，根据输入的类型来判断分支的走向 if初始化语句可以像for一样，将一些变量的生命周期控制在if里面 2.性能提升shared_mutexstring_view在调用一些strcpy函数的时候，不会进行值传递，而是会复制引用 try_emplace在插入map之类的数组的时候，会先检查是否已经有元素存在了 3.类型系统any代替了空类型void*，变得类型安全了 optinalvariant4.其他applymake_from_tuple[[nodiscard]]捕获*this结构化绑定auto [cur, pos] &#x3D; qu.front();https://blog.csdn.net/yaoshenjie/article/details/99288495 第三方库httplib库简介httplib库简介httplib库是一个以C++11特性编写的库，所以编译器也需要能支持C++11的。库在使用时只需包含一个头文件即可，非常方便。 下载地址 注意：此库为线程阻塞，使用时还请注意 jsoncpp库#include &lt;json&#x2F;json.h&gt; 注释规范@brief @param @return @author @date @version是代码书写的一种规范@brief ：简介，简单介绍函数作用@param ：介绍函数参数@return：函数返回类型说明@exception NSException 可能抛出的异常.@author zhangsan： 作者@date 2011-07-27 22:30:00 ：时间@version 1.0 ：版本@property ：属性介绍 std::recursive_mutexrecursive_mutex 精确到ns的计时方法std::chrono 参考文献：[C++ explicit 关键字]https://zhuanlan.zhihu.com/p/52152355[解决 VSCode 编写 C++11 代码报红问题]https://blog.csdn.net/weixin_42292229/article/details/113767569[C++11 带来的新特性 （3）—— 关键字noexcept]https://www.cnblogs.com/sword03/p/10020344.html[C++ limits头文件的用法numeric_limits]https://blog.csdn.net/CHYabc123456hh/article/details/117260306[C++中lock_guard的学习]https://blog.csdn.net/CHYabc123456hh/article/details/111317404[C++ std::lock_guard详解]https://jishuin.proginn.com/p/763bfbd6f671[一文详解OpenCV中的CUDA模块]https://zhuanlan.zhihu.com/p/358648337[「直播回放」腾讯工程师：C++17在业务代码中最好用的十个特性]https://www.zhihu.com/zvideo/1523417372937027584[Qt开源作品21-日志重定向输出类]https://www.cnblogs.com/feiyangqingyun/p/12970350.html[C++多线程之semaphore]https://blog.csdn.net/qq_41949047/article/details/108324225[C++11中enable_shared_from_this的用法解析]https://blog.csdn.net/breadheart/article/details/112451022[std::chrono::duration详解]https://blog.csdn.net/t114211200/article/details/78029553[C++ 11 多线程下std::unique_lock与std::lock_guard的区别和用法]http://t.zoukankan.com/moodlxs-p-10111843.html[C++ 条件变量(condition_variable)]https://cloud.tencent.com/developer/article/1584067[httplib库的使用(支持http&#x2F;https)（一）]https://blog.csdn.net/harry49/article/details/115763383[注释规范：详细]https://www.cnblogs.com/lyggqm/p/4629711.html[注释规范]https://blog.csdn.net/lxj362343/article/details/105711524/[C++11 新的计时方法——std::chrono 大法好]https://blog.csdn.net/u013390476/article/details/50209603","raw":"---\ntitle: Cpluspulus 语法\ndate: 2022-03-08 20:34:13\ntags:\n- 语法\n---\n\n# 不会的知识点的罗列\n\n\n# C++11\n\n# std::thread\nC++11中加入了\\<thread>头文件，此头文件主要声明了std::thread线程类\n\n\n\n# std::mutex\nC++11中新增了\\<mutex>，它是C++标准程序库中的一个头文件，定义了C++11标准中的一些互斥访问的类与方法等\n\n\n# explicit\nexplicit构造函数是用来防止隐式转换的\n\n\n\n# noexcept\n从C++11开始，我们能看到很多代码当中都有关键字noexcept。比如下面就是std::initializer_list的默认构造函数，其中使用了noexcept。\n\n      constexpr initializer_list() noexcept\n      : _M_array(0), _M_len(0) { }\n该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。\n如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。\n\n\n\n## Snowflake 雪花算法\n分布式系统中ID生成方案，比较简单的是UUID（Universally Unique Identifier，通用唯一识别码），但是其存在两个明显的弊端：一、UUID是128位的，长度过长；二、UUID是完全随机的，无法生成递增有序的UUID。而现在流行的基于 Snowflake 雪花算法的ID生成方案就可以很好的解决了UUID存在的这两个问题\n\n\n## numeric_limits\nnumeric_limits<double>::max ()是函数，返回编译器允许的 double 型数 最大值。\n类似的 numeric_limits<int>::max () 返回 编译器允许的 int 型数 最大值。\n需包含头文件 #include <limits>  imits是STL提供的头文件（包含numeric_limits模板类），limit.h是C语言提供的头文件（包含一些宏定义）\n\n\n## std::lock_guard\nlock_guard\n锁守卫是一个管理mutex对象的对象，使其始终处于锁定状态。\n在构造时，mutex对象被调用线程锁定，在销毁时，mutex被解锁。这是最简单的锁，作为一个自动持续时间的对象，它的作用特别大，可以持续到上下文结束。通过这种方式，它可以保证mutex对象在发生异常时被正确解锁。\n但请注意，lock_guard对象并不以任何方式管理mutex对象的寿命：mutex对象的持续时间至少应延长到锁定它的lock_guard被破坏为止。\n程序在std::lock_guard生命周期内加锁和解锁，其中加锁和解锁分别在构造函数和析构函数中完成，具体如何我们看下std::lock_guard的构造函数和析构函数。\n\n\n## cv::gpu::GpuMat\n\n\n## std::move\n\n\n\n## std::enable_shared_from_this\n在类的内部获取自己的 shared_ptr 这件事情而存在的。\n\n\n## std::chrono::duration\nstd::chrono::duration(下文简称duration)是标准库中用来代表时间段的一个类模板\n\n\n\n## std::unique_lock\n功能比std::unique_group更多\n\n\n## std::condition_variable\n condition_variable是一个类，搭配互斥量mutex来用，\n\n\n# C++17\n\n## 1.语法糖\n### 结构化绑定\n### 模板参数推导\n### constexpr if\n在编译时期就可以判断是否要用这个分支，根据输入的类型来判断分支的走向\n\n### if初始化语句\n可以像for一样，将一些变量的生命周期控制在if里面\n\n## 2.性能提升\n### shared_mutex\n\n### string_view\n在调用一些strcpy函数的时候，不会进行值传递，而是会复制引用\n\n\n### try_emplace\n在插入map之类的数组的时候，会先检查是否已经有元素存在了\n\n\n## 3.类型系统\n### any\n代替了空类型void*，变得类型安全了\n\n### optinal\n\n### variant\n\n## 4.其他\n\n### apply\n\n### make_from_tuple\n\n### [[nodiscard]]\n\n### 捕获*this\n\n## 结构化绑定\nauto [cur, pos] = qu.front();\nhttps://blog.csdn.net/yaoshenjie/article/details/99288495\n\n\n# 第三方库\n\n## httplib库简介\nhttplib库简介\nhttplib库是一个以C++11特性编写的库，所以编译器也需要能支持C++11的。库在使用时只需包含一个头文件即可，非常方便。\n\n下载地址\n\n注意：此库为线程阻塞，使用时还请注意\n\n##  jsoncpp库\n#include <json/json.h>\n\n\n# 注释规范\n\n@brief  @param  @return @author @date @version是代码书写的一种规范\n@brief  ：简介，简单介绍函数作用\n@param  ：介绍函数参数\n@return：函数返回类型说明\n@exception NSException 可能抛出的异常.\n@author zhangsan：  作者\n@date 2011-07-27 22:30:00 ：时间\n@version 1.0 ：版本  \n@property ：属性介绍\n\n\n\n# std::recursive_mutex\nrecursive_mutex\n\n\n\n# 精确到ns的计时方法\nstd::chrono\n\n# 参考文献：\n[C++ explicit 关键字]https://zhuanlan.zhihu.com/p/52152355\n[解决 VSCode 编写 C++11 代码报红问题]https://blog.csdn.net/weixin_42292229/article/details/113767569\n[C++11 带来的新特性 （3）—— 关键字noexcept]https://www.cnblogs.com/sword03/p/10020344.html\n[C++ limits头文件的用法numeric_limits]https://blog.csdn.net/CHYabc123456hh/article/details/117260306\n[C++中lock_guard的学习]https://blog.csdn.net/CHYabc123456hh/article/details/111317404\n[C++ std::lock_guard详解]https://jishuin.proginn.com/p/763bfbd6f671\n[一文详解OpenCV中的CUDA模块]https://zhuanlan.zhihu.com/p/358648337\n[「直播回放」腾讯工程师：C++17在业务代码中最好用的十个特性]https://www.zhihu.com/zvideo/1523417372937027584\n[Qt开源作品21-日志重定向输出类]https://www.cnblogs.com/feiyangqingyun/p/12970350.html\n[C++多线程之semaphore]https://blog.csdn.net/qq_41949047/article/details/108324225\n[C++11中enable_shared_from_this的用法解析]https://blog.csdn.net/breadheart/article/details/112451022\n[std::chrono::duration详解]https://blog.csdn.net/t114211200/article/details/78029553\n[C++ 11 多线程下std::unique_lock与std::lock_guard的区别和用法]http://t.zoukankan.com/moodlxs-p-10111843.html\n[C++ 条件变量(condition_variable)]https://cloud.tencent.com/developer/article/1584067\n[httplib库的使用(支持http/https)（一）]https://blog.csdn.net/harry49/article/details/115763383\n[注释规范：详细]https://www.cnblogs.com/lyggqm/p/4629711.html\n[注释规范]https://blog.csdn.net/lxj362343/article/details/105711524/\n[C++11 新的计时方法——std::chrono 大法好]https://blog.csdn.net/u013390476/article/details/50209603\n\n\n","content":"<h1 id=\"不会的知识点的罗列\"><a href=\"#不会的知识点的罗列\" class=\"headerlink\" title=\"不会的知识点的罗列\"></a>不会的知识点的罗列</h1><h1 id=\"C-11\"><a href=\"#C-11\" class=\"headerlink\" title=\"C++11\"></a>C++11</h1><h1 id=\"std-thread\"><a href=\"#std-thread\" class=\"headerlink\" title=\"std::thread\"></a>std::thread</h1><p>C++11中加入了&lt;thread&gt;头文件，此头文件主要声明了std::thread线程类</p>\n<h1 id=\"std-mutex\"><a href=\"#std-mutex\" class=\"headerlink\" title=\"std::mutex\"></a>std::mutex</h1><p>C++11中新增了&lt;mutex&gt;，它是C++标准程序库中的一个头文件，定义了C++11标准中的一些互斥访问的类与方法等</p>\n<h1 id=\"explicit\"><a href=\"#explicit\" class=\"headerlink\" title=\"explicit\"></a>explicit</h1><p>explicit构造函数是用来防止隐式转换的</p>\n<h1 id=\"noexcept\"><a href=\"#noexcept\" class=\"headerlink\" title=\"noexcept\"></a>noexcept</h1><p>从C++11开始，我们能看到很多代码当中都有关键字noexcept。比如下面就是std::initializer_list的默认构造函数，其中使用了noexcept。</p>\n<pre><code>  constexpr initializer_list() noexcept\n  : _M_array(0), _M_len(0) &#123; &#125;\n</code></pre>\n<p>该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。<br>如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。</p>\n<h2 id=\"Snowflake-雪花算法\"><a href=\"#Snowflake-雪花算法\" class=\"headerlink\" title=\"Snowflake 雪花算法\"></a>Snowflake 雪花算法</h2><p>分布式系统中ID生成方案，比较简单的是UUID（Universally Unique Identifier，通用唯一识别码），但是其存在两个明显的弊端：一、UUID是128位的，长度过长；二、UUID是完全随机的，无法生成递增有序的UUID。而现在流行的基于 Snowflake 雪花算法的ID生成方案就可以很好的解决了UUID存在的这两个问题</p>\n<h2 id=\"numeric-limits\"><a href=\"#numeric-limits\" class=\"headerlink\" title=\"numeric_limits\"></a>numeric_limits</h2><p>numeric_limits<double>::max ()是函数，返回编译器允许的 double 型数 最大值。<br>类似的 numeric_limits<int>::max () 返回 编译器允许的 int 型数 最大值。<br>需包含头文件 #include <limits>  imits是STL提供的头文件（包含numeric_limits模板类），limit.h是C语言提供的头文件（包含一些宏定义）</p>\n<h2 id=\"std-lock-guard\"><a href=\"#std-lock-guard\" class=\"headerlink\" title=\"std::lock_guard\"></a>std::lock_guard</h2><p>lock_guard<br>锁守卫是一个管理mutex对象的对象，使其始终处于锁定状态。<br>在构造时，mutex对象被调用线程锁定，在销毁时，mutex被解锁。这是最简单的锁，作为一个自动持续时间的对象，它的作用特别大，可以持续到上下文结束。通过这种方式，它可以保证mutex对象在发生异常时被正确解锁。<br>但请注意，lock_guard对象并不以任何方式管理mutex对象的寿命：mutex对象的持续时间至少应延长到锁定它的lock_guard被破坏为止。<br>程序在std::lock_guard生命周期内加锁和解锁，其中加锁和解锁分别在构造函数和析构函数中完成，具体如何我们看下std::lock_guard的构造函数和析构函数。</p>\n<h2 id=\"cv-gpu-GpuMat\"><a href=\"#cv-gpu-GpuMat\" class=\"headerlink\" title=\"cv::gpu::GpuMat\"></a>cv::gpu::GpuMat</h2><h2 id=\"std-move\"><a href=\"#std-move\" class=\"headerlink\" title=\"std::move\"></a>std::move</h2><h2 id=\"std-enable-shared-from-this\"><a href=\"#std-enable-shared-from-this\" class=\"headerlink\" title=\"std::enable_shared_from_this\"></a>std::enable_shared_from_this</h2><p>在类的内部获取自己的 shared_ptr 这件事情而存在的。</p>\n<h2 id=\"std-chrono-duration\"><a href=\"#std-chrono-duration\" class=\"headerlink\" title=\"std::chrono::duration\"></a>std::chrono::duration</h2><p>std::chrono::duration(下文简称duration)是标准库中用来代表时间段的一个类模板</p>\n<h2 id=\"std-unique-lock\"><a href=\"#std-unique-lock\" class=\"headerlink\" title=\"std::unique_lock\"></a>std::unique_lock</h2><p>功能比std::unique_group更多</p>\n<h2 id=\"std-condition-variable\"><a href=\"#std-condition-variable\" class=\"headerlink\" title=\"std::condition_variable\"></a>std::condition_variable</h2><p> condition_variable是一个类，搭配互斥量mutex来用，</p>\n<h1 id=\"C-17\"><a href=\"#C-17\" class=\"headerlink\" title=\"C++17\"></a>C++17</h1><h2 id=\"1-语法糖\"><a href=\"#1-语法糖\" class=\"headerlink\" title=\"1.语法糖\"></a>1.语法糖</h2><h3 id=\"结构化绑定\"><a href=\"#结构化绑定\" class=\"headerlink\" title=\"结构化绑定\"></a>结构化绑定</h3><h3 id=\"模板参数推导\"><a href=\"#模板参数推导\" class=\"headerlink\" title=\"模板参数推导\"></a>模板参数推导</h3><h3 id=\"constexpr-if\"><a href=\"#constexpr-if\" class=\"headerlink\" title=\"constexpr if\"></a>constexpr if</h3><p>在编译时期就可以判断是否要用这个分支，根据输入的类型来判断分支的走向</p>\n<h3 id=\"if初始化语句\"><a href=\"#if初始化语句\" class=\"headerlink\" title=\"if初始化语句\"></a>if初始化语句</h3><p>可以像for一样，将一些变量的生命周期控制在if里面</p>\n<h2 id=\"2-性能提升\"><a href=\"#2-性能提升\" class=\"headerlink\" title=\"2.性能提升\"></a>2.性能提升</h2><h3 id=\"shared-mutex\"><a href=\"#shared-mutex\" class=\"headerlink\" title=\"shared_mutex\"></a>shared_mutex</h3><h3 id=\"string-view\"><a href=\"#string-view\" class=\"headerlink\" title=\"string_view\"></a>string_view</h3><p>在调用一些strcpy函数的时候，不会进行值传递，而是会复制引用</p>\n<h3 id=\"try-emplace\"><a href=\"#try-emplace\" class=\"headerlink\" title=\"try_emplace\"></a>try_emplace</h3><p>在插入map之类的数组的时候，会先检查是否已经有元素存在了</p>\n<h2 id=\"3-类型系统\"><a href=\"#3-类型系统\" class=\"headerlink\" title=\"3.类型系统\"></a>3.类型系统</h2><h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><p>代替了空类型void*，变得类型安全了</p>\n<h3 id=\"optinal\"><a href=\"#optinal\" class=\"headerlink\" title=\"optinal\"></a>optinal</h3><h3 id=\"variant\"><a href=\"#variant\" class=\"headerlink\" title=\"variant\"></a>variant</h3><h2 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4.其他\"></a>4.其他</h2><h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><h3 id=\"make-from-tuple\"><a href=\"#make-from-tuple\" class=\"headerlink\" title=\"make_from_tuple\"></a>make_from_tuple</h3><h3 id=\"nodiscard\"><a href=\"#nodiscard\" class=\"headerlink\" title=\"[[nodiscard]]\"></a>[[nodiscard]]</h3><h3 id=\"捕获-this\"><a href=\"#捕获-this\" class=\"headerlink\" title=\"捕获*this\"></a>捕获*this</h3><h2 id=\"结构化绑定-1\"><a href=\"#结构化绑定-1\" class=\"headerlink\" title=\"结构化绑定\"></a>结构化绑定</h2><p>auto [cur, pos] &#x3D; qu.front();<br><a href=\"https://blog.csdn.net/yaoshenjie/article/details/99288495\">https://blog.csdn.net/yaoshenjie/article/details/99288495</a></p>\n<h1 id=\"第三方库\"><a href=\"#第三方库\" class=\"headerlink\" title=\"第三方库\"></a>第三方库</h1><h2 id=\"httplib库简介\"><a href=\"#httplib库简介\" class=\"headerlink\" title=\"httplib库简介\"></a>httplib库简介</h2><p>httplib库简介<br>httplib库是一个以C++11特性编写的库，所以编译器也需要能支持C++11的。库在使用时只需包含一个头文件即可，非常方便。</p>\n<p>下载地址</p>\n<p>注意：此库为线程阻塞，使用时还请注意</p>\n<h2 id=\"jsoncpp库\"><a href=\"#jsoncpp库\" class=\"headerlink\" title=\"jsoncpp库\"></a>jsoncpp库</h2><p>#include &lt;json&#x2F;json.h&gt;</p>\n<h1 id=\"注释规范\"><a href=\"#注释规范\" class=\"headerlink\" title=\"注释规范\"></a>注释规范</h1><p>@brief  @param  @return @author @date @version是代码书写的一种规范<br>@brief  ：简介，简单介绍函数作用<br>@param  ：介绍函数参数<br>@return：函数返回类型说明<br>@exception NSException 可能抛出的异常.<br>@author zhangsan：  作者<br>@date 2011-07-27 22:30:00 ：时间<br>@version 1.0 ：版本<br>@property ：属性介绍</p>\n<h1 id=\"std-recursive-mutex\"><a href=\"#std-recursive-mutex\" class=\"headerlink\" title=\"std::recursive_mutex\"></a>std::recursive_mutex</h1><p>recursive_mutex</p>\n<h1 id=\"精确到ns的计时方法\"><a href=\"#精确到ns的计时方法\" class=\"headerlink\" title=\"精确到ns的计时方法\"></a>精确到ns的计时方法</h1><p>std::chrono</p>\n<h1 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h1><p>[C++ explicit 关键字]<a href=\"https://zhuanlan.zhihu.com/p/52152355\">https://zhuanlan.zhihu.com/p/52152355</a><br>[解决 VSCode 编写 C++11 代码报红问题]<a href=\"https://blog.csdn.net/weixin_42292229/article/details/113767569\">https://blog.csdn.net/weixin_42292229/article/details/113767569</a><br>[C++11 带来的新特性 （3）—— 关键字noexcept]<a href=\"https://www.cnblogs.com/sword03/p/10020344.html\">https://www.cnblogs.com/sword03/p/10020344.html</a><br>[C++ limits头文件的用法numeric_limits]<a href=\"https://blog.csdn.net/CHYabc123456hh/article/details/117260306\">https://blog.csdn.net/CHYabc123456hh/article/details/117260306</a><br>[C++中lock_guard的学习]<a href=\"https://blog.csdn.net/CHYabc123456hh/article/details/111317404\">https://blog.csdn.net/CHYabc123456hh/article/details/111317404</a><br>[C++ std::lock_guard详解]<a href=\"https://jishuin.proginn.com/p/763bfbd6f671\">https://jishuin.proginn.com/p/763bfbd6f671</a><br>[一文详解OpenCV中的CUDA模块]<a href=\"https://zhuanlan.zhihu.com/p/358648337\">https://zhuanlan.zhihu.com/p/358648337</a><br>[「直播回放」腾讯工程师：C++17在业务代码中最好用的十个特性]<a href=\"https://www.zhihu.com/zvideo/1523417372937027584\">https://www.zhihu.com/zvideo/1523417372937027584</a><br>[Qt开源作品21-日志重定向输出类]<a href=\"https://www.cnblogs.com/feiyangqingyun/p/12970350.html\">https://www.cnblogs.com/feiyangqingyun/p/12970350.html</a><br>[C++多线程之semaphore]<a href=\"https://blog.csdn.net/qq_41949047/article/details/108324225\">https://blog.csdn.net/qq_41949047/article/details/108324225</a><br>[C++11中enable_shared_from_this的用法解析]<a href=\"https://blog.csdn.net/breadheart/article/details/112451022\">https://blog.csdn.net/breadheart/article/details/112451022</a><br>[std::chrono::duration详解]<a href=\"https://blog.csdn.net/t114211200/article/details/78029553\">https://blog.csdn.net/t114211200/article/details/78029553</a><br>[C++ 11 多线程下std::unique_lock与std::lock_guard的区别和用法]<a href=\"http://t.zoukankan.com/moodlxs-p-10111843.html\">http://t.zoukankan.com/moodlxs-p-10111843.html</a><br>[C++ 条件变量(condition_variable)]<a href=\"https://cloud.tencent.com/developer/article/1584067\">https://cloud.tencent.com/developer/article/1584067</a><br>[httplib库的使用(支持http&#x2F;https)（一）]<a href=\"https://blog.csdn.net/harry49/article/details/115763383\">https://blog.csdn.net/harry49/article/details/115763383</a><br>[注释规范：详细]<a href=\"https://www.cnblogs.com/lyggqm/p/4629711.html\">https://www.cnblogs.com/lyggqm/p/4629711.html</a><br>[注释规范]<a href=\"https://blog.csdn.net/lxj362343/article/details/105711524/\">https://blog.csdn.net/lxj362343/article/details/105711524/</a><br>[C++11 新的计时方法——std::chrono 大法好]<a href=\"https://blog.csdn.net/u013390476/article/details/50209603\">https://blog.csdn.net/u013390476/article/details/50209603</a></p>\n","slug":"Grammar/Cpluspulus-Grammar","updated":"21/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/08/Grammar/Cpluspulus-Grammar/","excerpt":"","categories":[],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"vim 教程","date":"04/03/2022","path":"2022/03/04/Tutorial/vim-tutorial/","text":"第一部分：一般模式移动光标的方法 命令 解释 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 0 或功能键[Home] 移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 gg 移动到这个档案的第一行，相当于 1G (常用) n n 为数字。光标向下移动 n 行 搜索替换 命令 解释 &#x2F;word 向光标之下寻找一个名称为 word 的字符串 ?word 向光标之上寻找一个字符串名称为 word 的字符串 n 这个 n 是英文按键。代表重复前一个搜寻的动作 N 反向进行前一个搜寻动作 删除、复制与粘贴 命令 解释 dd 剪切游标所在的那一整行(常用) yy 复制游标所在的那一行(常用) p p 为将已复制的数据在光标下一行贴上 P P 则为贴在游标上一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 第二部分：一般模式切换到编辑模式 第三部分：一般模式切换到指令行模式 vim 环境的变更 命令 解释 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号 :set ff&#x3D;unix 改变vim文件中换行符的编码格式 复制粘贴全选（高亮显示）：按esc后，然后ggvG或者ggVG 全部复制：按esc后，然后ggyG 全部删除：按esc后，然后dG 解析： gg：是让光标移到首行，在vim才有效，vi中无效 v ： 是进入Visual(可视）模式 G ：光标移到最后一行 选中内容以后就可以其他的操作了，比如： d 删除选中内容 y 复制选中内容到0号寄存器 “+y 复制选中内容到＋寄存器，也就是系统的剪贴板，供其他程序用 全选（高亮显示）：按esc后，然后ggvG或者ggVG 全部复制：按esc后，然后ggyG 全部删除：按esc后，然后dGvim全选，全部复制，全部删除 https://blog.51cto.com/u_15127698/3564626https://www.runoob.com/linux/linux-vim.html","raw":"---\ntitle: vim 教程\ndate: 2022-03-04 15:01:03\ntags:\n- 教程\n---\n![VIM](https://s1.ax1x.com/2022/04/05/qXil1P.png)\n\n# 第一部分：一般模式\n## 移动光标的方法\n| 命令  | 解释 |\n| ------ | ------ |\n|[Ctrl] + [f]\t|屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)|\n|[Ctrl] + [b]\t|屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)|\n|[Ctrl] + [d]\t|屏幕『向下』移动半页|\n|[Ctrl] + [u]\t|屏幕『向上』移动半页|\n|h 或 向左箭头键(←) |\t光标向左移动一个字符|\n|j 或 向下箭头键(↓)\t|光标向下移动一个字符|\n|k 或 向上箭头键(↑)\t|光标向上移动一个字符|\n|l 或 向右箭头键(→)\t|光标向右移动一个字符|\n|0 或功能键[Home]\t|移动到这一行的最前面字符处 (常用)|\n|$ 或功能键[End]\t|移动到这一行的最后面字符处(常用)|\n|G\t|移动到这个档案的最后一行(常用)|\n|nG\tn |为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 |\n|gg|移动到这个档案的第一行，相当于 1G  (常用)|\n|n<Enter>\t|n 为数字。光标向下移动 n 行 |\n\n\n##  搜索替换\n| 命令 | 解释 |\n| ------ | ------ |\n|/word|\t向光标之下寻找一个名称为 word 的字符串|\n|?word\t|向光标之上寻找一个字符串名称为 word 的字符串|\n|n\t|这个 n 是英文按键。代表重复前一个搜寻的动作|\n|N\t|反向进行前一个搜寻动作|\n\n\n\n## 删除、复制与粘贴\n\n| 命令 | 解释 |\n| ------ | ------ |\n|dd\t|剪切游标所在的那一整行(常用)|\n|yy\t|复制游标所在的那一行(常用)|\n|p\t|p 为将已复制的数据在光标下一行贴上|\n|P      | P 则为贴在游标上一行|\n|c|\t重复删除多个数据，例如向下删除 10 行，[ 10cj ]|\n|u\t|复原前一个动作。(常用)|\n|[Ctrl]+r\t|重做上一个动作。(常用)|\n\n\n\n---\n# 第二部分：一般模式切换到编辑模式\n\n\n\n\n\n---\n# 第三部分：一般模式切换到指令行模式\n\n\n\n---\n\n# vim 环境的变更\n\n| 命令 | 解释 |\n| ------ | ------ |\n| :set nu| \t显示行号，设定之后，会在每一行的前缀显示该行的行号| \n| :set nonu\t| 与 set nu 相反，为取消行号| \n| :set ff=unix|改变vim文件中换行符的编码格式|\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---\n\n# 复制粘贴\n全选（高亮显示）：按esc后，然后ggvG或者ggVG\n\n全部复制：按esc后，然后ggyG\n\n全部删除：按esc后，然后dG\n\n\n解析：\n\ngg：是让光标移到首行，在vim才有效，vi中无效 \n\nv ： 是进入Visual(可视）模式 \n\nG ：光标移到最后一行 \n\n选中内容以后就可以其他的操作了，比如： \nd  删除选中内容 \ny  复制选中内容到0号寄存器 \n\"+y  复制选中内容到＋寄存器，也就是系统的剪贴板，供其他程序用 \n\n \n\n全选（高亮显示）：按esc后，然后ggvG或者ggVG\n\n全部复制：按esc后，然后ggyG\n\n全部删除：按esc后，然后dG\n-----------------------------------\nvim全选，全部复制，全部删除\n\n\n\n\n\n\nhttps://blog.51cto.com/u_15127698/3564626\nhttps://www.runoob.com/linux/linux-vim.html\n","content":"<p><img src=\"https://s1.ax1x.com/2022/04/05/qXil1P.png\" alt=\"VIM\"></p>\n<h1 id=\"第一部分：一般模式\"><a href=\"#第一部分：一般模式\" class=\"headerlink\" title=\"第一部分：一般模式\"></a>第一部分：一般模式</h1><h2 id=\"移动光标的方法\"><a href=\"#移动光标的方法\" class=\"headerlink\" title=\"移动光标的方法\"></a>移动光标的方法</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[Ctrl] + [f]</td>\n<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>\n</tr>\n<tr>\n<td>[Ctrl] + [b]</td>\n<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>\n</tr>\n<tr>\n<td>[Ctrl] + [d]</td>\n<td>屏幕『向下』移动半页</td>\n</tr>\n<tr>\n<td>[Ctrl] + [u]</td>\n<td>屏幕『向上』移动半页</td>\n</tr>\n<tr>\n<td>h 或 向左箭头键(←)</td>\n<td>光标向左移动一个字符</td>\n</tr>\n<tr>\n<td>j 或 向下箭头键(↓)</td>\n<td>光标向下移动一个字符</td>\n</tr>\n<tr>\n<td>k 或 向上箭头键(↑)</td>\n<td>光标向上移动一个字符</td>\n</tr>\n<tr>\n<td>l 或 向右箭头键(→)</td>\n<td>光标向右移动一个字符</td>\n</tr>\n<tr>\n<td>0 或功能键[Home]</td>\n<td>移动到这一行的最前面字符处 (常用)</td>\n</tr>\n<tr>\n<td>$ 或功能键[End]</td>\n<td>移动到这一行的最后面字符处(常用)</td>\n</tr>\n<tr>\n<td>G</td>\n<td>移动到这个档案的最后一行(常用)</td>\n</tr>\n<tr>\n<td>nG\tn</td>\n<td>为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20</td>\n</tr>\n<tr>\n<td>gg</td>\n<td>移动到这个档案的第一行，相当于 1G  (常用)</td>\n</tr>\n<tr>\n<td>n<Enter></td>\n<td>n 为数字。光标向下移动 n 行</td>\n</tr>\n</tbody></table>\n<h2 id=\"搜索替换\"><a href=\"#搜索替换\" class=\"headerlink\" title=\"搜索替换\"></a>搜索替换</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x2F;word</td>\n<td>向光标之下寻找一个名称为 word 的字符串</td>\n</tr>\n<tr>\n<td>?word</td>\n<td>向光标之上寻找一个字符串名称为 word 的字符串</td>\n</tr>\n<tr>\n<td>n</td>\n<td>这个 n 是英文按键。代表重复前一个搜寻的动作</td>\n</tr>\n<tr>\n<td>N</td>\n<td>反向进行前一个搜寻动作</td>\n</tr>\n</tbody></table>\n<h2 id=\"删除、复制与粘贴\"><a href=\"#删除、复制与粘贴\" class=\"headerlink\" title=\"删除、复制与粘贴\"></a>删除、复制与粘贴</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dd</td>\n<td>剪切游标所在的那一整行(常用)</td>\n</tr>\n<tr>\n<td>yy</td>\n<td>复制游标所在的那一行(常用)</td>\n</tr>\n<tr>\n<td>p</td>\n<td>p 为将已复制的数据在光标下一行贴上</td>\n</tr>\n<tr>\n<td>P</td>\n<td>P 则为贴在游标上一行</td>\n</tr>\n<tr>\n<td>c</td>\n<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>\n</tr>\n<tr>\n<td>u</td>\n<td>复原前一个动作。(常用)</td>\n</tr>\n<tr>\n<td>[Ctrl]+r</td>\n<td>重做上一个动作。(常用)</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"第二部分：一般模式切换到编辑模式\"><a href=\"#第二部分：一般模式切换到编辑模式\" class=\"headerlink\" title=\"第二部分：一般模式切换到编辑模式\"></a>第二部分：一般模式切换到编辑模式</h1><hr>\n<h1 id=\"第三部分：一般模式切换到指令行模式\"><a href=\"#第三部分：一般模式切换到指令行模式\" class=\"headerlink\" title=\"第三部分：一般模式切换到指令行模式\"></a>第三部分：一般模式切换到指令行模式</h1><hr>\n<h1 id=\"vim-环境的变更\"><a href=\"#vim-环境的变更\" class=\"headerlink\" title=\"vim 环境的变更\"></a>vim 环境的变更</h1><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>:set nu</td>\n<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>\n</tr>\n<tr>\n<td>:set nonu</td>\n<td>与 set nu 相反，为取消行号</td>\n</tr>\n<tr>\n<td>:set ff&#x3D;unix</td>\n<td>改变vim文件中换行符的编码格式</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"复制粘贴\"><a href=\"#复制粘贴\" class=\"headerlink\" title=\"复制粘贴\"></a>复制粘贴</h1><p>全选（高亮显示）：按esc后，然后ggvG或者ggVG</p>\n<p>全部复制：按esc后，然后ggyG</p>\n<p>全部删除：按esc后，然后dG</p>\n<p>解析：</p>\n<p>gg：是让光标移到首行，在vim才有效，vi中无效 </p>\n<p>v ： 是进入Visual(可视）模式 </p>\n<p>G ：光标移到最后一行 </p>\n<p>选中内容以后就可以其他的操作了，比如： <br>d  删除选中内容 <br>y  复制选中内容到0号寄存器 <br>“+y  复制选中内容到＋寄存器，也就是系统的剪贴板，供其他程序用 </p>\n<p> </p>\n<p>全选（高亮显示）：按esc后，然后ggvG或者ggVG</p>\n<p>全部复制：按esc后，然后ggyG</p>\n<h2 id=\"全部删除：按esc后，然后dG\"><a href=\"#全部删除：按esc后，然后dG\" class=\"headerlink\" title=\"全部删除：按esc后，然后dG\"></a>全部删除：按esc后，然后dG</h2><p>vim全选，全部复制，全部删除</p>\n<p><a href=\"https://blog.51cto.com/u_15127698/3564626\">https://blog.51cto.com/u_15127698/3564626</a><br><a href=\"https://www.runoob.com/linux/linux-vim.html\">https://www.runoob.com/linux/linux-vim.html</a></p>\n","slug":"Tutorial/vim-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/04/Tutorial/vim-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"ubuntu command","date":"03/03/2022","path":"2022/03/03/Brids-Linux-private-kitchen/ubuntu-command/","text":"查看脚本文件是dos还是unix查看脚本文件是dos格式还是unix格式，dos格式的文件行尾为^M$ ，unix格式的文件行尾为$cat -A filename把dos格式的文件转换为unix格式的文件dos2unix filename [ -d DIR ] 如果 FILE 存在且是一个目录则为真。[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真； 二、文件&#x2F;文件夹(目录)判断 [ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。[ -d DIR ] 如果 FILE 存在且是一个目录则为真。[ -e FILE ] 如果 FILE 存在则为真。[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。[ -r FILE ] 如果 FILE 存在且是可读的则为真。[ -s FILE ] 如果 FILE 存在且大小不为0则为真。[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。[ -w FILE ] 如果 FILE存在且是可写的则为真。[ -x FILE ] 如果 FILE 存在且是可执行的则为真。[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。 三、字符串判断 [ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；[ -n STRING ] 如果STRING的长度非零则为真 ，即判断是否为非空，非空即是真；[ STRING1 &#x3D; STRING2 ] 如果两个字符串相同则为真 ；[ STRING1 !&#x3D; STRING2 ] 如果字符串不相同则为真 ；[ STRING1 ] 如果字符串不为空则为真,与-n类似 开启摄像头cheese 显示系统进程显示系统进程 top 杀死这个进程号的进程 sudo kill pid 获取最高用户权限sudo -i 挂载和弹出U盘查看挂载情况df -h 挂载查看系统磁盘设备信息，并找到待U盘的目录(Linux系统中所有设备均被视为文件)fdisk -l#&#x2F;dev&#x2F;sdb1将U盘挂载到系统某个位置mount &#x2F;dev&#x2F;sdb1 &#x2F;mnt现在U盘所有文件被挂载到了&#x2F;mnt目录中，进入U盘目录查看内容cd &#x2F;mnt 弹出df 查看一下有没有usb设备在挂载使用umount &#x2F;dev&#x2F;sdb1 export 添加环境变量last 显示最近使用者的登录列表set 观察bash下的所有环境变量id vvv 查询是不是有这个用户alias 设置永久的alias别名unameuname -r 获取内核版本uname -v 可以查看版本号uname -a，可以看到操作系统的发行版号和操作系统版本lsb_release -a，查看发行版本信息，并且方法可以适用于所有的Linux发行版本cat &#x2F;etc&#x2F;issue可以查看到当前是Linux什么版本系统。cat &#x2F;proc&#x2F;version可以查看内核的版本号。 更改.&#x2F;.bashrc配置vim .&#x2F;.bashrcsource .&#x2F;.bashrc 批量改权限sudo chmod +x ~&#x2F;bin&#x2F;* bash快捷键 按键 功能 ALT+B 光标移动到所在单词词首 — — CTRL+C 停止当前运行的命令 CTRL+L 清空屏幕并重新显示当前行 CTRL+U 删除光标前的所有字符 CTRL+K 删除光标后的所有字符 CTRL+A 快速移动到行首 CTRL+E 移动到行末 CTRL+T 交换最后两个字符 重启命令： reboot shutdown -r now 立刻重启(root用户使用) shutdown -r 10 过10分钟自动重启(root用户使用) shutdown -r 20:35 在时间为20:35时候重启(root用户使用)如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启 关机命令： halt 立刻关机 poweroff 立刻关机 shutdown -h now 立刻关机(root用户使用) shutdown -h 10 10分钟后自动关机 关机前准备who 查看谁在线netstat -a 网络的联机状态ps -aux 后台的使用情况dmesg 查看内核信息查看电脑是否支持虚拟化技术通过lscpu命令lscpu命令是一种提取有关CPU体系结构信息的常用方法。此命令从sysfs的&#x2F;pro &#x2F;cpuinfo文件中提取硬件信息。该信息包括处理器数量，CPU操作模式，套接字，内核，线程，型号名称和虚拟化信息等。 通过cpu-checker实用程序 sudo apt-get install cpu-checker sudo kvm-ok 查看系统位数 file &#x2F;bin&#x2F;ls vmstat 命令功能说明： 命令报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息du(disk usage) 命令功能说明：统计目录(或文件)所占磁盘空间的大小 qemu-kvm - 为 KVM 管理程序提供硬件模拟的软件程序libvirt-daemon-system - 将 libvirt 守护程序作为系统服务运行的配置文件libvirt-clients - 用来管理虚拟化平台的软件bridge-utils - 用来配置网络桥接的命令行工具virtinst - 用来创建虚拟机的命令行工具virt-manager - 提供一个易用的图形界面，并且通过libvirt 支持用于管理虚拟机的命令行工具 查看电量sudo apt-get install acpi使用acpi命令行工具查看电池是否在充电，剩余电量百分比，具体剩余时间，使用命令acpi[matrix@localhost ~]$ acpiBattery 0: Discharging, 33%, 00:44:53 remaining如果你要看更多的信息，如电池总容量、温度等信息，使用acpi -V命令 使用IBAM检测电池用量IBAM自称为“智能的电池监测器” upower –dump | grep –color&#x3D;never -E “state|to\\ full|to\\ empty|percentage” systemctl isolate multi-user.target systemctl isolate graphical.target 目录 用途 &#x2F; 虚拟目录的根目录，万物起源。通常不会在这里存储文件 &#x2F;bin 二进制目录，存放许多用户级的GNU工具 &#x2F;boot 启动目录，包含Linux内核，存放启动文件 &#x2F;boot&#x2F;grub&#x2F;grub.conf or menu.lst 被用来配置启动加载程序 &#x2F;boot&#x2F;vmlinuz Linux 内核 &#x2F;dev 设备目录，Linux在这里创建设备节点 &#x2F;etc 系统配置文件目录，也包含一系列的shell脚本 &#x2F;etc&#x2F;crontab 定义自动运行的任务 &#x2F;etc&#x2F;fstab 包含存储设备的列表，以及与他们相关的挂载点 &#x2F;etc&#x2F;passwd 包含用户帐号列表 &#x2F;home 主目录，Linux在这 里创建用户目录 &#x2F;lib 库目录，存放系统和应用程序的库文件 &#x2F;media 媒体目录，可移动媒体设备的常用挂载点 &#x2F;mnt 挂载目录，另一个可移动媒体设备的常用挂载点 &#x2F;opt 可选目录，常用于存放第三方软件包和数据文件 &#x2F;proc 进程目录，存放现有硬件及当前进程的相关信息 &#x2F;root root用户的主目录 &#x2F;sbin 系统二进制目录，存放许多GNU管理员级工具 &#x2F;run 运行目录，存放系统运作时的运行时数据 &#x2F;srv 服务目录，存放本地服务的相关文件 &#x2F;sys 系统目录，存放系统硬件信息的相关文件 &#x2F;tmp 临时目录，可以在该目录中创建和删除临时工作文件 &#x2F;usr 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里，它可能是Linux系统中最大的一个 &#x2F;usr&#x2F;bin 包含系统安装的可执行程序，通常会包含许多程序 &#x2F;usr&#x2F;lib 包含由&#x2F;usr&#x2F;bin目录中的程序所用的共享库 &#x2F;usr&#x2F;local 非系统发行版自带却打算让系统使用的程序的安装目录 &#x2F;usr&#x2F;sbin 包含许多系统管理程序 &#x2F;usr&#x2F;share 包含许多由&#x2F;usr&#x2F;bin目录中的程序使用的共享数据，其中包括像默认的配置文件、图标、桌面背景、音频文件等等 &#x2F;usr&#x2F;share&#x2F;doc 大多数安装在系统中的软件包会包含一些文档 &#x2F;var 可变目录，用以存放经常变化的文件，比如日志文件 常用的库GCC multilib主要是用于支持交叉编译（cross compiling），即编译出来的程序是用来在其他处理器平台上运行的。例如可以在x86 64位处理器上编译出x86 32位程序，运行在32位处理器上，或者在x86平台上编译出可以在ARM处理器上运行的程序 build-essentialUbuntu缺省情况下，并没有提供C&#x2F;C++的编译环境，因此还需要手动安装。但是如果单独安装gcc以及g++比较麻烦，幸运的是，Ubuntu提供了一个build-essential软件包。查看该软件包的依赖关系： libtool 是一个通用库支持脚本，将使用动态库的复杂性隐藏在统一、可移植的接口中，也就是说，你可以通过如下所示的标准方法，在不同平台上创建并调用动态库，我们 可以认为libtool是gcc的一个抽象，也就是说，它包装了gcc或者其他的任何编译器，用户无需知道细节，只要告诉libtool说我需要要编译哪 些库即可，并且，它只与libtool文件打交道，例如lo、la为后缀的文件。 dpkg 包管理工具 dpkg -l dpkg -l | grep mysql*dpkg -l “mysql*” sudo dpkg -r vimdpkg -l “mysql“ 第一种方法：df命令df -hT第二种方法：使用mount命令mount -l第三种方法：查看文件&#x2F;etc&#x2F;mtab。cat &#x2F;etc&#x2F;mtab第四种方法：使用lsblk命令查看lsblk -P查看端口号netstat -tunpl | grep 端口号 chronyChrony是一个开源自由的网络时间协议 NTP 的客户端和服务器软软件。它能让计算机保持系统时钟与时钟服务器（NTP）同步，因此让你的计算机保持精确的时间，Chrony也可以作为服务端软件为其他计算机提供时间同步服务。 modprobemodprobe命令用于智能地向内核中加载模块或者从内核中移除模块。 modprobe -Vkmod version 27+XZ -ZLIB +LIBCRYPTO -EXPERIMENTAL 加载模型modprobe sysrq都从这个路径下加载&#x2F;lib&#x2F;modules&#x2F;error:modprobe: FATAL: Module sysrq not found in directory &#x2F;lib&#x2F;modules&#x2F;5.10.16.3-microsoft-standard-WSL2 lsmod查看已加载的内核模块信息 sudo insmod hello.ko &#x2F;&#x2F;插入模块sudo rmmode hello &#x2F;&#x2F; 卸载模块modinfo hello.ko &#x2F;&#x2F; 查看模块信息lsmod &#x2F;&#x2F;查看系统模块dmesg &#x2F;&#x2F; 查看系统日志信息 systemctl-p 从指定文件夹加载sysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;my-default.conf 查看进程ps -a which systmd查看状态sysctl docker status wget https://github.com/microsoft/WSL2-Linux-Kernel/archive/refs/tags/linux-msft-5.4.72.tar.gz modprobe br_netfilterlinux透明防火墙–br_netfilter 更新内核查看内核是否存在apt-cache search linux | grep “linux-buildinfo-5.4.0-122-generic”寻找内核是否存在apt search ‘linux-image-5.4.0-122-generic’ apt install ‘linux-image-5.4.0-122-generic’sudo update-initramfs -u -k allsudo update-grub sudo update-initramfs -u -k all lsofswapoffLinux swapoff命令用于关闭系统交换区(swap area)。-a 将&#x2F;etc&#x2F;fstab文件中所有设置为swap的设备关闭-h 帮助信息-V 版本信息 free -h查看交换区 sudo -i 切换用户身份到root. mountmount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。 mount -t glusterfs 查看时间date \\cp不会询问是否覆盖\\cp &#x2F;app&#x2F;WEB-INF&#x2F;com&#x2F;cfg.properties &#x2F;app_bak&#x2F;WEB-INF&#x2F;com&#x2F;cfg.properties crontab 是用来定期执行程序的命令crontab 命令crontab 命令需要 crond 服务支持crond 是 Linux 下用来周期地执行某种任务或等待处理某些事件的一个守护进程，和 Windows 中的计划任务有些类似。 当安装完成操作系统之后，默认便会启动此任务调度命令。 crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。 注意：新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。 而 linux 任务调度的工作主要分为以下两类： 1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存2、个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置 apt-get install cron 安装crontab -l 列出目前的时程表，检查是否安装成功cat &#x2F;etc&#x2F;crontab 输出使用说明service crond status查看服务状态 ubuntu上的crond名称为cron没有d星号（*）：代表所有可能的值，如month字段为星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”正斜线（&#x2F;）：可以用正斜线指定时间的间隔频率，例如“0-23&#x2F;2”表示每两小时执行一次。 看内存使用情况free -h 查看ubuntu下都开启了哪些服务service –status-all systemctl pstree 列出当前目录的隐藏权限lsattr date +%Y%m%d_%H%M%S 轮循任务readlinkreadlink是Linux系统中一个常用工具，主要用来找出符号链接所指向的位置。 echo “shell脚本本身的名字: $0”echo “传给shell的第一个参数: $1”echo “传给shell的第二个参数: $2” 一、dirname命令dirname命令去除文件名中的非目录部分，仅显示与目录有关的内容。dirname命令读取指定路径名保留最后一个&#x2F;及其后面的字符，删除其他部分，并写结果到标准输出。如果最后一个&#x2F;后无字符，dirname 命令使用倒数第二个&#x2F;，并忽略其后的所有字符。dirname 和 basename 通常在 shell 内部命令替换使用，以指定一个与指定输入文件名略有差异的输出文件名。 sed选项 -e是编辑命令，用于sed执行多个编辑任务的情况下。在下一行开始编辑前，所有的编辑动作将应用到模式缓冲区中的行上。 sed -e ‘1,10d’ -e ‘s&#x2F;My&#x2F;Your&#x2F;g’ datafile #选项-e用于进行多重编辑。第一重编辑删除第1-3行。第二重编辑将出现的所有My替换为Your。因为是逐行进行这两项编辑（即这两个命令都在模式空间的当前行上执行），所以编辑命令的顺序会影响结果。 ls -t $DIR&#x2F;*_timedata.db | sed -e ‘1,10d’ | xargs rm按时间排序，1-10行删除掉 查看时区timedatectl timedatectl list-timezones 参考文献[查看linux用户密码]https://blog.csdn.net/feikillyou/article/details/109129870[chrony]https://www.cnblogs.com/my-show-time/p/14658895.html[linux kernel文档]https://www.kernel.org/doc/html/v5.4/admin-guide/sysctl/kernel.html[lsof]https://www.cnblogs.com/bangerlee/archive/2012/05/03/2464495.html[strace]https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html[Linux crontab命令详解-博客]https://www.cnblogs.com/ftl1012/p/crontab.html[Linux Crontab定时任务-菜鸟教程]https://www.runoob.com/w3cnote/linux-crontab-tasks.html[systemd]https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html[linux下计划任务学习记录 ]https://blog.51cto.com/u_15060465/4164796[xargs]https://ruanyifeng.com/blog/2019/08/xargs-tutorial.html[用history查看历史命令]https://blog.csdn.net/qq_34243930/article/details/107007654[让 history 命令显示日期和时间]https://zhuanlan.zhihu.com/p/99818664[环境变量HISTCONTROL命令及对快捷键Ctrl+o命令的影响]https://blog.csdn.net/weixin_30723433/article/details/96641179","raw":"---\ntitle: ubuntu command\ndate: 2022-03-03 22:03:11\ntags:\n- 鸟哥的Linux私房菜\n---\n\n\n# 查看脚本文件是dos还是unix\n\n查看脚本文件是dos格式还是unix格式，dos格式的文件行尾为^M$ ，unix格式的文件行尾为$\ncat -A filename\n把dos格式的文件转换为unix格式的文件\ndos2unix filename\n\n[ -d DIR ] 如果 FILE 存在且是一个目录则为真。\n[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；\n\n二、文件/文件夹(目录)判断\n\n[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。\n[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。\n[ -d DIR ] 如果 FILE 存在且是一个目录则为真。\n[ -e FILE ] 如果 FILE 存在则为真。\n[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。\n[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。\n[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。\n[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。\n[ -r FILE ] 如果 FILE 存在且是可读的则为真。\n[ -s FILE ] 如果 FILE 存在且大小不为0则为真。\n[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。\n[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。\n[ -w FILE ] 如果 FILE存在且是可写的则为真。\n[ -x FILE ] 如果 FILE 存在且是可执行的则为真。\n[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。\n[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。\n[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。\n[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。\n[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。\n[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。\n[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。\n[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。\n\n三、字符串判断\n\n[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；\n[ -n STRING ] 如果STRING的长度非零则为真 ，即判断是否为非空，非空即是真；\n[ STRING1 = STRING2 ] 如果两个字符串相同则为真 ；\n[ STRING1 != STRING2 ] 如果字符串不相同则为真 ；\n[ STRING1 ]　 如果字符串不为空则为真,与-n类似\n\n\n\n# 开启摄像头\n\n\ncheese\n\n\n# 显示系统进程\n\n显示系统进程 top\n\n杀死这个进程号的进程 sudo kill pid\n\n\n# 获取最高用户权限\n\nsudo -i\n\n# 挂载和弹出U盘\n查看挂载情况\ndf -h\n## 挂载\n查看系统磁盘设备信息，并找到待U盘的目录(Linux系统中所有设备均被视为文件)\nfdisk -l\n#/dev/sdb1\n将U盘挂载到系统某个位置\nmount /dev/sdb1 /mnt\n现在U盘所有文件被挂载到了/mnt目录中，进入U盘目录查看内容\ncd /mnt\n\n## 弹出\ndf 查看一下有没有usb设备在挂载使用\numount /dev/sdb1\n\n\n# export  添加环境变量\n\n# last 显示最近使用者的登录列表\n\n# set 观察bash下的所有环境变量\n\n\n# id vvv 查询是不是有这个用户\n\n# alias 设置永久的alias别名\n\n# uname\nuname -r 获取内核版本\nuname -v 可以查看版本号\nuname -a，可以看到操作系统的发行版号和操作系统版本\nlsb_release -a，查看发行版本信息，并且方法可以适用于所有的Linux发行版本\ncat /etc/issue可以查看到当前是Linux什么版本系统。\ncat /proc/version可以查看内核的版本号。\n\n# 更改./.bashrc配置\n\nvim ./.bashrc\nsource ./.bashrc\n\n# 批量改权限\nsudo chmod +x ~/bin/*\n\n\n# bash快捷键\n|按键|功能|\n|---|---|\n|ALT+B | 光标移动到所在单词词首|\n|---|---|\nCTRL+C | 停止当前运行的命令|\n|CTRL+L | 清空屏幕并重新显示当前行|\n|CTRL+U | 删除光标前的所有字符|\n|CTRL+K | 删除光标后的所有字符|\n|CTRL+A | 快速移动到行首|\n|CTRL+E | 移动到行末|\n|CTRL+T | 交换最后两个字符|\n\n\n\n# 重启命令：\n1. reboot\n2. shutdown -r now 立刻重启(root用户使用)\n3. shutdown -r 10 过10分钟自动重启(root用户使用)\n4. shutdown -r 20:35 在时间为20:35时候重启(root用户使用)\n如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启\n\n# 关机命令：\n1. halt   立刻关机\n2. poweroff 立刻关机\n3. shutdown -h now 立刻关机(root用户使用)\n4. shutdown -h 10 10分钟后自动关机\n\n\n# 关机前准备\n\n# who 查看谁在线\n\n# netstat -a 网络的联机状态\n\n# ps -aux 后台的使用情况\n\n# dmesg 查看内核信息\n\n\n# 查看电脑是否支持虚拟化技术\n## 通过lscpu命令\nlscpu命令是一种提取有关CPU体系结构信息的常用方法。此命令从sysfs的/pro /cpuinfo文件中提取硬件信息。该信息包括处理器数量，CPU操作模式，套接字，内核，线程，型号名称和虚拟化信息等。\n\n## 通过cpu-checker实用程序\n sudo apt-get install cpu-checker\n\n sudo kvm-ok\n\n# 查看系统位数\n file /bin/ls\n\n# vmstat 命令功能说明： 命令报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息\n\n\n# du(disk usage) 命令功能说明：统计目录(或文件)所占磁盘空间的大小\n qemu-kvm - 为 KVM 管理程序提供硬件模拟的软件程序\nlibvirt-daemon-system - 将 libvirt 守护程序作为系统服务运行的配置文件\nlibvirt-clients - 用来管理虚拟化平台的软件\nbridge-utils - 用来配置网络桥接的命令行工具\nvirtinst - 用来创建虚拟机的命令行工具\nvirt-manager - 提供一个易用的图形界面，并且通过libvirt 支持用于管理虚拟机的命令行工具\n\n\n# 查看电量\nsudo apt-get install acpi\n使用acpi命令行工具\n查看电池是否在充电，剩余电量百分比，具体剩余时间，使用命令acpi\n[matrix@localhost ~]$ acpi\nBattery 0: Discharging, 33%, 00:44:53 remaining\n如果你要看更多的信息，如电池总容量、温度等信息，使用acpi -V命令\n\n\n使用IBAM检测电池用量\nIBAM自称为“智能的电池监测器”\n\n\n\nupower --dump | grep --color=never -E \"state|to\\ full|to\\ empty|percentage\"\n\n\n\n systemctl isolate multi-user.target\n \n  systemctl isolate graphical.target\n\n|目录|\t用途|\n|---|---|\n|/|\t虚拟目录的根目录，万物起源。通常不会在这里存储文件|\n|/bin\t|二进制目录，存放许多用户级的GNU工具|\n|/boot\t|启动目录，包含Linux内核，存放启动文件|\n|/boot/grub/grub.conf or menu.lst|被用来配置启动加载程序|\n|/boot/vmlinuz|Linux 内核|\n|/dev\t|设备目录，Linux在这里创建设备节点|\n|/etc\t|系统配置文件目录，也包含一系列的shell脚本|\n|/etc/crontab|定义自动运行的任务\n|/etc/fstab|包含存储设备的列表，以及与他们相关的挂载点\n|/etc/passwd|包含用户帐号列表\n|/home\t|主目录，Linux在这 里创建用户目录|\n|/lib\t|库目录，存放系统和应用程序的库文件|\n|/media\t|媒体目录，可移动媒体设备的常用挂载点|\n|/mnt\t|挂载目录，另一个可移动媒体设备的常用挂载点|\n|/opt\t|可选目录，常用于存放第三方软件包和数据文件|\n|/proc\t|进程目录，存放现有硬件及当前进程的相关信息|\n|/root\t|root用户的主目录|\n|/sbin\t|系统二进制目录，存放许多GNU管理员级工具|\n|/run\t|运行目录，存放系统运作时的运行时数据|\n|/srv\t|服务目录，存放本地服务的相关文件|\n|/sys\t|系统目录，存放系统硬件信息的相关文件|\n|/tmp\t|临时目录，可以在该目录中创建和删除临时工作文件|\n|/usr\t|用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里，它可能是Linux系统中最大的一个\n|/usr/bin|包含系统安装的可执行程序，通常会包含许多程序\n|/usr/lib|包含由/usr/bin目录中的程序所用的共享库\n|/usr/local|非系统发行版自带却打算让系统使用的程序的安装目录\n|/usr/sbin|包含许多系统管理程序\n|/usr/share|包含许多由/usr/bin目录中的程序使用的共享数据，其中包括像默认的配置文件、图标、桌面背景、音频文件等等\n/usr/share/doc|大多数安装在系统中的软件包会包含一些文档|\n|/var\t|可变目录，用以存放经常变化的文件，比如日志文件\n\n\n# 常用的库\n\nGCC multilib主要是用于支持交叉编译（cross compiling），即编译出来的程序是用来在其他处理器平台上运行的。例如可以在x86 64位处理器上编译出x86 32位程序，运行在32位处理器上，或者在x86平台上编译出可以在ARM处理器上运行的程序\n\nbuild-essential\nUbuntu缺省情况下，并没有提供C/C++的编译环境，因此还需要手动安装。但是如果单独安装gcc以及g++比较麻烦，幸运的是，Ubuntu提供了一个build-essential软件包。查看该软件包的依赖关系：\n\n\nlibtool 是一个通用库支持脚本，将使用动态库的复杂性隐藏在统一、可移植的接口中，也就是说，你可以通过如下所示的标准方法，在不同平台上创建并调用动态库，我们 可以认为libtool是gcc的一个抽象，也就是说，它包装了gcc或者其他的任何编译器，用户无需知道细节，只要告诉libtool说我需要要编译哪 些库即可，并且，它只与libtool文件打交道，例如lo、la为后缀的文件。\n\n\ndpkg 包管理工具\n\ndpkg -l\n\ndpkg -l | grep mysql*\ndpkg -l \"mysql*\"\n\nsudo dpkg -r vim\ndpkg -l \"*mysql*\"\n\n\n\n# 第一种方法：df命令\n# df -hT\n\n# 第二种方法：使用mount命令\n# mount -l\n\n# 第三种方法：查看文件/etc/mtab。\n# cat /etc/mtab\n\n# 第四种方法：使用lsblk命令查看\n# lsblk -P\n\n# 查看端口号\nnetstat -tunpl | grep 端口号\n\n\n\n# chrony\n\nChrony是一个开源自由的网络时间协议 NTP 的客户端和服务器软软件。它能让计算机保持系统时钟与时钟服务器（NTP）同步，因此让你的计算机保持精确的时间，Chrony也可以作为服务端软件为其他计算机提供时间同步服务。\n\n\n# modprobe \nmodprobe命令用于智能地向内核中加载模块或者从内核中移除模块。\n\n\nmodprobe -V\nkmod version 27\n+XZ -ZLIB +LIBCRYPTO -EXPERIMENTAL\n\n加载模型\nmodprobe sysrq\n都从这个路径下加载\n/lib/modules/\nerror:\nmodprobe: FATAL: Module sysrq not found in directory /lib/modules/5.10.16.3-microsoft-standard-WSL2\n\n# lsmod\n查看已加载的内核模块信息\n\nsudo insmod hello.ko  //插入模块\nsudo rmmode hello // 卸载模块\nmodinfo hello.ko // 查看模块信息\nlsmod //查看系统模块\ndmesg // 查看系统日志信息\n\n\n# systemctl \n\n-p 从指定文件夹加载\nsysctl -p /etc/sysctl.d/my-default.conf\n\n\n查看进程\nps -a \n\nwhich systmd\n查看状态\nsysctl docker status\n\n\n\n\nwget https://github.com/microsoft/WSL2-Linux-Kernel/archive/refs/tags/linux-msft-5.4.72.tar.gz\n\n\n# modprobe br_netfilter\nlinux透明防火墙--br_netfilter\n\n\n\n# 更新内核\n查看内核是否存在\napt-cache search linux | grep \"linux-buildinfo-5.4.0-122-generic\"\n寻找内核是否存在\napt search 'linux-image-5.4.0-122-generic'\n\napt install 'linux-image-5.4.0-122-generic'\nsudo update-initramfs -u -k all\nsudo update-grub\n\nsudo update-initramfs -u -k all\n\n# lsof\n\n# swapoff\nLinux swapoff命令用于关闭系统交换区(swap area)。\n-a 将/etc/fstab文件中所有设置为swap的设备关闭\n-h 帮助信息\n-V 版本信息\n\n\n# free -h\n\n查看交换区\n\nsudo -i 切换用户身份到root.\n\n\n# mount\nmount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。\n-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。\n mount -t glusterfs\n\n\n# 查看时间\ndate\n\n# \\cp\n不会询问是否覆盖\n\\cp /app/WEB-INF/com/cfg.properties /app_bak/WEB-INF/com/cfg.properties \n\n# crontab 是用来定期执行程序的命令\ncrontab 命令\ncrontab 命令需要 crond 服务支持\ncrond 是 Linux 下用来周期地执行某种任务或等待处理某些事件的一个守护进程，和 Windows 中的计划任务有些类似。\n\n当安装完成操作系统之后，默认便会启动此任务调度命令。\n\ncrond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。\n\n注意：新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。\n\n而 linux 任务调度的工作主要分为以下两类：\n\n1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存\n2、个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置\n\napt-get install cron 安装\ncrontab -l 列出目前的时程表，检查是否安装成功\ncat /etc/crontab 输出使用说明\nservice crond status查看服务状态\n\nubuntu上的crond名称为cron没有d\n星号（*）：代表所有可能的值，如month字段为星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。\n逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”\n中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”\n正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。\n\n\n\n# 看内存使用情况\nfree -h\n\n\n\n# 查看ubuntu下都开启了哪些服务\n\nservice --status-all\n\nsystemctl\n\npstree\n\n\n# 列出当前目录的隐藏权限\nlsattr \n\n\ndate +%Y%m%d_%H%M%S\n\n\n# 轮循任务\n\n\n# readlink\nreadlink是Linux系统中一个常用工具，主要用来找出符号链接所指向的位置。\n\n\necho \"shell脚本本身的名字: $0\"\necho \"传给shell的第一个参数: $1\"\necho \"传给shell的第二个参数: $2\"\n\n\n\n一、dirname命令\ndirname命令去除文件名中的非目录部分，仅显示与目录有关的内容。dirname命令读取指定路径名保留最后一个/及其后面的字符，删除其他部分，并写结果到标准输出。如果最后一个/后无字符，dirname 命令使用倒数第二个/，并忽略其后的所有字符。dirname 和 basename 通常在 shell 内部命令替换使用，以指定一个与指定输入文件名略有差异的输出文件名。\n\n\n\n# sed \n选项\n\n-e是编辑命令，用于sed执行多个编辑任务的情况下。在下一行开始编辑前，所有的编辑动作将应用到模式缓冲区中的行上。\n\nsed -e '1,10d' -e 's/My/Your/g' datafile\n\n#选项-e用于进行多重编辑。第一重编辑删除第1-3行。第二重编辑将出现的所有My替换为Your。因为是逐行进行这两项编辑（即这两个命令都在模式空间的当前行上执行），所以编辑命令的顺序会影响结果。\n\n\nls -t $DIR/*_timedata.db | sed -e '1,10d' | xargs rm\n按时间排序，1-10行删除掉\n\n\n\n\n\n# 查看时区\n\ntimedatectl\n\ntimedatectl list-timezones\n\n\n# 参考文献\n[查看linux用户密码]https://blog.csdn.net/feikillyou/article/details/109129870\n[chrony]https://www.cnblogs.com/my-show-time/p/14658895.html\n[linux kernel文档]https://www.kernel.org/doc/html/v5.4/admin-guide/sysctl/kernel.html\n[lsof]https://www.cnblogs.com/bangerlee/archive/2012/05/03/2464495.html\n[strace]https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html\n[Linux crontab命令详解-博客]https://www.cnblogs.com/ftl1012/p/crontab.html\n[Linux Crontab定时任务-菜鸟教程]https://www.runoob.com/w3cnote/linux-crontab-tasks.html\n[systemd]https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html\n[linux下计划任务学习记录 ]https://blog.51cto.com/u_15060465/4164796\n[xargs]https://ruanyifeng.com/blog/2019/08/xargs-tutorial.html\n[用history查看历史命令]https://blog.csdn.net/qq_34243930/article/details/107007654\n[让 history 命令显示日期和时间]https://zhuanlan.zhihu.com/p/99818664\n[环境变量HISTCONTROL命令及对快捷键Ctrl+o命令的影响]https://blog.csdn.net/weixin_30723433/article/details/96641179\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"查看脚本文件是dos还是unix\"><a href=\"#查看脚本文件是dos还是unix\" class=\"headerlink\" title=\"查看脚本文件是dos还是unix\"></a>查看脚本文件是dos还是unix</h1><p>查看脚本文件是dos格式还是unix格式，dos格式的文件行尾为^M$ ，unix格式的文件行尾为$<br>cat -A filename<br>把dos格式的文件转换为unix格式的文件<br>dos2unix filename</p>\n<p>[ -d DIR ] 如果 FILE 存在且是一个目录则为真。<br>[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；</p>\n<p>二、文件&#x2F;文件夹(目录)判断</p>\n<p>[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。<br>[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。<br>[ -d DIR ] 如果 FILE 存在且是一个目录则为真。<br>[ -e FILE ] 如果 FILE 存在则为真。<br>[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。<br>[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。<br>[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。<br>[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。<br>[ -r FILE ] 如果 FILE 存在且是可读的则为真。<br>[ -s FILE ] 如果 FILE 存在且大小不为0则为真。<br>[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。<br>[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。<br>[ -w FILE ] 如果 FILE存在且是可写的则为真。<br>[ -x FILE ] 如果 FILE 存在且是可执行的则为真。<br>[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。<br>[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。<br>[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。<br>[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。<br>[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。<br>[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。<br>[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。<br>[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。</p>\n<p>三、字符串判断</p>\n<p>[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；<br>[ -n STRING ] 如果STRING的长度非零则为真 ，即判断是否为非空，非空即是真；<br>[ STRING1 &#x3D; STRING2 ] 如果两个字符串相同则为真 ；<br>[ STRING1 !&#x3D; STRING2 ] 如果字符串不相同则为真 ；<br>[ STRING1 ]　 如果字符串不为空则为真,与-n类似</p>\n<h1 id=\"开启摄像头\"><a href=\"#开启摄像头\" class=\"headerlink\" title=\"开启摄像头\"></a>开启摄像头</h1><p>cheese</p>\n<h1 id=\"显示系统进程\"><a href=\"#显示系统进程\" class=\"headerlink\" title=\"显示系统进程\"></a>显示系统进程</h1><p>显示系统进程 top</p>\n<p>杀死这个进程号的进程 sudo kill pid</p>\n<h1 id=\"获取最高用户权限\"><a href=\"#获取最高用户权限\" class=\"headerlink\" title=\"获取最高用户权限\"></a>获取最高用户权限</h1><p>sudo -i</p>\n<h1 id=\"挂载和弹出U盘\"><a href=\"#挂载和弹出U盘\" class=\"headerlink\" title=\"挂载和弹出U盘\"></a>挂载和弹出U盘</h1><p>查看挂载情况<br>df -h</p>\n<h2 id=\"挂载\"><a href=\"#挂载\" class=\"headerlink\" title=\"挂载\"></a>挂载</h2><p>查看系统磁盘设备信息，并找到待U盘的目录(Linux系统中所有设备均被视为文件)<br>fdisk -l<br>#&#x2F;dev&#x2F;sdb1<br>将U盘挂载到系统某个位置<br>mount &#x2F;dev&#x2F;sdb1 &#x2F;mnt<br>现在U盘所有文件被挂载到了&#x2F;mnt目录中，进入U盘目录查看内容<br>cd &#x2F;mnt</p>\n<h2 id=\"弹出\"><a href=\"#弹出\" class=\"headerlink\" title=\"弹出\"></a>弹出</h2><p>df 查看一下有没有usb设备在挂载使用<br>umount &#x2F;dev&#x2F;sdb1</p>\n<h1 id=\"export-添加环境变量\"><a href=\"#export-添加环境变量\" class=\"headerlink\" title=\"export  添加环境变量\"></a>export  添加环境变量</h1><h1 id=\"last-显示最近使用者的登录列表\"><a href=\"#last-显示最近使用者的登录列表\" class=\"headerlink\" title=\"last 显示最近使用者的登录列表\"></a>last 显示最近使用者的登录列表</h1><h1 id=\"set-观察bash下的所有环境变量\"><a href=\"#set-观察bash下的所有环境变量\" class=\"headerlink\" title=\"set 观察bash下的所有环境变量\"></a>set 观察bash下的所有环境变量</h1><h1 id=\"id-vvv-查询是不是有这个用户\"><a href=\"#id-vvv-查询是不是有这个用户\" class=\"headerlink\" title=\"id vvv 查询是不是有这个用户\"></a>id vvv 查询是不是有这个用户</h1><h1 id=\"alias-设置永久的alias别名\"><a href=\"#alias-设置永久的alias别名\" class=\"headerlink\" title=\"alias 设置永久的alias别名\"></a>alias 设置永久的alias别名</h1><h1 id=\"uname\"><a href=\"#uname\" class=\"headerlink\" title=\"uname\"></a>uname</h1><p>uname -r 获取内核版本<br>uname -v 可以查看版本号<br>uname -a，可以看到操作系统的发行版号和操作系统版本<br>lsb_release -a，查看发行版本信息，并且方法可以适用于所有的Linux发行版本<br>cat &#x2F;etc&#x2F;issue可以查看到当前是Linux什么版本系统。<br>cat &#x2F;proc&#x2F;version可以查看内核的版本号。</p>\n<h1 id=\"更改-x2F-bashrc配置\"><a href=\"#更改-x2F-bashrc配置\" class=\"headerlink\" title=\"更改.&#x2F;.bashrc配置\"></a>更改.&#x2F;.bashrc配置</h1><p>vim .&#x2F;.bashrc<br>source .&#x2F;.bashrc</p>\n<h1 id=\"批量改权限\"><a href=\"#批量改权限\" class=\"headerlink\" title=\"批量改权限\"></a>批量改权限</h1><p>sudo chmod +x ~&#x2F;bin&#x2F;*</p>\n<h1 id=\"bash快捷键\"><a href=\"#bash快捷键\" class=\"headerlink\" title=\"bash快捷键\"></a>bash快捷键</h1><table>\n<thead>\n<tr>\n<th>按键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ALT+B</td>\n<td>光标移动到所在单词词首</td>\n</tr>\n<tr>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td>CTRL+C</td>\n<td>停止当前运行的命令</td>\n</tr>\n<tr>\n<td>CTRL+L</td>\n<td>清空屏幕并重新显示当前行</td>\n</tr>\n<tr>\n<td>CTRL+U</td>\n<td>删除光标前的所有字符</td>\n</tr>\n<tr>\n<td>CTRL+K</td>\n<td>删除光标后的所有字符</td>\n</tr>\n<tr>\n<td>CTRL+A</td>\n<td>快速移动到行首</td>\n</tr>\n<tr>\n<td>CTRL+E</td>\n<td>移动到行末</td>\n</tr>\n<tr>\n<td>CTRL+T</td>\n<td>交换最后两个字符</td>\n</tr>\n</tbody></table>\n<h1 id=\"重启命令：\"><a href=\"#重启命令：\" class=\"headerlink\" title=\"重启命令：\"></a>重启命令：</h1><ol>\n<li>reboot</li>\n<li>shutdown -r now 立刻重启(root用户使用)</li>\n<li>shutdown -r 10 过10分钟自动重启(root用户使用)</li>\n<li>shutdown -r 20:35 在时间为20:35时候重启(root用户使用)<br>如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启</li>\n</ol>\n<h1 id=\"关机命令：\"><a href=\"#关机命令：\" class=\"headerlink\" title=\"关机命令：\"></a>关机命令：</h1><ol>\n<li>halt   立刻关机</li>\n<li>poweroff 立刻关机</li>\n<li>shutdown -h now 立刻关机(root用户使用)</li>\n<li>shutdown -h 10 10分钟后自动关机</li>\n</ol>\n<h1 id=\"关机前准备\"><a href=\"#关机前准备\" class=\"headerlink\" title=\"关机前准备\"></a>关机前准备</h1><h1 id=\"who-查看谁在线\"><a href=\"#who-查看谁在线\" class=\"headerlink\" title=\"who 查看谁在线\"></a>who 查看谁在线</h1><h1 id=\"netstat-a-网络的联机状态\"><a href=\"#netstat-a-网络的联机状态\" class=\"headerlink\" title=\"netstat -a 网络的联机状态\"></a>netstat -a 网络的联机状态</h1><h1 id=\"ps-aux-后台的使用情况\"><a href=\"#ps-aux-后台的使用情况\" class=\"headerlink\" title=\"ps -aux 后台的使用情况\"></a>ps -aux 后台的使用情况</h1><h1 id=\"dmesg-查看内核信息\"><a href=\"#dmesg-查看内核信息\" class=\"headerlink\" title=\"dmesg 查看内核信息\"></a>dmesg 查看内核信息</h1><h1 id=\"查看电脑是否支持虚拟化技术\"><a href=\"#查看电脑是否支持虚拟化技术\" class=\"headerlink\" title=\"查看电脑是否支持虚拟化技术\"></a>查看电脑是否支持虚拟化技术</h1><h2 id=\"通过lscpu命令\"><a href=\"#通过lscpu命令\" class=\"headerlink\" title=\"通过lscpu命令\"></a>通过lscpu命令</h2><p>lscpu命令是一种提取有关CPU体系结构信息的常用方法。此命令从sysfs的&#x2F;pro &#x2F;cpuinfo文件中提取硬件信息。该信息包括处理器数量，CPU操作模式，套接字，内核，线程，型号名称和虚拟化信息等。</p>\n<h2 id=\"通过cpu-checker实用程序\"><a href=\"#通过cpu-checker实用程序\" class=\"headerlink\" title=\"通过cpu-checker实用程序\"></a>通过cpu-checker实用程序</h2><p> sudo apt-get install cpu-checker</p>\n<p> sudo kvm-ok</p>\n<h1 id=\"查看系统位数\"><a href=\"#查看系统位数\" class=\"headerlink\" title=\"查看系统位数\"></a>查看系统位数</h1><p> file &#x2F;bin&#x2F;ls</p>\n<h1 id=\"vmstat-命令功能说明：-命令报告关于内核线程、虚拟内存、磁盘、陷阱和-CPU-活动的统计信息\"><a href=\"#vmstat-命令功能说明：-命令报告关于内核线程、虚拟内存、磁盘、陷阱和-CPU-活动的统计信息\" class=\"headerlink\" title=\"vmstat 命令功能说明： 命令报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息\"></a>vmstat 命令功能说明： 命令报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息</h1><h1 id=\"du-disk-usage-命令功能说明：统计目录-或文件-所占磁盘空间的大小\"><a href=\"#du-disk-usage-命令功能说明：统计目录-或文件-所占磁盘空间的大小\" class=\"headerlink\" title=\"du(disk usage) 命令功能说明：统计目录(或文件)所占磁盘空间的大小\"></a>du(disk usage) 命令功能说明：统计目录(或文件)所占磁盘空间的大小</h1><p> qemu-kvm - 为 KVM 管理程序提供硬件模拟的软件程序<br>libvirt-daemon-system - 将 libvirt 守护程序作为系统服务运行的配置文件<br>libvirt-clients - 用来管理虚拟化平台的软件<br>bridge-utils - 用来配置网络桥接的命令行工具<br>virtinst - 用来创建虚拟机的命令行工具<br>virt-manager - 提供一个易用的图形界面，并且通过libvirt 支持用于管理虚拟机的命令行工具</p>\n<h1 id=\"查看电量\"><a href=\"#查看电量\" class=\"headerlink\" title=\"查看电量\"></a>查看电量</h1><p>sudo apt-get install acpi<br>使用acpi命令行工具<br>查看电池是否在充电，剩余电量百分比，具体剩余时间，使用命令acpi<br>[matrix@localhost ~]$ acpi<br>Battery 0: Discharging, 33%, 00:44:53 remaining<br>如果你要看更多的信息，如电池总容量、温度等信息，使用acpi -V命令</p>\n<p>使用IBAM检测电池用量<br>IBAM自称为“智能的电池监测器”</p>\n<p>upower –dump | grep –color&#x3D;never -E “state|to\\ full|to\\ empty|percentage”</p>\n<p> systemctl isolate multi-user.target</p>\n<p>  systemctl isolate graphical.target</p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x2F;</td>\n<td>虚拟目录的根目录，万物起源。通常不会在这里存储文件</td>\n</tr>\n<tr>\n<td>&#x2F;bin</td>\n<td>二进制目录，存放许多用户级的GNU工具</td>\n</tr>\n<tr>\n<td>&#x2F;boot</td>\n<td>启动目录，包含Linux内核，存放启动文件</td>\n</tr>\n<tr>\n<td>&#x2F;boot&#x2F;grub&#x2F;grub.conf or menu.lst</td>\n<td>被用来配置启动加载程序</td>\n</tr>\n<tr>\n<td>&#x2F;boot&#x2F;vmlinuz</td>\n<td>Linux 内核</td>\n</tr>\n<tr>\n<td>&#x2F;dev</td>\n<td>设备目录，Linux在这里创建设备节点</td>\n</tr>\n<tr>\n<td>&#x2F;etc</td>\n<td>系统配置文件目录，也包含一系列的shell脚本</td>\n</tr>\n<tr>\n<td>&#x2F;etc&#x2F;crontab</td>\n<td>定义自动运行的任务</td>\n</tr>\n<tr>\n<td>&#x2F;etc&#x2F;fstab</td>\n<td>包含存储设备的列表，以及与他们相关的挂载点</td>\n</tr>\n<tr>\n<td>&#x2F;etc&#x2F;passwd</td>\n<td>包含用户帐号列表</td>\n</tr>\n<tr>\n<td>&#x2F;home</td>\n<td>主目录，Linux在这 里创建用户目录</td>\n</tr>\n<tr>\n<td>&#x2F;lib</td>\n<td>库目录，存放系统和应用程序的库文件</td>\n</tr>\n<tr>\n<td>&#x2F;media</td>\n<td>媒体目录，可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>&#x2F;mnt</td>\n<td>挂载目录，另一个可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>&#x2F;opt</td>\n<td>可选目录，常用于存放第三方软件包和数据文件</td>\n</tr>\n<tr>\n<td>&#x2F;proc</td>\n<td>进程目录，存放现有硬件及当前进程的相关信息</td>\n</tr>\n<tr>\n<td>&#x2F;root</td>\n<td>root用户的主目录</td>\n</tr>\n<tr>\n<td>&#x2F;sbin</td>\n<td>系统二进制目录，存放许多GNU管理员级工具</td>\n</tr>\n<tr>\n<td>&#x2F;run</td>\n<td>运行目录，存放系统运作时的运行时数据</td>\n</tr>\n<tr>\n<td>&#x2F;srv</td>\n<td>服务目录，存放本地服务的相关文件</td>\n</tr>\n<tr>\n<td>&#x2F;sys</td>\n<td>系统目录，存放系统硬件信息的相关文件</td>\n</tr>\n<tr>\n<td>&#x2F;tmp</td>\n<td>临时目录，可以在该目录中创建和删除临时工作文件</td>\n</tr>\n<tr>\n<td>&#x2F;usr</td>\n<td>用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里，它可能是Linux系统中最大的一个</td>\n</tr>\n<tr>\n<td>&#x2F;usr&#x2F;bin</td>\n<td>包含系统安装的可执行程序，通常会包含许多程序</td>\n</tr>\n<tr>\n<td>&#x2F;usr&#x2F;lib</td>\n<td>包含由&#x2F;usr&#x2F;bin目录中的程序所用的共享库</td>\n</tr>\n<tr>\n<td>&#x2F;usr&#x2F;local</td>\n<td>非系统发行版自带却打算让系统使用的程序的安装目录</td>\n</tr>\n<tr>\n<td>&#x2F;usr&#x2F;sbin</td>\n<td>包含许多系统管理程序</td>\n</tr>\n<tr>\n<td>&#x2F;usr&#x2F;share</td>\n<td>包含许多由&#x2F;usr&#x2F;bin目录中的程序使用的共享数据，其中包括像默认的配置文件、图标、桌面背景、音频文件等等</td>\n</tr>\n<tr>\n<td>&#x2F;usr&#x2F;share&#x2F;doc</td>\n<td>大多数安装在系统中的软件包会包含一些文档</td>\n</tr>\n<tr>\n<td>&#x2F;var</td>\n<td>可变目录，用以存放经常变化的文件，比如日志文件</td>\n</tr>\n</tbody></table>\n<h1 id=\"常用的库\"><a href=\"#常用的库\" class=\"headerlink\" title=\"常用的库\"></a>常用的库</h1><p>GCC multilib主要是用于支持交叉编译（cross compiling），即编译出来的程序是用来在其他处理器平台上运行的。例如可以在x86 64位处理器上编译出x86 32位程序，运行在32位处理器上，或者在x86平台上编译出可以在ARM处理器上运行的程序</p>\n<p>build-essential<br>Ubuntu缺省情况下，并没有提供C&#x2F;C++的编译环境，因此还需要手动安装。但是如果单独安装gcc以及g++比较麻烦，幸运的是，Ubuntu提供了一个build-essential软件包。查看该软件包的依赖关系：</p>\n<p>libtool 是一个通用库支持脚本，将使用动态库的复杂性隐藏在统一、可移植的接口中，也就是说，你可以通过如下所示的标准方法，在不同平台上创建并调用动态库，我们 可以认为libtool是gcc的一个抽象，也就是说，它包装了gcc或者其他的任何编译器，用户无需知道细节，只要告诉libtool说我需要要编译哪 些库即可，并且，它只与libtool文件打交道，例如lo、la为后缀的文件。</p>\n<p>dpkg 包管理工具</p>\n<p>dpkg -l</p>\n<p>dpkg -l | grep mysql*<br>dpkg -l “mysql*”</p>\n<p>sudo dpkg -r vim<br>dpkg -l “<em>mysql</em>“</p>\n<h1 id=\"第一种方法：df命令\"><a href=\"#第一种方法：df命令\" class=\"headerlink\" title=\"第一种方法：df命令\"></a>第一种方法：df命令</h1><h1 id=\"df-hT\"><a href=\"#df-hT\" class=\"headerlink\" title=\"df -hT\"></a>df -hT</h1><h1 id=\"第二种方法：使用mount命令\"><a href=\"#第二种方法：使用mount命令\" class=\"headerlink\" title=\"第二种方法：使用mount命令\"></a>第二种方法：使用mount命令</h1><h1 id=\"mount-l\"><a href=\"#mount-l\" class=\"headerlink\" title=\"mount -l\"></a>mount -l</h1><h1 id=\"第三种方法：查看文件-x2F-etc-x2F-mtab。\"><a href=\"#第三种方法：查看文件-x2F-etc-x2F-mtab。\" class=\"headerlink\" title=\"第三种方法：查看文件&#x2F;etc&#x2F;mtab。\"></a>第三种方法：查看文件&#x2F;etc&#x2F;mtab。</h1><h1 id=\"cat-x2F-etc-x2F-mtab\"><a href=\"#cat-x2F-etc-x2F-mtab\" class=\"headerlink\" title=\"cat &#x2F;etc&#x2F;mtab\"></a>cat &#x2F;etc&#x2F;mtab</h1><h1 id=\"第四种方法：使用lsblk命令查看\"><a href=\"#第四种方法：使用lsblk命令查看\" class=\"headerlink\" title=\"第四种方法：使用lsblk命令查看\"></a>第四种方法：使用lsblk命令查看</h1><h1 id=\"lsblk-P\"><a href=\"#lsblk-P\" class=\"headerlink\" title=\"lsblk -P\"></a>lsblk -P</h1><h1 id=\"查看端口号\"><a href=\"#查看端口号\" class=\"headerlink\" title=\"查看端口号\"></a>查看端口号</h1><p>netstat -tunpl | grep 端口号</p>\n<h1 id=\"chrony\"><a href=\"#chrony\" class=\"headerlink\" title=\"chrony\"></a>chrony</h1><p>Chrony是一个开源自由的网络时间协议 NTP 的客户端和服务器软软件。它能让计算机保持系统时钟与时钟服务器（NTP）同步，因此让你的计算机保持精确的时间，Chrony也可以作为服务端软件为其他计算机提供时间同步服务。</p>\n<h1 id=\"modprobe\"><a href=\"#modprobe\" class=\"headerlink\" title=\"modprobe\"></a>modprobe</h1><p>modprobe命令用于智能地向内核中加载模块或者从内核中移除模块。</p>\n<p>modprobe -V<br>kmod version 27<br>+XZ -ZLIB +LIBCRYPTO -EXPERIMENTAL</p>\n<p>加载模型<br>modprobe sysrq<br>都从这个路径下加载<br>&#x2F;lib&#x2F;modules&#x2F;<br>error:<br>modprobe: FATAL: Module sysrq not found in directory &#x2F;lib&#x2F;modules&#x2F;5.10.16.3-microsoft-standard-WSL2</p>\n<h1 id=\"lsmod\"><a href=\"#lsmod\" class=\"headerlink\" title=\"lsmod\"></a>lsmod</h1><p>查看已加载的内核模块信息</p>\n<p>sudo insmod hello.ko  &#x2F;&#x2F;插入模块<br>sudo rmmode hello &#x2F;&#x2F; 卸载模块<br>modinfo hello.ko &#x2F;&#x2F; 查看模块信息<br>lsmod &#x2F;&#x2F;查看系统模块<br>dmesg &#x2F;&#x2F; 查看系统日志信息</p>\n<h1 id=\"systemctl\"><a href=\"#systemctl\" class=\"headerlink\" title=\"systemctl\"></a>systemctl</h1><p>-p 从指定文件夹加载<br>sysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;my-default.conf</p>\n<p>查看进程<br>ps -a </p>\n<p>which systmd<br>查看状态<br>sysctl docker status</p>\n<p>wget <a href=\"https://github.com/microsoft/WSL2-Linux-Kernel/archive/refs/tags/linux-msft-5.4.72.tar.gz\">https://github.com/microsoft/WSL2-Linux-Kernel/archive/refs/tags/linux-msft-5.4.72.tar.gz</a></p>\n<h1 id=\"modprobe-br-netfilter\"><a href=\"#modprobe-br-netfilter\" class=\"headerlink\" title=\"modprobe br_netfilter\"></a>modprobe br_netfilter</h1><p>linux透明防火墙–br_netfilter</p>\n<h1 id=\"更新内核\"><a href=\"#更新内核\" class=\"headerlink\" title=\"更新内核\"></a>更新内核</h1><p>查看内核是否存在<br>apt-cache search linux | grep “linux-buildinfo-5.4.0-122-generic”<br>寻找内核是否存在<br>apt search ‘linux-image-5.4.0-122-generic’</p>\n<p>apt install ‘linux-image-5.4.0-122-generic’<br>sudo update-initramfs -u -k all<br>sudo update-grub</p>\n<p>sudo update-initramfs -u -k all</p>\n<h1 id=\"lsof\"><a href=\"#lsof\" class=\"headerlink\" title=\"lsof\"></a>lsof</h1><h1 id=\"swapoff\"><a href=\"#swapoff\" class=\"headerlink\" title=\"swapoff\"></a>swapoff</h1><p>Linux swapoff命令用于关闭系统交换区(swap area)。<br>-a 将&#x2F;etc&#x2F;fstab文件中所有设置为swap的设备关闭<br>-h 帮助信息<br>-V 版本信息</p>\n<h1 id=\"free-h\"><a href=\"#free-h\" class=\"headerlink\" title=\"free -h\"></a>free -h</h1><p>查看交换区</p>\n<p>sudo -i 切换用户身份到root.</p>\n<h1 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h1><p>mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。<br>-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。<br> mount -t glusterfs</p>\n<h1 id=\"查看时间\"><a href=\"#查看时间\" class=\"headerlink\" title=\"查看时间\"></a>查看时间</h1><p>date</p>\n<h1 id=\"cp\"><a href=\"#cp\" class=\"headerlink\" title=\"\\cp\"></a>\\cp</h1><p>不会询问是否覆盖<br>\\cp &#x2F;app&#x2F;WEB-INF&#x2F;com&#x2F;cfg.properties &#x2F;app_bak&#x2F;WEB-INF&#x2F;com&#x2F;cfg.properties </p>\n<h1 id=\"crontab-是用来定期执行程序的命令\"><a href=\"#crontab-是用来定期执行程序的命令\" class=\"headerlink\" title=\"crontab 是用来定期执行程序的命令\"></a>crontab 是用来定期执行程序的命令</h1><p>crontab 命令<br>crontab 命令需要 crond 服务支持<br>crond 是 Linux 下用来周期地执行某种任务或等待处理某些事件的一个守护进程，和 Windows 中的计划任务有些类似。</p>\n<p>当安装完成操作系统之后，默认便会启动此任务调度命令。</p>\n<p>crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p>\n<p>注意：新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。</p>\n<p>而 linux 任务调度的工作主要分为以下两类：</p>\n<p>1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存<br>2、个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</p>\n<p>apt-get install cron 安装<br>crontab -l 列出目前的时程表，检查是否安装成功<br>cat &#x2F;etc&#x2F;crontab 输出使用说明<br>service crond status查看服务状态</p>\n<p>ubuntu上的crond名称为cron没有d<br>星号（*）：代表所有可能的值，如month字段为星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（&#x2F;）：可以用正斜线指定时间的间隔频率，例如“0-23&#x2F;2”表示每两小时执行一次。</p>\n<h1 id=\"看内存使用情况\"><a href=\"#看内存使用情况\" class=\"headerlink\" title=\"看内存使用情况\"></a>看内存使用情况</h1><p>free -h</p>\n<h1 id=\"查看ubuntu下都开启了哪些服务\"><a href=\"#查看ubuntu下都开启了哪些服务\" class=\"headerlink\" title=\"查看ubuntu下都开启了哪些服务\"></a>查看ubuntu下都开启了哪些服务</h1><p>service –status-all</p>\n<p>systemctl</p>\n<p>pstree</p>\n<h1 id=\"列出当前目录的隐藏权限\"><a href=\"#列出当前目录的隐藏权限\" class=\"headerlink\" title=\"列出当前目录的隐藏权限\"></a>列出当前目录的隐藏权限</h1><p>lsattr </p>\n<p>date +%Y%m%d_%H%M%S</p>\n<h1 id=\"轮循任务\"><a href=\"#轮循任务\" class=\"headerlink\" title=\"轮循任务\"></a>轮循任务</h1><h1 id=\"readlink\"><a href=\"#readlink\" class=\"headerlink\" title=\"readlink\"></a>readlink</h1><p>readlink是Linux系统中一个常用工具，主要用来找出符号链接所指向的位置。</p>\n<p>echo “shell脚本本身的名字: $0”<br>echo “传给shell的第一个参数: $1”<br>echo “传给shell的第二个参数: $2”</p>\n<p>一、dirname命令<br>dirname命令去除文件名中的非目录部分，仅显示与目录有关的内容。dirname命令读取指定路径名保留最后一个&#x2F;及其后面的字符，删除其他部分，并写结果到标准输出。如果最后一个&#x2F;后无字符，dirname 命令使用倒数第二个&#x2F;，并忽略其后的所有字符。dirname 和 basename 通常在 shell 内部命令替换使用，以指定一个与指定输入文件名略有差异的输出文件名。</p>\n<h1 id=\"sed\"><a href=\"#sed\" class=\"headerlink\" title=\"sed\"></a>sed</h1><p>选项</p>\n<p>-e是编辑命令，用于sed执行多个编辑任务的情况下。在下一行开始编辑前，所有的编辑动作将应用到模式缓冲区中的行上。</p>\n<p>sed -e ‘1,10d’ -e ‘s&#x2F;My&#x2F;Your&#x2F;g’ datafile</p>\n<p>#选项-e用于进行多重编辑。第一重编辑删除第1-3行。第二重编辑将出现的所有My替换为Your。因为是逐行进行这两项编辑（即这两个命令都在模式空间的当前行上执行），所以编辑命令的顺序会影响结果。</p>\n<p>ls -t $DIR&#x2F;*_timedata.db | sed -e ‘1,10d’ | xargs rm<br>按时间排序，1-10行删除掉</p>\n<h1 id=\"查看时区\"><a href=\"#查看时区\" class=\"headerlink\" title=\"查看时区\"></a>查看时区</h1><p>timedatectl</p>\n<p>timedatectl list-timezones</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[查看linux用户密码]<a href=\"https://blog.csdn.net/feikillyou/article/details/109129870\">https://blog.csdn.net/feikillyou/article/details/109129870</a><br>[chrony]<a href=\"https://www.cnblogs.com/my-show-time/p/14658895.html\">https://www.cnblogs.com/my-show-time/p/14658895.html</a><br>[linux kernel文档]<a href=\"https://www.kernel.org/doc/html/v5.4/admin-guide/sysctl/kernel.html\">https://www.kernel.org/doc/html/v5.4/admin-guide/sysctl/kernel.html</a><br>[lsof]<a href=\"https://www.cnblogs.com/bangerlee/archive/2012/05/03/2464495.html\">https://www.cnblogs.com/bangerlee/archive/2012/05/03/2464495.html</a><br>[strace]<a href=\"https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html\">https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html</a><br>[Linux crontab命令详解-博客]<a href=\"https://www.cnblogs.com/ftl1012/p/crontab.html\">https://www.cnblogs.com/ftl1012/p/crontab.html</a><br>[Linux Crontab定时任务-菜鸟教程]<a href=\"https://www.runoob.com/w3cnote/linux-crontab-tasks.html\">https://www.runoob.com/w3cnote/linux-crontab-tasks.html</a><br>[systemd]<a href=\"https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html\">https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a><br>[linux下计划任务学习记录 ]<a href=\"https://blog.51cto.com/u_15060465/4164796\">https://blog.51cto.com/u_15060465/4164796</a><br>[xargs]<a href=\"https://ruanyifeng.com/blog/2019/08/xargs-tutorial.html\">https://ruanyifeng.com/blog/2019/08/xargs-tutorial.html</a><br>[用history查看历史命令]<a href=\"https://blog.csdn.net/qq_34243930/article/details/107007654\">https://blog.csdn.net/qq_34243930/article/details/107007654</a><br>[让 history 命令显示日期和时间]<a href=\"https://zhuanlan.zhihu.com/p/99818664\">https://zhuanlan.zhihu.com/p/99818664</a><br>[环境变量HISTCONTROL命令及对快捷键Ctrl+o命令的影响]<a href=\"https://blog.csdn.net/weixin_30723433/article/details/96641179\">https://blog.csdn.net/weixin_30723433/article/details/96641179</a></p>\n","slug":"Brids-Linux-private-kitchen/ubuntu-command","updated":"16/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/03/Brids-Linux-private-kitchen/ubuntu-command/","excerpt":"","categories":[],"tags":[{"name":"鸟哥的Linux私房菜","slug":"鸟哥的Linux私房菜","permalink":"http://example.com/tags/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"}]},{"title":"如何阅读源码","date":"25/02/2022","path":"2022/02/25/Others/How-to-read-the-source-code/","text":"0.确定阅读源码的目的1.通过编译，能跑起来。有的时候环境比较复杂，搭建调试环境的时候就需要花很多时间。先通过搜索把调试环境搭建起来，这一步就能积累很多经验。 2.精简调试环境，减少干扰信息python用pycharmC\\C++类的代码，使用Vim+Ctags+Cscope来 3.调试手段 加调试语句。为了做到这一点，你需要先了解项目如何加调试日志，可能需要修改项目的日志级别支持输出一些在调试级别的日志，等等。 断点调试。并不是所有项目代码，跑起来之后都自带调试信息能够断点调试的。所以在自己的调试环境里需要先确定这一点。 利用好测试用例好的项目都会自带不少用例，这类型的例子有：etcd、google出品的几个开源项目。 如果测试用例写的很仔细，那么很值得好好去研究一下。原因在于：测试用例往往是针对某个单一的场景，独自构造出一些数据来对程序的流程进行验证。所以，其实跟前面的“情景分析”一样，都是让你从大的项目转而关注具体某个场景的手段之一。 厘清核心数据结构之间的关系虽然说“程序设计&#x3D;算法+数据结构”，然后我实际中的体会，数据结构更加重要。 因为结构定义了一个程序的架构，结构定下来了才有具体的实现。 Linus说： “烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。” 因此，在阅读一份代码时，厘清核心的数据结构之间的关系尤其重要。这个时候，需要使用一些工具来画一下这些结构之间的关系，我的源码分析类博客中有很多这样的例子，比如《Leveldb代码阅读笔记》、《Etcd存储的实现》等等。 需要说明的是，情景分析、厘清核心数据结构这两步并没有严格的顺序关系，不见得是先做某事再做某事，而是交互进行的。 比如，你如果现在刚接手某个项目，需要简单的了解一下项目，可以先阅读代码了解都有哪些核心数据结构。理解了之后，如果不清楚某些情景下的流程，可以使用情景分析法。总而言之，交替进行直到解答你的疑问为止。 3整体和细节阅读代码的过程中，需要在整体和细节之间做权衡。 比如，有时候你需要大体了解一个整体的框架、轮廓、流程之后，才能再针对具体的细节深入进去。这个时候，不宜针对具体的函数实现、算法等深入分析。而细节的分析，又不能缺少，否则一些东西的理解又流于表面。 所以，如何把握整体和细节是一个需要累积阅读代码经验才能把握好的。我的建议是：过程中还是以整体为首，在不理解整体的前提之前，不要太过深入某个细节。把某个函数、数据结构当成一个黑盒，知道它们的输入、输出就好，只要不影响整体的理解就暂且放下接着往前看。 3多问自己几个问题学习的过程中离不开交互。 如果阅读代码只是输入（Input），那么还需要有输出（Output）。只有简单的输入好比喂东西给你吃，而只有更好的消化才能变为自己的营养，而输出就是更好消化知识的重要手段。 其实这个思想很常见，比如学生上课（Input）了需要做练习作业（Output），比如学了算法（Input）需要自己编码练习（Output），等等。简而言之，输出是学习过程中的一种及时反馈，质量越高学习效率越高。 输出的手段有很多，在阅读代码时，比较建议的是自己能够多问自己一些问题，比如： 为什么选择这个数据结构来描述这个问题？类似的场景下，其他项目是怎么设计的？都有哪些数据结构做这样的事情？如果由我来设计这样的项目，我会怎么做？等等等等。越是主动积极的思考，就越有更好的输出，输出质量与学习质量成正比关系。 4.写自己的代码阅读笔记我从开始写博客，就是写不少各种项目的代码解读类文章，网名“codedump”也源于想把“code内部的实现原理dump出来”之意。 前面提到学习质量与输出质量成正比关系，这是我自己的深刻体会。也因为如此，所以才要坚持阅读源码之后写自己的分析类笔记。 写这类笔记，有以下几个需要注意的地方。 虽然是笔记，但是要想象着在向一个不太熟悉这个项目的人讲解原理，或者想象一下是几个月甚至几年后的自己回头来看这个文章。在这种情况下，会尽量的把语言组织好，循循善诱的解释。 尽量避免大段的贴代码。我认为在这类文章中，大段贴上代码有点自欺欺人：就是看上去自己懂了，其实并不见得。如果真要解释某段代码，可以使用伪代码或者缩减代码的方式。记住：不要自欺欺人，要真的懂了。如果真的想在代码上加上自己的注释，我有一个建议是fork出来一份该项目某个版本的代码，提交到自己的github上，上面随时可以加上自己的注释并且保存提交。比如我自己注释的etcd 3.1.10代码：etcd-3.1.10-codedump，类似的我阅读的其他项目都会在github上fork出一个带上codedump后缀的项目。 多画图，一图胜千言，使用图形展示代码流程、数据结构之间的关系。我最近才发现画图能力也是很重要的能力，自己在从头学习如何使用图像来表达自己的想法。 写作是很重要的基础能力，我一个朋友最近教育我，大体的意思是说：如果你在某方面的能力很强，如果再加上写作好、英语好，那么将极大放大你在这方面的能力。而类似写作、英语这样的底层基础能力，不是一撮而就的，需要长时间保持练习才可以。而写博客，对于技术人员而言，就是一种很好的锻炼写作的手段。 必须找好切入点。你要解决什么问题。是要fix bug；还是要把这个系统和其它模块集成；还是要增加新功能。物理学家没有上来就研究整个宇宙的，必须选好分支。如果你有一个猜想，但是又和你的目标关联不太大，那就坚持这个猜想，直到出现明显反例。物理学有很多这样的例子，和数学不同，为了旁支猜想投入过多研究是不明智的。如果有明显证据证明你的某个旁支猜想大错特错，你就要放弃主要目标，暂时把解决旁支猜想作为主要目标。比如，你本来以为某个结构是LRU的cache，结果发现怎么做都不对，那就先放弃原来的目标，专门研究这个结构的用途。对于旁支猜想的不断切换，要做好自己的task stack保留。在旁支猜想解决之后，要根据结论尽快回到上次中断的任务。 很简单的第一，找准入口出口，不要直接跳进去看，任何代码都有触发点，无论是http request，还是服务器自动启动，还是main函数，还是其他的，先从入口开始。第二，手边一支笔一张纸，除非你是Jeff，否则你不会记得那么多跳转的。一个跳转就写下来函数&#x2F;方法名和参数，读完一遍，就有了一个sequence diagram雏形第三，私有方法掠过，只要记住输入输出即可，无需看具体实现 常见的困难在阅读源代码的过程中，会遇到不少的困难，常见的有： 成熟的开源项目往往自身的代码量很大，盲目地从入口文件开始阅读，会陷入到各种代码分支上，耗费大量时间不说，收获也甚微。代码难以看懂，不清楚来龙去脉。本人在阅读源代码的时候，走了不少的弯路，结合自己的实践谈谈自己是如何克服上述的困难。 阅读的目的首先，做一件事件，要先明确目的。目的可以起到指引的作用，同时也可以检验自己是否已经完成。 阅读源代码也不例外。阅读源代码的目的可能是： 了解源代码的目录结构，学习开源项目是如何组织代码开源项目有某些强大的功能，阅读源代码了解实现细节，以便更加全面的掌握。在使用开源项目时，遇到一些问题，边阅读源码，边debug其他漫无目的的看源代码一般难以有收获。 事先准备如果目的是通过阅读源代码，加深对技术细节的理解，做好以下几步，可以降低阅读源码的难度。 了解这门技术的历史，搞清楚这门技术是为了解决什么样的问题而发展起来的。了解技术的架构，概念。优秀的开源项目源码实现和技术架构，概念都有清晰的联系。如果没有在实际运用中使用过该技术，建议还是仔细阅读官网上的start指引，编写运行几个小的demo。准备问题，试着在阅读官网文档或者编写demo的过程中提出几个问题，当然也可以参考别人提出的问题（常见的面试题也是不错的）。在github上clone该项目到本地，保留项目完整的commit和tag。 参考链接https://www.codedump.info/post/20190324-how-to-read-code/https://www.zhihu.com/question/19625320/answer/12429108https://www.zhihu.com/question/19625320/answer/307133854https://github.com/zhangguixu/myblogs/issues/4[英文能力与独立思考]https://www.raychase.net/6902","raw":"---\ntitle: 如何阅读源码\ndate: 2022-02-25 12:44:36\ntags:\n- - 其他\n---\n\n# 0.确定阅读源码的目的\n\n1.通过编译，能跑起来。\n有的时候环境比较复杂，搭建调试环境的时候就需要花很多时间。\n先通过搜索把调试环境搭建起来，这一步就能积累很多经验。\n\n\n\n2.精简调试环境，减少干扰信息\npython用pycharm\nC\\C++类的代码，使用Vim+Ctags+Cscope来\n\n3.调试手段\n\n- 加调试语句。为了做到这一点，你需要先了解项目如何加调试日志，可能需要修改项目的日志级别支持输出一些在调试级别的日志，等等。\n\n- 断点调试。并不是所有项目代码，跑起来之后都自带调试信息能够断点调试的。所以在自己的调试环境里需要先确定这一点。\n\n# 利用好测试用例\n好的项目都会自带不少用例，这类型的例子有：etcd、google出品的几个开源项目。\n\n如果测试用例写的很仔细，那么很值得好好去研究一下。原因在于：测试用例往往是针对某个单一的场景，独自构造出一些数据来对程序的流程进行验证。所以，其实跟前面的“情景分析”一样，都是让你从大的项目转而关注具体某个场景的手段之一。\n\n# 厘清核心数据结构之间的关系\n虽然说“程序设计=算法+数据结构”，然后我实际中的体会，数据结构更加重要。\n\n因为结构定义了一个程序的架构，结构定下来了才有具体的实现。\n\nLinus说： “烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。”\n\n因此，在阅读一份代码时，厘清核心的数据结构之间的关系尤其重要。这个时候，需要使用一些工具来画一下这些结构之间的关系，我的源码分析类博客中有很多这样的例子，比如《Leveldb代码阅读笔记》、《Etcd存储的实现》等等。\n\n需要说明的是，情景分析、厘清核心数据结构这两步并没有严格的顺序关系，不见得是先做某事再做某事，而是交互进行的。\n\n比如，你如果现在刚接手某个项目，需要简单的了解一下项目，可以先阅读代码了解都有哪些核心数据结构。理解了之后，如果不清楚某些情景下的流程，可以使用情景分析法。总而言之，交替进行直到解答你的疑问为止。\n\n\n# 3整体和细节\n阅读代码的过程中，需要在整体和细节之间做权衡。\n\n比如，有时候你需要大体了解一个整体的框架、轮廓、流程之后，才能再针对具体的细节深入进去。这个时候，不宜针对具体的函数实现、算法等深入分析。而细节的分析，又不能缺少，否则一些东西的理解又流于表面。\n\n所以，如何把握整体和细节是一个需要累积阅读代码经验才能把握好的。我的建议是：过程中还是以整体为首，在不理解整体的前提之前，不要太过深入某个细节。把某个函数、数据结构当成一个黑盒，知道它们的输入、输出就好，只要不影响整体的理解就暂且放下接着往前看。\n\n# 3多问自己几个问题\n学习的过程中离不开交互。\n\n如果阅读代码只是输入（Input），那么还需要有输出（Output）。只有简单的输入好比喂东西给你吃，而只有更好的消化才能变为自己的营养，而输出就是更好消化知识的重要手段。\n\n其实这个思想很常见，比如学生上课（Input）了需要做练习作业（Output），比如学了算法（Input）需要自己编码练习（Output），等等。简而言之，输出是学习过程中的一种及时反馈，质量越高学习效率越高。\n\n输出的手段有很多，在阅读代码时，比较建议的是自己能够多问自己一些问题，比如：\n\n为什么选择这个数据结构来描述这个问题？类似的场景下，其他项目是怎么设计的？都有哪些数据结构做这样的事情？\n如果由我来设计这样的项目，我会怎么做？\n等等等等。越是主动积极的思考，就越有更好的输出，输出质量与学习质量成正比关系。\n\n\n4.写自己的代码阅读笔记\n我从开始写博客，就是写不少各种项目的代码解读类文章，网名“codedump”也源于想把“code内部的实现原理dump出来”之意。\n\n前面提到学习质量与输出质量成正比关系，这是我自己的深刻体会。也因为如此，所以才要坚持阅读源码之后写自己的分析类笔记。\n\n写这类笔记，有以下几个需要注意的地方。\n\n虽然是笔记，但是要想象着在向一个不太熟悉这个项目的人讲解原理，或者想象一下是几个月甚至几年后的自己回头来看这个文章。在这种情况下，会尽量的把语言组织好，循循善诱的解释。\n\n尽量避免大段的贴代码。我认为在这类文章中，大段贴上代码有点自欺欺人：就是看上去自己懂了，其实并不见得。如果真要解释某段代码，可以使用伪代码或者缩减代码的方式。记住：不要自欺欺人，要真的懂了。如果真的想在代码上加上自己的注释，我有一个建议是fork出来一份该项目某个版本的代码，提交到自己的github上，上面随时可以加上自己的注释并且保存提交。比如我自己注释的etcd 3.1.10代码：etcd-3.1.10-codedump，类似的我阅读的其他项目都会在github上fork出一个带上codedump后缀的项目。\n\n多画图，一图胜千言，使用图形展示代码流程、数据结构之间的关系。我最近才发现画图能力也是很重要的能力，自己在从头学习如何使用图像来表达自己的想法。\n\n写作是很重要的基础能力，我一个朋友最近教育我，大体的意思是说：如果你在某方面的能力很强，如果再加上写作好、英语好，那么将极大放大你在这方面的能力。而类似写作、英语这样的底层基础能力，不是一撮而就的，需要长时间保持练习才可以。而写博客，对于技术人员而言，就是一种很好的锻炼写作的手段。\n\n\n必须找好切入点。你要解决什么问题。是要fix bug；还是要把这个系统和其它模块集成；还是要增加新功能。物理学家没有上来就研究整个宇宙的，必须选好分支。如果你有一个猜想，但是又和你的目标关联不太大，那就坚持这个猜想，直到出现明显反例。物理学有很多这样的例子，和数学不同，为了旁支猜想投入过多研究是不明智的。如果有明显证据证明你的某个旁支猜想大错特错，你就要放弃主要目标，暂时把解决旁支猜想作为主要目标。比如，你本来以为某个结构是LRU的cache，结果发现怎么做都不对，那就先放弃原来的目标，专门研究这个结构的用途。对于旁支猜想的不断切换，要做好自己的task stack保留。在旁支猜想解决之后，要根据结论尽快回到上次中断的任务。\n\n\n很简单的第一，找准入口出口，不要直接跳进去看，任何代码都有触发点，无论是http request，还是服务器自动启动，还是main函数，还是其他的，先从入口开始。第二，手边一支笔一张纸，除非你是Jeff，否则你不会记得那么多跳转的。一个跳转就写下来函数/方法名和参数，读完一遍，就有了一个sequence diagram雏形第三，私有方法掠过，只要记住输入输出即可，无需看具体实现\n\n\n常见的困难\n在阅读源代码的过程中，会遇到不少的困难，常见的有：\n\n成熟的开源项目往往自身的代码量很大，盲目地从入口文件开始阅读，会陷入到各种代码分支上，耗费大量时间不说，收获也甚微。\n代码难以看懂，不清楚来龙去脉。\n本人在阅读源代码的时候，走了不少的弯路，结合自己的实践谈谈自己是如何克服上述的困难。\n\n阅读的目的\n首先，做一件事件，要先明确目的。目的可以起到指引的作用，同时也可以检验自己是否已经完成。\n\n阅读源代码也不例外。阅读源代码的目的可能是：\n\n了解源代码的目录结构，学习开源项目是如何组织代码\n开源项目有某些强大的功能，阅读源代码了解实现细节，以便更加全面的掌握。\n在使用开源项目时，遇到一些问题，边阅读源码，边debug\n其他\n漫无目的的看源代码一般难以有收获。\n\n事先准备\n如果目的是通过阅读源代码，加深对技术细节的理解，做好以下几步，可以降低阅读源码的难度。\n\n了解这门技术的历史，搞清楚这门技术是为了解决什么样的问题而发展起来的。\n了解技术的架构，概念。优秀的开源项目源码实现和技术架构，概念都有清晰的联系。\n如果没有在实际运用中使用过该技术，建议还是仔细阅读官网上的start指引，编写运行几个小的demo。\n准备问题，试着在阅读官网文档或者编写demo的过程中提出几个问题，当然也可以参考别人提出的问题（常见的面试题也是不错的）。\n在github上clone该项目到本地，保留项目完整的commit和tag。\n\n\n## 参考链接\n\n\nhttps://www.codedump.info/post/20190324-how-to-read-code/\nhttps://www.zhihu.com/question/19625320/answer/12429108\nhttps://www.zhihu.com/question/19625320/answer/307133854\nhttps://github.com/zhangguixu/myblogs/issues/4\n[英文能力与独立思考]https://www.raychase.net/6902","content":"<h1 id=\"0-确定阅读源码的目的\"><a href=\"#0-确定阅读源码的目的\" class=\"headerlink\" title=\"0.确定阅读源码的目的\"></a>0.确定阅读源码的目的</h1><p>1.通过编译，能跑起来。<br>有的时候环境比较复杂，搭建调试环境的时候就需要花很多时间。<br>先通过搜索把调试环境搭建起来，这一步就能积累很多经验。</p>\n<p>2.精简调试环境，减少干扰信息<br>python用pycharm<br>C\\C++类的代码，使用Vim+Ctags+Cscope来</p>\n<p>3.调试手段</p>\n<ul>\n<li><p>加调试语句。为了做到这一点，你需要先了解项目如何加调试日志，可能需要修改项目的日志级别支持输出一些在调试级别的日志，等等。</p>\n</li>\n<li><p>断点调试。并不是所有项目代码，跑起来之后都自带调试信息能够断点调试的。所以在自己的调试环境里需要先确定这一点。</p>\n</li>\n</ul>\n<h1 id=\"利用好测试用例\"><a href=\"#利用好测试用例\" class=\"headerlink\" title=\"利用好测试用例\"></a>利用好测试用例</h1><p>好的项目都会自带不少用例，这类型的例子有：etcd、google出品的几个开源项目。</p>\n<p>如果测试用例写的很仔细，那么很值得好好去研究一下。原因在于：测试用例往往是针对某个单一的场景，独自构造出一些数据来对程序的流程进行验证。所以，其实跟前面的“情景分析”一样，都是让你从大的项目转而关注具体某个场景的手段之一。</p>\n<h1 id=\"厘清核心数据结构之间的关系\"><a href=\"#厘清核心数据结构之间的关系\" class=\"headerlink\" title=\"厘清核心数据结构之间的关系\"></a>厘清核心数据结构之间的关系</h1><p>虽然说“程序设计&#x3D;算法+数据结构”，然后我实际中的体会，数据结构更加重要。</p>\n<p>因为结构定义了一个程序的架构，结构定下来了才有具体的实现。</p>\n<p>Linus说： “烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。”</p>\n<p>因此，在阅读一份代码时，厘清核心的数据结构之间的关系尤其重要。这个时候，需要使用一些工具来画一下这些结构之间的关系，我的源码分析类博客中有很多这样的例子，比如《Leveldb代码阅读笔记》、《Etcd存储的实现》等等。</p>\n<p>需要说明的是，情景分析、厘清核心数据结构这两步并没有严格的顺序关系，不见得是先做某事再做某事，而是交互进行的。</p>\n<p>比如，你如果现在刚接手某个项目，需要简单的了解一下项目，可以先阅读代码了解都有哪些核心数据结构。理解了之后，如果不清楚某些情景下的流程，可以使用情景分析法。总而言之，交替进行直到解答你的疑问为止。</p>\n<h1 id=\"3整体和细节\"><a href=\"#3整体和细节\" class=\"headerlink\" title=\"3整体和细节\"></a>3整体和细节</h1><p>阅读代码的过程中，需要在整体和细节之间做权衡。</p>\n<p>比如，有时候你需要大体了解一个整体的框架、轮廓、流程之后，才能再针对具体的细节深入进去。这个时候，不宜针对具体的函数实现、算法等深入分析。而细节的分析，又不能缺少，否则一些东西的理解又流于表面。</p>\n<p>所以，如何把握整体和细节是一个需要累积阅读代码经验才能把握好的。我的建议是：过程中还是以整体为首，在不理解整体的前提之前，不要太过深入某个细节。把某个函数、数据结构当成一个黑盒，知道它们的输入、输出就好，只要不影响整体的理解就暂且放下接着往前看。</p>\n<h1 id=\"3多问自己几个问题\"><a href=\"#3多问自己几个问题\" class=\"headerlink\" title=\"3多问自己几个问题\"></a>3多问自己几个问题</h1><p>学习的过程中离不开交互。</p>\n<p>如果阅读代码只是输入（Input），那么还需要有输出（Output）。只有简单的输入好比喂东西给你吃，而只有更好的消化才能变为自己的营养，而输出就是更好消化知识的重要手段。</p>\n<p>其实这个思想很常见，比如学生上课（Input）了需要做练习作业（Output），比如学了算法（Input）需要自己编码练习（Output），等等。简而言之，输出是学习过程中的一种及时反馈，质量越高学习效率越高。</p>\n<p>输出的手段有很多，在阅读代码时，比较建议的是自己能够多问自己一些问题，比如：</p>\n<p>为什么选择这个数据结构来描述这个问题？类似的场景下，其他项目是怎么设计的？都有哪些数据结构做这样的事情？<br>如果由我来设计这样的项目，我会怎么做？<br>等等等等。越是主动积极的思考，就越有更好的输出，输出质量与学习质量成正比关系。</p>\n<p>4.写自己的代码阅读笔记<br>我从开始写博客，就是写不少各种项目的代码解读类文章，网名“codedump”也源于想把“code内部的实现原理dump出来”之意。</p>\n<p>前面提到学习质量与输出质量成正比关系，这是我自己的深刻体会。也因为如此，所以才要坚持阅读源码之后写自己的分析类笔记。</p>\n<p>写这类笔记，有以下几个需要注意的地方。</p>\n<p>虽然是笔记，但是要想象着在向一个不太熟悉这个项目的人讲解原理，或者想象一下是几个月甚至几年后的自己回头来看这个文章。在这种情况下，会尽量的把语言组织好，循循善诱的解释。</p>\n<p>尽量避免大段的贴代码。我认为在这类文章中，大段贴上代码有点自欺欺人：就是看上去自己懂了，其实并不见得。如果真要解释某段代码，可以使用伪代码或者缩减代码的方式。记住：不要自欺欺人，要真的懂了。如果真的想在代码上加上自己的注释，我有一个建议是fork出来一份该项目某个版本的代码，提交到自己的github上，上面随时可以加上自己的注释并且保存提交。比如我自己注释的etcd 3.1.10代码：etcd-3.1.10-codedump，类似的我阅读的其他项目都会在github上fork出一个带上codedump后缀的项目。</p>\n<p>多画图，一图胜千言，使用图形展示代码流程、数据结构之间的关系。我最近才发现画图能力也是很重要的能力，自己在从头学习如何使用图像来表达自己的想法。</p>\n<p>写作是很重要的基础能力，我一个朋友最近教育我，大体的意思是说：如果你在某方面的能力很强，如果再加上写作好、英语好，那么将极大放大你在这方面的能力。而类似写作、英语这样的底层基础能力，不是一撮而就的，需要长时间保持练习才可以。而写博客，对于技术人员而言，就是一种很好的锻炼写作的手段。</p>\n<p>必须找好切入点。你要解决什么问题。是要fix bug；还是要把这个系统和其它模块集成；还是要增加新功能。物理学家没有上来就研究整个宇宙的，必须选好分支。如果你有一个猜想，但是又和你的目标关联不太大，那就坚持这个猜想，直到出现明显反例。物理学有很多这样的例子，和数学不同，为了旁支猜想投入过多研究是不明智的。如果有明显证据证明你的某个旁支猜想大错特错，你就要放弃主要目标，暂时把解决旁支猜想作为主要目标。比如，你本来以为某个结构是LRU的cache，结果发现怎么做都不对，那就先放弃原来的目标，专门研究这个结构的用途。对于旁支猜想的不断切换，要做好自己的task stack保留。在旁支猜想解决之后，要根据结论尽快回到上次中断的任务。</p>\n<p>很简单的第一，找准入口出口，不要直接跳进去看，任何代码都有触发点，无论是http request，还是服务器自动启动，还是main函数，还是其他的，先从入口开始。第二，手边一支笔一张纸，除非你是Jeff，否则你不会记得那么多跳转的。一个跳转就写下来函数&#x2F;方法名和参数，读完一遍，就有了一个sequence diagram雏形第三，私有方法掠过，只要记住输入输出即可，无需看具体实现</p>\n<p>常见的困难<br>在阅读源代码的过程中，会遇到不少的困难，常见的有：</p>\n<p>成熟的开源项目往往自身的代码量很大，盲目地从入口文件开始阅读，会陷入到各种代码分支上，耗费大量时间不说，收获也甚微。<br>代码难以看懂，不清楚来龙去脉。<br>本人在阅读源代码的时候，走了不少的弯路，结合自己的实践谈谈自己是如何克服上述的困难。</p>\n<p>阅读的目的<br>首先，做一件事件，要先明确目的。目的可以起到指引的作用，同时也可以检验自己是否已经完成。</p>\n<p>阅读源代码也不例外。阅读源代码的目的可能是：</p>\n<p>了解源代码的目录结构，学习开源项目是如何组织代码<br>开源项目有某些强大的功能，阅读源代码了解实现细节，以便更加全面的掌握。<br>在使用开源项目时，遇到一些问题，边阅读源码，边debug<br>其他<br>漫无目的的看源代码一般难以有收获。</p>\n<p>事先准备<br>如果目的是通过阅读源代码，加深对技术细节的理解，做好以下几步，可以降低阅读源码的难度。</p>\n<p>了解这门技术的历史，搞清楚这门技术是为了解决什么样的问题而发展起来的。<br>了解技术的架构，概念。优秀的开源项目源码实现和技术架构，概念都有清晰的联系。<br>如果没有在实际运用中使用过该技术，建议还是仔细阅读官网上的start指引，编写运行几个小的demo。<br>准备问题，试着在阅读官网文档或者编写demo的过程中提出几个问题，当然也可以参考别人提出的问题（常见的面试题也是不错的）。<br>在github上clone该项目到本地，保留项目完整的commit和tag。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.codedump.info/post/20190324-how-to-read-code/\">https://www.codedump.info/post/20190324-how-to-read-code/</a><br><a href=\"https://www.zhihu.com/question/19625320/answer/12429108\">https://www.zhihu.com/question/19625320/answer/12429108</a><br><a href=\"https://www.zhihu.com/question/19625320/answer/307133854\">https://www.zhihu.com/question/19625320/answer/307133854</a><br><a href=\"https://github.com/zhangguixu/myblogs/issues/4\">https://github.com/zhangguixu/myblogs/issues/4</a><br>[英文能力与独立思考]<a href=\"https://www.raychase.net/6902\">https://www.raychase.net/6902</a></p>\n","slug":"Others/How-to-read-the-source-code","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/25/Others/How-to-read-the-source-code/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"python 语法","date":"24/02/2022","path":"2022/02/24/Grammar/python-Grammar/","text":"基础infPython中可以用如下方式表示正负无穷 12float(&quot;inf&quot;) # 正无穷float(&quot;-inf&quot;) # 负无穷 INF做加法、乘法等算数运算仍然会的到inf： 除了 INF 外的其他数除以 INF ，会得到0： 任何其他的数值除以 INF 都会得到 INF， 因为INF表示正无穷 如果 INF 涉及到 &lt; 和 &gt; 不等式的问题，所有数都比 -inf 大，所有数都比 +inf 小就可以了。 Numpynp.mean()np.mean()函数功能：求取均值经常操作的参数为axis，以m * n矩阵举例：axis 不设置值，对 mn 个数求均值，返回一个实数axis &#x3D; 0：压缩行，对各列求均值，返回 1 n 矩阵axis &#x3D;1 ：压缩列，对各行求均值，返回 m *1 矩阵 12345678910111213np.mean(num1,0)num1 = np.array([[1,2,3],[2,3,4],[3,4,5],[4,5,6]])num2 = np.mat(num1)ans = np.mean(num1,0)3.5ans = np.mean(num1,0) # 压缩行，对各列求均值matrix([[ 2.5, 3.5, 4.5]])ans = np.mean(num1,1) # 压缩列，对各行求均值matrix([[ 2.], [ 3.], [ 4.], [ 5.]]) np.fliplr()将数组在左右方向上翻转 123456789arr = np.array([[[0,1],[2,3]],[[4,5],[6,7]]], dtype=float)print(arr)print(np.fliplr(arr))[[[0,1], [2, 3]] [[4,5], [6, 7]]][[[2, 3], [0, 1]] [[6, 7], [4, 5]] ] px, py = np.transpose(np.flipud(np.fliplr(path))) np.flipud()翻转列表，将矩阵进行上下翻转 123456789101112arr=np.diag([1,2,3,4]) #diag用于声明对角矩阵print(arr)print(np.flipud(arr))[[1 0 0 0] [0 2 0 0] [0 0 3 0] [0 0 0 4]][[0, 0, 0, 4], [0, 0, 3, 0], [0, 2, 0, 0], [1, 0, 0, 0]] np.transpose()transpose在不指定参数是默认是矩阵转置 123456arr = np.arange(4).reshape((2,2))[[0, 1],[2, 3]][[0, 2],[1, 3]] 求维数，求长宽data &#x3D; np.array([ [1,2,3], [4,5,6], [7,8,9], [0,0,0] ]) print(data)print(data.ndim)print(data.shape) 2(4, 3) Mathmath.ceil()ceil() 向上取整 12ans = math.ceil(-45.17) : -45.0ans = math.ceil(100.12) : 101.0","raw":"---\ntitle: python 语法\ndate: 2022-02-24 20:47:46\ntags:\n- 语法\n---\n\n# 基础\n\n## inf\nPython中可以用如下方式表示正负无穷\n```\nfloat(\"inf\")  # 正无穷\nfloat(\"-inf\")  # 负无穷\n```\n 1. INF做加法、乘法等算数运算仍然会的到inf：\n 2. 除了 INF 外的其他数除以 INF ，会得到0：\n 3. 任何其他的数值除以 INF 都会得到 INF， 因为INF表示正无穷\n 4. 如果 INF 涉及到 < 和 > 不等式的问题，所有数都比 -inf 大，所有数都比 +inf 小就可以了。\n\n# Numpy\n\n## np.mean()\nnp.mean()函数功能：求取均值\n经常操作的参数为axis，以m * n矩阵举例：\naxis 不设置值，对 m*n 个数求均值，返回一个实数\naxis = 0：压缩行，对各列求均值，返回 1* n 矩阵\naxis =1 ：压缩列，对各行求均值，返回 m *1 矩阵\n\n```\nnp.mean(num1,0)\nnum1 = np.array([[1,2,3],[2,3,4],[3,4,5],[4,5,6]])\nnum2 = np.mat(num1)\n\nans = np.mean(num1,0)\n3.5\nans = np.mean(num1,0) # 压缩行，对各列求均值\nmatrix([[ 2.5,  3.5,  4.5]])\nans = np.mean(num1,1) # 压缩列，对各行求均值\nmatrix([[ 2.],\n        [ 3.],\n        [ 4.],\n        [ 5.]])\n```\n\n## np.fliplr()\n将数组在左右方向上翻转\n```\narr = np.array([[[0,1],[2,3]],[[4,5],[6,7]]], dtype=float)\nprint(arr)\nprint(np.fliplr(arr))\n\n[[[0,1], [2, 3]]\n [[4,5], [6, 7]]]\n\n[[[2, 3], [0, 1]]\n [[6, 7], [4, 5]] ]\n```\n    px, py = np.transpose(np.flipud(np.fliplr(path)))\n\n## np.flipud()\n翻转列表，将矩阵进行上下翻转\n```\narr=np.diag([1,2,3,4]) #diag用于声明对角矩阵\nprint(arr)\nprint(np.flipud(arr))\n[[1 0 0 0]\n [0 2 0 0]\n [0 0 3 0]\n [0 0 0 4]]\n\n[[0, 0, 0, 4],\n [0, 0, 3, 0],\n [0, 2, 0, 0],\n [1, 0, 0, 0]]\n```\n\n\n## np.transpose()\ntranspose在不指定参数是默认是矩阵转置\n```\narr = np.arange(4).reshape((2,2))\n[[0, 1],\n[2, 3]]\n\n[[0, 2],\n[1, 3]]\n```\n\n\n\n\n# 求维数，求长宽\n\ndata = np.array([\n\t\t[1,2,3],\n\t\t[4,5,6],\n\t\t[7,8,9],\n\t\t[0,0,0]\n\t])\n\n\nprint(data)\nprint(data.ndim)\nprint(data.shape) \n\n2\n(4, 3)\n\n# Math\n\n## math.ceil()\nceil() 向上取整\n```\nans = math.ceil(-45.17) : -45.0\nans = math.ceil(100.12) :  101.0\n```\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"inf\"><a href=\"#inf\" class=\"headerlink\" title=\"inf\"></a>inf</h2><p>Python中可以用如下方式表示正负无穷</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>)  <span class=\"comment\"># 正无穷</span></span><br><span class=\"line\"><span class=\"built_in\">float</span>(<span class=\"string\">&quot;-inf&quot;</span>)  <span class=\"comment\"># 负无穷</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>INF做加法、乘法等算数运算仍然会的到inf：</li>\n<li>除了 INF 外的其他数除以 INF ，会得到0：</li>\n<li>任何其他的数值除以 INF 都会得到 INF， 因为INF表示正无穷</li>\n<li>如果 INF 涉及到 &lt; 和 &gt; 不等式的问题，所有数都比 -inf 大，所有数都比 +inf 小就可以了。</li>\n</ol>\n<h1 id=\"Numpy\"><a href=\"#Numpy\" class=\"headerlink\" title=\"Numpy\"></a>Numpy</h1><h2 id=\"np-mean\"><a href=\"#np-mean\" class=\"headerlink\" title=\"np.mean()\"></a>np.mean()</h2><p>np.mean()函数功能：求取均值<br>经常操作的参数为axis，以m * n矩阵举例：<br>axis 不设置值，对 m<em>n 个数求均值，返回一个实数<br>axis &#x3D; 0：压缩行，对各列求均值，返回 1</em> n 矩阵<br>axis &#x3D;1 ：压缩列，对各行求均值，返回 m *1 矩阵</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.mean(num1,<span class=\"number\">0</span>)</span><br><span class=\"line\">num1 = np.array(<span class=\"string\">[[1,2,3],[2,3,4],[3,4,5],[4,5,6]]</span>)</span><br><span class=\"line\">num2 = np.mat(num1)</span><br><span class=\"line\"></span><br><span class=\"line\">ans = np.mean(num1,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">3.5</span></span><br><span class=\"line\">ans = np.mean(num1,<span class=\"number\">0</span>) # 压缩行，对各列求均值</span><br><span class=\"line\">matrix(<span class=\"string\">[[ 2.5,  3.5,  4.5]]</span>)</span><br><span class=\"line\">ans = np.mean(num1,<span class=\"number\">1</span>) # 压缩列，对各行求均值</span><br><span class=\"line\">matrix(<span class=\"string\">[[ 2.],</span></span><br><span class=\"line\"><span class=\"string\">        [ 3.],</span></span><br><span class=\"line\"><span class=\"string\">        [ 4.],</span></span><br><span class=\"line\"><span class=\"string\">        [ 5.]]</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"np-fliplr\"><a href=\"#np-fliplr\" class=\"headerlink\" title=\"np.fliplr()\"></a>np.fliplr()</h2><p>将数组在左右方向上翻转</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = np.array(<span class=\"string\">[[[0,1],[2,3]]</span>,<span class=\"string\">[[4,5],[6,7]]</span>], dtype=float)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(arr)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.fliplr(arr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">[[[0,1], [2, 3]]</span></span><br><span class=\"line\"> <span class=\"string\">[[4,5], [6, 7]]</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">[[[2, 3], [0, 1]]</span></span><br><span class=\"line\"> <span class=\"string\">[[6, 7], [4, 5]]</span> ]</span><br></pre></td></tr></table></figure>\n<pre><code>px, py = np.transpose(np.flipud(np.fliplr(path)))\n</code></pre>\n<h2 id=\"np-flipud\"><a href=\"#np-flipud\" class=\"headerlink\" title=\"np.flipud()\"></a>np.flipud()</h2><p>翻转列表，将矩阵进行上下翻转</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr=np<span class=\"selector-class\">.diag</span>(<span class=\"selector-attr\">[1,2,3,4]</span>) #diag用于声明对角矩阵</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(arr)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(np.flipud(arr)</span></span>)</span><br><span class=\"line\"><span class=\"selector-attr\">[[1 0 0 0]</span></span><br><span class=\"line\"> <span class=\"selector-attr\">[0 2 0 0]</span></span><br><span class=\"line\"> <span class=\"selector-attr\">[0 0 3 0]</span></span><br><span class=\"line\"> <span class=\"selector-attr\">[0 0 0 4]</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[[0, 0, 0, 4]</span>,</span><br><span class=\"line\"> <span class=\"selector-attr\">[0, 0, 3, 0]</span>,</span><br><span class=\"line\"> <span class=\"selector-attr\">[0, 2, 0, 0]</span>,</span><br><span class=\"line\"> <span class=\"selector-attr\">[1, 0, 0, 0]</span>]</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"np-transpose\"><a href=\"#np-transpose\" class=\"headerlink\" title=\"np.transpose()\"></a>np.transpose()</h2><p>transpose在不指定参数是默认是矩阵转置</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = np.arange(<span class=\"number\">4</span>).reshape((<span class=\"number\">2</span>,<span class=\"number\">2</span>))</span><br><span class=\"line\"><span class=\"string\">[[0, 1],</span></span><br><span class=\"line\"><span class=\"string\">[2, 3]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">[[0, 2],</span></span><br><span class=\"line\"><span class=\"string\">[1, 3]]</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"求维数，求长宽\"><a href=\"#求维数，求长宽\" class=\"headerlink\" title=\"求维数，求长宽\"></a>求维数，求长宽</h1><p>data &#x3D; np.array([<br>        [1,2,3],<br>        [4,5,6],<br>        [7,8,9],<br>        [0,0,0]<br>    ])</p>\n<p>print(data)<br>print(data.ndim)<br>print(data.shape) </p>\n<p>2<br>(4, 3)</p>\n<h1 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h1><h2 id=\"math-ceil\"><a href=\"#math-ceil\" class=\"headerlink\" title=\"math.ceil()\"></a>math.ceil()</h2><p>ceil() 向上取整</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ans</span> = math.ceil(-<span class=\"number\">45</span>.<span class=\"number\">17</span>) : -<span class=\"number\">45</span>.<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attribute\">ans</span> = math.ceil(<span class=\"number\">100</span>.<span class=\"number\">12</span>) :  <span class=\"number\">101</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Grammar/python-Grammar","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/24/Grammar/python-Grammar/","excerpt":"","categories":[],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"hexo-Logs","date":"21/02/2022","path":"2022/02/21/Others/hexo-Logs/","text":"2022-2-12 创建博客，添加了两篇文章 2022-2-21 更改了主题，统计访问人数，更改分类，改了网站图标 2022-3-21 不断增加文章 2022-4-5 暂时用路过图床作为图床，图片本地保存一份，起码可以上传图片了 以后考虑用腾讯云的CDS来代替https://imgtu.com/ytgh678 做了一些头像等细节的优化，图片放大插件，阅读时长，字数统计 2022-6-21 修复了左边导航栏的问题 添加了搜索功能 等待加入的功能 刚进入的页面要弄得整齐 置顶某一篇文章 每篇文章的显示更加详细 做归档那边的功能，不能空着 每个分类点进去应该是横着的格式，而不是现在的样子 改变字体颜色 同一个页面下的多级目录 左下角显示时间，访客 可以被搜索到 修改markdown样式分开统计每个页面浏览量标签云添加颜色图片点一下会放大 文章中还没有添加的 厨房烧菜的内容 vscode的linux环境的配置写task.josn和lanch.json每个选项到底是怎么用的，还有怎么开始调试和配置、 周会的记录，看看测试和产品干的内容写进来 redis相关，mysql相关都没有总结 TIDB的相关知识 mysql面试问题 如何搭建环境 租房指南 如何提升系统性能（???还不知道怎么去做）","raw":"---\ntitle: hexo-Logs\ntoc: true\ndate: 2022-02-21 20:41:42\ntags:\n- 其他\n---\n\n\n\n\n## 2022-2-12\n- 创建博客，添加了两篇文章\n\n## 2022-2-21\n- 更改了主题，统计访问人数，更改分类，改了网站图标\n\n## 2022-3-21\n- 不断增加文章\n\n## 2022-4-5\n- 暂时用路过图床作为图床，图片本地保存一份，起码可以上传图片了\n- 以后考虑用腾讯云的CDS来代替\nhttps://imgtu.com/ytgh678\n- 做了一些头像等细节的优化，图片放大插件，阅读时长，字数统计\n\n## 2022-6-21\n- 修复了左边导航栏的问题\n- 添加了搜索功能\n\n\n\n\n# 等待加入的功能\n\n1. 刚进入的页面要弄得整齐\n    - 置顶某一篇文章\n    - 每篇文章的显示更加详细\n\n2. 做归档那边的功能，不能空着\n3. 每个分类点进去应该是横着的格式，而不是现在的样子\n    \n--------\n1. 改变字体颜色\n2. 同一个页面下的多级目录\n4. 左下角显示时间，访客\n5. 可以被搜索到\n6. 修改markdown样式\n分开统计每个页面浏览量\n标签云添加颜色\n图片点一下会放大\n\n\n# 文章中还没有添加的\n\n1. 厨房烧菜的内容\n2. vscode的linux环境的配置\n写task.josn和lanch.json每个选项到底是怎么用的，还有怎么开始调试和配置、\n3. 周会的记录，看看测试和产品干的内容写进来\n4. redis相关，mysql相关都没有总结\n5. TIDB的相关知识\n6. mysql面试问题\n\n\n7. 如何搭建环境\n8. 租房指南\n9. 如何提升系统性能（???还不知道怎么去做）\n","content":"<h2 id=\"2022-2-12\"><a href=\"#2022-2-12\" class=\"headerlink\" title=\"2022-2-12\"></a>2022-2-12</h2><ul>\n<li>创建博客，添加了两篇文章</li>\n</ul>\n<h2 id=\"2022-2-21\"><a href=\"#2022-2-21\" class=\"headerlink\" title=\"2022-2-21\"></a>2022-2-21</h2><ul>\n<li>更改了主题，统计访问人数，更改分类，改了网站图标</li>\n</ul>\n<h2 id=\"2022-3-21\"><a href=\"#2022-3-21\" class=\"headerlink\" title=\"2022-3-21\"></a>2022-3-21</h2><ul>\n<li>不断增加文章</li>\n</ul>\n<h2 id=\"2022-4-5\"><a href=\"#2022-4-5\" class=\"headerlink\" title=\"2022-4-5\"></a>2022-4-5</h2><ul>\n<li>暂时用路过图床作为图床，图片本地保存一份，起码可以上传图片了</li>\n<li>以后考虑用腾讯云的CDS来代替<br><a href=\"https://imgtu.com/ytgh678\">https://imgtu.com/ytgh678</a></li>\n<li>做了一些头像等细节的优化，图片放大插件，阅读时长，字数统计</li>\n</ul>\n<h2 id=\"2022-6-21\"><a href=\"#2022-6-21\" class=\"headerlink\" title=\"2022-6-21\"></a>2022-6-21</h2><ul>\n<li>修复了左边导航栏的问题</li>\n<li>添加了搜索功能</li>\n</ul>\n<h1 id=\"等待加入的功能\"><a href=\"#等待加入的功能\" class=\"headerlink\" title=\"等待加入的功能\"></a>等待加入的功能</h1><ol>\n<li><p>刚进入的页面要弄得整齐</p>\n<ul>\n<li>置顶某一篇文章</li>\n<li>每篇文章的显示更加详细</li>\n</ul>\n</li>\n<li><p>做归档那边的功能，不能空着</p>\n</li>\n<li><p>每个分类点进去应该是横着的格式，而不是现在的样子</p>\n</li>\n</ol>\n<hr>\n<ol>\n<li>改变字体颜色</li>\n<li>同一个页面下的多级目录</li>\n<li>左下角显示时间，访客</li>\n<li>可以被搜索到</li>\n<li>修改markdown样式<br>分开统计每个页面浏览量<br>标签云添加颜色<br>图片点一下会放大</li>\n</ol>\n<h1 id=\"文章中还没有添加的\"><a href=\"#文章中还没有添加的\" class=\"headerlink\" title=\"文章中还没有添加的\"></a>文章中还没有添加的</h1><ol>\n<li><p>厨房烧菜的内容</p>\n</li>\n<li><p>vscode的linux环境的配置<br>写task.josn和lanch.json每个选项到底是怎么用的，还有怎么开始调试和配置、</p>\n</li>\n<li><p>周会的记录，看看测试和产品干的内容写进来</p>\n</li>\n<li><p>redis相关，mysql相关都没有总结</p>\n</li>\n<li><p>TIDB的相关知识</p>\n</li>\n<li><p>mysql面试问题</p>\n</li>\n<li><p>如何搭建环境</p>\n</li>\n<li><p>租房指南</p>\n</li>\n<li><p>如何提升系统性能（???还不知道怎么去做）</p>\n</li>\n</ol>\n","slug":"Others/hexo-Logs","updated":"22/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/21/Others/hexo-Logs/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"cmake 教程","date":"21/02/2022","path":"2022/02/21/Tutorial/linux-dev-env/CMake-tutorial/","text":"PROJECT 指令的语法12PROJECT(projectname [CXX] [C] [Java])PROJECT (HELLO) 定义了工程的名称为HELLO SET 指令的语法123SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])SET(SRC_LIST main.c t1.c t2.c)SET(SRC_LIST main.c)也可以写成 SET(SRC_LIST “main.c”) SET 指令可以用来显式的定义变量即可 MESSAGE 指令的语法123MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] &quot;message to display&quot;...)MESSAGE(STATUS &quot;This is BINARY dir &quot; $&#123;HELLO_BINARY_DIR&#125;) 由 PROJECT 指令定义的两个隐式变量HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。 SEND_ERROR，产生错误，生成过程被跳过SATUS，输出前缀为—的信息FATAL_ERROR，立即终止所有 cmake 过程 ADD_EXECUTABLE 指令的语法1ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;) 定义了这个工程会生成一个文件名为 hello 的可执行文件 变量${}来引用变量，这是 cmake 的变量引用方式如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。 清理1make clean cmake 并不支持 make distclean，无法清理构建过程产生的中间文件 cmake使用时候的命名cmake .. -DCMAKE_BUILD_TYPE&#x3D;Debug CMAKE_BUILD_TYPE可选值包括：Debug：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件Release：用于构建的优化的库或可执行文件，不包含调试符号RelWithDebInfo：由于构建较少的优化库或可执行文件，包含调试符号MinSizeRel：用于不增加目标代码大小的优化方式，来构建或可执行文件 交叉编译工具CMAKE给交叉编译预留了一个变量CMAKE_TOOLCHAIN_FILE，它定义了一个.cmake文件的路径，该文件里面设置了一系列CMAKE变量和属性，比如C_COMPILER，CXX_COMPILER等。.cmake文件的好处是一次编写多次使用，不同平台架构的交叉编译工具链可以编写一个独立的toolchain.cmake文件，而工程的CMakeLists.txt可以编写为通用格式，对工具链不可见。cmake脚本可以如下形式： 参考文献[find_package讲解]https://blog.csdn.net/zhanghm1995/article/details/105466372[C++连接mysql用cmake编译]https://blog.csdn.net/lbwanghr/article/details/111076593[什么是交叉编译]https://zhuanlan.zhihu.com/p/77116555","raw":"---\ntitle: cmake 教程\ndate: 2022-02-21 17:40:18\ntags:\n- 教程\n---\n\n\n# PROJECT 指令的语法\n```\nPROJECT(projectname [CXX] [C] [Java])\nPROJECT (HELLO)\n```\n定义了工程的名称为HELLO\n\n\n# SET 指令的语法\n```\nSET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])\nSET(SRC_LIST main.c t1.c t2.c)\nSET(SRC_LIST main.c)也可以写成 SET(SRC_LIST “main.c”)\n```\nSET 指令可以用来显式的定义变量即可\n\n\n# MESSAGE 指令的语法\n```\nMESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] \"message to display\"\n...)\nMESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR})\n```\n\n由 PROJECT 指令定义的两个隐式变量HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。\n\n**SEND_ERROR，产生错误，生成过程被跳过\nSATUS，输出前缀为—的信息\nFATAL_ERROR，立即终止所有 cmake 过程**\n\n\n# ADD_EXECUTABLE 指令的语法\n```\nADD_EXECUTABLE(hello ${SRC_LIST})\n```\n定义了这个工程会生成一个文件名为 hello 的可执行文件\n\n# 变量\n${}来引用变量，这是 cmake 的变量引用方式\n如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。\n\n\n# 清理\n```\nmake clean\n```\ncmake 并不支持 make distclean，无法清理构建过程产生的中间文件\n\n\n# cmake使用时候的命名\n\ncmake .. -DCMAKE_BUILD_TYPE=Debug\n\nCMAKE_BUILD_TYPE\n可选值包括：\nDebug：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件\nRelease：用于构建的优化的库或可执行文件，不包含调试符号\nRelWithDebInfo：由于构建较少的优化库或可执行文件，包含调试符号\nMinSizeRel：用于不增加目标代码大小的优化方式，来构建或可执行文件\n\n\n\n# 交叉编译工具\nCMAKE给交叉编译预留了一个变量CMAKE_TOOLCHAIN_FILE，它定义了一个.cmake文件的路径，该文件里面设置了一系列CMAKE变量和属性，比如C_COMPILER，CXX_COMPILER等。.cmake文件的好处是一次编写多次使用，不同平台架构的交叉编译工具链可以编写一个独立的toolchain.cmake文件，而工程的CMakeLists.txt可以编写为通用格式，对工具链不可见。cmake脚本可以如下形式：\n\n# 参考文献\n\n[find_package讲解]https://blog.csdn.net/zhanghm1995/article/details/105466372\n[C++连接mysql用cmake编译]https://blog.csdn.net/lbwanghr/article/details/111076593\n[什么是交叉编译]https://zhuanlan.zhihu.com/p/77116555\n\n","content":"<h1 id=\"PROJECT-指令的语法\"><a href=\"#PROJECT-指令的语法\" class=\"headerlink\" title=\"PROJECT 指令的语法\"></a>PROJECT 指令的语法</h1><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROJECT(projectname <span class=\"selector-attr\">[CXX]</span> <span class=\"selector-attr\">[C]</span> <span class=\"selector-attr\">[Java]</span>)</span><br><span class=\"line\">PROJECT (HELLO)</span><br></pre></td></tr></table></figure>\n<p>定义了工程的名称为HELLO</p>\n<h1 id=\"SET-指令的语法\"><a href=\"#SET-指令的语法\" class=\"headerlink\" title=\"SET 指令的语法\"></a>SET 指令的语法</h1><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span></span><br><span class=\"line\"><span class=\"constructor\">SET(SRC_LIST <span class=\"params\">main</span>.<span class=\"params\">c</span> <span class=\"params\">t1</span>.<span class=\"params\">c</span> <span class=\"params\">t2</span>.<span class=\"params\">c</span>)</span></span><br><span class=\"line\"><span class=\"constructor\">SET(SRC_LIST <span class=\"params\">main</span>.<span class=\"params\">c</span>)</span>也可以写成 <span class=\"constructor\">SET(SRC_LIST “<span class=\"params\">main</span>.<span class=\"params\">c</span>”)</span></span><br></pre></td></tr></table></figure>\n<p>SET 指令可以用来显式的定义变量即可</p>\n<h1 id=\"MESSAGE-指令的语法\"><a href=\"#MESSAGE-指令的语法\" class=\"headerlink\" title=\"MESSAGE 指令的语法\"></a>MESSAGE 指令的语法</h1><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">MESSAGE</span>(<span class=\"selector-attr\">[SEND_ERROR | STATUS | FATAL_ERROR]</span> <span class=\"string\">&quot;message to display&quot;</span></span><br><span class=\"line\">...)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MESSAGE</span><span class=\"params\">(STATUS <span class=\"string\">&quot;This is BINARY dir &quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>由 PROJECT 指令定义的两个隐式变量HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。</p>\n<p><strong>SEND_ERROR，产生错误，生成过程被跳过<br>SATUS，输出前缀为—的信息<br>FATAL_ERROR，立即终止所有 cmake 过程</strong></p>\n<h1 id=\"ADD-EXECUTABLE-指令的语法\"><a href=\"#ADD-EXECUTABLE-指令的语法\" class=\"headerlink\" title=\"ADD_EXECUTABLE 指令的语法\"></a>ADD_EXECUTABLE 指令的语法</h1><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">ADD_EXECUTABLE</span><span class=\"params\">(hello $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure>\n<p>定义了这个工程会生成一个文件名为 hello 的可执行文件</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p>${}来引用变量，这是 cmake 的变量引用方式<br>如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。</p>\n<h1 id=\"清理\"><a href=\"#清理\" class=\"headerlink\" title=\"清理\"></a>清理</h1><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">make clean</span></span><br></pre></td></tr></table></figure>\n<p>cmake 并不支持 make distclean，无法清理构建过程产生的中间文件</p>\n<h1 id=\"cmake使用时候的命名\"><a href=\"#cmake使用时候的命名\" class=\"headerlink\" title=\"cmake使用时候的命名\"></a>cmake使用时候的命名</h1><p>cmake .. -DCMAKE_BUILD_TYPE&#x3D;Debug</p>\n<p>CMAKE_BUILD_TYPE<br>可选值包括：<br>Debug：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件<br>Release：用于构建的优化的库或可执行文件，不包含调试符号<br>RelWithDebInfo：由于构建较少的优化库或可执行文件，包含调试符号<br>MinSizeRel：用于不增加目标代码大小的优化方式，来构建或可执行文件</p>\n<h1 id=\"交叉编译工具\"><a href=\"#交叉编译工具\" class=\"headerlink\" title=\"交叉编译工具\"></a>交叉编译工具</h1><p>CMAKE给交叉编译预留了一个变量CMAKE_TOOLCHAIN_FILE，它定义了一个.cmake文件的路径，该文件里面设置了一系列CMAKE变量和属性，比如C_COMPILER，CXX_COMPILER等。.cmake文件的好处是一次编写多次使用，不同平台架构的交叉编译工具链可以编写一个独立的toolchain.cmake文件，而工程的CMakeLists.txt可以编写为通用格式，对工具链不可见。cmake脚本可以如下形式：</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[find_package讲解]<a href=\"https://blog.csdn.net/zhanghm1995/article/details/105466372\">https://blog.csdn.net/zhanghm1995/article/details/105466372</a><br>[C++连接mysql用cmake编译]<a href=\"https://blog.csdn.net/lbwanghr/article/details/111076593\">https://blog.csdn.net/lbwanghr/article/details/111076593</a><br>[什么是交叉编译]<a href=\"https://zhuanlan.zhihu.com/p/77116555\">https://zhuanlan.zhihu.com/p/77116555</a></p>\n","slug":"Tutorial/linux-dev-env/CMake-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/21/Tutorial/linux-dev-env/CMake-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"物理机安装 ubuntu20","date":"12/02/2022","path":"2022/02/12/Environment-Configuration/install-ubuntu20/","text":"惠普进入BOIS模式，直接按F10 [win10安装]https://zhuanlan.zhihu.com/p/108156241win10安装ubuntu双系统","raw":"---\ntitle: 物理机安装 ubuntu20\ndate: 2022-02-12 18:40:28\ntags:\n- 环境配置\n---\n\n\n惠普进入BOIS模式，直接按F10\n\n\n\n[win10安装]https://zhuanlan.zhihu.com/p/108156241\n[win10安装ubuntu双系统](https://zhuanlan.zhihu.com/p/363640824#:~:text=Windows%2BUbuntu20.04%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%201%201.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Ubuntu20.04%202%202.%20%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%203,%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85%2012%204.%20%E6%9B%B4%E6%94%B9BIOS%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9.%20%E6%8C%89ENTER%E5%B0%86Ubuntu%E5%90%AF%E5%8A%A8%E7%A7%BB%E5%88%B0%E7%AC%AC%E4%B8%80%E4%BD%8D%EF%BC%8C%E4%BF%9D%E5%AD%98%E9%80%80%E5%87%BA%EF%BC%8C%E5%BC%80%E6%9C%BA%E8%BF%9B%E5%85%A5%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%80%89%E9%A1%B9%E4%BA%86%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%BD%8D%E6%98%AFUbuntu%EF%BC%8C%E7%AC%AC%E4%B8%89%E4%B8%AA%E6%98%AFWindows.%2013%20%E5%9B%9B.%20%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90)","content":"<p>惠普进入BOIS模式，直接按F10</p>\n<p>[win10安装]<a href=\"https://zhuanlan.zhihu.com/p/108156241\">https://zhuanlan.zhihu.com/p/108156241</a><br><a href=\"https://zhuanlan.zhihu.com/p/363640824#:~:text=Windows%2BUbuntu20.04%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%201%201.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Ubuntu20.04%202%202.%20%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%203,%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85%2012%204.%20%E6%9B%B4%E6%94%B9BIOS%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9.%20%E6%8C%89ENTER%E5%B0%86Ubuntu%E5%90%AF%E5%8A%A8%E7%A7%BB%E5%88%B0%E7%AC%AC%E4%B8%80%E4%BD%8D%EF%BC%8C%E4%BF%9D%E5%AD%98%E9%80%80%E5%87%BA%EF%BC%8C%E5%BC%80%E6%9C%BA%E8%BF%9B%E5%85%A5%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%80%89%E9%A1%B9%E4%BA%86%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%BD%8D%E6%98%AFUbuntu%EF%BC%8C%E7%AC%AC%E4%B8%89%E4%B8%AA%E6%98%AFWindows.%2013%20%E5%9B%9B.%20%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90\">win10安装ubuntu双系统</a></p>\n","slug":"Environment-Configuration/install-ubuntu20","updated":"29/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/12/Environment-Configuration/install-ubuntu20/","excerpt":"","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"hexo 教程","date":"12/02/2022","path":"2022/02/12/Tutorial/hexo-tutorial/","text":"常见的博客种类的介绍 动态博客 全都自己搭建 springboot +js+mysql wordpress docker PHP 静态博客 基于XXX的开源博客 hexo 纯前端，纯js的展示界面 node.js jekyllrb Ruby hugo go语言 VuePress solo java 一、hexo 安装教程1.下载node.js去http://nodejs.cn/ 下载长期支持版直接下一步安装即可安装后有两个东西node.js本身npm包管理器确认安装成功 1234node -vv16.13.1npm -v8.1.2 2.安装cnpm代替npm在国内npm比较慢npm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org确认安装成功 1cnpm -v 3..cnpm安装hexocnpm install -g hexo-cli确认安装成功 1hexo -v 到这里，hexo博客的框架已经安装好了 二、搭建第一个hexo博客1.新建一个文件夹D盘随便新建一个文件夹blog以后的东西都是在里面用的，如果出错了直接删掉找个文件夹重来就可以了 2.初始化博客进入文件夹hexo init 3.第一次启动博客hexo s粘贴网址，查看启动的博客 4.部署到github安装一个git插件npm install hexo-deployer-git –save 5.对hexo进行配置打开blog文件夹下的_config.yml拉到最底部 12deploy: type: &#x27;&#x27; 改为 1234deploy: type: git repository: # github中仓库的地址 branch: master/main # 参考github中主分支的名字 git config –global user.name “name”git config –global user.email “emal” hexo d # 推送上去，就推送到github了 6.在github中开启GitHub Pages服务在最上面一行找到settings找到Pages 三、hexo 常用命令下次开始再次编辑的时候，在需要编辑的文件夹里面打开git bash，不需要hexo init,直接hexo s就可以启动本地页面 初始化1hexo init 创建新页面12hexo n &quot;我的页面名称&quot;hexo new [layout] &quot;我的页面名称&quot; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 生成静态文件12hexo g hexo generate 启动服务器每次再次想要编辑网站的时候可以直接用这个命令 12hexo s hexo server 部署网站12hexo d hexo deploy 清除缓存文件1hexo clean 列出网站资料1234hexo list Usage: hexo list &lt;type&gt;Arguments: type Available types: page, post, route, tag, category 链接12https://hexo.io/zh-cn/docs/commands.html直接放链接就可以了 四、修复一些问题hexo下markdown表格失效表格和正文空开一行 编码使用UTF-8编码GB 2312会乱码 标题文件名没有用，只有文章里面的内容的名字才有用直接新建文件，开头用如下格式，就可以新建文章 123456---title: day07123141date: 2022-04-03 15:51:39tags:- Linux网络编程--- Cannot GET&#x2F;xxxx使用了pure主题以后，多出了很多的分类，比如友链，书单之类的，点进出会出现Cannot GET /book的错误，实际情况希望能获取到自己想要的页面修复方法 步骤一：去主题目录下查看\\blog\\theme\\pure_config.yml这就是当前左边的主标签1234567menu: Home: . Archives: archives # 归档 Categories: categories # 分类 Links: links # 友链 About: about # 关于 Books: book # 关于 步骤二：想要创建对应的标签的内容，以book举例在控制台中执行hexo new page “book”\\blog\\source\\book\\index.mdindex.md就是每个文件都要包含的文件，也是需要展示的内容直接生成就可以了 步骤三：如果需要建立新的标签，重复上面两个步骤如果不改编码，会在左侧标签出现menu.book的问题由于使用了中文字符编码，所以需要进入主题中改一下yml文件\\blog\\themes\\pure\\languages使用的是zh-CN.yml12345678menu: Home: 首页 Archives: 归档 Categories: 分类 ... book: 书 About: 关于 Cat: 猫 # 自己添加的标签 将自己想要添加标签写上重新生成 添加搜索功能安装插件npm i -S hexo-generator-json-content在你运行 hexo g 或者 hexo s 时生效，在 hexo g 生成站点时, 会在根目录下生成 content.json 该文件内容即为搜索内容。你可以对搜索内容进行自定义的配置， 只要在 _config.yml 中配置 12345678910111213141516171819# 示例: 隐藏分类和标签的搜索jsonContent: dateFormat: DD/MM/YYYY posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false author: false 五、配置相关配置语言12language: zh-CN # 中文language: en # 英文 得查看当前使用的主题使用的什么配置我使用的主题是pure里面有languages文件有配置文件名字zh-CN.yml，使用中文需要改成这个 pure主题的改变fancybox：实现点击图片放大的部件，默认关闭，打开后会导致友链打不开profile：改变个人信息 改变每页的文章数目per_page: 20 参考文献[B站羊哥的教程]https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca[官方的链接参考] https://hexo.io/zh-cn/docs/commands.htmlhexo下Markdown语法失效总结 https://blog.csdn.net/weixin_42932905/article/details/106153679?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-106153679.pc_agg_new_rank&amp;utm_term=hexo+markdown%E4%B8%8D%E7%94%9F%E6%95%88&amp;spm=1000.2123.3001.4430大佬的一些教程 https://hwame.top/[hexo博客出现“Cannot GET&#x2F;xxxx”的错误]https://blog.csdn.net/weixin_30699831/article/details/96894620[启用搜索功能]https://blog.plcent.com/2019/11/05/hexo-theme-pure/[添加友链]https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md[启用RSS订阅]https://wxnacy.com/2018/12/12/hexo-add-rss/[启用RSS订阅]https://www.jianshu.com/p/2aaac7a19736","raw":"---\ntitle: hexo 教程\ndate: 2022-02-12 18:18:12\ntags:\n- 教程\n---\n\n# 常见的博客种类的介绍\n\n- 动态博客\n    - 全都自己搭建\n        - springboot +js+mysql\n    - wordpress\n        - docker\n        - PHP\n\n- 静态博客\n    - 基于XXX的开源博客\n    - hexo\n        - 纯前端，纯js的展示界面\n        - node.js\n    - jekyllrb\n        - Ruby\n    - hugo\n        - go语言\n    - VuePress\n    - solo\n        - java\n\n# 一、hexo 安装教程\n\n## 1.下载node.js\n去http://nodejs.cn/ 下载长期支持版\n直接下一步安装即可\n安装后有两个东西\nnode.js本身\nnpm包管理器\n确认安装成功\n```\nnode -v\nv16.13.1\nnpm -v\n8.1.2\n```\n## 2.安装cnpm代替npm\n在国内npm比较慢\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n确认安装成功\n```\ncnpm -v\n```\n## 3..cnpm安装hexo\ncnpm install -g hexo-cli\n确认安装成功\n```\nhexo -v\n```\n到这里，hexo博客的框架已经安装好了\n\n# 二、搭建第一个hexo博客\n## 1.新建一个文件夹\nD盘随便新建一个文件夹blog\n以后的东西都是在里面用的，如果出错了直接删掉找个文件夹重来就可以了\n## 2.初始化博客\n进入文件夹\nhexo init\n## 3.第一次启动博客\nhexo s\n粘贴网址，查看启动的博客\n## 4.部署到github\n安装一个git插件\nnpm install hexo-deployer-git --save\n## 5.对hexo进行配置\n打开blog文件夹下的_config.yml\n拉到最底部\n```\ndeploy:\n  type: ''\n```\n改为\n```\ndeploy:\n  type: git\n  repository: # github中仓库的地址\n  branch: master/main # 参考github中主分支的名字\n```\ngit config --global user.name  \"name\"\ngit config --global user.email  \"emal\"\n\nhexo d # 推送上去，就推送到github了\n\n## 6.在github中开启GitHub Pages服务\n在最上面一行找到settings\n找到Pages\n\n\n\n# 三、hexo 常用命令\n下次开始再次编辑的时候，在需要编辑的文件夹里面打开git bash，不需要hexo init,直接hexo s就可以启动本地页面\n\n## 初始化\n``` \nhexo init\n```\n\n## 创建新页面\n``` \nhexo n \"我的页面名称\"\nhexo new [layout] \"我的页面名称\"\n```\n您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。\n\n## 生成静态文件\n``` \nhexo g \nhexo generate\n```\n\n## 启动服务器\n每次再次想要编辑网站的时候可以直接用这个命令\n``` \nhexo s \nhexo server\n```\n\n## 部署网站\n```\nhexo d \nhexo deploy\n```\n\n## 清除缓存文件\n```\nhexo clean\n```\n## 列出网站资料\n```\nhexo list \nUsage: hexo list <type>\nArguments:\n  type  Available types: page, post, route, tag, category\n```\n\n## 链接\n```\nhttps://hexo.io/zh-cn/docs/commands.html\n直接放链接就可以了\n```\n# 四、修复一些问题\n## hexo下markdown表格失效\n表格和正文空开一行\n\n## 编码\n使用UTF-8编码\nGB 2312会乱码\n\n## 标题\n文件名没有用，只有文章里面的内容的名字才有用\n直接新建文件，开头用如下格式，就可以新建文章\n\n```\n---\ntitle: day07123141\ndate: 2022-04-03 15:51:39\ntags:\n- Linux网络编程\n---\n```\n## Cannot GET/xxxx\n使用了pure主题以后，多出了很多的分类，比如友链，书单之类的，点进出会出现```Cannot GET /book```的错误，实际情况希望能获取到自己想要的页面修复方法\n- 步骤一：\n去主题目录下查看\\blog\\theme\\pure\\_config.yml\n这就是当前左边的主标签\n```\nmenu:\n  Home: .\n  Archives: archives  # 归档\n  Categories: categories  # 分类\n  Links: links  # 友链\n  About: about  # 关于\n  Books: book  # 关于\n```\n- 步骤二：\n想要创建对应的标签的内容，以book举例\n在控制台中执行\nhexo new page \"book\"\n\\blog\\source\\book\\index.md\nindex.md就是每个文件都要包含的文件，也是需要展示的内容\n直接生成就可以了\n- 步骤三：\n如果需要建立新的标签，重复上面两个步骤\n如果不改编码，会在左侧标签出现\nmenu.book的问题\n由于使用了中文字符编码，所以需要进入主题中改一下yml文件\n\\blog\\themes\\pure\\languages\\\n使用的是zh-CN.yml\n```\nmenu:\n  Home: 首页\n  Archives: 归档\n  Categories: 分类\n  ...\n  book: 书\n  About: 关于\n  Cat: 猫 # 自己添加的标签\n```\n将自己想要添加标签写上\n重新生成\n\n## 添加搜索功能\n安装插件\nnpm i -S hexo-generator-json-content \n在你运行 hexo g 或者 hexo s 时生效，在 hexo g 生成站点时, 会在根目录下生成 content.json 该文件内容即为搜索内容。\n你可以对搜索内容进行自定义的配置， 只要在 _config.yml 中配置\n```\n# 示例: 隐藏分类和标签的搜索\njsonContent:\n  dateFormat: DD/MM/YYYY\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: false\n    author: false\n```\n\n# 五、配置相关\n## 配置语言\n```\nlanguage: zh-CN  # 中文\nlanguage: en        # 英文\n```\n得查看当前使用的主题使用的什么配置\n我使用的主题是pure里面有languages文件有配置文件名字zh-CN.yml，使用中文需要改成这个\n\n## pure主题的改变\nfancybox：实现点击图片放大的部件，默认关闭，打开后会导致友链打不开\nprofile：改变个人信息\n\n### 改变每页的文章数目\nper_page: 20\n\n# 参考文献\n[B站羊哥的教程]https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&vd_source=76dff3ae3b42b00d067c0921bf6859ca\n[官方的链接参考] https://hexo.io/zh-cn/docs/commands.html\nhexo下Markdown语法失效总结 https://blog.csdn.net/weixin_42932905/article/details/106153679?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-106153679.pc_agg_new_rank&utm_term=hexo+markdown%E4%B8%8D%E7%94%9F%E6%95%88&spm=1000.2123.3001.4430\n大佬的一些教程 https://hwame.top/\n[hexo博客出现“Cannot GET/xxxx”的错误]https://blog.csdn.net/weixin_30699831/article/details/96894620\n[启用搜索功能]https://blog.plcent.com/2019/11/05/hexo-theme-pure/\n[添加友链]https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md\n[启用RSS订阅]https://wxnacy.com/2018/12/12/hexo-add-rss/\n[启用RSS订阅]https://www.jianshu.com/p/2aaac7a19736","content":"<h1 id=\"常见的博客种类的介绍\"><a href=\"#常见的博客种类的介绍\" class=\"headerlink\" title=\"常见的博客种类的介绍\"></a>常见的博客种类的介绍</h1><ul>\n<li><p>动态博客</p>\n<ul>\n<li>全都自己搭建<ul>\n<li>springboot +js+mysql</li>\n</ul>\n</li>\n<li>wordpress<ul>\n<li>docker</li>\n<li>PHP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>静态博客</p>\n<ul>\n<li>基于XXX的开源博客</li>\n<li>hexo<ul>\n<li>纯前端，纯js的展示界面</li>\n<li>node.js</li>\n</ul>\n</li>\n<li>jekyllrb<ul>\n<li>Ruby</li>\n</ul>\n</li>\n<li>hugo<ul>\n<li>go语言</li>\n</ul>\n</li>\n<li>VuePress</li>\n<li>solo<ul>\n<li>java</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"一、hexo-安装教程\"><a href=\"#一、hexo-安装教程\" class=\"headerlink\" title=\"一、hexo 安装教程\"></a>一、hexo 安装教程</h1><h2 id=\"1-下载node-js\"><a href=\"#1-下载node-js\" class=\"headerlink\" title=\"1.下载node.js\"></a>1.下载node.js</h2><p>去<a href=\"http://nodejs.cn/\">http://nodejs.cn/</a> 下载长期支持版<br>直接下一步安装即可<br>安装后有两个东西<br>node.js本身<br>npm包管理器<br>确认安装成功</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">node</span> -v</span><br><span class=\"line\"><span class=\"attribute\">v16</span>.<span class=\"number\">13</span>.<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attribute\">npm</span> -v</span><br><span class=\"line\"><span class=\"attribute\">8</span>.<span class=\"number\">1</span>.<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-安装cnpm代替npm\"><a href=\"#2-安装cnpm代替npm\" class=\"headerlink\" title=\"2.安装cnpm代替npm\"></a>2.安装cnpm代替npm</h2><p>在国内npm比较慢<br>npm install -g cnpm –registry&#x3D;<a href=\"https://registry.npm.taobao.org/\">https://registry.npm.taobao.org</a><br>确认安装成功</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">cnpm -v</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-cnpm安装hexo\"><a href=\"#3-cnpm安装hexo\" class=\"headerlink\" title=\"3..cnpm安装hexo\"></a>3..cnpm安装hexo</h2><p>cnpm install -g hexo-cli<br>确认安装成功</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo -v</span></span><br></pre></td></tr></table></figure>\n<p>到这里，hexo博客的框架已经安装好了</p>\n<h1 id=\"二、搭建第一个hexo博客\"><a href=\"#二、搭建第一个hexo博客\" class=\"headerlink\" title=\"二、搭建第一个hexo博客\"></a>二、搭建第一个hexo博客</h1><h2 id=\"1-新建一个文件夹\"><a href=\"#1-新建一个文件夹\" class=\"headerlink\" title=\"1.新建一个文件夹\"></a>1.新建一个文件夹</h2><p>D盘随便新建一个文件夹blog<br>以后的东西都是在里面用的，如果出错了直接删掉找个文件夹重来就可以了</p>\n<h2 id=\"2-初始化博客\"><a href=\"#2-初始化博客\" class=\"headerlink\" title=\"2.初始化博客\"></a>2.初始化博客</h2><p>进入文件夹<br>hexo init</p>\n<h2 id=\"3-第一次启动博客\"><a href=\"#3-第一次启动博客\" class=\"headerlink\" title=\"3.第一次启动博客\"></a>3.第一次启动博客</h2><p>hexo s<br>粘贴网址，查看启动的博客</p>\n<h2 id=\"4-部署到github\"><a href=\"#4-部署到github\" class=\"headerlink\" title=\"4.部署到github\"></a>4.部署到github</h2><p>安装一个git插件<br>npm install hexo-deployer-git –save</p>\n<h2 id=\"5-对hexo进行配置\"><a href=\"#5-对hexo进行配置\" class=\"headerlink\" title=\"5.对hexo进行配置\"></a>5.对hexo进行配置</h2><p>打开blog文件夹下的_config.yml<br>拉到最底部</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: <span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">deploy:</span></span><br><span class=\"line\"><span class=\"symbol\">  type:</span> git</span><br><span class=\"line\"><span class=\"symbol\">  repository:</span> <span class=\"meta\"># github中仓库的地址</span></span><br><span class=\"line\"><span class=\"symbol\">  branch:</span> master/main <span class=\"meta\"># 参考github中主分支的名字</span></span><br></pre></td></tr></table></figure>\n<p>git config –global user.name  “name”<br>git config –global user.email  “emal”</p>\n<p>hexo d # 推送上去，就推送到github了</p>\n<h2 id=\"6-在github中开启GitHub-Pages服务\"><a href=\"#6-在github中开启GitHub-Pages服务\" class=\"headerlink\" title=\"6.在github中开启GitHub Pages服务\"></a>6.在github中开启GitHub Pages服务</h2><p>在最上面一行找到settings<br>找到Pages</p>\n<h1 id=\"三、hexo-常用命令\"><a href=\"#三、hexo-常用命令\" class=\"headerlink\" title=\"三、hexo 常用命令\"></a>三、hexo 常用命令</h1><p>下次开始再次编辑的时候，在需要编辑的文件夹里面打开git bash，不需要hexo init,直接hexo s就可以启动本地页面</p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">init</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建新页面\"><a href=\"#创建新页面\" class=\"headerlink\" title=\"创建新页面\"></a>创建新页面</h2><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n <span class=\"string\">&quot;我的页面名称&quot;</span></span><br><span class=\"line\">hexo <span class=\"keyword\">new</span> <span class=\"type\"></span>[layout] <span class=\"string\">&quot;我的页面名称&quot;</span></span><br></pre></td></tr></table></figure>\n<p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p>\n<h2 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h2><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g </span><br><span class=\"line\">hexo <span class=\"keyword\">generate</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p>每次再次想要编辑网站的时候可以直接用这个命令</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s </span><br><span class=\"line\">hexo <span class=\"keyword\">server</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"部署网站\"><a href=\"#部署网站\" class=\"headerlink\" title=\"部署网站\"></a>部署网站</h2><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo d </span></span><br><span class=\"line\"><span class=\"attribute\">hexo deploy</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"清除缓存文件\"><a href=\"#清除缓存文件\" class=\"headerlink\" title=\"清除缓存文件\"></a>清除缓存文件</h2><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo clean</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"列出网站资料\"><a href=\"#列出网站资料\" class=\"headerlink\" title=\"列出网站资料\"></a>列出网站资料</h2><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">hexo</span> list </span><br><span class=\"line\"><span class=\"type\">Usage</span>: hexo list &lt;<span class=\"keyword\">type</span>&gt;</span><br><span class=\"line\"><span class=\"type\">Arguments</span>:</span><br><span class=\"line\">  <span class=\"keyword\">type</span>  <span class=\"type\">Available</span> types: page, post, route, tag, category</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https:<span class=\"regexp\">//</span>hexo.io<span class=\"regexp\">/zh-cn/</span>docs/commands.html</span><br><span class=\"line\">直接放链接就可以了</span><br></pre></td></tr></table></figure>\n<h1 id=\"四、修复一些问题\"><a href=\"#四、修复一些问题\" class=\"headerlink\" title=\"四、修复一些问题\"></a>四、修复一些问题</h1><h2 id=\"hexo下markdown表格失效\"><a href=\"#hexo下markdown表格失效\" class=\"headerlink\" title=\"hexo下markdown表格失效\"></a>hexo下markdown表格失效</h2><p>表格和正文空开一行</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>使用UTF-8编码<br>GB 2312会乱码</p>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>文件名没有用，只有文章里面的内容的名字才有用<br>直接新建文件，开头用如下格式，就可以新建文章</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">day07123141</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2022-04-03 15:51:39</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">Linux网络编程</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Cannot-GET-x2F-xxxx\"><a href=\"#Cannot-GET-x2F-xxxx\" class=\"headerlink\" title=\"Cannot GET&#x2F;xxxx\"></a>Cannot GET&#x2F;xxxx</h2><p>使用了pure主题以后，多出了很多的分类，比如友链，书单之类的，点进出会出现<code>Cannot GET /book</code>的错误，实际情况希望能获取到自己想要的页面修复方法</p>\n<ul>\n<li>步骤一：<br>去主题目录下查看\\blog\\theme\\pure_config.yml<br>这就是当前左边的主标签<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">menu:</span></span><br><span class=\"line\"><span class=\"symbol\">  Home:</span> .</span><br><span class=\"line\"><span class=\"symbol\">  Archives:</span> archives  <span class=\"meta\"># 归档</span></span><br><span class=\"line\"><span class=\"symbol\">  Categories:</span> categories  <span class=\"meta\"># 分类</span></span><br><span class=\"line\"><span class=\"symbol\">  Links:</span> links  <span class=\"meta\"># 友链</span></span><br><span class=\"line\"><span class=\"symbol\">  About:</span> about  <span class=\"meta\"># 关于</span></span><br><span class=\"line\"><span class=\"symbol\">  Books:</span> book  <span class=\"meta\"># 关于</span></span><br></pre></td></tr></table></figure></li>\n<li>步骤二：<br>想要创建对应的标签的内容，以book举例<br>在控制台中执行<br>hexo new page “book”<br>\\blog\\source\\book\\index.md<br>index.md就是每个文件都要包含的文件，也是需要展示的内容<br>直接生成就可以了</li>\n<li>步骤三：<br>如果需要建立新的标签，重复上面两个步骤<br>如果不改编码，会在左侧标签出现<br>menu.book的问题<br>由于使用了中文字符编码，所以需要进入主题中改一下yml文件<br>\\blog\\themes\\pure\\languages<br>使用的是zh-CN.yml<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">menu:</span></span><br><span class=\"line\"><span class=\"symbol\">  Home:</span> 首页</span><br><span class=\"line\"><span class=\"symbol\">  Archives:</span> 归档</span><br><span class=\"line\"><span class=\"symbol\">  Categories:</span> 分类</span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"symbol\">  book:</span> 书</span><br><span class=\"line\"><span class=\"symbol\">  About:</span> 关于</span><br><span class=\"line\"><span class=\"symbol\">  Cat:</span> 猫 <span class=\"meta\"># 自己添加的标签</span></span><br></pre></td></tr></table></figure>\n将自己想要添加标签写上<br>重新生成</li>\n</ul>\n<h2 id=\"添加搜索功能\"><a href=\"#添加搜索功能\" class=\"headerlink\" title=\"添加搜索功能\"></a>添加搜索功能</h2><p>安装插件<br>npm i -S hexo-generator-json-content<br>在你运行 hexo g 或者 hexo s 时生效，在 hexo g 生成站点时, 会在根目录下生成 content.json 该文件内容即为搜索内容。<br>你可以对搜索内容进行自定义的配置， 只要在 _config.yml 中配置</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例: 隐藏分类和标签的搜索</span></span><br><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\">  <span class=\"attr\">dateFormat:</span> <span class=\"string\">DD/MM/YYYY</span></span><br><span class=\"line\">  <span class=\"attr\">posts:</span></span><br><span class=\"line\">    <span class=\"attr\">title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">tags:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">author:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"五、配置相关\"><a href=\"#五、配置相关\" class=\"headerlink\" title=\"五、配置相关\"></a>五、配置相关</h1><h2 id=\"配置语言\"><a href=\"#配置语言\" class=\"headerlink\" title=\"配置语言\"></a>配置语言</h2><figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">language:</span> <span class=\"built_in\">zh</span>-CN  <span class=\"meta\"># 中文</span></span><br><span class=\"line\"><span class=\"symbol\">language:</span> en        <span class=\"meta\"># 英文</span></span><br></pre></td></tr></table></figure>\n<p>得查看当前使用的主题使用的什么配置<br>我使用的主题是pure里面有languages文件有配置文件名字zh-CN.yml，使用中文需要改成这个</p>\n<h2 id=\"pure主题的改变\"><a href=\"#pure主题的改变\" class=\"headerlink\" title=\"pure主题的改变\"></a>pure主题的改变</h2><p>fancybox：实现点击图片放大的部件，默认关闭，打开后会导致友链打不开<br>profile：改变个人信息</p>\n<h3 id=\"改变每页的文章数目\"><a href=\"#改变每页的文章数目\" class=\"headerlink\" title=\"改变每页的文章数目\"></a>改变每页的文章数目</h3><p>per_page: 20</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[B站羊哥的教程]<a href=\"https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca\">https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca</a><br>[官方的链接参考] <a href=\"https://hexo.io/zh-cn/docs/commands.html\">https://hexo.io/zh-cn/docs/commands.html</a><br>hexo下Markdown语法失效总结 <a href=\"https://blog.csdn.net/weixin_42932905/article/details/106153679?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-106153679.pc_agg_new_rank&amp;utm_term=hexo+markdown%E4%B8%8D%E7%94%9F%E6%95%88&amp;spm=1000.2123.3001.4430\">https://blog.csdn.net/weixin_42932905/article/details/106153679?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-106153679.pc_agg_new_rank&amp;utm_term=hexo+markdown%E4%B8%8D%E7%94%9F%E6%95%88&amp;spm=1000.2123.3001.4430</a><br>大佬的一些教程 <a href=\"https://hwame.top/\">https://hwame.top/</a><br>[hexo博客出现“Cannot GET&#x2F;xxxx”的错误]<a href=\"https://blog.csdn.net/weixin_30699831/article/details/96894620\">https://blog.csdn.net/weixin_30699831/article/details/96894620</a><br>[启用搜索功能]<a href=\"https://blog.plcent.com/2019/11/05/hexo-theme-pure/\">https://blog.plcent.com/2019/11/05/hexo-theme-pure/</a><br>[添加友链]<a href=\"https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md\">https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md</a><br>[启用RSS订阅]<a href=\"https://wxnacy.com/2018/12/12/hexo-add-rss/\">https://wxnacy.com/2018/12/12/hexo-add-rss/</a><br>[启用RSS订阅]<a href=\"https://www.jianshu.com/p/2aaac7a19736\">https://www.jianshu.com/p/2aaac7a19736</a></p>\n","slug":"Tutorial/hexo-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/12/Tutorial/hexo-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Markdown 教程","date":"12/02/2022","path":"2022/02/12/Tutorial/Markdown-tutorial/","text":"生成目录 [TOC][TOC] 1标题1234567891011# 这是 &lt;h1&gt; 一级标题## 这是 &lt;h2&gt; 二级标题### 这是 &lt;h3&gt; 三级标题#### 这是 &lt;h4&gt; 四级标题##### 这是 &lt;h5&gt; 五级标题###### 这是 &lt;h6&gt; 六级标题 2斜体123456```*这会是 斜体 的文字*``` *这会是 斜体 的文字*```_这会是 斜体 的文字_``` _这会是 斜体 的文字_```**这会是 粗体 的文字**``` **这会是 粗体 的文字**```__这会是 粗体 的文字__``` __这会是 粗体 的文字__```_你也 **组合** 这些符号_``` _你也 **组合** 这些符号_```~~这个文字将会被横线删除~~``` ~~这个文字将会被横线删除~~ 3列表无序列表 Item 1 Item 2 Item 2a Item 2b 1234- Item 1- Item 2 - Item 2a - Item 2b 有序列表 Item 1 Item 2 Item 3 Item 3a Item 3b123451. Item 11. Item 21. Item 3 1. Item 3a 1. Item 3b 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 1234567891011* 第一项 * 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项 图片1![Alt text](图片链接 &quot;optional title&quot;) Alt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。图片链接：可以是图片的本地地址或者是网址。“optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。 引用12&gt; We&#x27;re living the future so&gt; the present is our past. 4分隔符 连字符星号下划线你可以在你的代码上面和下面添加 &#96;&#96;&#96; 来表示代码块。 1printf(&quot;hello world&quot;) 5创建表格默认表格1234| 标题1 | 标题2 | 标题3 || ------ | ------ | ------ || 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 || 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 | 标题1 标题2 标题3 文本好短 文本不短也不长 文本好长文本好长文本好长 文本好长文本好长文本好长 文本好短 文本不短也不长 带有对齐格式的表格1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 || 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 | 左对齐 右对齐 居中对齐 文本好短 文本不短也不长 文本好长文本好长文本好长 文本好长文本好长文本好长 文本好短 文本不短也不长 Markdown关于表格的语法默认标题居中对齐，内容居左对齐:-内容和标题栏居左对齐，:-:内容和标题栏居中对齐，-:内容和标题栏居右对齐| - :之间多余的空格会被忽略，-的数量至少一个内容和|之间多余的空格会被忽略 表格内换行&lt;br&gt; 转义字符\\&lt;mutex&gt;&lt;mutex&gt; 6代码块123456789@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): &#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Greater&#x27; return (param2 - param1 + 1) or Noneclass SomeClass: pass 12345#include &quot;config.h&quot;Config::Config()&#123; //端口号,默认9006 PORT = 9006;&#125; 7已完成的标记+引用[^code] 有一个launch.json文件，会调用刚刚写的 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） &#x2F;&#x2F; 引用[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8隐藏超链接[md文件编写可以使用在线所见即所得编辑器]https://www.zybuluo.com/mdeditormd文件编写可以使用在线所见即所得编辑器 参考文献https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basicshttps://www.jianshu.com/p/280c6a6f2594[md文件编写可以使用在线所见即所得编辑器]https://www.zybuluo.com/mdeditor","raw":"---\ntitle: Markdown 教程\ndate: 2022-02-12 16:44:29\ntags:\n- 教程\n---\n\n生成目录 [TOC]\n[TOC]\n\n# 1标题\n```\n# 这是 <h1> 一级标题\n\n## 这是 <h2> 二级标题\n\n### 这是 <h3> 三级标题\n\n#### 这是 <h4> 四级标题\n\n##### 这是 <h5> 五级标题\n\n###### 这是 <h6> 六级标题\n```\n\n# 2斜体\n\n```\n```*这会是 斜体 的文字*``` *这会是 斜体 的文字*\n```_这会是 斜体 的文字_``` _这会是 斜体 的文字_\n```**这会是 粗体 的文字**``` **这会是 粗体 的文字**\n```__这会是 粗体 的文字__``` __这会是 粗体 的文字__\n```_你也 **组合** 这些符号_``` _你也 **组合** 这些符号_\n```~~这个文字将会被横线删除~~``` ~~这个文字将会被横线删除~~\n```\n\n\n\n\n# 3列表\n## 无序列表\n- Item 1\n- Item 2\n  - Item 2a\n  - Item 2b\n\n```\n- Item 1\n- Item 2\n  - Item 2a\n  - Item 2b\n```\n\n## 有序列表\n1. Item 1\n1. Item 2\n1. Item 3\n   1. Item 3a\n   1. Item 3b\n```\n1. Item 1\n1. Item 2\n1. Item 3\n   1. Item 3a\n   1. Item 3b\n```\n* 第一项      \n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n\n```\n* 第一项      \n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n\n# 图片\n\n```\n![Alt text](图片链接 \"optional title\")\n```\nAlt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。 \n图片链接：可以是图片的本地地址或者是网址。\n\"optional title\"：鼠标悬置于图片上会出现的标题文字，可以不写。\n\n![Hollow Knight](../img/1.jpg)\n\n# 引用\n```\n> We're living the future so\n> the present is our past.\n```\n\n# 4分隔符\n---\n连字符\n---\n星号\n---\n下划线\n---\n\n\n你可以在你的代码上面和下面添加 ``` 来表示代码块。\n\n```\nprintf(\"hello world\") \n```\n\n\n# 5创建表格\n\n## 默认表格\n```\n| 标题1 | 标题2 | 标题3 |\n| ------ | ------ | ------ |\n| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |\n| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |\n```\n| 标题1 | 标题2 | 标题3 |\n| ------ | ------ | ------ |\n| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |\n| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |\n\n## 带有对齐格式的表格\n```\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |\n| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |\n```\n\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |\n| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |\n\n\n## Markdown关于表格的语法\n默认标题居中对齐，内容居左对齐\n:-内容和标题栏居左对齐，:-:内容和标题栏居中对齐，-:内容和标题栏居右对齐\n| - :之间多余的空格会被忽略，-的数量至少一个\n内容和|之间多余的空格会被忽略\n\n## 表格内换行\n```<br>```\n\n## 转义字符\n\n``\\<mutex>``\n\\<mutex>\n\n# 6代码块\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\n\nclass SomeClass:\n    pass\n```\n\n\n```cpp\n#include \"config.h\"\nConfig::Config(){\n    //端口号,默认9006\n    PORT = 9006;\n}\n```\n\n\n# 7已完成的标记+引用[^code]\n- [x] 有一个launch.json文件，会调用刚刚写的\n- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n- [x] 新增 Todo 列表功能\n\n\n> * 整理知识，学习笔记\n> * 发布日记，杂文，所见所想\n> * 撰写发布技术文稿（代码支持）\n> * 撰写发布学术论文（LaTeX 公式支持）\n\n\n// 引用\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，**四十一**种主流编程语言。\n\n\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n\n# 8隐藏超链接\n[md文件编写可以使用在线所见即所得编辑器]https://www.zybuluo.com/mdeditor\n[md文件编写可以使用在线所见即所得编辑器](https://www.zybuluo.com/mdeditor)\n\n\n# 参考文献\nhttps://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics\nhttps://www.jianshu.com/p/280c6a6f2594\n[md文件编写可以使用在线所见即所得编辑器]https://www.zybuluo.com/mdeditor\n\n","content":"<p>生成目录 [TOC]<br>[TOC]</p>\n<h1 id=\"1标题\"><a href=\"#1标题\" class=\"headerlink\" title=\"1标题\"></a>1标题</h1><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是 &lt;h1&gt; 一级标题</span><br><span class=\"line\"></span><br><span class=\"line\">## 这是 &lt;h2&gt; 二级标题</span><br><span class=\"line\"></span><br><span class=\"line\">### 这是 &lt;h3&gt; 三级标题</span><br><span class=\"line\"></span><br><span class=\"line\">#### 这是 &lt;h4&gt; 四级标题</span><br><span class=\"line\"></span><br><span class=\"line\">##### 这是 &lt;h5&gt; 五级标题</span><br><span class=\"line\"></span><br><span class=\"line\">###### 这是 &lt;h6&gt; 六级标题</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2斜体\"><a href=\"#2斜体\" class=\"headerlink\" title=\"2斜体\"></a>2斜体</h1><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```*这会是 斜体 的文字*``` *这会是 斜体 的文字*</span><br><span class=\"line\">```_这会是 斜体 的文字_``` _这会是 斜体 的文字_</span><br><span class=\"line\">```**这会是 粗体 的文字**``` **这会是 粗体 的文字**</span><br><span class=\"line\">```__这会是 粗体 的文字__``` __这会是 粗体 的文字__</span><br><span class=\"line\">```_你也 **组合** 这些符号_``` _你也 **组合** 这些符号_</span><br><span class=\"line\">```~~这个文字将会被横线删除~~``` ~~这个文字将会被横线删除~~</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"3列表\"><a href=\"#3列表\" class=\"headerlink\" title=\"3列表\"></a>3列表</h1><h2 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h2><ul>\n<li>Item 1</li>\n<li>Item 2<ul>\n<li>Item 2a</li>\n<li>Item 2b</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> Item 1</span><br><span class=\"line\"><span class=\"bullet\">-</span> Item 2</span><br><span class=\"line\"><span class=\"bullet\">  -</span> Item 2a</span><br><span class=\"line\"><span class=\"bullet\">  -</span> Item 2b</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h2><ol>\n<li>Item 1</li>\n<li>Item 2</li>\n<li>Item 3<ol>\n<li>Item 3a</li>\n<li>Item 3b<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">1</span>. Item <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attribute\">1</span>. Item <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"attribute\">1</span>. Item <span class=\"number\">3</span></span><br><span class=\"line\">   <span class=\"attribute\">1</span>. Item <span class=\"number\">3</span>a</span><br><span class=\"line\">   <span class=\"attribute\">1</span>. Item <span class=\"number\">3</span>b</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>第一项      </li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">*</span> 第一项      </span><br><span class=\"line\"><span class=\"bullet\">*</span> 第二项</span><br><span class=\"line\"><span class=\"bullet\">*</span> 第三项</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">+</span> 第一项</span><br><span class=\"line\"><span class=\"bullet\">+</span> 第二项</span><br><span class=\"line\"><span class=\"bullet\">+</span> 第三项</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> 第一项</span><br><span class=\"line\"><span class=\"bullet\">-</span> 第二项</span><br><span class=\"line\"><span class=\"bullet\">-</span> 第三项</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h1><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt <span class=\"built_in\">text</span>](图片链接 <span class=\"string\">&quot;optional title&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>Alt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。<br>图片链接：可以是图片的本地地址或者是网址。<br>“optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。</p>\n<p><img src=\"/../img/1.jpg\" alt=\"Hollow Knight\"></p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><figure class=\"highlight node-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"title class_\">We</span><span class=\"string\">&#x27;re living the future so</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"string\">the present is our past.</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4分隔符\"><a href=\"#4分隔符\" class=\"headerlink\" title=\"4分隔符\"></a>4分隔符</h1><hr>\n<h2 id=\"连字符\"><a href=\"#连字符\" class=\"headerlink\" title=\"连字符\"></a>连字符</h2><h2 id=\"星号\"><a href=\"#星号\" class=\"headerlink\" title=\"星号\"></a>星号</h2><h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>你可以在你的代码上面和下面添加 &#96;&#96;&#96; 来表示代码块。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">printf</span><span class=\"params\">(<span class=\"string\">&quot;hello world&quot;</span>)</span></span> </span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"5创建表格\"><a href=\"#5创建表格\" class=\"headerlink\" title=\"5创建表格\"></a>5创建表格</h1><h2 id=\"默认表格\"><a href=\"#默认表格\" class=\"headerlink\" title=\"默认表格\"></a>默认表格</h2><figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|<span class=\"string\"> 标题1 </span>|<span class=\"string\"> 标题2 </span>|<span class=\"string\"> 标题3 </span>|</span><br><span class=\"line\">|<span class=\"string\"> ------ </span>|<span class=\"string\"> ------ </span>|<span class=\"string\"> ------ </span>|</span><br><span class=\"line\">|<span class=\"string\"> 文本好短 </span>|<span class=\"string\"> 文本不短也不长 </span>|<span class=\"string\"> 文本好长文本好长文本好长 </span>|</span><br><span class=\"line\">|<span class=\"string\"> 文本好长文本好长文本好长 </span>|<span class=\"string\"> 文本好短 </span>|<span class=\"string\"> 文本不短也不长 </span>|</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>标题1</th>\n<th>标题2</th>\n<th>标题3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文本好短</td>\n<td>文本不短也不长</td>\n<td>文本好长文本好长文本好长</td>\n</tr>\n<tr>\n<td>文本好长文本好长文本好长</td>\n<td>文本好短</td>\n<td>文本不短也不长</td>\n</tr>\n</tbody></table>\n<h2 id=\"带有对齐格式的表格\"><a href=\"#带有对齐格式的表格\" class=\"headerlink\" title=\"带有对齐格式的表格\"></a>带有对齐格式的表格</h2><figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|<span class=\"string\"> 左对齐 </span>|<span class=\"string\"> 右对齐 </span>|<span class=\"string\"> 居中对齐 </span>|</span><br><span class=\"line\">|<span class=\"string\"> :-----</span>|<span class=\"string\"> ----: </span>|<span class=\"string\"> :----: </span>|</span><br><span class=\"line\">|<span class=\"string\"> 文本好短 </span>|<span class=\"string\"> 文本不短也不长 </span>|<span class=\"string\"> 文本好长文本好长文本好长 </span>|</span><br><span class=\"line\">|<span class=\"string\"> 文本好长文本好长文本好长 </span>|<span class=\"string\"> 文本好短 </span>|<span class=\"string\"> 文本不短也不长 </span>|</span><br></pre></td></tr></table></figure>\n\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">左对齐</th>\n<th align=\"right\">右对齐</th>\n<th align=\"center\">居中对齐</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">文本好短</td>\n<td align=\"right\">文本不短也不长</td>\n<td align=\"center\">文本好长文本好长文本好长</td>\n</tr>\n<tr>\n<td align=\"left\">文本好长文本好长文本好长</td>\n<td align=\"right\">文本好短</td>\n<td align=\"center\">文本不短也不长</td>\n</tr>\n</tbody></table>\n<h2 id=\"Markdown关于表格的语法\"><a href=\"#Markdown关于表格的语法\" class=\"headerlink\" title=\"Markdown关于表格的语法\"></a>Markdown关于表格的语法</h2><p>默认标题居中对齐，内容居左对齐<br>:-内容和标题栏居左对齐，:-:内容和标题栏居中对齐，-:内容和标题栏居右对齐<br>| - :之间多余的空格会被忽略，-的数量至少一个<br>内容和|之间多余的空格会被忽略</p>\n<h2 id=\"表格内换行\"><a href=\"#表格内换行\" class=\"headerlink\" title=\"表格内换行\"></a>表格内换行</h2><p><code>&lt;br&gt;</code></p>\n<h2 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h2><p><code>\\&lt;mutex&gt;</code><br>&lt;mutex&gt;</p>\n<h1 id=\"6代码块\"><a href=\"#6代码块\" class=\"headerlink\" title=\"6代码块\"></a>6代码块</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@requires_authorization</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">somefunc</span>(<span class=\"params\">param1=<span class=\"string\">&#x27;&#x27;</span>, param2=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> param1 &gt; param2: <span class=\"comment\"># interesting</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&#x27;Greater&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (param2 - param1 + <span class=\"number\">1</span>) <span class=\"keyword\">or</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SomeClass</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;config.h&quot;</span></span></span><br><span class=\"line\">Config::<span class=\"built_in\">Config</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//端口号,默认9006</span></span><br><span class=\"line\">    PORT = <span class=\"number\">9006</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"7已完成的标记-引用-code\"><a href=\"#7已完成的标记-引用-code\" class=\"headerlink\" title=\"7已完成的标记+引用[^code]\"></a>7已完成的标记+引用[^code]</h1><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 有一个launch.json文件，会调用刚刚写的</li>\n<li><input disabled=\"\" type=\"checkbox\"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新增 Todo 列表功能</li>\n</ul>\n<blockquote>\n<ul>\n<li>整理知识，学习笔记</li>\n<li>发布日记，杂文，所见所想</li>\n<li>撰写发布技术文稿（代码支持）</li>\n<li>撰写发布学术论文（LaTeX 公式支持）</li>\n</ul>\n</blockquote>\n<p>&#x2F;&#x2F; 引用<br>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>\n<p><i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>\n<h1 id=\"8隐藏超链接\"><a href=\"#8隐藏超链接\" class=\"headerlink\" title=\"8隐藏超链接\"></a>8隐藏超链接</h1><p>[md文件编写可以使用在线所见即所得编辑器]<a href=\"https://www.zybuluo.com/mdeditor\">https://www.zybuluo.com/mdeditor</a><br><a href=\"https://www.zybuluo.com/mdeditor\">md文件编写可以使用在线所见即所得编辑器</a></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics\">https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics</a><br><a href=\"https://www.jianshu.com/p/280c6a6f2594\">https://www.jianshu.com/p/280c6a6f2594</a><br>[md文件编写可以使用在线所见即所得编辑器]<a href=\"https://www.zybuluo.com/mdeditor\">https://www.zybuluo.com/mdeditor</a></p>\n","slug":"Tutorial/Markdown-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/12/Tutorial/Markdown-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]}],"categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"反思","slug":"反思","permalink":"http://example.com/tags/%E5%8F%8D%E6%80%9D/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"鸟哥的Linux私房菜","slug":"鸟哥的Linux私房菜","permalink":"http://example.com/tags/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/"}]}