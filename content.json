{"meta":{"title":"gtoo8888","subtitle":"会扇扇子的猪","description":"Linux学习者","author":"Kuku De","url":"http://example.com","root":"/"},"pages":[{"title":"友情链接","date":"16/08/2022","updated":"16/08/2022","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"","date":"26/07/2022","updated":"26/07/2022","comments":true,"path":"README.html","permalink":"http://example.com/README.html","excerpt":"","text":"blog_detail博客的具体内容"},{"title":"关于","date":"21/06/2022","updated":"21/06/2022","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"21/06/2022","updated":"21/06/2022","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"常用链接","date":"21/06/2022","updated":"16/03/2023","comments":true,"path":"source/index.html","permalink":"http://example.com/source/index.html","excerpt":"","text":"官方网站和文档 CMake https://cmake.org/ hexo https://hexo.io/zh-cn/ raspberry https://www.raspberrypi.org/ 路过图床 https://imgtu.com/ halo博客系统https://halo.run/ 阿里云开发者网站 https://developer.aliyun.com/?spm=a2c6h.23182525.J_5404914170.1.77483b2fjWTL8k Google Research https://research.google/ docker hub https://hub.docker.com/ WIKI PythonRobotics documentation https://pythonrobotics.readthedocs.io/en/latest/index.html CMake Document https://cmake.org/cmake/help/v3.23/ ROS document http://wiki.ros.org/Documentation TIDB https://docs.pingcap.com/zh/tidb/stable/overview redis https://www.redis.net.cn/ 腾讯云开发者社区 https://cloud.tencent.com/developer/chapter/12850 opencv document https://docs.opencv.org/4.x/ pytorch document https://pytorch.org/tutorials/ Wireshark User’s Guide https://www.wireshark.org/docs/wsug_html_chunked/ 鸟哥的Linuxs私房菜 http://cn.linux.vbird.org/linux_basic/linux_basic.php zeromq https://zguide.zeromq.org/ ZeroMQ 教程 https://www.jianshu.com/p/a8b657472518 zeroguide 中文翻译 https://wizardforcel.gitbooks.io/zmq-guide/content/chapter1.html https://www.cnblogs.com/Anker/p/4706244.html https://blog.csdn.net/a19891024/article/details/78182287 摩天轮中国数据库流行排名 https://www.modb.pro/dbRank LABULADONG 的算法网站 https://labuladong.github.io/algo/5/43/ 中文WIKI 鸟哥的Linux私房菜 https://linux.vbird.org/ 树莓派实验室 https://shumeipai.nxez.com/download 古月居 https://www.guyuehome.com/ 外文网站 Hacker News https://news.ycombinator.com/ stackoverflow https://stackoverflow.com/ Reddit https://www.reddit.com/ &#x2F;cpp: &#x2F;programming： &#x2F;java： https://www.reddit.com/r/programming/ &#x2F;shittyprogramming： Medium https://medium.com/ Quora https://www.quora.com/ InfoQ https://www.infoq.com/ 求职 牛客网 https://www.nowcoder.com/discuss/experience/index?parentJobId=1 大佬自己建的网站 代码随想录 https://programmercarl.com/ 阿秀的求职笔记 https://interviewguide.cn/#/ 编程之路 https://www.r2coding.com/#/ 经典技术书籍 https://awesome-programming-books.github.io/ 数据结构的演示 https://www.cs.usfca.edu/~galles/visualization/ pkucs自学指南 https://csdiy.wiki/ 小白视角：一文读懂社长的TinyWebServer 追梦算法网 http://acm.mangata.ltd/ vincents https://vincents.top/2022/08/14/60.html 被删的前端游乐场 https://godbasin.github.io/front-end-playground/ go+pythonhttps://jiajunhuang.com/ LearnData 开源笔记 https://vincentsx.github.io/ 一些动画在线练习 Learn Git Branching https://learngitbranching.js.org/?locale=zh_CN 技术博客学习 Luc https://www.cnblogs.com/figure9 codedump的网络日志 https://www.codedump.info/post/20200122-series-pages/ 程序员的喵 https://catcoding.me/ 秦怀杂货店 http://aphysia.cn/ 外国博客 Kent C. Dodds https://kentcdodds.com/ 软件社区 v2ex https://www.v2ex.com/t/852843#reply11 博客形式学习 阮一峰的博客 http://www.ruanyifeng.com/home.html 小冰的博客 https://zfe.space/ 鴻塵 https://hwame.top/ hexo https://bestzuo.cn/ goodwell https://goodwell42.github.io/ std::mutex 用法與範例 https://shengyu7697.github.io/std-mutex/ 前端写的博客 https://carefulsuper.github.io/#articles ACM学习计划 https://gist.github.com/dodola/6227480 NOIP2018游记 http://lycltb.top/post/noip2018/ 打了三年ACM，拿了几个金牌 https://mp.ofweek.com/ee/a356714167237 课程 MIT 6.828 Fall 2018 https://pdos.csail.mit.edu/6.828/2018/schedule.html MIT 6.828 Fall 2011 https://pdos.csail.mit.edu/6.828/2011/schedule.html CS144 https://cs144.github.io/ C++高薪求职项目 Linux高并发服务器开发 https://www.nowcoder.com/courses/cover/live/504 刷题 leetcode https://leetcode-cn.com/ 洛谷 https://www.luogu.com.cn/ codeforces https://codeforces.com/ AtCoder https://atcoder.jp/ 代码源 http://oj.daimayuan.top/ AcWing https://www.acwing.com/ vjudge https://vjudge.net/ codetop企业题库 https://codetop.cc/home 牛客竞赛OJ https://ac.nowcoder.com/acm/home/935083664 AtCoder从小白到大神的进阶攻略 https://www.cnblogs.com/LHYLHY/p/11572011.html OIWIKI https://oi-wiki.org/ 宫水三叶的刷题日记 https://github.com/SharingSource/LogicStack-LeetCode/wiki 技术文档 进程间通讯 https://www.cnblogs.com/xiaolincoding/p/13402297.html 嵌入式相关电子社区 电路城 https://www.cirmall.com/ 51黑论坛 http://www.51hei.com/bbs/ 电子发烧友 https://bbs.elecfans.com/ Free PCB Design https://circuitmaker.com/ 官网 ST https://www.st.com/content/st_com/en.html keil https://www.keil.com/download/product/ TI官网 https://www.ti.com.cn/ ADI https://www.analog.com/cn/index.html arduino中文社区 https://www.arduino.cn/ alldatesheet https://www.alldatasheet.com/ 淘宝购物 洋桃电子 http://www.doyoung.net/YT/ 野火产品下载中心 https://doc.embedfire.com/products/link/zh/latest/index.html crazepony http://www.crazepony.com/wiki/algorithm-pid.html 工具索引类 w3school https://www.w3school.com.cn/ 重庆大学开源镜像 https://mirrors.cqu.edu.cn/ 站长工具ping https://ping.chinaz.com/ 找文献arxiv https://arxiv.org/ 翻译 DeepL翻译 https://www.deepl.com/translator 其他 Starting Strength https://startingstrength.com/ 测网速 https://beta.speedtest.net/ 思维导图 https://www.processon.com/ 路过图床 https://imgtu.com/ make a gif https://makeagif.com/ 木及简历 https://www.mujicv.com/ RSS订阅其他博主 https://feedly.com/i/welcome 地图 阿里云地图 http://datav.aliyun.com/portal/school/atlas/area_selector 中国标准地图服务网站 http://bzdt.ch.mnr.gov.cn/ PPT模板 第一PPT https://www.1ppt.com/ 优品PPT https://www.ypppt.com/ 小软件 everything https://www.voidtools.com/zh-cn/downloads/ 阿里云服务器白嫖 https://developer.aliyun.com/plan/acc 其他 在线整数数列查询网站 http://oeis.org/"},{"title":"raft-kv","date":"19/08/2022","updated":"17/04/2023","comments":true,"path":"多机协同.html","permalink":"http://example.com/%E5%A4%9A%E6%9C%BA%E5%8D%8F%E5%90%8C.html","excerpt":"","text":"sudo apt-get install libyaml-cpp-dev"}],"posts":[{"title":"app总结","date":"16/04/2023","path":"2023/04/16/Others/app/","text":"对于前端开发知识的一些总结 大前端——泛GUI交互 HTML CSS javascript TypeScript nodejs 原生app开发 开发adroid ios facebook React native google dart flutter webapp开发 Vue React 混合开发HybirdAPP 微信公众号 小程序 Electron H5页面嵌入到桌面段应用 ES6ReactPromisehtml5Css3AxiosJqueryVue RouterNode.jsAJAX webpack、rollup、vite 原生开发 Android Studio JAVA Kotlin 跨端开发 uniapp HBuildX Flutter dart Google 公司开发的一款跨平台的 UI 框架 Taro 京东 参考资料Flutter官网uni-app官网Android StudioAndroid Studio 2022.1.1版本 保姆级安装教程","raw":"---\ntitle: app总结\ndate: 2023-04-16 15:46:00\ntags:\n---\n\n对于前端开发知识的一些总结\n\n\n\n\n大前端——泛GUI交互\n    HTML\n    CSS\n    javascript\n    TypeScript\n    nodejs\n    原生app开发\n        开发adroid ios\n        facebook\n            React native\n\n        google\n            dart\n            flutter\n\n\n    webapp开发\n        Vue\n        React\n\n    混合开发HybirdAPP\n        微信公众号\n        小程序\n        Electron\n            H5页面嵌入到桌面段应用\nES6\nReact        \nPromise\nhtml5\nCss3\nAxios\nJquery\nVue Router\nNode.js\nAJAX\n\n\n\n\nwebpack、rollup、vite\n\n# 原生开发\n1. Android Studio\n   1. JAVA\n   2. Kotlin\n\n\n# 跨端开发\n1. uniapp\n   1. HBuildX\n2. Flutter\n   1. dart \n   2. Google 公司开发的一款跨平台的 UI 框架\n3. Taro \n   1. 京东\n\n# 参考资料\n[Flutter官网](https://flutter.cn/)\n[uni-app官网](https://www.dcloud.io/)\n[Android Studio](https://developer.android.google.cn/?hl=zh-cn)\n[Android Studio 2022.1.1版本 保姆级安装教程](https://blog.csdn.net/SherlockStark/article/details/129298768?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D)\n\n","content":"<p>对于前端开发知识的一些总结</p>\n<p>大前端——泛GUI交互<br>    HTML<br>    CSS<br>    javascript<br>    TypeScript<br>    nodejs<br>    原生app开发<br>        开发adroid ios<br>        facebook<br>            React native</p>\n<pre><code>    google\n        dart\n        flutter\n\n\nwebapp开发\n    Vue\n    React\n\n混合开发HybirdAPP\n    微信公众号\n    小程序\n    Electron\n        H5页面嵌入到桌面段应用\n</code></pre>\n<p>ES6<br>React<br>Promise<br>html5<br>Css3<br>Axios<br>Jquery<br>Vue Router<br>Node.js<br>AJAX</p>\n<p>webpack、rollup、vite</p>\n<h1 id=\"原生开发\"><a href=\"#原生开发\" class=\"headerlink\" title=\"原生开发\"></a>原生开发</h1><ol>\n<li>Android Studio<ol>\n<li>JAVA</li>\n<li>Kotlin</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"跨端开发\"><a href=\"#跨端开发\" class=\"headerlink\" title=\"跨端开发\"></a>跨端开发</h1><ol>\n<li>uniapp<ol>\n<li>HBuildX</li>\n</ol>\n</li>\n<li>Flutter<ol>\n<li>dart </li>\n<li>Google 公司开发的一款跨平台的 UI 框架</li>\n</ol>\n</li>\n<li>Taro <ol>\n<li>京东</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://flutter.cn/\">Flutter官网</a><br><a href=\"https://www.dcloud.io/\">uni-app官网</a><br><a href=\"https://developer.android.google.cn/?hl=zh-cn\">Android Studio</a><br><a href=\"https://blog.csdn.net/SherlockStark/article/details/129298768?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8=\">Android Studio 2022.1.1版本 保姆级安装教程</a></p>\n","slug":"Others/app","updated":"16/04/2023","comments":true,"link":"","permalink":"http://example.com/2023/04/16/Others/app/","excerpt":"","categories":[],"tags":[]},{"title":"ffmpeg","date":"14/04/2023","path":"2023/04/14/Project/ffmpeg/","text":".&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg –enable-shared –disable-static –disable-doc –enable-gpl –enable-libx264 fmpeg-master-latest-win64-gpl-shared.zip avcodec.lib;avdevice.lib;avfilter.lib;avformat.lib;avutil.lib;swresample.lib;swscale.lib;postproc.lib 1234567891011121314MSBuild属性宏:- $(OutDir)：输出目录，用于存放生成的可执行文件或库文件。- $(ProjectName)：项目名称，通常与项目文件名相同。- $(Configuration)：当前项目配置，例如Debug或Release。- $(Platform)：当前项目平台，例如Win32或x64。- $(SolutionDir)：解决方案目录，包含解决方案文件所在的路径。- $(ProjectDir)：项目目录，包含项目文件所在的路径。$(SolutionDir)$(SolutionExt)$(SolutionFileName)$(SolutionName)$(SolutionPath) FFmpeg一共包含8个库：avcodec：编解码（最重要的库）。avformat：封装格式处理。avfilter：滤镜特效处理。avdevice：各种设备的输入输出。avutil：工具库（大部分库都需要这个库的支持）。postproc：后加工。swresample：音频采样数据格式转换。swscale：视频像素数据格式转换。其中加粗的库为本课程涉及到的库。 参考资料ffmpeg官网 linuxUbuntu上安装ffmpegUbuntu下x264库编译安装编译ffmpeg错误：ERROR: x264 not found using pkg-config编译安装libx264库遇到Found no assembler Minimum version is nasm-nasm官网nasm下载链接 windowsffmpeg windows下载地址FFmpeg三种版本（static、shared、dev）和实际操作举例","raw":"---\ntitle: ffmpeg\ndate: 2023-04-14 22:29:24\ntags:\n---\n\n./configure --prefix=/usr/local/ffmpeg --enable-shared --disable-static --disable-doc  --enable-gpl --enable-libx264\n\nfmpeg-master-latest-win64-gpl-shared.zip\n\n\navcodec.lib;avdevice.lib;avfilter.lib;avformat.lib;avutil.lib;swresample.lib;swscale.lib;postproc.lib\n\n\n\n\n\n\n\n\n```\nMSBuild属性宏:\n- $(OutDir)：输出目录，用于存放生成的可执行文件或库文件。\n- $(ProjectName)：项目名称，通常与项目文件名相同。\n- $(Configuration)：当前项目配置，例如Debug或Release。\n- $(Platform)：当前项目平台，例如Win32或x64。\n- $(SolutionDir)：解决方案目录，包含解决方案文件所在的路径。\n- $(ProjectDir)：项目目录，包含项目文件所在的路径。\n\n\n$(SolutionDir)\n$(SolutionExt)\n$(SolutionFileName)\n$(SolutionName)\n$(SolutionPath)\n```\n\n\n\nFFmpeg一共包含8个库：\n**avcodec：编解码（最重要的库）。**\n**avformat：封装格式处理。**\navfilter：滤镜特效处理。\navdevice：各种设备的输入输出。\n**avutil：工具库（大部分库都需要这个库的支持）。**\npostproc：后加工。\nswresample：音频采样数据格式转换。\n**swscale：视频像素数据格式转换。**\n其中加粗的库为本课程涉及到的库。\n\n\n# 参考资料\n[ffmpeg官网](https://ffmpeg.org/)\n\n## linux\n[Ubuntu上安装ffmpeg](https://blog.csdn.net/TracelessLe/article/details/107362505)\n[Ubuntu下x264库编译安装](https://blog.csdn.net/TracelessLe/article/details/107522845)\n[编译ffmpeg错误：ERROR: x264 not found using pkg-config](https://blog.csdn.net/qq_44054791/article/details/127861823)\n[编译安装libx264库遇到Found no assembler Minimum version is nasm-](https://www.lixian.fun/4237.html)\n[nasm官网](https://www.nasm.us/)\n[nasm下载链接](https://www.nasm.us/pub/nasm/releasebuilds/)\n\n## windows\n[ffmpeg windows下载地址](https://github.com/BtbN/FFmpeg-Builds/releases)\n[FFmpeg三种版本（static、shared、dev）和实际操作举例](https://blog.csdn.net/ustc_sse_shenzhang/article/details/102546753)\n\n\n\n\n","content":"<p>.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg –enable-shared –disable-static –disable-doc  –enable-gpl –enable-libx264</p>\n<p>fmpeg-master-latest-win64-gpl-shared.zip</p>\n<p>avcodec.lib;avdevice.lib;avfilter.lib;avformat.lib;avutil.lib;swresample.lib;swscale.lib;postproc.lib</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSBuild属性宏:</span><br><span class=\"line\">- $<span class=\"comment\">(OutDir)</span>：输出目录，用于存放生成的可执行文件或库文件。</span><br><span class=\"line\">- $<span class=\"comment\">(ProjectName)</span>：项目名称，通常与项目文件名相同。</span><br><span class=\"line\">- $<span class=\"comment\">(Configuration)</span>：当前项目配置，例如Debug或Release。</span><br><span class=\"line\">- $<span class=\"comment\">(Platform)</span>：当前项目平台，例如Wi<span class=\"symbol\">n32</span>或x<span class=\"number\">64</span>。</span><br><span class=\"line\">- $<span class=\"comment\">(SolutionDir)</span>：解决方案目录，包含解决方案文件所在的路径。</span><br><span class=\"line\">- $<span class=\"comment\">(ProjectDir)</span>：项目目录，包含项目文件所在的路径。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$<span class=\"comment\">(SolutionDir)</span></span><br><span class=\"line\">$<span class=\"comment\">(SolutionExt)</span></span><br><span class=\"line\">$<span class=\"comment\">(SolutionFileName)</span></span><br><span class=\"line\">$<span class=\"comment\">(SolutionName)</span></span><br><span class=\"line\">$<span class=\"comment\">(SolutionPath)</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>FFmpeg一共包含8个库：<br><strong>avcodec：编解码（最重要的库）。</strong><br><strong>avformat：封装格式处理。</strong><br>avfilter：滤镜特效处理。<br>avdevice：各种设备的输入输出。<br><strong>avutil：工具库（大部分库都需要这个库的支持）。</strong><br>postproc：后加工。<br>swresample：音频采样数据格式转换。<br><strong>swscale：视频像素数据格式转换。</strong><br>其中加粗的库为本课程涉及到的库。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://ffmpeg.org/\">ffmpeg官网</a></p>\n<h2 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h2><p><a href=\"https://blog.csdn.net/TracelessLe/article/details/107362505\">Ubuntu上安装ffmpeg</a><br><a href=\"https://blog.csdn.net/TracelessLe/article/details/107522845\">Ubuntu下x264库编译安装</a><br><a href=\"https://blog.csdn.net/qq_44054791/article/details/127861823\">编译ffmpeg错误：ERROR: x264 not found using pkg-config</a><br><a href=\"https://www.lixian.fun/4237.html\">编译安装libx264库遇到Found no assembler Minimum version is nasm-</a><br><a href=\"https://www.nasm.us/\">nasm官网</a><br><a href=\"https://www.nasm.us/pub/nasm/releasebuilds/\">nasm下载链接</a></p>\n<h2 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h2><p><a href=\"https://github.com/BtbN/FFmpeg-Builds/releases\">ffmpeg windows下载地址</a><br><a href=\"https://blog.csdn.net/ustc_sse_shenzhang/article/details/102546753\">FFmpeg三种版本（static、shared、dev）和实际操作举例</a></p>\n","slug":"Project/ffmpeg","updated":"15/04/2023","comments":true,"link":"","permalink":"http://example.com/2023/04/14/Project/ffmpeg/","excerpt":"","categories":[],"tags":[]},{"title":"google test","date":"14/04/2023","path":"2023/04/14/Project/google-test/","text":"1.安装教程123456git clone git@github.com:google/googletest.gitmkdir build &amp;&amp; cd buildmake -j allfind . -name &quot;*.a&quot; # 查看静态链接库是否生成make insatllls -l /user/local/ # 查看是否安装过去了 2. demo测试12cd googletests/samplesg++ ../src/gtest_main.cc sample1.cc sample1_unittest.cc -o sample1 -lgtest -lgmock -lpthread -std=c++14 # 一定要使用C++11以上，C++14或者C++17才能编译通过 样例分析：gtest_main.cc: 测试主程序的入口sample1.cc：等待测试的源码sample1_unittest.cc: 测试用例 3.写一个自己的测试用例1.有一个包含GTEST_API_的主函数，引入testing::InitGoogleTest2.包含头文件gtest&#x2F;gtest.h3.使用TEST宏定义，第一个参数是test suite的名字，第二个参数是test case的名字，写自己的测试函数4.在测试函数中使用EXPECT_EQ,EXPECT_NE,EXPECT_LT,EXPECT_LE,EXPECT_GT,EXPECT_GE5.在主函数中调用RUN_ALL_TESTS()，返回值是0表示成功，非0表示失败6.编译，链接gtest库，运行 参考资料官方文档github仓库Google Test(GTEST)使用入门（1）- 下载编译安装执行Ubuntu 16.04安装gtest遇坑，成功安装及使用记录","raw":"---\ntitle: google test\ndate: 2023-04-14 19:40:49\ntags:\n---\n\n\n# 1.安装教程\n```shell\ngit clone git@github.com:google/googletest.git\nmkdir build && cd build\nmake -j all\nfind . -name \"*.a\" # 查看静态链接库是否生成\nmake insatll\nls -l /user/local/ # 查看是否安装过去了\n```\n\n# 2. demo测试\n```shell\ncd googletests/samples\ng++ ../src/gtest_main.cc sample1.cc sample1_unittest.cc -o sample1 -lgtest -lgmock -lpthread -std=c++14 # 一定要使用C++11以上，C++14或者C++17才能编译通过\n```\n样例分析：\ngtest_main.cc: 测试主程序的入口\nsample1.cc：等待测试的源码\nsample1_unittest.cc: 测试用例\n\n\n# 3.写一个自己的测试用例\n1.有一个包含GTEST_API_的主函数，引入testing::InitGoogleTest\n2.包含头文件gtest/gtest.h\n3.使用TEST宏定义，第一个参数是test suite的名字，第二个参数是test case的名字，写自己的测试函数\n4.在测试函数中使用EXPECT_EQ,EXPECT_NE,EXPECT_LT,EXPECT_LE,EXPECT_GT,EXPECT_GE\n5.在主函数中调用RUN_ALL_TESTS()，返回值是0表示成功，非0表示失败\n6.编译，链接gtest库，运行\n\n# 参考资料\n[官方文档](https://google.github.io/googletest/)\n[github仓库](https://github.com/google/googletest)\n[Google Test(GTEST)使用入门（1）- 下载编译安装执行](https://blog.csdn.net/wdcyf15/article/details/108855960)\n[Ubuntu 16.04安装gtest遇坑，成功安装及使用记录](https://blog.csdn.net/qq_34525916/article/details/113752768)\n\n\n","content":"<h1 id=\"1-安装教程\"><a href=\"#1-安装教程\" class=\"headerlink\" title=\"1.安装教程\"></a>1.安装教程</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:google/googletest.git</span><br><span class=\"line\">mkdir build &amp;&amp; cd build</span><br><span class=\"line\">make -j all</span><br><span class=\"line\">find . -name &quot;*.a&quot; # 查看静态链接库是否生成</span><br><span class=\"line\">make insatll</span><br><span class=\"line\">ls -l /user/local/ # 查看是否安装过去了</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-demo测试\"><a href=\"#2-demo测试\" class=\"headerlink\" title=\"2. demo测试\"></a>2. demo测试</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd googletests/samples</span><br><span class=\"line\">g++ ../src/gtest_main.cc sample1.cc sample1_unittest.cc -o sample1 -lgtest -lgmock -lpthread -std=c++14 # 一定要使用C++11以上，C++14或者C++17才能编译通过</span><br></pre></td></tr></table></figure>\n<p>样例分析：<br>gtest_main.cc: 测试主程序的入口<br>sample1.cc：等待测试的源码<br>sample1_unittest.cc: 测试用例</p>\n<h1 id=\"3-写一个自己的测试用例\"><a href=\"#3-写一个自己的测试用例\" class=\"headerlink\" title=\"3.写一个自己的测试用例\"></a>3.写一个自己的测试用例</h1><p>1.有一个包含GTEST_API_的主函数，引入testing::InitGoogleTest<br>2.包含头文件gtest&#x2F;gtest.h<br>3.使用TEST宏定义，第一个参数是test suite的名字，第二个参数是test case的名字，写自己的测试函数<br>4.在测试函数中使用EXPECT_EQ,EXPECT_NE,EXPECT_LT,EXPECT_LE,EXPECT_GT,EXPECT_GE<br>5.在主函数中调用RUN_ALL_TESTS()，返回值是0表示成功，非0表示失败<br>6.编译，链接gtest库，运行</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://google.github.io/googletest/\">官方文档</a><br><a href=\"https://github.com/google/googletest\">github仓库</a><br><a href=\"https://blog.csdn.net/wdcyf15/article/details/108855960\">Google Test(GTEST)使用入门（1）- 下载编译安装执行</a><br><a href=\"https://blog.csdn.net/qq_34525916/article/details/113752768\">Ubuntu 16.04安装gtest遇坑，成功安装及使用记录</a></p>\n","slug":"Project/google-test","updated":"14/04/2023","comments":true,"link":"","permalink":"http://example.com/2023/04/14/Project/google-test/","excerpt":"","categories":[],"tags":[]},{"title":"EIseg环境安装","date":"23/03/2023","path":"2023/03/23/Environment-Configuration/EIseg_install/","text":"1. 安装python勾选安装环境变量 2. 安装anaconda 不要勾选安装环境变量 安装后增加环境变量E:\\AnacondaE:\\Anaconda\\ScriptsE:\\Anaconda\\Library\\mingw-w64\\binE:\\Anaconda\\Library\\usr\\binE:\\Anaconda\\Library\\bin 测试是否安装成功 1conda --version anaconda换源 先打开第一次anaconda，会创建.condarc 在C:\\Users{username} 文件夹下面修改.condarc 123456789101112131415channels: - defaultsshow_channel_urls: truedefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud conda clean -i 检测是否换源成功 1conda config --show-sources # 仅查看所有镜像 3. 安装EIseg 创建自己的环境 12345# 环境所用的python版本需要在后面指定，如果不指定默认Anaconda自带python版本# doccano 是环境名称，可根据自己命名区分不同自己的环境conda create -n eiseg_env python=3.10# 激活自己的环境conda activate ant 切换到新创建的环境中，打开open Terminal 安装PaddlePaddle，是依赖环境 1pip3 install paddlepaddle -i https://mirror.baidu.com/pypi/simple 安装EIseg 1pip3 install eiseg -i https://mirror.baidu.com/pypi/simple 启动直接在命令行中输入eiseg 配置EIseg 只保存彩色图片 编辑快捷键 前后移动 自动保存 删除所有多边形 保存路径不能有中文 基础操作 正负样本点 转化为矩形，拖动 删除矩形 标注时候需要注意每次打开操作 选择保存类型，只保留伪彩色，coco格式 加载模型 打开文件夹 载入标签 标注 空格，转化为矩形 下一张 anaconda常用指令12345678910conda config --show # 查看conda的配置，确认channelsconda config --show-sources # 仅查看所有镜像conda config --get channels # 查看已经添加的channelsconda config --show channels # 查看已经添加的channelsconda list # 当前安装的包列表# 未查看conda update -n base condaconda install --yes --file requirements.txtconda config --remove-key channels 参考资料[Anaconda超详细安装教程（Windows环境下）]https://blog.csdn.net/fan18317517352/article/details/123035625 [新手教程一：Anaconda新建开发环境]https://blog.csdn.net/qq_42573052/article/details/113770662 anaconda 换清华镜像源 windows 清华大学开源软件镜像站 Anaconda之导出&#x2F;导出配置好的虚拟环境 EISeg工具对应博文 EIseg官方安装说明 飞桨安装参考文档","raw":"---\ntitle: EIseg环境安装\ndate: 2023-03-23 14:00:50\ntags:\n---\n\n# 1. 安装python\n勾选安装环境变量\n\n# 2. 安装anaconda\n1. 不要勾选安装环境变量\n\n\n2. 安装后增加环境变量\nE:\\Anaconda \nE:\\Anaconda\\Scripts \nE:\\Anaconda\\Library\\mingw-w64\\bin\nE:\\Anaconda\\Library\\usr\\bin \nE:\\Anaconda\\Library\\bin\n\n测试是否安装成功\n```bash\nconda --version\n```\n1. anaconda换源\n\n   1. 先打开第一次anaconda，会创建.condarc\n   2. 在C:\\Users\\{username} 文件夹下面修改.condarc\n\n```bash\nchannels:\n  - defaults\nshow_channel_urls: true\ndefault_channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n```\n\n   3. conda clean -i\n   \n   \n   4. 检测是否换源成功\n\n```bash\nconda config --show-sources # 仅查看所有镜像\n```\n\n\n\n# 3. 安装EIseg\n\n1. 创建自己的环境\n\n\n```bash\n# 环境所用的python版本需要在后面指定，如果不指定默认Anaconda自带python版本\n# doccano 是环境名称，可根据自己命名区分不同自己的环境\nconda create -n eiseg_env python=3.10\n# 激活自己的环境\nconda activate ant\n```\n\n2. 切换到新创建的环境中，打开open Terminal\n\n3. 安装PaddlePaddle，是依赖环境\n\n```bash\npip3 install paddlepaddle -i https://mirror.baidu.com/pypi/simple\n```\n\n\n4. 安装EIseg\n```bash\npip3 install eiseg -i https://mirror.baidu.com/pypi/simple\n```\n\n5. 启动\n直接在命令行中输入eiseg\n\n\n# 配置EIseg\n1. 只保存彩色图片\n2. 编辑快捷键\n   1. 前后移动\n   2. 自动保存\n   3. 删除所有多边形\n3. 保存路径不能有中文\n\n\n# 基础操作\n1. 正负样本点\n2. 转化为矩形，拖动\n3. 删除矩形\n\n# 标注时候需要注意\n\n\n# 每次打开操作\n1. 选择保存类型，只保留伪彩色，coco格式\n2. 加载模型\n3. 打开文件夹\n4. 载入标签\n5. 标注\n6. 空格，转化为矩形\n7. 下一张\n\n# anaconda常用指令\n```bash\nconda config --show # 查看conda的配置，确认channels\nconda config --show-sources # 仅查看所有镜像\nconda config --get channels # 查看已经添加的channels\nconda config --show channels # 查看已经添加的channels\nconda list # 当前安装的包列表\n\n# 未查看\nconda update -n base conda\nconda install --yes --file requirements.txt\nconda config --remove-key channels\n```\n\n\n# 参考资料\n[Anaconda超详细安装教程（Windows环境下）]https://blog.csdn.net/fan18317517352/article/details/123035625 <br/>\n[新手教程一：Anaconda新建开发环境]https://blog.csdn.net/qq_42573052/article/details/113770662 <br/>\n[anaconda 换清华镜像源 windows](https://blog.csdn.net/jasneik/article/details/114227716) <br/>\n[清华大学开源软件镜像站](https://mirrors.tuna.tsinghua.edu.cn/) <br/>\n[Anaconda之导出/导出配置好的虚拟环境](https://blog.csdn.net/qq_43382635/article/details/127124980) <br/>\n[EISeg工具对应博文](https://blog.csdn.net/qq_37541097/article/details/120154543) <br/>\n[EIseg官方安装说明](https://github.com/PaddlePaddle/PaddleSeg/blob/release/2.7/README_CN.md) <br/>\n[飞桨安装参考文档](https://www.paddlepaddle.org.cn/documentation/docs/zh/install/index_cn.html) <br/>\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"1-安装python\"><a href=\"#1-安装python\" class=\"headerlink\" title=\"1. 安装python\"></a>1. 安装python</h1><p>勾选安装环境变量</p>\n<h1 id=\"2-安装anaconda\"><a href=\"#2-安装anaconda\" class=\"headerlink\" title=\"2. 安装anaconda\"></a>2. 安装anaconda</h1><ol>\n<li><p>不要勾选安装环境变量</p>\n</li>\n<li><p>安装后增加环境变量<br>E:\\Anaconda<br>E:\\Anaconda\\Scripts<br>E:\\Anaconda\\Library\\mingw-w64\\bin<br>E:\\Anaconda\\Library\\usr\\bin<br>E:\\Anaconda\\Library\\bin</p>\n</li>\n</ol>\n<p>测试是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda --version</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>anaconda换源</p>\n<ol>\n<li>先打开第一次anaconda，会创建.condarc</li>\n<li>在C:\\Users{username} 文件夹下面修改.condarc</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channels:</span><br><span class=\"line\">  - defaults</span><br><span class=\"line\">show_channel_urls: <span class=\"literal\">true</span></span><br><span class=\"line\">default_channels:</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class=\"line\">custom_channels:</span><br><span class=\"line\">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class=\"line\">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class=\"line\">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class=\"line\">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class=\"line\">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class=\"line\">  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class=\"line\">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>conda clean -i</p>\n</li>\n<li><p>检测是否换源成功</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --show-sources <span class=\"comment\"># 仅查看所有镜像</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"3-安装EIseg\"><a href=\"#3-安装EIseg\" class=\"headerlink\" title=\"3. 安装EIseg\"></a>3. 安装EIseg</h1><ol>\n<li>创建自己的环境</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 环境所用的python版本需要在后面指定，如果不指定默认Anaconda自带python版本</span></span><br><span class=\"line\"><span class=\"comment\"># doccano 是环境名称，可根据自己命名区分不同自己的环境</span></span><br><span class=\"line\">conda create -n eiseg_env python=3.10</span><br><span class=\"line\"><span class=\"comment\"># 激活自己的环境</span></span><br><span class=\"line\">conda activate ant</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>切换到新创建的环境中，打开open Terminal</p>\n</li>\n<li><p>安装PaddlePaddle，是依赖环境</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install paddlepaddle -i https://mirror.baidu.com/pypi/simple</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"4\">\n<li><p>安装EIseg</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install eiseg -i https://mirror.baidu.com/pypi/simple</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动<br>直接在命令行中输入eiseg</p>\n</li>\n</ol>\n<h1 id=\"配置EIseg\"><a href=\"#配置EIseg\" class=\"headerlink\" title=\"配置EIseg\"></a>配置EIseg</h1><ol>\n<li>只保存彩色图片</li>\n<li>编辑快捷键<ol>\n<li>前后移动</li>\n<li>自动保存</li>\n<li>删除所有多边形</li>\n</ol>\n</li>\n<li>保存路径不能有中文</li>\n</ol>\n<h1 id=\"基础操作\"><a href=\"#基础操作\" class=\"headerlink\" title=\"基础操作\"></a>基础操作</h1><ol>\n<li>正负样本点</li>\n<li>转化为矩形，拖动</li>\n<li>删除矩形</li>\n</ol>\n<h1 id=\"标注时候需要注意\"><a href=\"#标注时候需要注意\" class=\"headerlink\" title=\"标注时候需要注意\"></a>标注时候需要注意</h1><h1 id=\"每次打开操作\"><a href=\"#每次打开操作\" class=\"headerlink\" title=\"每次打开操作\"></a>每次打开操作</h1><ol>\n<li>选择保存类型，只保留伪彩色，coco格式</li>\n<li>加载模型</li>\n<li>打开文件夹</li>\n<li>载入标签</li>\n<li>标注</li>\n<li>空格，转化为矩形</li>\n<li>下一张</li>\n</ol>\n<h1 id=\"anaconda常用指令\"><a href=\"#anaconda常用指令\" class=\"headerlink\" title=\"anaconda常用指令\"></a>anaconda常用指令</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --show <span class=\"comment\"># 查看conda的配置，确认channels</span></span><br><span class=\"line\">conda config --show-sources <span class=\"comment\"># 仅查看所有镜像</span></span><br><span class=\"line\">conda config --get channels <span class=\"comment\"># 查看已经添加的channels</span></span><br><span class=\"line\">conda config --show channels <span class=\"comment\"># 查看已经添加的channels</span></span><br><span class=\"line\">conda list <span class=\"comment\"># 当前安装的包列表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 未查看</span></span><br><span class=\"line\">conda update -n base conda</span><br><span class=\"line\">conda install --<span class=\"built_in\">yes</span> --file requirements.txt</span><br><span class=\"line\">conda config --remove-key channels</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[Anaconda超详细安装教程（Windows环境下）]<a href=\"https://blog.csdn.net/fan18317517352/article/details/123035625\">https://blog.csdn.net/fan18317517352/article/details/123035625</a> <br/><br>[新手教程一：Anaconda新建开发环境]<a href=\"https://blog.csdn.net/qq_42573052/article/details/113770662\">https://blog.csdn.net/qq_42573052/article/details/113770662</a> <br/><br><a href=\"https://blog.csdn.net/jasneik/article/details/114227716\">anaconda 换清华镜像源 windows</a> <br/><br><a href=\"https://mirrors.tuna.tsinghua.edu.cn/\">清华大学开源软件镜像站</a> <br/><br><a href=\"https://blog.csdn.net/qq_43382635/article/details/127124980\">Anaconda之导出&#x2F;导出配置好的虚拟环境</a> <br/><br><a href=\"https://blog.csdn.net/qq_37541097/article/details/120154543\">EISeg工具对应博文</a> <br/><br><a href=\"https://github.com/PaddlePaddle/PaddleSeg/blob/release/2.7/README_CN.md\">EIseg官方安装说明</a> <br/><br><a href=\"https://www.paddlepaddle.org.cn/documentation/docs/zh/install/index_cn.html\">飞桨安装参考文档</a> <br/></p>\n","slug":"Environment-Configuration/EIseg_install","updated":"23/03/2023","comments":true,"link":"","permalink":"http://example.com/2023/03/23/Environment-Configuration/EIseg_install/","excerpt":"","categories":[],"tags":[]},{"title":"minio 环境配置","date":"19/01/2023","path":"2023/01/19/Environment-Configuration/Minio_install/","text":"minio 环境配置安装docker1)按指令安装 12345678sudo apt-get remove docker docker-engine docker.iosudo apt-get updatesudo apt-get install apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt-key fingerprint 0EBFCD88sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;sudo apt-get updatesudo apt-get install docker-ce -y 2)查看是否安装成功docker version 安装minio1234567docker run -it -d -p 9000:9000 -p 9001:9001 --name minio \\-e &quot;MINIO_ACCESS_KEY=minio&quot; \\-e &quot;MINIO_SECRET_KEY=minio123&quot; \\-v /home/admin/minio/data:/data \\-v /home/admin/minio/config:/root/.minio \\minio/minio server /data \\--console-address &quot;:9000&quot; --address &quot;:9001&quot; MINIO_ACCESS_KEY账号MINIO_SECRET_KEY密码 http://39.106.72.165:9000本地：http://127.0.0.1:9000 参考资料https://cloud.tencent.com/developer/article/2057224https://www.minio.org.cn/download.shtml#/linux","raw":"---\ntitle: minio 环境配置\ndate: 2023-01-19 18:40:28\ntags:\n- 环境配置\n---\n# minio 环境配置\n\n# 安装docker\n1)按指令安装\n```shell\nsudo apt-get remove docker docker-engine docker.io\nsudo apt-get update\nsudo apt-get install apt-transport-https ca-certificates curl software-properties-common\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nsudo apt-key fingerprint 0EBFCD88\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu  $(lsb_release -cs) stable\"\nsudo apt-get update\nsudo apt-get install docker-ce -y\n```\n2)查看是否安装成功\ndocker version\n\n\n# 安装minio\n```shell\ndocker run -it -d -p 9000:9000 -p 9001:9001 --name minio \\\n-e \"MINIO_ACCESS_KEY=minio\" \\\n-e \"MINIO_SECRET_KEY=minio123\" \\\n-v /home/admin/minio/data:/data \\\n-v /home/admin/minio/config:/root/.minio \\\nminio/minio server /data \\\n--console-address \":9000\" --address \":9001\"\n```\nMINIO_ACCESS_KEY账号\nMINIO_SECRET_KEY密码\n\n\nhttp://39.106.72.165:9000\n本地：\nhttp://127.0.0.1:9000\n\n\n\n\n\n\n# 参考资料\n\nhttps://cloud.tencent.com/developer/article/2057224\nhttps://www.minio.org.cn/download.shtml#/linux\n\n","content":"<h1 id=\"minio-环境配置\"><a href=\"#minio-环境配置\" class=\"headerlink\" title=\"minio 环境配置\"></a>minio 环境配置</h1><h1 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h1><p>1)按指令安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get remove docker docker-engine docker.io</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class=\"line\">sudo apt-key fingerprint 0EBFCD88</span><br><span class=\"line\">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu  $(lsb_release -cs) stable&quot;</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install docker-ce -y</span><br></pre></td></tr></table></figure>\n<p>2)查看是否安装成功<br>docker version</p>\n<h1 id=\"安装minio\"><a href=\"#安装minio\" class=\"headerlink\" title=\"安装minio\"></a>安装minio</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -d -p 9000:9000 -p 9001:9001 --name minio \\</span><br><span class=\"line\">-e &quot;MINIO_ACCESS_KEY=minio&quot; \\</span><br><span class=\"line\">-e &quot;MINIO_SECRET_KEY=minio123&quot; \\</span><br><span class=\"line\">-v /home/admin/minio/data:/data \\</span><br><span class=\"line\">-v /home/admin/minio/config:/root/.minio \\</span><br><span class=\"line\">minio/minio server /data \\</span><br><span class=\"line\">--console-address &quot;:9000&quot; --address &quot;:9001&quot;</span><br></pre></td></tr></table></figure>\n<p>MINIO_ACCESS_KEY账号<br>MINIO_SECRET_KEY密码</p>\n<p><a href=\"http://39.106.72.165:9000/\">http://39.106.72.165:9000</a><br>本地：<br><a href=\"http://127.0.0.1:9000/\">http://127.0.0.1:9000</a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://cloud.tencent.com/developer/article/2057224\">https://cloud.tencent.com/developer/article/2057224</a><br><a href=\"https://www.minio.org.cn/download.shtml#/linux\">https://www.minio.org.cn/download.shtml#/linux</a></p>\n","slug":"Environment-Configuration/Minio_install","updated":"16/03/2023","comments":true,"link":"","permalink":"http://example.com/2023/01/19/Environment-Configuration/Minio_install/","excerpt":"","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"ubuntu通用教程","date":"15/01/2023","path":"2023/01/15/Environment-Configuration/ubuntu20/","text":"装VMware中出现的问题本地环境，win11+Vmware14先安装了VMware14，安装过程没有问题，导入虚拟机，启动以后，电脑直接蓝屏，开机还是这个现象 网上搜索发现是没有启动虚拟工具 安装ubuntu后需要做的 换源 更换时区 安装vim 安装ipconfig 安装ssh 配置历史记录 配置静态ip – 不需要？ 安装git 安装ssh 准备工作1234apt-get updateapt-get install sudoapt-get install vimpasswd # 修改密码 安装opensshapt-get install openssh-serverapt-get install openssh-client 修改ssh配置文件sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_configPermitRootLogin yes（默认为#PermitRootLogin prohibit-password）前面的#号要放开 启动服务&#x2F;etc&#x2F;init.d&#x2F;ssh restart 连接测试ssh user@[ip] -p [端口]ssh &#117;&#x73;&#x65;&#114;&#x40;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#48;&#46;&#51; -p 22 vscode配置123Host 192.168.0.3 HostName 192.168.0.3 User username https://golang.google.cn/dl/wget https://golang.google.cn/dl/go1.19.5.linux-amd64.tar.gz tar -C &#x2F;usr&#x2F;local -xzf go1.19.5.linux-amd64.tar.gz vim &#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profileexport GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go#export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;binexport PATH&#x3D;$PATH:$GOROOT&#x2F;binexport GOPATH&#x3D;&#x2F;yzxexport GOBIN&#x3D;$GOPATH&#x2F;binexport GOPROXY&#x3D;https://goproxy.cn/,direct https://goproxy.io/zh/https://goproxy.cn/ 1234go mod init [工程名字]go mod tidy # 刷新modgo mod vendergo get [跟着整个github目录] 遇到问题下错版本go1.19.5.linux-arm64.tar.gz报错:bash: &#x2F;usr&#x2F;local&#x2F;go&#x2F;bin&#x2F;go: cannot execute binary file: Exec format error VScode无法调试go安装dlv cgo: C compiler “gcc” not found: exec: “gcc”: executable file not found in $PATH (exit status 2) 参考资料Ubuntu20.04软件源更换 - 知乎 (zhihu.com) https://blog.csdn.net/liangcsdn111/article/details/115405223 https://www.jianshu.com/p/2802d71ab9e9","raw":"---\ntitle: ubuntu通用教程\ndate: 2023-01-15 21:40:01\ntags:\n- 环境配置\n---\n\n\n# 装VMware中出现的问题\n\n本地环境，win11+Vmware14\n先安装了VMware14，安装过程没有问题，导入虚拟机，启动以后，电脑直接蓝屏，开机还是这个现象\n\n网上搜索发现是没有启动虚拟工具\n\n\n\n# 安装ubuntu后需要做的\n\n1. 换源\n2. 更换时区\n3. 安装vim\n4. 安装ipconfig\n5. 安装ssh\n6. 配置历史记录\n7. 配置静态ip -- 不需要？\n8. 安装git\n\n\n\n\n\n# 安装ssh\n\n1. 准备工作\n```\napt-get update\napt-get install sudo\napt-get install vim\npasswd # 修改密码\n```\n2. 安装openssh\napt-get install openssh-server\napt-get install openssh-client\n3. 修改ssh配置文件 \nsudo vi /etc/ssh/sshd_config\nPermitRootLogin yes \n（默认为#PermitRootLogin prohibit-password）前面的#号要放开\n4. 启动服务\n/etc/init.d/ssh restart\n5. 连接测试\nssh user@[ip] -p [端口]\nssh user@192.168.0.3 -p 22\n6. vscode配置\n```\nHost 192.168.0.3\n  HostName 192.168.0.3\n  User username\n```\n\n\n\nhttps://golang.google.cn/dl/\nwget https://golang.google.cn/dl/go1.19.5.linux-amd64.tar.gz\n\ntar -C /usr/local -xzf go1.19.5.linux-amd64.tar.gz\n\nvim /etc/profile\nsource /etc/profile\nexport GOROOT=/usr/local/go\n#export PATH=$PATH:/usr/local/go/bin\nexport PATH=$PATH:$GOROOT/bin\nexport GOPATH=/yzx\nexport GOBIN=$GOPATH/bin\nexport GOPROXY=https://goproxy.cn/,direct\n\n\nhttps://goproxy.io/zh/\nhttps://goproxy.cn/\n\n\n```shell\ngo mod init [工程名字]\ngo mod tidy  # 刷新mod\ngo mod vender\ngo get [跟着整个github目录]\n```\n\n\n\n# 遇到问题\n下错版本\ngo1.19.5.linux-arm64.tar.gz\n报错:\nbash: /usr/local/go/bin/go: cannot execute binary file: Exec format error\n\n\nVScode无法调试go\n安装dlv\n\n\ncgo: C compiler \"gcc\" not found: exec: \"gcc\": executable file not found in $PATH (exit status 2)\n\n# 参考资料\n\n[Ubuntu20.04软件源更换 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/142014944)\n\nhttps://blog.csdn.net/liangcsdn111/article/details/115405223\n\nhttps://www.jianshu.com/p/2802d71ab9e9","content":"<h1 id=\"装VMware中出现的问题\"><a href=\"#装VMware中出现的问题\" class=\"headerlink\" title=\"装VMware中出现的问题\"></a>装VMware中出现的问题</h1><p>本地环境，win11+Vmware14<br>先安装了VMware14，安装过程没有问题，导入虚拟机，启动以后，电脑直接蓝屏，开机还是这个现象</p>\n<p>网上搜索发现是没有启动虚拟工具</p>\n<h1 id=\"安装ubuntu后需要做的\"><a href=\"#安装ubuntu后需要做的\" class=\"headerlink\" title=\"安装ubuntu后需要做的\"></a>安装ubuntu后需要做的</h1><ol>\n<li>换源</li>\n<li>更换时区</li>\n<li>安装vim</li>\n<li>安装ipconfig</li>\n<li>安装ssh</li>\n<li>配置历史记录</li>\n<li>配置静态ip – 不需要？</li>\n<li>安装git</li>\n</ol>\n<h1 id=\"安装ssh\"><a href=\"#安装ssh\" class=\"headerlink\" title=\"安装ssh\"></a>安装ssh</h1><ol>\n<li>准备工作<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-<span class=\"built_in\">get</span> update</span><br><span class=\"line\">apt-<span class=\"built_in\">get</span> install sudo</span><br><span class=\"line\">apt-<span class=\"built_in\">get</span> install vim</span><br><span class=\"line\">passwd # 修改密码</span><br></pre></td></tr></table></figure></li>\n<li>安装openssh<br>apt-get install openssh-server<br>apt-get install openssh-client</li>\n<li>修改ssh配置文件<br>sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>PermitRootLogin yes<br>（默认为#PermitRootLogin prohibit-password）前面的#号要放开</li>\n<li>启动服务<br>&#x2F;etc&#x2F;init.d&#x2F;ssh restart</li>\n<li>连接测试<br>ssh user@[ip] -p [端口]<br>ssh <a href=\"mailto:&#117;&#x73;&#x65;&#114;&#x40;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#48;&#46;&#51;\">&#117;&#x73;&#x65;&#114;&#x40;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#48;&#46;&#51;</a> -p 22</li>\n<li>vscode配置<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host <span class=\"number\">192.168</span>.<span class=\"number\">0.3</span></span><br><span class=\"line\">  HostName <span class=\"number\">192.168</span>.<span class=\"number\">0.3</span></span><br><span class=\"line\">  <span class=\"keyword\">User</span> <span class=\"title\">username</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><a href=\"https://golang.google.cn/dl/\">https://golang.google.cn/dl/</a><br>wget <a href=\"https://golang.google.cn/dl/go1.19.5.linux-amd64.tar.gz\">https://golang.google.cn/dl/go1.19.5.linux-amd64.tar.gz</a></p>\n<p>tar -C &#x2F;usr&#x2F;local -xzf go1.19.5.linux-amd64.tar.gz</p>\n<p>vim &#x2F;etc&#x2F;profile<br>source &#x2F;etc&#x2F;profile<br>export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go<br>#export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin<br>export PATH&#x3D;$PATH:$GOROOT&#x2F;bin<br>export GOPATH&#x3D;&#x2F;yzx<br>export GOBIN&#x3D;$GOPATH&#x2F;bin<br>export GOPROXY&#x3D;<a href=\"https://goproxy.cn/,direct\">https://goproxy.cn/,direct</a></p>\n<p><a href=\"https://goproxy.io/zh/\">https://goproxy.io/zh/</a><br><a href=\"https://goproxy.cn/\">https://goproxy.cn/</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod init [工程名字]</span><br><span class=\"line\">go mod tidy  # 刷新mod</span><br><span class=\"line\">go mod vender</span><br><span class=\"line\">go get [跟着整个github目录]</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"遇到问题\"><a href=\"#遇到问题\" class=\"headerlink\" title=\"遇到问题\"></a>遇到问题</h1><p>下错版本<br>go1.19.5.linux-arm64.tar.gz<br>报错:<br>bash: &#x2F;usr&#x2F;local&#x2F;go&#x2F;bin&#x2F;go: cannot execute binary file: Exec format error</p>\n<p>VScode无法调试go<br>安装dlv</p>\n<p>cgo: C compiler “gcc” not found: exec: “gcc”: executable file not found in $PATH (exit status 2)</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://zhuanlan.zhihu.com/p/142014944\">Ubuntu20.04软件源更换 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://blog.csdn.net/liangcsdn111/article/details/115405223\">https://blog.csdn.net/liangcsdn111/article/details/115405223</a></p>\n<p><a href=\"https://www.jianshu.com/p/2802d71ab9e9\">https://www.jianshu.com/p/2802d71ab9e9</a></p>\n","slug":"Environment-Configuration/ubuntu20","updated":"16/03/2023","comments":true,"link":"","permalink":"http://example.com/2023/01/15/Environment-Configuration/ubuntu20/","excerpt":"","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Qt5教程","date":"31/12/2022","path":"2022/12/31/Course/Qt5_Course/","text":"Qt需要学习的知识点QMLQt QuickQpython Qt相关不了解的QRegExpQButtonGroupQFactoryInterfaceQStandardItemModelQt::WA_inputmethodenabled QDomElementQDomDocumentQDomNode #include &lt;QtXml&#x2F;qtxmlglobal.h&gt; 安装过滤器 Q_DECL_EXPORTQ_DECL_IMPORTQ_PROPERTY qt的继承关系 C++中不了解的stdcall,cdecl,fastcall,thiscall, naked call afx_msg afxwin.hwindows.hODBC类 stdafx.h 继承自己单例的数组奇异递归模板模式CRTP dynamic_cast&lt;&gt;() 其他需要了解的知识Microsoft XNAWPFxamlMFCelectronWin32 SDKSTL,WTLLCU客户端CEF架构WinFormsC++ builderGTK+libcefUnity桌面应用程序桌面的客户端软件Hive githubminicsv","raw":"---\ntitle: Qt5教程\ndate: 2022-12-31 13:34:44\ntags:\n- 课程\n---\n\n# Qt需要学习的知识点\nQML\nQt Quick\nQpython\n\n# Qt相关不了解的\nQRegExp\nQButtonGroup\nQFactoryInterface\nQStandardItemModel\nQt::WA_inputmethodenabled\n\nQDomElement\nQDomDocument\nQDomNode\n\n#include <QtXml/qtxmlglobal.h>\n\n安装过滤器\n\n\nQ_DECL_EXPORT\nQ_DECL_IMPORT\nQ_PROPERTY\n\nqt的继承关系\n# C++中不了解的\nstdcall,cdecl,fastcall,\nthiscall, naked call\n\nafx_msg\n\nafxwin.h\nwindows.h\nODBC类\n\nstdafx.h\n\n继承自己单例的数组\n奇异递归模板模式CRTP\n\ndynamic_cast<>()\n\n\n\n\n# 其他需要了解的知识\nMicrosoft XNA\nWPF\nxaml\nMFC\nelectron\nWin32 SDK\nSTL,WTL\nLCU客户端\nCEF架构\nWinForms\nC++ builder\nGTK+\nlibcef\nUnity\n桌面应用程序\n桌面的客户端软件\nHive\n\n# github\nminicsv\n","content":"<h1 id=\"Qt需要学习的知识点\"><a href=\"#Qt需要学习的知识点\" class=\"headerlink\" title=\"Qt需要学习的知识点\"></a>Qt需要学习的知识点</h1><p>QML<br>Qt Quick<br>Qpython</p>\n<h1 id=\"Qt相关不了解的\"><a href=\"#Qt相关不了解的\" class=\"headerlink\" title=\"Qt相关不了解的\"></a>Qt相关不了解的</h1><p>QRegExp<br>QButtonGroup<br>QFactoryInterface<br>QStandardItemModel<br>Qt::WA_inputmethodenabled</p>\n<p>QDomElement<br>QDomDocument<br>QDomNode</p>\n<p>#include &lt;QtXml&#x2F;qtxmlglobal.h&gt;</p>\n<p>安装过滤器</p>\n<p>Q_DECL_EXPORT<br>Q_DECL_IMPORT<br>Q_PROPERTY</p>\n<p>qt的继承关系</p>\n<h1 id=\"C-中不了解的\"><a href=\"#C-中不了解的\" class=\"headerlink\" title=\"C++中不了解的\"></a>C++中不了解的</h1><p>stdcall,cdecl,fastcall,<br>thiscall, naked call</p>\n<p>afx_msg</p>\n<p>afxwin.h<br>windows.h<br>ODBC类</p>\n<p>stdafx.h</p>\n<p>继承自己单例的数组<br>奇异递归模板模式CRTP</p>\n<p>dynamic_cast&lt;&gt;()</p>\n<h1 id=\"其他需要了解的知识\"><a href=\"#其他需要了解的知识\" class=\"headerlink\" title=\"其他需要了解的知识\"></a>其他需要了解的知识</h1><p>Microsoft XNA<br>WPF<br>xaml<br>MFC<br>electron<br>Win32 SDK<br>STL,WTL<br>LCU客户端<br>CEF架构<br>WinForms<br>C++ builder<br>GTK+<br>libcef<br>Unity<br>桌面应用程序<br>桌面的客户端软件<br>Hive</p>\n<h1 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h1><p>minicsv</p>\n","slug":"Course/Qt5_Course","updated":"31/12/2022","comments":true,"link":"","permalink":"http://example.com/2022/12/31/Course/Qt5_Course/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"抢票系统","date":"11/11/2022","path":"2022/11/11/Project/Ticketing_system/","text":"实现抢票的要素：时间- 确定列车的剩余票数区间- 后台开发导论1接入层服务通常把网络中直接面向用户连接的部分称为接入层对外提供一体服务，对内实现负载均衡 DNS网络接入-DNS均衡算法:就近+同运营商接入+轮询存在问题:1.域名解析系统的缓存问题(缓存的ip失效将导致出错)2.公网ip问题应用场景:解决服务接入的第一跳 LVSLvS : Linux Virtual Server , Linux上通用的负载均衡技术可以将内部的100个IP变成一个IP LVS-DR1.Virtual Server via Direct Routing (VS&#x2F;DR)通过改写请求报文的MAC地址，将请求发送到真实服务器，而真实服务器将响应直接返E种方法没有IP隧道的开销，对集群中的真实服务器也没有必须支持IP隧道协议的要求，但与真实服务器都有一块网卡连在同一物理网段上。 3.Virtual Server via Network Address Translation (VS&#x2F;NAT)通过网络地址转换，调度器重写请求报文的目标地址，将请求分派给后端的真实服务器;响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。 均衡算法︰RR、Weight RR、地址hash、最少连接等优点︰1.成本低性能高，抗负载能力强2.业务透明，可应用范围广3.基于内核网络协议栈，稳定可靠应用场景∶解决网络接入的第二跳，一般称为四层负载均衡问题：如果连接的服务器出现问题，那么客户端的TCP请求直接失败了 反向代理负载均衡-反向代理正向代理:被代理方是客户端反向代理:被代理方是服务端，服务端隐藏在反向代理后面 反向代理-nginxnginx可以通过解析http协议包来路由流量 ( http:域名，url , method ) 反向代理-手Q接入层SSO就近接入（相同运营商和相同地域会更快)测速+调度两套系统连接保持、推送支持反向代理信道安全(加密防监听，鉴权防伪装，cookie防重放)流量优化、数据压缩、智能聚合、精简协议容灾容错异常发现和过载保护 负载均衡-七层均衡算法∶RR、Weight RR、ip_hash、url_hash优点︰1.可针对应用本身来做调度策略2支持故障剔除应用场景∶解决网络接入的第三跳，一般称为七层负载均衡好处：因为连接是和代理建立的，当机器出现问题的时候，连接是和代理保持的，可以用反向代理去轮询有没有好的机器可以更加精细化管理，但是性能没有LVS那么高 总结通常把网络中直接面向用户连接或访问网络的部分称为接入层接入层常用技术:DNS、LVS、反向代理比较大型的在线应用，通常这三种技术都会同时使用 一般DNS和LVS都由公司级别服务提供GSLB域名管理平台5.1腾讯云|DNSPOD负载均衡CLB|Cloud Lo&amp;d Balancer完整的接入层技术应该包括这三种，日常开发中我们说的接入层一般指反向代理。 2应用服务网络接入业务逻辑数据存储运维保障业务需求决定方案 单体架构小型网站–单机架构使用到的技术:LAMPLinux + Apache + Mysql + Php 缓存与读写分离基于二八定律引入缓存(高频访问数据提高访问速度）数据库读多写少-&gt;读写分离（读多写少，分离提速) 动静分离 引入CDN(将静态资源的访问分流到用户附近的结点) 集群化部罢 通过负载均衡和反向将请求分散到多个服方命果肝十 服务拆分―业务拆分项目规模增长，维护难度提高:任意修改都需要整体发布任意缺陷都会影响整个系统解决方案:将应用按业务模块拆分分而治之降低复杂度缩小影响明确职责引入消息队列进一步解耦 分布式架构运营保障运营保障–微服务框架 组件化、框架化消除重复劳动微服务框架1.RPC2.名字服务3．配置服务4.日志、监控5．链路追踪 微服务框架全链路追踪什么是全链路追踪系统监控的三种手段:Log日志——记录离散事件，包含程序在事件发生时详细信息Metrics指标——记录可聚合的数据，经过汇总后成为我们关心的指标(QPS、DAU) ——monitorTracing链路追踪——记录单个请求的处理流程，其中包括服务调用和处理时长等信息。Tracing的特点是，它所记录的信息是一个请求范围内的。 微服务时代:单体应用被拆分为多个微服务，导致服务数量增多、内部调用链复杂化，手Q后端就有600多个模块，涉及到的服务器更是不计其数。 随着服务数量的增多和内部调用链的复杂化，仅凭借日志和指标监控进行问题排查或是性能分析的时候，无异于盲人摸象。全链路追踪可以帮助我们做到“See the Whole Picture” . Logging很重要，但存在问题分布式系统中日志隔离问题:链路缺乏统一标志:SSO : seq+uin，后端:可能有另一套标识方式日志染色问题︰各个服务染色不一，日志信息可能在某一环缺失查问题效率低:查问题时每一个服务方都各自查自己的日志，使用排除法来查问题，效率较低 Metrics必不可少，但不是万能Monitor和多维监控Habo : 指标数据是我们日常需要关注的，它可以帮助我们发现系统的异常，设置告警并及时处理。但指标数据是数据的汇总呈现，我们不能依赖其来定位具体问题和优化系统。 Tracing提供了什么全链路追踪能够帮助开发者直观分析请求链路，快速定位问题和性能瓶颈，逐渐优化服务间依赖，也有助于开发者从更宏观的角度更好地理解整个分布式系统。 cpu问题分析总结粗看系统负载情况:uptime, vmstat 开发测试环境+线上环境机器实时的CPU资源消耗详细情况top 开发测试环境+线上环境分析系统调用: strace 开发测试环境分析函数的热点:perf，可以输出成火焰图便于直观观察 开发测试环境+线上环境分析各个线程的资源消耗情况，线程内的函数消耗情况:valgriand 开发测试环境分析程序各个线程的堆栈执行情况︰pstack &amp; pt-pmp 开发测试环境 内存问题分析总结1.C++开发的时候必须掌握智能指针2.熟练使用valgriand分析内存泄漏3.了解多线程内存库jemalloc&#x2F;tcmalloc，可以熟悉下jemalloc源代码4.free的输出结果会解读5.建议关闭swap6.熟悉&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;下的参数，比如控制刷脏页的频率，脏页占有量， IO问题的分析几个重要的概念 顺序IO顺序读写文件，能很好地利用预读，对于机械磁盘也不用做磁头寻道，所以是性能最好的读写模式，但是一般适用于日志类场景 随机IO随机读写，机械磁盘性能会非常差，如果是这种场景建议用SSD。当然应用层也会做各种努力尽量会将随机IO改成顺序IO fsync刷盘为了数据安全，每次写入完成通过fsync做强制刷盘操作，避免机器突然掉电能情况丢失数据，但是这个操作对吞吐和响应延时有较大的影响，一般会采用一些批量合并fsync的模式做优化 direct io绕过page cache，直接对设备进行读写，一般性能不如带page cache，适用于在业务层做了cache,比如数据库 aio:异步IO读写操作异步化，一般也是directio模式，编程会比较复杂，对于大部分应用不要采用，一般也是适用于数据库场景 参考资料设计一个抢票秒杀系统_luslin1711的博客-CSDN博客抢票系统之架构设计_lfssst的博客-CSDN博客_抢票系统设计陈朋 (feishu.cn)EduFriendChen&#x2F;snatch-tickets-demo: 解：字节校园镜像技术项目实战活动 —— 【后端】如果有一千万个人抢票怎么办？ (github.com)中间件概览 | CloudWeGocloudwego&#x2F;hertz-benchmark: Tracking performance changes for Hertz (github.com)","raw":"---\ntitle: 抢票系统\ndate: 2022-11-11 19:47:19\ntags:\n- 项目\n---\n\n# 实现\n抢票的要素：\n时间- 确定列车的剩余票数\n区间- \n\n\n\n# 后台开发导论\n## 1接入层服务\n通常把网络中直接面向用户连接的部分称为接入层\n对外提供一体服务，对内实现负载均衡\n### DNS\n网络接入-DNS\n均衡算法:\n就近+同运营商接入+轮询\n存在问题:\n1.域名解析系统的缓存问题(缓存的ip失效将导致出错)\n2.公网ip问题\n应用场景:\n解决服务接入的第一跳\n\n### LVS\nLvS : Linux Virtual Server , Linux上通用的负载均衡技术\n可以将内部的100个IP变成一个IP\n\n\n#### LVS-DR\n1.Virtual Server via Direct Routing (VS/DR)\n通过改写请求报文的MAC地址，将请求发送到真实服务器，而真实服务器将响应直接返E种方法没有IP隧道的开销，对集群中的真实服务器也没有必须支持IP隧道协议的要求，但与真实服务器都有一块网卡连在同一物理网段上。\n\n3.Virtual Server via Network Address Translation (VS/NAT)\n通过网络地址转换，调度器重写请求报文的目标地址，将请求分派给后端的真实服务器;响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。\n \n均衡算法︰\nRR、Weight RR、地址hash、最少连接等\n优点︰\n1.成本低性能高，抗负载能力强\n2.业务透明，可应用范围广\n3.基于内核网络协议栈，稳定可靠\n应用场景∶\n解决网络接入的第二跳，一般称为四层负载均衡\n问题：\n如果连接的服务器出现问题，那么客户端的TCP请求直接失败了\n\n### 反向代理\n#### 负载均衡-反向代理\n正向代理:被代理方是客户端\n反向代理:被代理方是服务端，服务端隐藏在反向代理后面\n\n#### 反向代理-nginx\nnginx可以通过解析http协议包来路由流量 ( http:域名，url , method )\n\n#### 反向代理-手Q接入层SSO\n就近接入（相同运营商和相同地域会更快)测速+调度两套系统\n连接保持、推送支持\n反向代理\n信道安全(加密防监听，鉴权防伪装，cookie防重放)\n流量优化、数据压缩、智能聚合、精简协议\n容灾容错\n异常发现和过载保护\n\n\n#### 负载均衡-七层\n均衡算法∶\nRR、Weight RR、ip_hash、url_hash\n优点︰\n1.可针对应用本身来做调度策略\n2支持故障剔除\n应用场景∶\n解决网络接入的第三跳，一般称为七层负载均衡\n好处：\n因为连接是和代理建立的，当机器出现问题的时候，连接是和代理保持的，可以用反向代理去轮询有没有好的机器\n可以更加精细化管理，但是性能没有LVS那么高\n\n\n\n### 总结\n通常把网络中直接面向用户连接或访问网络的部分称为接入层\n接入层常用技术:DNS、LVS、反向代理\n比较大型的在线应用，通常这三种技术都会同时使用\n\n一般DNS和LVS都由公司级别服务提供\nGSLB域名管理平台5.1\n腾讯云|DNSPOD\n负载均衡CLB|Cloud Lo&d Balancer\n完整的接入层技术应该包括这三种，日常开发中我们说的接入层一般指反向代理。\n\n## 2应用服务\n网络接入\n业务逻辑\n数据存储\n运维保障\n业务需求决定方案\n\n### 单体架构\n小型网站–单机架构\n使用到的技术:LAMP\nLinux + Apache + Mysql + Php\n\n缓存与读写分离\n基于二八定律引入缓存\n(高频访问数据提高访问速度）\n数据库读多写少->读写分离\n（读多写少，分离提速)\n\n动静分离\n\n引入CDN\n(将静态资源的访问分流到用户附近的结点)\n\n\n集群化部罢\n\n通过负载均衡和反向\n将请求分散到多个服方命果肝十\n\n\n\n服务拆分―业务拆分\n项目规模增长，维护难度提高:\n任意修改都需要整体发布\n任意缺陷都会影响整个系统\n解决方案:\n将应用按业务模块拆分\n分而治之降低复杂度\n缩小影响\n明确职责\n引入消息队列进一步解耦\n\n\n### 分布式架构\n\n\n## 运营保障\n\n运营保障–微服务框架\n\n组件化、框架化消除重复劳动微服务框架\n1.RPC\n2.名字服务\n3．配置服务\n4.日志、监控\n5．链路追踪\n\n\n### 微服务框架\n### 全链路追踪\n\n什么是全链路追踪\n系统监控的三种手段:\nLog日志——记录离散事件，包含程序在事件发生时详细信息\nMetrics指标——记录可聚合的数据，经过汇总后成为我们关心的指标(QPS、DAU) ——monitor\nTracing链路追踪——记录单个请求的处理流程，其中包括服务调用和处理时长等信息。\nTracing的特点是，它所记录的信息是一个请求范围内的。\n\n微服务时代:\n单体应用被拆分为多个微服务，导致服务数量增多、内部调用链复杂化，手Q后端就有600多个模块，涉及到的服务器更是不计其数。\n\n随着服务数量的增多和内部调用链的复杂化，仅凭借日志和指标监控进行问题排查或是性能分析的时候，无异于盲人摸象。\n全链路追踪可以帮助我们做到“See the Whole Picture” .\n\n\n\n\n\nLogging很重要，但存在问题\n分布式系统中日志隔离问题:\n链路缺乏统一标志:SSO : seq+uin，后端:可能有另一套标识方式\n日志染色问题︰各个服务染色不一，日志信息可能在某一环缺失\n查问题效率低:查问题时每一个服务方都各自查自己的日志，使用排除法来查问题，效率较低\n\n\n\nMetrics必不可少，但不是万能\nMonitor和多维监控Habo :\n\n指标数据是我们日常需要关注的，它可以帮助我们发现系统的异常，设置告警并及时处理。\n但指标数据是数据的汇总呈现，我们不能依赖其来定位具体问题和优化系统。\n\n\n\nTracing提供了什么\n全链路追踪能够帮助开发者直观分析请求链路，快速定位问题和性能瓶颈，逐渐优化服务间依赖，也有助于开发者从更宏观的角度更好地理解整个分布式系统。\n\n\n\n\n\n\n\n# cpu问题分析总结\n粗看系统负载情况:uptime, vmstat 开发测试环境+线上环境\n机器实时的CPU资源消耗详细情况top 开发测试环境+线上环境\n分析系统调用: strace  开发测试环境\n分析函数的热点:perf，可以输出成火焰图便于直观观察 开发测试环境+线上环境\n分析各个线程的资源消耗情况，线程内的函数消耗情况:valgriand 开发测试环境\n分析程序各个线程的堆栈执行情况︰pstack & pt-pmp 开发测试环境\n\n\n\n# 内存问题分析总结\n1.C++开发的时候必须掌握智能指针\n2.熟练使用valgriand分析内存泄漏\n3.了解多线程内存库jemalloc/tcmalloc，可以熟悉下jemalloc源代码\n4.free的输出结果会解读\n5.建议关闭swap\n6.熟悉/proc/sys/vm/下的参数，比如控制刷脏页的频率，脏页占有量，\n\n\n\nIO问题的分析\n几个重要的概念\n# 顺序IO\n顺序读写文件，能很好地利用预读，对于机械磁盘也不用做磁头寻道，所以是性能最好的读写模\n式，但是一般适用于日志类场景\n# 随机IO\n随机读写，机械磁盘性能会非常差，如果是这种场景建议用SSD。当然应用层也会做各种努力尽量会将随机IO改成顺序IO\n# fsync刷盘\n为了数据安全，每次写入完成通过fsync做强制刷盘操作，避免机器突然掉电能情况丢失数据，但是这个操作对吞吐和响应延时有较大的影响，一般会采用一些批量合并fsync的模式做优化\n# direct io\n绕过page cache，直接对设备进行读写，一般性能不如带page cache，适用于在业务层做了cache,比如数据库\n# aio:异步IO\n读写操作异步化，一般也是directio模式，编程会比较复杂，对于大部分应用不要采用，一般也是适用于数据库场景\n\n\n\n# 参考资料\n\n[设计一个抢票秒杀系统_luslin1711的博客-CSDN博客](https://blog.csdn.net/luslin1711/article/details/105859523)\n[抢票系统之架构设计_lfssst的博客-CSDN博客_抢票系统设计](https://blog.csdn.net/lfssst/article/details/123722149)\n[陈朋 (feishu.cn)](https://bytedancecampus1.feishu.cn/minutes/obcn2m3bdq645dm627u6u38w)\n[EduFriendChen/snatch-tickets-demo: 解：字节校园镜像技术项目实战活动 —— 【后端】如果有一千万个人抢票怎么办？ (github.com)](https://github.com/EduFriendChen/snatch-tickets-demo)\n[中间件概览 | CloudWeGo](https://www.cloudwego.io/zh/docs/hertz/tutorials/basic-feature/middleware/)\n[cloudwego/hertz-benchmark: Tracking performance changes for Hertz (github.com)](https://github.com/cloudwego/hertz-benchmark)","content":"<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>抢票的要素：<br>时间- 确定列车的剩余票数<br>区间- </p>\n<h1 id=\"后台开发导论\"><a href=\"#后台开发导论\" class=\"headerlink\" title=\"后台开发导论\"></a>后台开发导论</h1><h2 id=\"1接入层服务\"><a href=\"#1接入层服务\" class=\"headerlink\" title=\"1接入层服务\"></a>1接入层服务</h2><p>通常把网络中直接面向用户连接的部分称为接入层<br>对外提供一体服务，对内实现负载均衡</p>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>网络接入-DNS<br>均衡算法:<br>就近+同运营商接入+轮询<br>存在问题:<br>1.域名解析系统的缓存问题(缓存的ip失效将导致出错)<br>2.公网ip问题<br>应用场景:<br>解决服务接入的第一跳</p>\n<h3 id=\"LVS\"><a href=\"#LVS\" class=\"headerlink\" title=\"LVS\"></a>LVS</h3><p>LvS : Linux Virtual Server , Linux上通用的负载均衡技术<br>可以将内部的100个IP变成一个IP</p>\n<h4 id=\"LVS-DR\"><a href=\"#LVS-DR\" class=\"headerlink\" title=\"LVS-DR\"></a>LVS-DR</h4><p>1.Virtual Server via Direct Routing (VS&#x2F;DR)<br>通过改写请求报文的MAC地址，将请求发送到真实服务器，而真实服务器将响应直接返E种方法没有IP隧道的开销，对集群中的真实服务器也没有必须支持IP隧道协议的要求，但与真实服务器都有一块网卡连在同一物理网段上。</p>\n<p>3.Virtual Server via Network Address Translation (VS&#x2F;NAT)<br>通过网络地址转换，调度器重写请求报文的目标地址，将请求分派给后端的真实服务器;响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。</p>\n<p>均衡算法︰<br>RR、Weight RR、地址hash、最少连接等<br>优点︰<br>1.成本低性能高，抗负载能力强<br>2.业务透明，可应用范围广<br>3.基于内核网络协议栈，稳定可靠<br>应用场景∶<br>解决网络接入的第二跳，一般称为四层负载均衡<br>问题：<br>如果连接的服务器出现问题，那么客户端的TCP请求直接失败了</p>\n<h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><h4 id=\"负载均衡-反向代理\"><a href=\"#负载均衡-反向代理\" class=\"headerlink\" title=\"负载均衡-反向代理\"></a>负载均衡-反向代理</h4><p>正向代理:被代理方是客户端<br>反向代理:被代理方是服务端，服务端隐藏在反向代理后面</p>\n<h4 id=\"反向代理-nginx\"><a href=\"#反向代理-nginx\" class=\"headerlink\" title=\"反向代理-nginx\"></a>反向代理-nginx</h4><p>nginx可以通过解析http协议包来路由流量 ( http:域名，url , method )</p>\n<h4 id=\"反向代理-手Q接入层SSO\"><a href=\"#反向代理-手Q接入层SSO\" class=\"headerlink\" title=\"反向代理-手Q接入层SSO\"></a>反向代理-手Q接入层SSO</h4><p>就近接入（相同运营商和相同地域会更快)测速+调度两套系统<br>连接保持、推送支持<br>反向代理<br>信道安全(加密防监听，鉴权防伪装，cookie防重放)<br>流量优化、数据压缩、智能聚合、精简协议<br>容灾容错<br>异常发现和过载保护</p>\n<h4 id=\"负载均衡-七层\"><a href=\"#负载均衡-七层\" class=\"headerlink\" title=\"负载均衡-七层\"></a>负载均衡-七层</h4><p>均衡算法∶<br>RR、Weight RR、ip_hash、url_hash<br>优点︰<br>1.可针对应用本身来做调度策略<br>2支持故障剔除<br>应用场景∶<br>解决网络接入的第三跳，一般称为七层负载均衡<br>好处：<br>因为连接是和代理建立的，当机器出现问题的时候，连接是和代理保持的，可以用反向代理去轮询有没有好的机器<br>可以更加精细化管理，但是性能没有LVS那么高</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通常把网络中直接面向用户连接或访问网络的部分称为接入层<br>接入层常用技术:DNS、LVS、反向代理<br>比较大型的在线应用，通常这三种技术都会同时使用</p>\n<p>一般DNS和LVS都由公司级别服务提供<br>GSLB域名管理平台5.1<br>腾讯云|DNSPOD<br>负载均衡CLB|Cloud Lo&amp;d Balancer<br>完整的接入层技术应该包括这三种，日常开发中我们说的接入层一般指反向代理。</p>\n<h2 id=\"2应用服务\"><a href=\"#2应用服务\" class=\"headerlink\" title=\"2应用服务\"></a>2应用服务</h2><p>网络接入<br>业务逻辑<br>数据存储<br>运维保障<br>业务需求决定方案</p>\n<h3 id=\"单体架构\"><a href=\"#单体架构\" class=\"headerlink\" title=\"单体架构\"></a>单体架构</h3><p>小型网站–单机架构<br>使用到的技术:LAMP<br>Linux + Apache + Mysql + Php</p>\n<p>缓存与读写分离<br>基于二八定律引入缓存<br>(高频访问数据提高访问速度）<br>数据库读多写少-&gt;读写分离<br>（读多写少，分离提速)</p>\n<p>动静分离</p>\n<p>引入CDN<br>(将静态资源的访问分流到用户附近的结点)</p>\n<p>集群化部罢</p>\n<p>通过负载均衡和反向<br>将请求分散到多个服方命果肝十</p>\n<p>服务拆分―业务拆分<br>项目规模增长，维护难度提高:<br>任意修改都需要整体发布<br>任意缺陷都会影响整个系统<br>解决方案:<br>将应用按业务模块拆分<br>分而治之降低复杂度<br>缩小影响<br>明确职责<br>引入消息队列进一步解耦</p>\n<h3 id=\"分布式架构\"><a href=\"#分布式架构\" class=\"headerlink\" title=\"分布式架构\"></a>分布式架构</h3><h2 id=\"运营保障\"><a href=\"#运营保障\" class=\"headerlink\" title=\"运营保障\"></a>运营保障</h2><p>运营保障–微服务框架</p>\n<p>组件化、框架化消除重复劳动微服务框架<br>1.RPC<br>2.名字服务<br>3．配置服务<br>4.日志、监控<br>5．链路追踪</p>\n<h3 id=\"微服务框架\"><a href=\"#微服务框架\" class=\"headerlink\" title=\"微服务框架\"></a>微服务框架</h3><h3 id=\"全链路追踪\"><a href=\"#全链路追踪\" class=\"headerlink\" title=\"全链路追踪\"></a>全链路追踪</h3><p>什么是全链路追踪<br>系统监控的三种手段:<br>Log日志——记录离散事件，包含程序在事件发生时详细信息<br>Metrics指标——记录可聚合的数据，经过汇总后成为我们关心的指标(QPS、DAU) ——monitor<br>Tracing链路追踪——记录单个请求的处理流程，其中包括服务调用和处理时长等信息。<br>Tracing的特点是，它所记录的信息是一个请求范围内的。</p>\n<p>微服务时代:<br>单体应用被拆分为多个微服务，导致服务数量增多、内部调用链复杂化，手Q后端就有600多个模块，涉及到的服务器更是不计其数。</p>\n<p>随着服务数量的增多和内部调用链的复杂化，仅凭借日志和指标监控进行问题排查或是性能分析的时候，无异于盲人摸象。<br>全链路追踪可以帮助我们做到“See the Whole Picture” .</p>\n<p>Logging很重要，但存在问题<br>分布式系统中日志隔离问题:<br>链路缺乏统一标志:SSO : seq+uin，后端:可能有另一套标识方式<br>日志染色问题︰各个服务染色不一，日志信息可能在某一环缺失<br>查问题效率低:查问题时每一个服务方都各自查自己的日志，使用排除法来查问题，效率较低</p>\n<p>Metrics必不可少，但不是万能<br>Monitor和多维监控Habo :</p>\n<p>指标数据是我们日常需要关注的，它可以帮助我们发现系统的异常，设置告警并及时处理。<br>但指标数据是数据的汇总呈现，我们不能依赖其来定位具体问题和优化系统。</p>\n<p>Tracing提供了什么<br>全链路追踪能够帮助开发者直观分析请求链路，快速定位问题和性能瓶颈，逐渐优化服务间依赖，也有助于开发者从更宏观的角度更好地理解整个分布式系统。</p>\n<h1 id=\"cpu问题分析总结\"><a href=\"#cpu问题分析总结\" class=\"headerlink\" title=\"cpu问题分析总结\"></a>cpu问题分析总结</h1><p>粗看系统负载情况:uptime, vmstat 开发测试环境+线上环境<br>机器实时的CPU资源消耗详细情况top 开发测试环境+线上环境<br>分析系统调用: strace  开发测试环境<br>分析函数的热点:perf，可以输出成火焰图便于直观观察 开发测试环境+线上环境<br>分析各个线程的资源消耗情况，线程内的函数消耗情况:valgriand 开发测试环境<br>分析程序各个线程的堆栈执行情况︰pstack &amp; pt-pmp 开发测试环境</p>\n<h1 id=\"内存问题分析总结\"><a href=\"#内存问题分析总结\" class=\"headerlink\" title=\"内存问题分析总结\"></a>内存问题分析总结</h1><p>1.C++开发的时候必须掌握智能指针<br>2.熟练使用valgriand分析内存泄漏<br>3.了解多线程内存库jemalloc&#x2F;tcmalloc，可以熟悉下jemalloc源代码<br>4.free的输出结果会解读<br>5.建议关闭swap<br>6.熟悉&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;下的参数，比如控制刷脏页的频率，脏页占有量，</p>\n<p>IO问题的分析<br>几个重要的概念</p>\n<h1 id=\"顺序IO\"><a href=\"#顺序IO\" class=\"headerlink\" title=\"顺序IO\"></a>顺序IO</h1><p>顺序读写文件，能很好地利用预读，对于机械磁盘也不用做磁头寻道，所以是性能最好的读写模<br>式，但是一般适用于日志类场景</p>\n<h1 id=\"随机IO\"><a href=\"#随机IO\" class=\"headerlink\" title=\"随机IO\"></a>随机IO</h1><p>随机读写，机械磁盘性能会非常差，如果是这种场景建议用SSD。当然应用层也会做各种努力尽量会将随机IO改成顺序IO</p>\n<h1 id=\"fsync刷盘\"><a href=\"#fsync刷盘\" class=\"headerlink\" title=\"fsync刷盘\"></a>fsync刷盘</h1><p>为了数据安全，每次写入完成通过fsync做强制刷盘操作，避免机器突然掉电能情况丢失数据，但是这个操作对吞吐和响应延时有较大的影响，一般会采用一些批量合并fsync的模式做优化</p>\n<h1 id=\"direct-io\"><a href=\"#direct-io\" class=\"headerlink\" title=\"direct io\"></a>direct io</h1><p>绕过page cache，直接对设备进行读写，一般性能不如带page cache，适用于在业务层做了cache,比如数据库</p>\n<h1 id=\"aio-异步IO\"><a href=\"#aio-异步IO\" class=\"headerlink\" title=\"aio:异步IO\"></a>aio:异步IO</h1><p>读写操作异步化，一般也是directio模式，编程会比较复杂，对于大部分应用不要采用，一般也是适用于数据库场景</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://blog.csdn.net/luslin1711/article/details/105859523\">设计一个抢票秒杀系统_luslin1711的博客-CSDN博客</a><br><a href=\"https://blog.csdn.net/lfssst/article/details/123722149\">抢票系统之架构设计_lfssst的博客-CSDN博客_抢票系统设计</a><br><a href=\"https://bytedancecampus1.feishu.cn/minutes/obcn2m3bdq645dm627u6u38w\">陈朋 (feishu.cn)</a><br><a href=\"https://github.com/EduFriendChen/snatch-tickets-demo\">EduFriendChen&#x2F;snatch-tickets-demo: 解：字节校园镜像技术项目实战活动 —— 【后端】如果有一千万个人抢票怎么办？ (github.com)</a><br><a href=\"https://www.cloudwego.io/zh/docs/hertz/tutorials/basic-feature/middleware/\">中间件概览 | CloudWeGo</a><br><a href=\"https://github.com/cloudwego/hertz-benchmark\">cloudwego&#x2F;hertz-benchmark: Tracking performance changes for Hertz (github.com)</a></p>\n","slug":"Project/Ticketing_system","updated":"31/12/2022","comments":true,"link":"","permalink":"http://example.com/2022/11/11/Project/Ticketing_system/","excerpt":"","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"mudduo-ch01","date":"02/11/2022","path":"2022/11/02/Linux-Network-Programming/ChenShuo-muduo/mudduo-ch01/","text":"仅仅只能在linux下运行 第一步muduo采用CMake为build systemCMake的安装如下：（CMake最好不低于2.8版，CentOS 6自带的2.6版也能用，但是无法自动识别Protobuf库） 12sudo apt-get install cmakesudo apt-get install g++ 第二步muduo依赖于Boost，Boost的安装如下 1sudo apt-get install libboost-dev libboost-test-dev 安装出现问题 123E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 5865 (unattended-upgr)N: Be aware that removing the lock file is not a solution and may break your system.E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it? 解决方法： 123sudo rm /var/lib/dpkg/lock-frontendsudo rm /var/lib/dpkg/locksudo rm /var/cache/apt/archives/lock 第三步（可选）muduo有三个非必须的依赖库（curl、c-ares DNS、Google Protobuf）如果安装了这三个库，cmake会自动多编译一些示例安装方法如下： 12sudo apt-get install libcurl4-openssl-dev libc-ares-devsudo apt-get install protobuf-compiler libprotobuf-dev 第四步：下载muduo源码包1git clone https://github.com/chenshuo/muduo.git 第五步：编译muduo1234# 下载完成之后进入muduo根目录cd muduo# 编译muduo库和它自带的例子./build.sh -j2 编译完成之后：会在muduo源码根路径的上一级路径下生成一个build目录（下面全文我们以..&#x2F;build表示）生成的可执行文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;bin静态文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;lib 第六步：安装muduo库1./build.sh install muduo头文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;include目录下库文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;lib目录下以便muduo-protorpc和muduo-udns等库使用 文件内容的分析recipes&#x2F;tpc&#x2F;netcat.cc thread-per-connectionrecipes&#x2F;python&#x2F;netcat.py IO-multiplexingrecipes&#x2F;python&#x2F;netcat-nonblock.py IO-multiplexing 参考文件所在位置：recipes&#x2F;tpc&#x2F;chargen.ccrecipes&#x2F;python&#x2F;chargen.pymuduo&#x2F;examples&#x2F;simple&#x2F;chargen&#x2F;* 安装boost库apt-get install libboost-all-dev 多个netcat的实现各种工具nmapntcatnc -l 1234 # 当做服务器,监听本机的1234端口nc localhost 1234 # 当做客户端,连接到本机的1234端口 学习netcat怎么编写g++ -Wall -std&#x3D;c++11 -pthread -O2 -g -iquote include&#x2F; -I..&#x2F; -I&#x2F;usr&#x2F;local&#x2F;include -L lib&#x2F; -L&#x2F;usr&#x2F;local&#x2F;lib -ltpc bin&#x2F;echo_client.cc lib&#x2F;libtpc.a -o bin&#x2F;echo_client 测试方法apt-get install libboost-all-devcd recipes&#x2F;tpc&#x2F;make 1.系统自带的nc 终端1，作为服务器 ./chargen -l 1234 # 启动服务器，监听在1234端口，如果有连接到来，就给他发送消息 终端2，作为客户端 nc localhost 1234 &gt; /dev/null # 启动客户端，将收到的信息给扔掉 终端1的输出结果 123456789805.430 MiB/s1936.315 MiB/s1927.679 MiB/s1925.130 MiB/s1928.128 MiB/s1937.221 MiB/s1930.871 MiB/s1929.448 MiB/s... 使用top查看进程使用情况 12345PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND6814 root 20 0 3340 2016 1892 R 100.0 0.0 0:36.72 nc6783 root 20 0 87976 2020 1836 S 65.4 0.0 0:38.23 chargen 33 root 20 0 0 0 0 S 0.3 0.0 0:00.03 ksoftirqd/3 936 redis 20 0 55872 4608 3300 S 0.3 0.0 0:05.40 redis-server 可以看到nc的占用率已经满了，现在是netcat是瓶颈 2.自己写的ntcat 终端1，作为服务器 ./chargen -l 1234 # 启动服务器，监听在1234端口，如果有连接到来，就给他发送消息 终端2，作为客户端 ./netcat localhost 1234 &gt; /dev/null # 启动自己写的netcat客户端 终端1的输出结果 123456789125.255 MiB/s2285.290 MiB/s2292.587 MiB/s2271.676 MiB/s2296.449 MiB/s2272.828 MiB/s2290.678 MiB/s2269.953 MiB/s... 使用top查看进程使用情况 12345 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND6910 root 20 0 14324 3292 3072 S 99.7 0.0 0:10.31 netcat 6908 root 20 0 87976 1740 1580 S 78.7 0.0 0:08.18 chargen 1062 mysql 20 0 2319480 394948 37472 S 0.7 2.4 0:27.63 mysqld 6843 root 20 0 15068 4048 3228 R 0.7 0.0 0:00.82 top 可以看到 参考文献陈硕的博客 https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html陈硕的csdn https://blog.csdn.net/Solstice?type=blog陈硕的课程主页 http://chenshuo.com/practical-network-programming/相关的代码仓库：http://github.com/chenshuo/muduohttp://github.com/chenshuo/recipeshttp://github.com/chenshuo/muduo-protorpchttp://github.com/chenshuo/muduo-examples-in-go如何安装 https://www.365seal.com/y/elnWyG1GVr.htmlmake编译源码时-j的作用 https://blog.csdn.net/JeekMrc/article/details/118332252安装boost的问题 https://zhuanlan.zhihu.com/p/126538251[万字长文梳理Muduo库核心代码及优秀编程细节思想剖析]https://zhuanlan.zhihu.com/p/495016351","raw":"---\ntitle: mudduo-ch01\ndate: 2022-11-02 19:46:15\ntags:\n- Linux网络编程\n---\n\n仅仅只能在linux下运行\n## 第一步\nmuduo采用CMake为build system\nCMake的安装如下：（CMake最好不低于2.8版，CentOS 6自带的2.6版也能用，但是无法自动识别Protobuf库）\n```\nsudo apt-get install cmake\nsudo apt-get install g++\n```\n## 第二步\nmuduo依赖于Boost，Boost的安装如下\n```\nsudo apt-get install libboost-dev libboost-test-dev\n```\n安装出现问题\n```\nE: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 5865 (unattended-upgr)\nN: Be aware that removing the lock file is not a solution and may break your system.\nE: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?\n```\n解决方法：\n```\nsudo rm /var/lib/dpkg/lock-frontend\nsudo rm /var/lib/dpkg/lock\nsudo rm /var/cache/apt/archives/lock\n```\n## 第三步（可选）\nmuduo有三个非必须的依赖库（curl、c-ares DNS、Google Protobuf）如果安装了这三个库，cmake会自动多编译一些示例\n安装方法如下：\n```\nsudo apt-get install libcurl4-openssl-dev libc-ares-dev\nsudo apt-get install protobuf-compiler libprotobuf-dev\n```\n\n## 第四步：下载muduo源码包\n```\ngit clone https://github.com/chenshuo/muduo.git\n```\n\n## 第五步：编译muduo\n```\n# 下载完成之后进入muduo根目录\ncd muduo\n# 编译muduo库和它自带的例子\n./build.sh -j2\n```\n编译完成之后：\n会在muduo源码根路径的上一级路径下生成一个build目录（下面全文我们以../build表示）\n生成的可执行文件位于：../build/release-cpp11/bin\n静态文件位于：../build/release-cpp11/lib\n\n## 第六步：安装muduo库\n```\n./build.sh install\n```\nmuduo头文件安装在../build/release-install-cpp11/include目录下\n库文件安装在../build/release-install-cpp11/lib目录下\n以便muduo-protorpc和muduo-udns等库使用\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 文件内容的分析\n\nrecipes/tpc/netcat.cc  thread-per-connection\nrecipes/python/netcat.py IO-multiplexing\nrecipes/python/netcat-nonblock.py IO-multiplexing\n\n参考文件所在位置：\nrecipes/tpc/chargen.cc\nrecipes/python/chargen.py\nmuduo/examples/simple/chargen/*\n\n# 安装boost库\napt-get install libboost-all-dev\n\n# 多个netcat的实现\n\n\n\n## 各种工具\n### nmap\n### ntcat\nnc -l 1234 # 当做服务器,监听本机的1234端口\nnc localhost 1234 # 当做客户端,连接到本机的1234端口\n\n# 学习netcat怎么编写\ng++ -Wall -std=c++11 -pthread -O2 -g -iquote include/ -I../ -I/usr/local/include  -L lib/ -L/usr/local/lib -ltpc  bin/echo_client.cc lib/libtpc.a   -o bin/echo_client\n\n\n# 测试方法\napt-get install libboost-all-dev\ncd recipes/tpc/\nmake\n\n## 1.系统自带的nc\n> 终端1，作为服务器\n\n```./chargen -l 1234  # 启动服务器，监听在1234端口，如果有连接到来，就给他发送消息```\n\n> 终端2，作为客户端\n\n```nc localhost 1234 > /dev/null  # 启动客户端，将收到的信息给扔掉```\n\n> 终端1的输出结果\n\n```\n805.430 MiB/s\n1936.315 MiB/s\n1927.679 MiB/s\n1925.130 MiB/s\n1928.128 MiB/s\n1937.221 MiB/s\n1930.871 MiB/s\n1929.448 MiB/s\n...\n```\n\n> 使用top查看进程使用情况\n```\n   PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\n   6814 root      20   0    3340   2016   1892 R 100.0   0.0   0:36.72 nc\n   6783 root      20   0   87976   2020   1836 S  65.4   0.0   0:38.23 chargen\n     33 root      20   0       0      0      0 S   0.3   0.0   0:00.03 ksoftirqd/3\n    936 redis     20   0   55872   4608   3300 S   0.3   0.0   0:05.40 redis-server\n```\n可以看到nc的占用率已经满了，现在是netcat是瓶颈\n\n## 2.自己写的ntcat\n> 终端1，作为服务器\n\n```./chargen -l 1234  # 启动服务器，监听在1234端口，如果有连接到来，就给他发送消息```\n\n> 终端2，作为客户端\n\n```./netcat localhost 1234 > /dev/null  # 启动自己写的netcat客户端```\n\n> 终端1的输出结果\n\n```\n125.255 MiB/s\n2285.290 MiB/s\n2292.587 MiB/s\n2271.676 MiB/s\n2296.449 MiB/s\n2272.828 MiB/s\n2290.678 MiB/s\n2269.953 MiB/s\n...\n```\n> 使用top查看进程使用情况\n```\n   PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\n 6910 root      20   0   14324   3292   3072 S  99.7   0.0   0:10.31 netcat\n   6908 root      20   0   87976   1740   1580 S  78.7   0.0   0:08.18 chargen\n   1062 mysql     20   0 2319480 394948  37472 S   0.7   2.4   0:27.63 mysqld\n   6843 root      20   0   15068   4048   3228 R   0.7   0.0   0:00.82 top\n```\n可以看到\n\n\n\n# 参考文献\n陈硕的博客 https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html\n陈硕的csdn https://blog.csdn.net/Solstice?type=blog\n陈硕的课程主页 http://chenshuo.com/practical-network-programming/\n相关的代码仓库：\nhttp://github.com/chenshuo/muduo\nhttp://github.com/chenshuo/recipes\nhttp://github.com/chenshuo/muduo-protorpc\nhttp://github.com/chenshuo/muduo-examples-in-go\n如何安装 https://www.365seal.com/y/elnWyG1GVr.html\nmake编译源码时-j的作用 https://blog.csdn.net/JeekMrc/article/details/118332252\n安装boost的问题 https://zhuanlan.zhihu.com/p/126538251\n[万字长文梳理Muduo库核心代码及优秀编程细节思想剖析]https://zhuanlan.zhihu.com/p/495016351\n\n\n\n","content":"<p>仅仅只能在linux下运行</p>\n<h2 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h2><p>muduo采用CMake为build system<br>CMake的安装如下：（CMake最好不低于2.8版，CentOS 6自带的2.6版也能用，但是无法自动识别Protobuf库）</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install cmake</span><br><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install g++</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h2><p>muduo依赖于Boost，Boost的安装如下</p>\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install libboost-<span class=\"built_in\">dev</span> libboost-test-<span class=\"built_in\">dev</span></span><br></pre></td></tr></table></figure>\n<p>安装出现问题</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E: Could <span class=\"keyword\">not</span> <span class=\"keyword\">get</span> <span class=\"keyword\">lock</span> /<span class=\"keyword\">var</span>/lib/dpkg/<span class=\"keyword\">lock</span>-frontend. It <span class=\"keyword\">is</span> held <span class=\"keyword\">by</span> process <span class=\"number\">5865</span> (unattended-upgr)</span><br><span class=\"line\">N: Be aware that removing the <span class=\"keyword\">lock</span> file <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> a solution <span class=\"keyword\">and</span> may <span class=\"keyword\">break</span> your system.</span><br><span class=\"line\">E: <span class=\"function\">Unable to acquire the dpkg frontend <span class=\"title\">lock</span> (<span class=\"params\">/<span class=\"keyword\">var</span>/lib/dpkg/<span class=\"keyword\">lock</span>-frontend</span>), <span class=\"keyword\">is</span> another process <span class=\"keyword\">using</span> it?</span></span><br></pre></td></tr></table></figure>\n<p>解决方法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm <span class=\"regexp\">/var/</span>lib<span class=\"regexp\">/dpkg/</span>lock-frontend</span><br><span class=\"line\">sudo rm <span class=\"regexp\">/var/</span>lib<span class=\"regexp\">/dpkg/</span>lock</span><br><span class=\"line\">sudo rm <span class=\"regexp\">/var/</span>cache<span class=\"regexp\">/apt/</span>archives/lock</span><br></pre></td></tr></table></figure>\n<h2 id=\"第三步（可选）\"><a href=\"#第三步（可选）\" class=\"headerlink\" title=\"第三步（可选）\"></a>第三步（可选）</h2><p>muduo有三个非必须的依赖库（curl、c-ares DNS、Google Protobuf）如果安装了这三个库，cmake会自动多编译一些示例<br>安装方法如下：</p>\n<figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install libcurl4-openssl-<span class=\"built_in\">dev</span> libc-ares-<span class=\"built_in\">dev</span></span><br><span class=\"line\">sudo apt-<span class=\"built_in\">get</span> install protobuf-compiler libprotobuf-<span class=\"built_in\">dev</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第四步：下载muduo源码包\"><a href=\"#第四步：下载muduo源码包\" class=\"headerlink\" title=\"第四步：下载muduo源码包\"></a>第四步：下载muduo源码包</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:<span class=\"regexp\">//gi</span>thub.com<span class=\"regexp\">/chenshuo/mu</span>duo.git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第五步：编译muduo\"><a href=\"#第五步：编译muduo\" class=\"headerlink\" title=\"第五步：编译muduo\"></a>第五步：编译muduo</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载完成之后进入muduo根目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> muduo</span><br><span class=\"line\"><span class=\"comment\"># 编译muduo库和它自带的例子</span></span><br><span class=\"line\">./build.sh -j2</span><br></pre></td></tr></table></figure>\n<p>编译完成之后：<br>会在muduo源码根路径的上一级路径下生成一个build目录（下面全文我们以..&#x2F;build表示）<br>生成的可执行文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;bin<br>静态文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;lib</p>\n<h2 id=\"第六步：安装muduo库\"><a href=\"#第六步：安装muduo库\" class=\"headerlink\" title=\"第六步：安装muduo库\"></a>第六步：安装muduo库</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./build.sh install</span><br></pre></td></tr></table></figure>\n<p>muduo头文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;include目录下<br>库文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;lib目录下<br>以便muduo-protorpc和muduo-udns等库使用</p>\n<h1 id=\"文件内容的分析\"><a href=\"#文件内容的分析\" class=\"headerlink\" title=\"文件内容的分析\"></a>文件内容的分析</h1><p>recipes&#x2F;tpc&#x2F;netcat.cc  thread-per-connection<br>recipes&#x2F;python&#x2F;netcat.py IO-multiplexing<br>recipes&#x2F;python&#x2F;netcat-nonblock.py IO-multiplexing</p>\n<p>参考文件所在位置：<br>recipes&#x2F;tpc&#x2F;chargen.cc<br>recipes&#x2F;python&#x2F;chargen.py<br>muduo&#x2F;examples&#x2F;simple&#x2F;chargen&#x2F;*</p>\n<h1 id=\"安装boost库\"><a href=\"#安装boost库\" class=\"headerlink\" title=\"安装boost库\"></a>安装boost库</h1><p>apt-get install libboost-all-dev</p>\n<h1 id=\"多个netcat的实现\"><a href=\"#多个netcat的实现\" class=\"headerlink\" title=\"多个netcat的实现\"></a>多个netcat的实现</h1><h2 id=\"各种工具\"><a href=\"#各种工具\" class=\"headerlink\" title=\"各种工具\"></a>各种工具</h2><h3 id=\"nmap\"><a href=\"#nmap\" class=\"headerlink\" title=\"nmap\"></a>nmap</h3><h3 id=\"ntcat\"><a href=\"#ntcat\" class=\"headerlink\" title=\"ntcat\"></a>ntcat</h3><p>nc -l 1234 # 当做服务器,监听本机的1234端口<br>nc localhost 1234 # 当做客户端,连接到本机的1234端口</p>\n<h1 id=\"学习netcat怎么编写\"><a href=\"#学习netcat怎么编写\" class=\"headerlink\" title=\"学习netcat怎么编写\"></a>学习netcat怎么编写</h1><p>g++ -Wall -std&#x3D;c++11 -pthread -O2 -g -iquote include&#x2F; -I..&#x2F; -I&#x2F;usr&#x2F;local&#x2F;include  -L lib&#x2F; -L&#x2F;usr&#x2F;local&#x2F;lib -ltpc  bin&#x2F;echo_client.cc lib&#x2F;libtpc.a   -o bin&#x2F;echo_client</p>\n<h1 id=\"测试方法\"><a href=\"#测试方法\" class=\"headerlink\" title=\"测试方法\"></a>测试方法</h1><p>apt-get install libboost-all-dev<br>cd recipes&#x2F;tpc&#x2F;<br>make</p>\n<h2 id=\"1-系统自带的nc\"><a href=\"#1-系统自带的nc\" class=\"headerlink\" title=\"1.系统自带的nc\"></a>1.系统自带的nc</h2><blockquote>\n<p>终端1，作为服务器</p>\n</blockquote>\n<p><code>./chargen -l 1234  # 启动服务器，监听在1234端口，如果有连接到来，就给他发送消息</code></p>\n<blockquote>\n<p>终端2，作为客户端</p>\n</blockquote>\n<p><code>nc localhost 1234 &gt; /dev/null  # 启动客户端，将收到的信息给扔掉</code></p>\n<blockquote>\n<p>终端1的输出结果</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">805.430 MiB/s</span><br><span class=\"line\">1936.315 MiB/s</span><br><span class=\"line\">1927.679 MiB/s</span><br><span class=\"line\">1925.130 MiB/s</span><br><span class=\"line\">1928.128 MiB/s</span><br><span class=\"line\">1937.221 MiB/s</span><br><span class=\"line\">1930.871 MiB/s</span><br><span class=\"line\">1929.448 MiB/s</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用top查看进程使用情况</p>\n</blockquote>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">PID</span> USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class=\"line\"><span class=\"attribute\">6814</span> root      <span class=\"number\">20</span>   <span class=\"number\">0</span>    <span class=\"number\">3340</span>   <span class=\"number\">2016</span>   <span class=\"number\">1892</span> R <span class=\"number\">100</span>.<span class=\"number\">0</span>   <span class=\"number\">0</span>.<span class=\"number\">0</span>   <span class=\"number\">0</span>:<span class=\"number\">36</span>.<span class=\"number\">72</span> nc</span><br><span class=\"line\"><span class=\"attribute\">6783</span> root      <span class=\"number\">20</span>   <span class=\"number\">0</span>   <span class=\"number\">87976</span>   <span class=\"number\">2020</span>   <span class=\"number\">1836</span> S  <span class=\"number\">65</span>.<span class=\"number\">4</span>   <span class=\"number\">0</span>.<span class=\"number\">0</span>   <span class=\"number\">0</span>:<span class=\"number\">38</span>.<span class=\"number\">23</span> chargen</span><br><span class=\"line\">  <span class=\"attribute\">33</span> root      <span class=\"number\">20</span>   <span class=\"number\">0</span>       <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> S   <span class=\"number\">0</span>.<span class=\"number\">3</span>   <span class=\"number\">0</span>.<span class=\"number\">0</span>   <span class=\"number\">0</span>:<span class=\"number\">00</span>.<span class=\"number\">03</span> ksoftirqd/<span class=\"number\">3</span></span><br><span class=\"line\"> <span class=\"attribute\">936</span> redis     <span class=\"number\">20</span>   <span class=\"number\">0</span>   <span class=\"number\">55872</span>   <span class=\"number\">4608</span>   <span class=\"number\">3300</span> S   <span class=\"number\">0</span>.<span class=\"number\">3</span>   <span class=\"number\">0</span>.<span class=\"number\">0</span>   <span class=\"number\">0</span>:<span class=\"number\">05</span>.<span class=\"number\">40</span> redis-server</span><br></pre></td></tr></table></figure>\n<p>可以看到nc的占用率已经满了，现在是netcat是瓶颈</p>\n<h2 id=\"2-自己写的ntcat\"><a href=\"#2-自己写的ntcat\" class=\"headerlink\" title=\"2.自己写的ntcat\"></a>2.自己写的ntcat</h2><blockquote>\n<p>终端1，作为服务器</p>\n</blockquote>\n<p><code>./chargen -l 1234  # 启动服务器，监听在1234端口，如果有连接到来，就给他发送消息</code></p>\n<blockquote>\n<p>终端2，作为客户端</p>\n</blockquote>\n<p><code>./netcat localhost 1234 &gt; /dev/null  # 启动自己写的netcat客户端</code></p>\n<blockquote>\n<p>终端1的输出结果</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">125.255 MiB/s</span><br><span class=\"line\">2285.290 MiB/s</span><br><span class=\"line\">2292.587 MiB/s</span><br><span class=\"line\">2271.676 MiB/s</span><br><span class=\"line\">2296.449 MiB/s</span><br><span class=\"line\">2272.828 MiB/s</span><br><span class=\"line\">2290.678 MiB/s</span><br><span class=\"line\">2269.953 MiB/s</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用top查看进程使用情况</p>\n</blockquote>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"attribute\">PID</span> USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class=\"line\"><span class=\"attribute\">6910</span> root      <span class=\"number\">20</span>   <span class=\"number\">0</span>   <span class=\"number\">14324</span>   <span class=\"number\">3292</span>   <span class=\"number\">3072</span> S  <span class=\"number\">99</span>.<span class=\"number\">7</span>   <span class=\"number\">0</span>.<span class=\"number\">0</span>   <span class=\"number\">0</span>:<span class=\"number\">10</span>.<span class=\"number\">31</span> netcat</span><br><span class=\"line\">  <span class=\"attribute\">6908</span> root      <span class=\"number\">20</span>   <span class=\"number\">0</span>   <span class=\"number\">87976</span>   <span class=\"number\">1740</span>   <span class=\"number\">1580</span> S  <span class=\"number\">78</span>.<span class=\"number\">7</span>   <span class=\"number\">0</span>.<span class=\"number\">0</span>   <span class=\"number\">0</span>:<span class=\"number\">08</span>.<span class=\"number\">18</span> chargen</span><br><span class=\"line\">  <span class=\"attribute\">1062</span> mysql     <span class=\"number\">20</span>   <span class=\"number\">0</span> <span class=\"number\">2319480</span> <span class=\"number\">394948</span>  <span class=\"number\">37472</span> S   <span class=\"number\">0</span>.<span class=\"number\">7</span>   <span class=\"number\">2</span>.<span class=\"number\">4</span>   <span class=\"number\">0</span>:<span class=\"number\">27</span>.<span class=\"number\">63</span> mysqld</span><br><span class=\"line\">  <span class=\"attribute\">6843</span> root      <span class=\"number\">20</span>   <span class=\"number\">0</span>   <span class=\"number\">15068</span>   <span class=\"number\">4048</span>   <span class=\"number\">3228</span> R   <span class=\"number\">0</span>.<span class=\"number\">7</span>   <span class=\"number\">0</span>.<span class=\"number\">0</span>   <span class=\"number\">0</span>:<span class=\"number\">00</span>.<span class=\"number\">82</span> top</span><br></pre></td></tr></table></figure>\n<p>可以看到</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>陈硕的博客 <a href=\"https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html\">https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html</a><br>陈硕的csdn <a href=\"https://blog.csdn.net/Solstice?type=blog\">https://blog.csdn.net/Solstice?type=blog</a><br>陈硕的课程主页 <a href=\"http://chenshuo.com/practical-network-programming/\">http://chenshuo.com/practical-network-programming/</a><br>相关的代码仓库：<br><a href=\"http://github.com/chenshuo/muduo\">http://github.com/chenshuo/muduo</a><br><a href=\"http://github.com/chenshuo/recipes\">http://github.com/chenshuo/recipes</a><br><a href=\"http://github.com/chenshuo/muduo-protorpc\">http://github.com/chenshuo/muduo-protorpc</a><br><a href=\"http://github.com/chenshuo/muduo-examples-in-go\">http://github.com/chenshuo/muduo-examples-in-go</a><br>如何安装 <a href=\"https://www.365seal.com/y/elnWyG1GVr.html\">https://www.365seal.com/y/elnWyG1GVr.html</a><br>make编译源码时-j的作用 <a href=\"https://blog.csdn.net/JeekMrc/article/details/118332252\">https://blog.csdn.net/JeekMrc/article/details/118332252</a><br>安装boost的问题 <a href=\"https://zhuanlan.zhihu.com/p/126538251\">https://zhuanlan.zhihu.com/p/126538251</a><br>[万字长文梳理Muduo库核心代码及优秀编程细节思想剖析]<a href=\"https://zhuanlan.zhihu.com/p/495016351\">https://zhuanlan.zhihu.com/p/495016351</a></p>\n","slug":"Linux-Network-Programming/ChenShuo-muduo/mudduo-ch01","updated":"16/03/2023","comments":true,"link":"","permalink":"http://example.com/2022/11/02/Linux-Network-Programming/ChenShuo-muduo/mudduo-ch01/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"计算机网络 面经","date":"02/11/2022","path":"2022/11/02/Interview-Q&A/network_Q&A/","text":"概述1、OSI 的七层模型分别是？各自的功能是什么？ 层数 作用 传输数据的名称 物理层 保证有物理上的连接的传输 比特流 （Bits） 数据链路层 帧 （Frames） 网络层 提供点对点的服务，可以找到对方的IP，就是找到对方主机的位置 包 （Packages） 传输层 从传递到主机变成可以传递到进程之间 段 （Segments） 会话层 表示层 应用层 在隔绝下层的通信内容后，可以制作各种的应用 应用层一、概述应用层常见协议知道多少？了解几个？ 应用层协议 传输层 端口 说明 HTTP TCP 80 超文本传输协议 FTP TCP 23 文件传输 DNS UDP 53 域名服务器 SMTP 465&#x2F;994 邮件发送协议 POP3 995 邮件接收协议，邮件存到本机，删除服务器上邮件 IMAP 993 邮件接收协议，邮件存到本机，不删除服务器上邮件 BitTorrent TCP&#x2F;UDP P2P的文件共享协议 RTSP TCP&#x2F;UDP 主要用于拉取视频流，用在VLC 二、HTTP1)HTTP基础1.说一下一次完整的HTTP请求过程包括哪些内容？ 建立客户端和服务器的连接 客户端发送消息给服务器 服务器给客户端发送应答消息 客户端收到消息，浏览器解析，给用户呈现 2.HTTP长连接和短连接的区别HTTP1.0默认使用短连接，每次HTTP连接完成以后，都会自动断开，下一次连接的时候的时候又会重新建立，十分的花费时间 HTTP1.1默认使用长连接，也就是持久连接 其中HTTP1.1报文首部中使用Connection:Keep-Alive字段，指定使用了长链接 3.HTTP请求方法你知道多少？ 方法 作用 HTTP1.0 HTTP1.1 GET 主要为获取和查询数据 √ √ POST 发送修改请求 √ √ HEAD 获取响应首部 √ √ DELETE 删除资源 √ √ PUT 传输文件 √ √ OPTION 查询对应的URL支持的方法 × √ TRACE 将请求通信回路返回给客户端 × √ CONNECT 使用隧道协议代理进行连接 × √ LINK × 现在被取消了 UNLINK × 现在被取消了 4.常见的HTTP状态码有哪些？ 状态码 具体状态码 类别 原因短语 常见情况 1XX 请求正在处理 POST的请求中转时候使用 2XX 请求成功 200 OK 204 206 3XX 请求重定向 301 302 303 304 307 4XX Client Error 客户端错误 400 Bad Request 错误请求 请求报文中存在语法问题 401 403 Forbidden 禁止访问 没有访问的权限 404 Not Found 服务器上没有请求的资源 5XX Server Error 服务器错误 500 Internal Server Error 服务器本身出错 对于URL请求过来，处理出现了BUG代码有bug 503 Service Unavilable 服务器正忙 6.HTTP请求和响应报文有哪些主要字段？请求报文： 请求行 ： 包括请求方法，URL，协议&#x2F;版本，例如：GET HTTP&#x2F;1.1 请求头部：User-Agent: 请求主体：body 响应报文： 状态行：HTTP&#x2F;1.1 200 OK 响应头部：Content-Length:200 响应主体： 7.HTTPS是什么？HTTPS不是一种新的协议，是在HTTP协议的下方通过SSL&#x2F;TLS来提供加密服务，但是HTTP+SSL依然处在应用层 然后通过TCP协议将加密的信息发送给对方，从而达到，防窃听，防伪装，防篡改的目的 8.SSL是什么？SSL(Secure Socket Layer，安全套接字层) TSL(Transport Layer Security，传输安全层)，前身是SSL 9.HTTPS和HTTP的区别 HTTP是明文传输的，数据都没有进行加密，HTTPS通过SSL&#x2F;TLS层提供了加密服务 HTTP只需要在TCP三次握手后就可以建立连接，只需要交换3个数据报，但是HTTPS除了需要TCP的三次握手之外，还需要SSL握手需要9个包，建立连接的速度比HTTP慢 HTTP需要到CA(证书颁发机构)申请证书，后才能使用，但是免费的证书比较少，而且需要一定的费用 HTTP和HTTPS使用的连接方式不同，使用的端口也不同，HTTP在80号端口，HTTPS在443号端口 10.HTTP的缺点有哪些？ 使用明文传输，传输过程没有加密，传送内容容易被窃听 不验证通信方的身份，通信方的身份可能遭遇伪装 无法验证报文完整性，加密内容容易被篡改 11.HTTPS采用的加密方式有哪些？是对称还是非对称？12.HTTP如何禁用缓存？如何确认缓存？13.URI和URL的区别URI：Uniform Resource Identifier，统一资源定位符 URL：Uniform Resource Location，统一资源标识符 URI是用来标识一个资源的，可以通过这个知道资源是什么 URL是用来定位具体资源的，通过这个可以拉取到想要的资源 2)请求方法1.GET 和 POST 的区别，你知道哪些？ GET传输的内容在参数中传递，POST在body中传递参数 GET一般用于获取数据，POST一般用于修改数据，比如登录的场景 GET提交的数据，理论上长度为2K，POST传递的数据长度，理论上没有限制 GET请求会被浏览器缓存，POST一般情况下不会 GET是幂等的，POST不是幂等的 记忆：1.传参，2.作用，3.长度，4.缓存，5.幂等 幂等性的意思：对服务器的请求，请求一次的结果和请求多次的结果是一样的 GET查询一个数据，每次查询的结果是一样的，所以是幂等的 POST生成一个新的数据，比如生成一个博客，POST请求了两次，可能会生成两个页面 2.GET 方法参数写法是固定的吗？一般情况下，GET请求的参数都是写在?后面，通过&amp;来连接多个参数 服务器解析的过程是，获取TCP连接传输过来的数据，通过正则表达式的方法获取Header和Body，从而提取到GET请求的参数 但这个参数的写法也是由客户端和服务器之间约定形成的，只要双方遵守约定的规则，都是可以解析的 3.GET 方法的长度限制是怎么回事？GET方法理论上没有长度的限制，HTTP协议没有对Body和URL进行长度限制 一般是浏览器或者服务器给GET方法添加的限制，一般为2K大小 服务器限制GET方法的长度的原因：1.从性能角度考虑，处理较长的URL消耗较多的资源，2.从安全角度考虑，防止恶意构造长的URL来攻击 4.POST 方法比 GET 方法安全？POST方法，传输的数据，从地址栏是不可见的，看起来比GET方法安全 但是HTTP都是明文传输的，只要进行数据抓包，就能抓到POST方法中Body的内容，所以其实也是不安全的 想要安全传输，还需要将HTTP改造成HTTPS 5.POST 方法会产生两个 TCP 数据包？你了解吗？HTTP协议中没有说POST会发送两次请求 是有些文章中提到使用POST会将head和body分开发送，先发送header，服务器返回100后再次发送body 但是实际上发现，在大多数情况下并不是这样 所以说POST产生两个TCP数据包的情况，是部分浏览器和框架的行为，不是POST的必然行为 6.GET与POST传递数据的最大长度能够达到多少呢？HTTP没有对GET和POST请求，传递数据的最大长度做规范 GET能传输的最大长度取决于URL的长度，一般浏览器的限制为2K，主要是服务器设计者从安全和性能的角度考虑的 POST的传输长度取决于body能传输多大，一般都是要求小于MB 3)状态管理1.Cookie是什么？由于HTTP协议是无状态的，所以在HTTP&#x2F;1.1中就引入了cookie来保存用户信息。 用来解决每次刷新一次页面都需要重新登录的情况 客户端向服务器发送请求后，服务器返回的消息中会携带一小段数据用于标识这个用户，之后每次客户端的请求都会带上这一小段cookie表示来自同一个用户的请求，会增加一些性能开销 2.Cookie有什么用途？用途 会话状态的管理，记住用户的登录状态，购物车信息，收藏夹内容 个性化设置，电商页面的话会给用户做个性化推荐 浏览器行为跟踪，跟踪分析用户的行为 3.Session是什么？除了将用户的cookie存在本地，还可以使用session将用户信息存储在服务器 sesion可以存储在服务器的文件，数据库，内存中，或者存在redis这种内存数据中，效率更高 Session 的工作原理是什么？&#x2F;使用 Session 的过程是怎样的？Cookies和Session区别是什么？Cookie与Session的对比Session和cookie应该如何去选择（适用场景）？ cookie只能保存ASCII码值，cookie可以保存各种类型的信息，当存储的内容较复杂的时候，首选cookie cookie存储在浏览器中，容易被恶意查看，容易造成隐私的泄漏，隐私数据应该存在session中 session对于大型网站，用户量十分大，储存的开销也是十分大的，只需要在sesion中保存重要信息 二、DNS1.你知道DNS是什么？DNS是一种域名解析服务器，可以将用户发送过来的域名转化为具体的IP地址 2.DNS的工作原理？DNS查询方式有哪些？攻击方式SYN攻击是什么？DDos 攻击了解吗？XSS攻击是什么？（低频）CSRF攻击？你知道吗？如何防范CSRF攻击参考资料计算机网络-01-20 | 阿秀的学习笔记 (interviewguide.cn)[ 面试必备：GET和POST 的区别详细解说 - 腾讯云开发者社区-腾讯云 (tencent.com) HTTP POST请求发送两个TCP包？_john-zeng的博客-CSDN博客_post 两个tcp","raw":"---\ntitle: 计算机网络 面经\ndate: 2022-11-02 13:39:59\ntags:\n- 面试\n---\n\n# 概述\n\n## 1、OSI 的七层模型分别是？各自的功能是什么？\n\n| 层数       | 作用                                                       | 传输数据的名称  |\n| ---------- | :--------------------------------------------------------- | --------------- |\n| 物理层     | 保证有物理上的连接的传输                                   | 比特流 （Bits） |\n| 数据链路层 |                                                            | 帧 （Frames）   |\n| 网络层     | 提供点对点的服务，可以找到对方的IP，就是找到对方主机的位置 | 包 （Packages） |\n| 传输层     | 从传递到主机变成可以传递到进程之间                         | 段 （Segments） |\n| 会话层     |                                                            |                 |\n| 表示层     |                                                            |                 |\n| 应用层     | 在隔绝下层的通信内容后，可以制作各种的应用                 |                 |\n\n# 应用层\n\n## 一、概述\n\n## 应用层常见协议知道多少？了解几个？\n\n| 应用层协议 | 传输层  | 端口    | 说明                                           |\n| ---------- | ------- | ------- | ---------------------------------------------- |\n| HTTP       | TCP     | 80      | 超文本传输协议                                 |\n| FTP        | TCP     | 23      | 文件传输                                       |\n| DNS        | UDP     | 53      | 域名服务器                                     |\n| SMTP       |         | 465/994 | 邮件发送协议                                   |\n| POP3       |         | 995     | 邮件接收协议，邮件存到本机，删除服务器上邮件   |\n| IMAP       |         | 993     | 邮件接收协议，邮件存到本机，不删除服务器上邮件 |\n| BitTorrent | TCP/UDP |         | P2P的文件共享协议                              |\n| RTSP       | TCP/UDP |         | 主要用于拉取视频流，用在VLC                    |\n\n## 二、HTTP\n\n### 1)HTTP基础\n\n#### 1.说一下一次完整的HTTP请求过程包括哪些内容？\n\n1. 建立客户端和服务器的连接\n2. 客户端发送消息给服务器\n3. 服务器给客户端发送应答消息\n4. 客户端收到消息，浏览器解析，给用户呈现\n\n#### 2.HTTP长连接和短连接的区别\n\nHTTP1.0默认使用短连接，每次HTTP连接完成以后，都会自动断开，下一次连接的时候的时候又会重新建立，十分的花费时间\n\nHTTP1.1默认使用长连接，也就是**持久连接**\n\n其中HTTP1.1报文首部中使用Connection:Keep-Alive字段，指定使用了长链接\n\n#### 3.HTTP请求方法你知道多少？\n\n| 方法       | 作用                       | HTTP1.0 | HTTP1.1      |\n| ---------- | -------------------------- | ------- | ------------ |\n| GET        | 主要为获取和查询数据       | √       | √            |\n| POST       | 发送修改请求               | √       | √            |\n| HEAD       | 获取响应首部               | √       | √            |\n| DELETE     | 删除资源                   | √       | √            |\n| PUT        | 传输文件                   | √       | √            |\n| OPTION     | 查询对应的URL支持的方法    | ×       | √            |\n| TRACE      | 将请求通信回路返回给客户端 | ×       | √            |\n| CONNECT    | 使用隧道协议代理进行连接   | ×       | √            |\n| ~~LINK~~   |                            | ×       | 现在被取消了 |\n| ~~UNLINK~~ |                            | ×       | 现在被取消了 |\n\n#### 4.常见的HTTP状态码有哪些？\n\n| 状态码 | 具体状态码 | 类别                  | 原因短语               | 常见情况                                     |\n| ------ | ---------- | --------------------- | ---------------------- | -------------------------------------------- |\n| 1XX    |            |                       | 请求正在处理           | POST的请求中转时候使用                       |\n| 2XX    |            |                       | 请求成功               |                                              |\n|        | 200        | OK                    |                        |                                              |\n|        | 204        |                       |                        |                                              |\n|        | 206        |                       |                        |                                              |\n| 3XX    |            |                       | 请求重定向             |                                              |\n|        | 301        |                       |                        |                                              |\n|        | 302        |                       |                        |                                              |\n|        | 303        |                       |                        |                                              |\n|        | 304        |                       |                        |                                              |\n|        | 307        |                       |                        |                                              |\n| 4XX    |            | Client Error          | 客户端错误             |                                              |\n|        | 400        | Bad Request           | 错误请求               | 请求报文中存在语法问题                       |\n|        | 401        |                       |                        |                                              |\n|        | 403        | Forbidden             | 禁止访问               | 没有访问的权限                               |\n|        | 404        | Not Found             | 服务器上没有请求的资源 |                                              |\n| 5XX    |            | Server Error          | 服务器错误             |                                              |\n|        | 500        | Internal Server Error | 服务器本身出错         | 对于URL请求过来，处理出现了BUG<br/>代码有bug |\n|        | 503        | Service Unavilable    | 服务器正忙             |                                              |\n|        |            |                       |                        |                                              |\n\n#### 6.HTTP请求和响应报文有哪些主要字段？\n\n请求报文：\n\n请求行 ： 包括请求方法，URL，协议/版本，例如：GET HTTP/1.1\n\n请求头部：User-Agent:\n\n请求主体：body\n\n响应报文：\n\n状态行：HTTP/1.1 200 OK\n\n响应头部：Content-Length:200\n\n响应主体：<html></html>\n\n#### 7.HTTPS是什么？\n\nHTTPS不是一种新的协议，是在HTTP协议的下方通过SSL/TLS来提供加密服务，但是HTTP+SSL依然处在应用层\n\n然后通过TCP协议将加密的信息发送给对方，从而达到，防窃听，防伪装，防篡改的目的\n\n#### 8.SSL是什么？\n\nSSL(Secure Socket Layer，安全套接字层)\n\nTSL(Transport Layer Security，传输安全层)，前身是SSL\n\n#### 9.HTTPS和HTTP的区别\n\n1. HTTP是明文传输的，数据都没有进行加密，HTTPS通过SSL/TLS层提供了加密服务\n2. HTTP只需要在TCP三次握手后就可以建立连接，只需要交换3个数据报，但是HTTPS除了需要TCP的三次握手之外，还需要SSL握手需要9个包，建立连接的速度比HTTP慢\n3. HTTP需要到CA(证书颁发机构)申请证书，后才能使用，但是免费的证书比较少，而且需要一定的费用\n4. HTTP和HTTPS使用的连接方式不同，使用的端口也不同，HTTP在80号端口，HTTPS在443号端口\n\n#### 10.HTTP的缺点有哪些？\n\n1. 使用明文传输，传输过程没有加密，传送内容容易被**窃听**\n2. 不验证通信方的身份，通信方的身份可能遭遇**伪装**\n3. 无法验证报文完整性，加密内容容易被**篡改**\n\n#### 11.HTTPS采用的加密方式有哪些？是对称还是非对称？\n\n#### 12.HTTP如何禁用缓存？如何确认缓存？\n\n#### 13.URI和URL的区别\n\nURI：Uniform Resource Identifier，统一资源**定位**符\n\nURL：Uniform Resource Location，统一资源**标识**符\n\nURI是用来标识一个资源的，可以通过这个知道资源是什么\n\nURL是用来定位具体资源的，通过这个可以拉取到想要的资源\n\n### 2)请求方法\n\n#### 1.GET 和 POST 的区别，你知道哪些？\n\n1. GET传输的内容在参数中传递，POST在body中传递参数\n2. GET一般用于获取数据，POST一般用于修改数据，比如登录的场景\n3. GET提交的数据，理论上长度为2K，POST传递的数据长度，理论上没有限制\n4. GET请求会被浏览器缓存，POST一般情况下不会\n5. GET是幂等的，POST不是幂等的\n\n记忆：1.传参，2.作用，3.长度，4.缓存，5.幂等\n\n幂等性的意思：对服务器的请求，请求一次的结果和请求多次的结果是一样的\n\nGET查询一个数据，每次查询的结果是一样的，所以是幂等的\n\nPOST生成一个新的数据，比如生成一个博客，POST请求了两次，可能会生成两个页面\n\n#### 2.GET 方法参数写法是固定的吗？\n\n一般情况下，GET请求的参数都是写在?后面，通过&来连接多个参数\n\n服务器解析的过程是，获取TCP连接传输过来的数据，通过正则表达式的方法获取Header和Body，从而提取到GET请求的参数\n\n但这个参数的写法也是由客户端和服务器之间约定形成的，只要双方遵守约定的规则，都是可以解析的\n\n#### 3.GET 方法的长度限制是怎么回事？\n\nGET方法理论上没有长度的限制，HTTP协议没有对Body和URL进行长度限制\n\n一般是浏览器或者服务器给GET方法添加的限制，一般为2K大小\n\n服务器限制GET方法的长度的原因：1.从性能角度考虑，处理较长的URL消耗较多的资源，2.从安全角度考虑，防止恶意构造长的URL来攻击\n\n#### 4.POST 方法比 GET 方法安全？\n\nPOST方法，传输的数据，从地址栏是不可见的，看起来比GET方法安全\n\n但是HTTP都是明文传输的，只要进行数据抓包，就能抓到POST方法中Body的内容，所以其实也是不安全的\n\n想要安全传输，还需要将HTTP改造成HTTPS\n\n#### 5.POST 方法会产生两个 TCP 数据包？你了解吗？\n\nHTTP协议中没有说POST会发送两次请求\n\n是有些文章中提到使用POST会将head和body分开发送，先发送header，服务器返回100后再次发送body\n\n但是实际上发现，在大多数情况下并不是这样\n\n所以说POST产生两个TCP数据包的情况，是部分浏览器和框架的行为，不是POST的必然行为\n\n#### 6.GET与POST传递数据的最大长度能够达到多少呢？\n\nHTTP没有对GET和POST请求，传递数据的最大长度做规范\n\nGET能传输的最大长度取决于URL的长度，一般浏览器的限制为2K，主要是服务器设计者从安全和性能的角度考虑的\n\nPOST的传输长度取决于body能传输多大，一般都是要求小于MB\n\n### 3)状态管理\n\n#### 1.Cookie是什么？\n\n由于HTTP协议是无状态的，所以在HTTP/1.1中就引入了cookie来保存用户信息。\n\n用来解决每次刷新一次页面都需要重新登录的情况\n\n客户端向服务器发送请求后，服务器返回的消息中会携带一小段数据用于标识这个用户，之后每次客户端的请求都会带上这一小段cookie表示来自同一个用户的请求，会增加一些性能开销\n\n#### 2.Cookie有什么用途？用途\n\n1. 会话状态的管理，记住用户的登录状态，购物车信息，收藏夹内容\n2. 个性化设置，电商页面的话会给用户做个性化推荐\n3. 浏览器行为跟踪，跟踪分析用户的行为\n\n#### 3.Session是什么？\n\n除了将用户的cookie存在本地，还可以使用session将用户信息存储在服务器\n\nsesion可以存储在服务器的文件，数据库，内存中，或者存在redis这种内存数据中，效率更高\n\n#### Session 的工作原理是什么？/使用 Session 的过程是怎样的？\n\n#### Cookies和Session区别是什么？Cookie与Session的对比\n\n#### Session和cookie应该如何去选择（适用场景）？\n\n1. cookie只能保存ASCII码值，cookie可以保存各种类型的信息，当存储的内容较复杂的时候，首选cookie\n2. cookie存储在浏览器中，容易被恶意查看，容易造成隐私的泄漏，隐私数据应该存在session中\n3. session对于大型网站，用户量十分大，储存的开销也是十分大的，只需要在sesion中保存重要信息\n\n\n## 二、DNS\n\n### 1.你知道DNS是什么？\n\nDNS是一种域名解析服务器，可以将用户发送过来的域名转化为具体的IP地址\n\n### 2.DNS的工作原理？\n\n### DNS查询方式有哪些？\n\n\n\n\n\n\n\n\n\n\n\n# 攻击方式\n\n### SYN攻击是什么？\n\n### DDos 攻击了解吗？\n\n### XSS攻击是什么？（低频）\n\n### CSRF攻击？你知道吗？\n\n### 如何防范CSRF攻击\n\n\n\n\n\n\n\n# 参考资料\n\n[计算机网络-01-20 | 阿秀的学习笔记 (interviewguide.cn)](https://interviewguide.cn/notes/03-hunting_job/02-interview/03-01-net.html#_11%E3%80%81get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B)[\n\n[面试必备：GET和POST 的区别详细解说 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1498283)\n\n[HTTP POST请求发送两个TCP包？_john-zeng的博客-CSDN博客_post 两个tcp](https://blog.csdn.net/zerooffdate/article/details/78962818)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><h2 id=\"1、OSI-的七层模型分别是？各自的功能是什么？\"><a href=\"#1、OSI-的七层模型分别是？各自的功能是什么？\" class=\"headerlink\" title=\"1、OSI 的七层模型分别是？各自的功能是什么？\"></a>1、OSI 的七层模型分别是？各自的功能是什么？</h2><table>\n<thead>\n<tr>\n<th>层数</th>\n<th align=\"left\">作用</th>\n<th>传输数据的名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>物理层</td>\n<td align=\"left\">保证有物理上的连接的传输</td>\n<td>比特流 （Bits）</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td align=\"left\"></td>\n<td>帧 （Frames）</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td align=\"left\">提供点对点的服务，可以找到对方的IP，就是找到对方主机的位置</td>\n<td>包 （Packages）</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td align=\"left\">从传递到主机变成可以传递到进程之间</td>\n<td>段 （Segments）</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td align=\"left\"></td>\n<td></td>\n</tr>\n<tr>\n<td>表示层</td>\n<td align=\"left\"></td>\n<td></td>\n</tr>\n<tr>\n<td>应用层</td>\n<td align=\"left\">在隔绝下层的通信内容后，可以制作各种的应用</td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h1><h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><h2 id=\"应用层常见协议知道多少？了解几个？\"><a href=\"#应用层常见协议知道多少？了解几个？\" class=\"headerlink\" title=\"应用层常见协议知道多少？了解几个？\"></a>应用层常见协议知道多少？了解几个？</h2><table>\n<thead>\n<tr>\n<th>应用层协议</th>\n<th>传输层</th>\n<th>端口</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP</td>\n<td>TCP</td>\n<td>80</td>\n<td>超文本传输协议</td>\n</tr>\n<tr>\n<td>FTP</td>\n<td>TCP</td>\n<td>23</td>\n<td>文件传输</td>\n</tr>\n<tr>\n<td>DNS</td>\n<td>UDP</td>\n<td>53</td>\n<td>域名服务器</td>\n</tr>\n<tr>\n<td>SMTP</td>\n<td></td>\n<td>465&#x2F;994</td>\n<td>邮件发送协议</td>\n</tr>\n<tr>\n<td>POP3</td>\n<td></td>\n<td>995</td>\n<td>邮件接收协议，邮件存到本机，删除服务器上邮件</td>\n</tr>\n<tr>\n<td>IMAP</td>\n<td></td>\n<td>993</td>\n<td>邮件接收协议，邮件存到本机，不删除服务器上邮件</td>\n</tr>\n<tr>\n<td>BitTorrent</td>\n<td>TCP&#x2F;UDP</td>\n<td></td>\n<td>P2P的文件共享协议</td>\n</tr>\n<tr>\n<td>RTSP</td>\n<td>TCP&#x2F;UDP</td>\n<td></td>\n<td>主要用于拉取视频流，用在VLC</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、HTTP\"><a href=\"#二、HTTP\" class=\"headerlink\" title=\"二、HTTP\"></a>二、HTTP</h2><h3 id=\"1-HTTP基础\"><a href=\"#1-HTTP基础\" class=\"headerlink\" title=\"1)HTTP基础\"></a>1)HTTP基础</h3><h4 id=\"1-说一下一次完整的HTTP请求过程包括哪些内容？\"><a href=\"#1-说一下一次完整的HTTP请求过程包括哪些内容？\" class=\"headerlink\" title=\"1.说一下一次完整的HTTP请求过程包括哪些内容？\"></a>1.说一下一次完整的HTTP请求过程包括哪些内容？</h4><ol>\n<li>建立客户端和服务器的连接</li>\n<li>客户端发送消息给服务器</li>\n<li>服务器给客户端发送应答消息</li>\n<li>客户端收到消息，浏览器解析，给用户呈现</li>\n</ol>\n<h4 id=\"2-HTTP长连接和短连接的区别\"><a href=\"#2-HTTP长连接和短连接的区别\" class=\"headerlink\" title=\"2.HTTP长连接和短连接的区别\"></a>2.HTTP长连接和短连接的区别</h4><p>HTTP1.0默认使用短连接，每次HTTP连接完成以后，都会自动断开，下一次连接的时候的时候又会重新建立，十分的花费时间</p>\n<p>HTTP1.1默认使用长连接，也就是<strong>持久连接</strong></p>\n<p>其中HTTP1.1报文首部中使用Connection:Keep-Alive字段，指定使用了长链接</p>\n<h4 id=\"3-HTTP请求方法你知道多少？\"><a href=\"#3-HTTP请求方法你知道多少？\" class=\"headerlink\" title=\"3.HTTP请求方法你知道多少？\"></a>3.HTTP请求方法你知道多少？</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>HTTP1.0</th>\n<th>HTTP1.1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>主要为获取和查询数据</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>发送修改请求</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>获取响应首部</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>删除资源</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>传输文件</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>OPTION</td>\n<td>查询对应的URL支持的方法</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>将请求通信回路返回给客户端</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>使用隧道协议代理进行连接</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td><del>LINK</del></td>\n<td></td>\n<td>×</td>\n<td>现在被取消了</td>\n</tr>\n<tr>\n<td><del>UNLINK</del></td>\n<td></td>\n<td>×</td>\n<td>现在被取消了</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-常见的HTTP状态码有哪些？\"><a href=\"#4-常见的HTTP状态码有哪些？\" class=\"headerlink\" title=\"4.常见的HTTP状态码有哪些？\"></a>4.常见的HTTP状态码有哪些？</h4><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>具体状态码</th>\n<th>类别</th>\n<th>原因短语</th>\n<th>常见情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td></td>\n<td></td>\n<td>请求正在处理</td>\n<td>POST的请求中转时候使用</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td></td>\n<td></td>\n<td>请求成功</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>200</td>\n<td>OK</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>204</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>206</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>3XX</td>\n<td></td>\n<td></td>\n<td>请求重定向</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>301</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>302</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>303</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>304</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>307</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>4XX</td>\n<td></td>\n<td>Client Error</td>\n<td>客户端错误</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>400</td>\n<td>Bad Request</td>\n<td>错误请求</td>\n<td>请求报文中存在语法问题</td>\n</tr>\n<tr>\n<td></td>\n<td>401</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>403</td>\n<td>Forbidden</td>\n<td>禁止访问</td>\n<td>没有访问的权限</td>\n</tr>\n<tr>\n<td></td>\n<td>404</td>\n<td>Not Found</td>\n<td>服务器上没有请求的资源</td>\n<td></td>\n</tr>\n<tr>\n<td>5XX</td>\n<td></td>\n<td>Server Error</td>\n<td>服务器错误</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>服务器本身出错</td>\n<td>对于URL请求过来，处理出现了BUG<br/>代码有bug</td>\n</tr>\n<tr>\n<td></td>\n<td>503</td>\n<td>Service Unavilable</td>\n<td>服务器正忙</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"6-HTTP请求和响应报文有哪些主要字段？\"><a href=\"#6-HTTP请求和响应报文有哪些主要字段？\" class=\"headerlink\" title=\"6.HTTP请求和响应报文有哪些主要字段？\"></a>6.HTTP请求和响应报文有哪些主要字段？</h4><p>请求报文：</p>\n<p>请求行 ： 包括请求方法，URL，协议&#x2F;版本，例如：GET HTTP&#x2F;1.1</p>\n<p>请求头部：User-Agent:</p>\n<p>请求主体：body</p>\n<p>响应报文：</p>\n<p>状态行：HTTP&#x2F;1.1 200 OK</p>\n<p>响应头部：Content-Length:200</p>\n<p>响应主体：<html></html></p>\n<h4 id=\"7-HTTPS是什么？\"><a href=\"#7-HTTPS是什么？\" class=\"headerlink\" title=\"7.HTTPS是什么？\"></a>7.HTTPS是什么？</h4><p>HTTPS不是一种新的协议，是在HTTP协议的下方通过SSL&#x2F;TLS来提供加密服务，但是HTTP+SSL依然处在应用层</p>\n<p>然后通过TCP协议将加密的信息发送给对方，从而达到，防窃听，防伪装，防篡改的目的</p>\n<h4 id=\"8-SSL是什么？\"><a href=\"#8-SSL是什么？\" class=\"headerlink\" title=\"8.SSL是什么？\"></a>8.SSL是什么？</h4><p>SSL(Secure Socket Layer，安全套接字层)</p>\n<p>TSL(Transport Layer Security，传输安全层)，前身是SSL</p>\n<h4 id=\"9-HTTPS和HTTP的区别\"><a href=\"#9-HTTPS和HTTP的区别\" class=\"headerlink\" title=\"9.HTTPS和HTTP的区别\"></a>9.HTTPS和HTTP的区别</h4><ol>\n<li>HTTP是明文传输的，数据都没有进行加密，HTTPS通过SSL&#x2F;TLS层提供了加密服务</li>\n<li>HTTP只需要在TCP三次握手后就可以建立连接，只需要交换3个数据报，但是HTTPS除了需要TCP的三次握手之外，还需要SSL握手需要9个包，建立连接的速度比HTTP慢</li>\n<li>HTTP需要到CA(证书颁发机构)申请证书，后才能使用，但是免费的证书比较少，而且需要一定的费用</li>\n<li>HTTP和HTTPS使用的连接方式不同，使用的端口也不同，HTTP在80号端口，HTTPS在443号端口</li>\n</ol>\n<h4 id=\"10-HTTP的缺点有哪些？\"><a href=\"#10-HTTP的缺点有哪些？\" class=\"headerlink\" title=\"10.HTTP的缺点有哪些？\"></a>10.HTTP的缺点有哪些？</h4><ol>\n<li>使用明文传输，传输过程没有加密，传送内容容易被<strong>窃听</strong></li>\n<li>不验证通信方的身份，通信方的身份可能遭遇<strong>伪装</strong></li>\n<li>无法验证报文完整性，加密内容容易被<strong>篡改</strong></li>\n</ol>\n<h4 id=\"11-HTTPS采用的加密方式有哪些？是对称还是非对称？\"><a href=\"#11-HTTPS采用的加密方式有哪些？是对称还是非对称？\" class=\"headerlink\" title=\"11.HTTPS采用的加密方式有哪些？是对称还是非对称？\"></a>11.HTTPS采用的加密方式有哪些？是对称还是非对称？</h4><h4 id=\"12-HTTP如何禁用缓存？如何确认缓存？\"><a href=\"#12-HTTP如何禁用缓存？如何确认缓存？\" class=\"headerlink\" title=\"12.HTTP如何禁用缓存？如何确认缓存？\"></a>12.HTTP如何禁用缓存？如何确认缓存？</h4><h4 id=\"13-URI和URL的区别\"><a href=\"#13-URI和URL的区别\" class=\"headerlink\" title=\"13.URI和URL的区别\"></a>13.URI和URL的区别</h4><p>URI：Uniform Resource Identifier，统一资源<strong>定位</strong>符</p>\n<p>URL：Uniform Resource Location，统一资源<strong>标识</strong>符</p>\n<p>URI是用来标识一个资源的，可以通过这个知道资源是什么</p>\n<p>URL是用来定位具体资源的，通过这个可以拉取到想要的资源</p>\n<h3 id=\"2-请求方法\"><a href=\"#2-请求方法\" class=\"headerlink\" title=\"2)请求方法\"></a>2)请求方法</h3><h4 id=\"1-GET-和-POST-的区别，你知道哪些？\"><a href=\"#1-GET-和-POST-的区别，你知道哪些？\" class=\"headerlink\" title=\"1.GET 和 POST 的区别，你知道哪些？\"></a>1.GET 和 POST 的区别，你知道哪些？</h4><ol>\n<li>GET传输的内容在参数中传递，POST在body中传递参数</li>\n<li>GET一般用于获取数据，POST一般用于修改数据，比如登录的场景</li>\n<li>GET提交的数据，理论上长度为2K，POST传递的数据长度，理论上没有限制</li>\n<li>GET请求会被浏览器缓存，POST一般情况下不会</li>\n<li>GET是幂等的，POST不是幂等的</li>\n</ol>\n<p>记忆：1.传参，2.作用，3.长度，4.缓存，5.幂等</p>\n<p>幂等性的意思：对服务器的请求，请求一次的结果和请求多次的结果是一样的</p>\n<p>GET查询一个数据，每次查询的结果是一样的，所以是幂等的</p>\n<p>POST生成一个新的数据，比如生成一个博客，POST请求了两次，可能会生成两个页面</p>\n<h4 id=\"2-GET-方法参数写法是固定的吗？\"><a href=\"#2-GET-方法参数写法是固定的吗？\" class=\"headerlink\" title=\"2.GET 方法参数写法是固定的吗？\"></a>2.GET 方法参数写法是固定的吗？</h4><p>一般情况下，GET请求的参数都是写在?后面，通过&amp;来连接多个参数</p>\n<p>服务器解析的过程是，获取TCP连接传输过来的数据，通过正则表达式的方法获取Header和Body，从而提取到GET请求的参数</p>\n<p>但这个参数的写法也是由客户端和服务器之间约定形成的，只要双方遵守约定的规则，都是可以解析的</p>\n<h4 id=\"3-GET-方法的长度限制是怎么回事？\"><a href=\"#3-GET-方法的长度限制是怎么回事？\" class=\"headerlink\" title=\"3.GET 方法的长度限制是怎么回事？\"></a>3.GET 方法的长度限制是怎么回事？</h4><p>GET方法理论上没有长度的限制，HTTP协议没有对Body和URL进行长度限制</p>\n<p>一般是浏览器或者服务器给GET方法添加的限制，一般为2K大小</p>\n<p>服务器限制GET方法的长度的原因：1.从性能角度考虑，处理较长的URL消耗较多的资源，2.从安全角度考虑，防止恶意构造长的URL来攻击</p>\n<h4 id=\"4-POST-方法比-GET-方法安全？\"><a href=\"#4-POST-方法比-GET-方法安全？\" class=\"headerlink\" title=\"4.POST 方法比 GET 方法安全？\"></a>4.POST 方法比 GET 方法安全？</h4><p>POST方法，传输的数据，从地址栏是不可见的，看起来比GET方法安全</p>\n<p>但是HTTP都是明文传输的，只要进行数据抓包，就能抓到POST方法中Body的内容，所以其实也是不安全的</p>\n<p>想要安全传输，还需要将HTTP改造成HTTPS</p>\n<h4 id=\"5-POST-方法会产生两个-TCP-数据包？你了解吗？\"><a href=\"#5-POST-方法会产生两个-TCP-数据包？你了解吗？\" class=\"headerlink\" title=\"5.POST 方法会产生两个 TCP 数据包？你了解吗？\"></a>5.POST 方法会产生两个 TCP 数据包？你了解吗？</h4><p>HTTP协议中没有说POST会发送两次请求</p>\n<p>是有些文章中提到使用POST会将head和body分开发送，先发送header，服务器返回100后再次发送body</p>\n<p>但是实际上发现，在大多数情况下并不是这样</p>\n<p>所以说POST产生两个TCP数据包的情况，是部分浏览器和框架的行为，不是POST的必然行为</p>\n<h4 id=\"6-GET与POST传递数据的最大长度能够达到多少呢？\"><a href=\"#6-GET与POST传递数据的最大长度能够达到多少呢？\" class=\"headerlink\" title=\"6.GET与POST传递数据的最大长度能够达到多少呢？\"></a>6.GET与POST传递数据的最大长度能够达到多少呢？</h4><p>HTTP没有对GET和POST请求，传递数据的最大长度做规范</p>\n<p>GET能传输的最大长度取决于URL的长度，一般浏览器的限制为2K，主要是服务器设计者从安全和性能的角度考虑的</p>\n<p>POST的传输长度取决于body能传输多大，一般都是要求小于MB</p>\n<h3 id=\"3-状态管理\"><a href=\"#3-状态管理\" class=\"headerlink\" title=\"3)状态管理\"></a>3)状态管理</h3><h4 id=\"1-Cookie是什么？\"><a href=\"#1-Cookie是什么？\" class=\"headerlink\" title=\"1.Cookie是什么？\"></a>1.Cookie是什么？</h4><p>由于HTTP协议是无状态的，所以在HTTP&#x2F;1.1中就引入了cookie来保存用户信息。</p>\n<p>用来解决每次刷新一次页面都需要重新登录的情况</p>\n<p>客户端向服务器发送请求后，服务器返回的消息中会携带一小段数据用于标识这个用户，之后每次客户端的请求都会带上这一小段cookie表示来自同一个用户的请求，会增加一些性能开销</p>\n<h4 id=\"2-Cookie有什么用途？用途\"><a href=\"#2-Cookie有什么用途？用途\" class=\"headerlink\" title=\"2.Cookie有什么用途？用途\"></a>2.Cookie有什么用途？用途</h4><ol>\n<li>会话状态的管理，记住用户的登录状态，购物车信息，收藏夹内容</li>\n<li>个性化设置，电商页面的话会给用户做个性化推荐</li>\n<li>浏览器行为跟踪，跟踪分析用户的行为</li>\n</ol>\n<h4 id=\"3-Session是什么？\"><a href=\"#3-Session是什么？\" class=\"headerlink\" title=\"3.Session是什么？\"></a>3.Session是什么？</h4><p>除了将用户的cookie存在本地，还可以使用session将用户信息存储在服务器</p>\n<p>sesion可以存储在服务器的文件，数据库，内存中，或者存在redis这种内存数据中，效率更高</p>\n<h4 id=\"Session-的工作原理是什么？-x2F-使用-Session-的过程是怎样的？\"><a href=\"#Session-的工作原理是什么？-x2F-使用-Session-的过程是怎样的？\" class=\"headerlink\" title=\"Session 的工作原理是什么？&#x2F;使用 Session 的过程是怎样的？\"></a>Session 的工作原理是什么？&#x2F;使用 Session 的过程是怎样的？</h4><h4 id=\"Cookies和Session区别是什么？Cookie与Session的对比\"><a href=\"#Cookies和Session区别是什么？Cookie与Session的对比\" class=\"headerlink\" title=\"Cookies和Session区别是什么？Cookie与Session的对比\"></a>Cookies和Session区别是什么？Cookie与Session的对比</h4><h4 id=\"Session和cookie应该如何去选择（适用场景）？\"><a href=\"#Session和cookie应该如何去选择（适用场景）？\" class=\"headerlink\" title=\"Session和cookie应该如何去选择（适用场景）？\"></a>Session和cookie应该如何去选择（适用场景）？</h4><ol>\n<li>cookie只能保存ASCII码值，cookie可以保存各种类型的信息，当存储的内容较复杂的时候，首选cookie</li>\n<li>cookie存储在浏览器中，容易被恶意查看，容易造成隐私的泄漏，隐私数据应该存在session中</li>\n<li>session对于大型网站，用户量十分大，储存的开销也是十分大的，只需要在sesion中保存重要信息</li>\n</ol>\n<h2 id=\"二、DNS\"><a href=\"#二、DNS\" class=\"headerlink\" title=\"二、DNS\"></a>二、DNS</h2><h3 id=\"1-你知道DNS是什么？\"><a href=\"#1-你知道DNS是什么？\" class=\"headerlink\" title=\"1.你知道DNS是什么？\"></a>1.你知道DNS是什么？</h3><p>DNS是一种域名解析服务器，可以将用户发送过来的域名转化为具体的IP地址</p>\n<h3 id=\"2-DNS的工作原理？\"><a href=\"#2-DNS的工作原理？\" class=\"headerlink\" title=\"2.DNS的工作原理？\"></a>2.DNS的工作原理？</h3><h3 id=\"DNS查询方式有哪些？\"><a href=\"#DNS查询方式有哪些？\" class=\"headerlink\" title=\"DNS查询方式有哪些？\"></a>DNS查询方式有哪些？</h3><h1 id=\"攻击方式\"><a href=\"#攻击方式\" class=\"headerlink\" title=\"攻击方式\"></a>攻击方式</h1><h3 id=\"SYN攻击是什么？\"><a href=\"#SYN攻击是什么？\" class=\"headerlink\" title=\"SYN攻击是什么？\"></a>SYN攻击是什么？</h3><h3 id=\"DDos-攻击了解吗？\"><a href=\"#DDos-攻击了解吗？\" class=\"headerlink\" title=\"DDos 攻击了解吗？\"></a>DDos 攻击了解吗？</h3><h3 id=\"XSS攻击是什么？（低频）\"><a href=\"#XSS攻击是什么？（低频）\" class=\"headerlink\" title=\"XSS攻击是什么？（低频）\"></a>XSS攻击是什么？（低频）</h3><h3 id=\"CSRF攻击？你知道吗？\"><a href=\"#CSRF攻击？你知道吗？\" class=\"headerlink\" title=\"CSRF攻击？你知道吗？\"></a>CSRF攻击？你知道吗？</h3><h3 id=\"如何防范CSRF攻击\"><a href=\"#如何防范CSRF攻击\" class=\"headerlink\" title=\"如何防范CSRF攻击\"></a>如何防范CSRF攻击</h3><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://interviewguide.cn/notes/03-hunting_job/02-interview/03-01-net.html#_11%E3%80%81get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B\">计算机网络-01-20 | 阿秀的学习笔记 (interviewguide.cn)</a>[</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1498283\">面试必备：GET和POST 的区别详细解说 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n<p><a href=\"https://blog.csdn.net/zerooffdate/article/details/78962818\">HTTP POST请求发送两个TCP包？_john-zeng的博客-CSDN博客_post 两个tcp</a></p>\n","slug":"Interview-Q&A/network_Q&A","updated":"03/11/2022","comments":true,"link":"","permalink":"http://example.com/2022/11/02/Interview-Q&A/network_Q&A/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"学习路径","date":"29/10/2022","path":"2022/10/29/Others/learn-road/","text":"[TOC] 书籍推荐C++书籍基础Essential C++C++ primer plus 进阶1C++ PrimerEffective C++More Effective C++Effective STL 进阶2STL 源码剖析深度探索 C++ 对象模型 候捷 C++：C++内存管理STL源码分析C++ STL与泛型编程高级C++11 新特性 内化功力C++ 语言的设计与演化C++ 沉思录C++ Templates和C++模版元编程C+标准库(第2版) C++网络编程linux网络编程-宋敬彬Linux高性能服务器编程-陈硕 linux书籍入门鸟哥私房菜 高级Unix网络编程（选看）UNIX环境高级编程（选看） MySQL入门mysql必知必会 进阶MySQL是怎样运行的——有个小孩子 高性能mysql——很厚 MySQL技术内幕：InnoDB存储引擎 高级MySQL排错指南 数据库索引设计与优化 Effective MySQL redis Redis设计与实现——必看 更高维度数据库系统实现 python入门Python编程，从入门到实践 进阶流畅的pythonPython Cookbook Python数据分析类利用Python进行数据分析Python数据分析实战Python数据可视化编程实战Python金融大数据分析 Python网络爬虫类从零开始学Python网络爬虫精通Python网络爬虫精通Scrapy网络爬虫Python3网络爬虫数据采集精通Python网络爬虫 核心技术、框架与项目实战自己动手写网络爬虫 机器学习类机器学习应用实验手册模式识别与机器学习 中文版 编码规范类Python 编码规范(Google) dockerdocker技术入门与实践——初级入门docker进阶与实战——初级介绍不多，讲了很多例子Docker源码分析自己动手写docker——高难度","raw":"---\ntitle: 学习路径\ndate: 2022-10-29 15:08:31\ntags:\n- 其他\n---\n\n[TOC]\n\n\n# 书籍推荐\n\n\n# C++书籍\n## 基础\nEssential C++\nC++ primer plus\n\n## 进阶1\nC++ Primer\nEffective C++\nMore Effective C++\nEffective STL\n\n## 进阶2\nSTL 源码剖析\n深度探索 C++ 对象模型\n\n候捷 C++：\nC++内存管理\nSTL源码分析\nC++ STL与泛型编程高级\nC++11 新特性\n\n\n## 内化功力\nC++ 语言的设计与演化\nC++ 沉思录\nC++ Templates和C++模版元编程\nC+标准库(第2版)\n\n\n# C++网络编程\nlinux网络编程-宋敬彬\nLinux高性能服务器编程-陈硕\n\n# linux书籍\n## 入门\n鸟哥私房菜\n\n\n## 高级\nUnix网络编程（选看）\nUNIX环境高级编程（选看）\n\n\n\n# MySQL\n\n## 入门\n    mysql必知必会\n\n## 进阶\n    MySQL是怎样运行的——有个小孩子\n    高性能mysql——很厚\n    MySQL技术内幕：InnoDB存储引擎\n\n## 高级\n    MySQL排错指南\n    数据库索引设计与优化\n    Effective MySQL\n\n## redis\n        Redis设计与实现——必看\n\n## 更高维度\n    数据库系统实现\n\n\n\n# python\n## 入门\nPython编程，从入门到实践\n\n## 进阶\n流畅的python\nPython Cookbook\n\n## Python数据分析类\n利用Python进行数据分析\nPython数据分析实战\nPython数据可视化编程实战\nPython金融大数据分析\n\n## Python网络爬虫类\n从零开始学Python网络爬虫\n精通Python网络爬虫\n精通Scrapy网络爬虫\nPython3网络爬虫数据采集\n精通Python网络爬虫 核心技术、框架与项目实战\n自己动手写网络爬虫\n\n## 机器学习类\n机器学习应用实验手册\n模式识别与机器学习 中文版\n\n## 编码规范类\nPython 编码规范(Google)\n\n\n# docker\ndocker技术入门与实践——初级入门\ndocker进阶与实战——初级介绍不多，讲了很多例子\nDocker源码分析\n自己动手写docker——高难度\n\n","content":"<p>[TOC]</p>\n<h1 id=\"书籍推荐\"><a href=\"#书籍推荐\" class=\"headerlink\" title=\"书籍推荐\"></a>书籍推荐</h1><h1 id=\"C-书籍\"><a href=\"#C-书籍\" class=\"headerlink\" title=\"C++书籍\"></a>C++书籍</h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>Essential C++<br>C++ primer plus</p>\n<h2 id=\"进阶1\"><a href=\"#进阶1\" class=\"headerlink\" title=\"进阶1\"></a>进阶1</h2><p>C++ Primer<br>Effective C++<br>More Effective C++<br>Effective STL</p>\n<h2 id=\"进阶2\"><a href=\"#进阶2\" class=\"headerlink\" title=\"进阶2\"></a>进阶2</h2><p>STL 源码剖析<br>深度探索 C++ 对象模型</p>\n<p>候捷 C++：<br>C++内存管理<br>STL源码分析<br>C++ STL与泛型编程高级<br>C++11 新特性</p>\n<h2 id=\"内化功力\"><a href=\"#内化功力\" class=\"headerlink\" title=\"内化功力\"></a>内化功力</h2><p>C++ 语言的设计与演化<br>C++ 沉思录<br>C++ Templates和C++模版元编程<br>C+标准库(第2版)</p>\n<h1 id=\"C-网络编程\"><a href=\"#C-网络编程\" class=\"headerlink\" title=\"C++网络编程\"></a>C++网络编程</h1><p>linux网络编程-宋敬彬<br>Linux高性能服务器编程-陈硕</p>\n<h1 id=\"linux书籍\"><a href=\"#linux书籍\" class=\"headerlink\" title=\"linux书籍\"></a>linux书籍</h1><h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>鸟哥私房菜</p>\n<h2 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h2><p>Unix网络编程（选看）<br>UNIX环境高级编程（选看）</p>\n<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"入门-1\"><a href=\"#入门-1\" class=\"headerlink\" title=\"入门\"></a>入门</h2><pre><code>mysql必知必会\n</code></pre>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><pre><code>MySQL是怎样运行的——有个小孩子\n高性能mysql——很厚\nMySQL技术内幕：InnoDB存储引擎\n</code></pre>\n<h2 id=\"高级-1\"><a href=\"#高级-1\" class=\"headerlink\" title=\"高级\"></a>高级</h2><pre><code>MySQL排错指南\n数据库索引设计与优化\nEffective MySQL\n</code></pre>\n<h2 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h2><pre><code>    Redis设计与实现——必看\n</code></pre>\n<h2 id=\"更高维度\"><a href=\"#更高维度\" class=\"headerlink\" title=\"更高维度\"></a>更高维度</h2><pre><code>数据库系统实现\n</code></pre>\n<h1 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h1><h2 id=\"入门-2\"><a href=\"#入门-2\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>Python编程，从入门到实践</p>\n<h2 id=\"进阶-1\"><a href=\"#进阶-1\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>流畅的python<br>Python Cookbook</p>\n<h2 id=\"Python数据分析类\"><a href=\"#Python数据分析类\" class=\"headerlink\" title=\"Python数据分析类\"></a>Python数据分析类</h2><p>利用Python进行数据分析<br>Python数据分析实战<br>Python数据可视化编程实战<br>Python金融大数据分析</p>\n<h2 id=\"Python网络爬虫类\"><a href=\"#Python网络爬虫类\" class=\"headerlink\" title=\"Python网络爬虫类\"></a>Python网络爬虫类</h2><p>从零开始学Python网络爬虫<br>精通Python网络爬虫<br>精通Scrapy网络爬虫<br>Python3网络爬虫数据采集<br>精通Python网络爬虫 核心技术、框架与项目实战<br>自己动手写网络爬虫</p>\n<h2 id=\"机器学习类\"><a href=\"#机器学习类\" class=\"headerlink\" title=\"机器学习类\"></a>机器学习类</h2><p>机器学习应用实验手册<br>模式识别与机器学习 中文版</p>\n<h2 id=\"编码规范类\"><a href=\"#编码规范类\" class=\"headerlink\" title=\"编码规范类\"></a>编码规范类</h2><p>Python 编码规范(Google)</p>\n<h1 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h1><p>docker技术入门与实践——初级入门<br>docker进阶与实战——初级介绍不多，讲了很多例子<br>Docker源码分析<br>自己动手写docker——高难度</p>\n","slug":"Others/learn-road","updated":"08/01/2023","comments":true,"link":"","permalink":"http://example.com/2022/10/29/Others/learn-road/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"github 教程","date":"29/10/2022","path":"2022/10/29/Tutorial/github-tutorial/","text":"如何将自己的代码传到github上 步骤一：注册账号https://github.com/ 步骤二：下载Githttps://git-scm.com/downloads 步骤三：生成ssh秘钥git config –global user.name “XXX”git config –global user.email “XXX” 1.生成公钥：git命令：ssh-keygen -m [密钥格式] -t [密钥类型] -C[密钥注解] 123ssh-keygen -m PEM -t ed25519 -C &quot;your.email@example.com&quot; // 创建新的 SSH 私钥与公钥秘钥对，输入你的邮箱作为标签Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 推荐使用默认地址Enter passphrase (empty for no passphrase): // 此处直接回车即可；若设置密码，则每次使用 SSH 方式推送代码时都会要求输入密码 2.添加公钥windows地址为（C:\\Users\\you.ssh\\id_ed25519.pub）linux地址为（&#x2F;home&#x2F;user&#x2F;.ssh&#x2F;id_ed25519）linux地址为（&#x2F;root&#x2F;.ssh&#x2F;id_ed25519）打开上文中生成的秘钥对的地址（默认地址通常为 ~&#x2F;.ssh&#x2F;）找到后缀为 pub 的公钥文件，使用 cat 命令输出所有内容并复制。 3.尝试使用ssh连接githubssh -T &#103;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#109; 4.在github中添加秘钥1.右上角点击自己的头像2.setting3.SSH and GPG keys4.New SSH keys 步骤四：github上创建仓库步骤五：将仓库下载到本地git clone [ssh地址] 步骤六：上传代码git add acm.cppgit add . git commit -m “init” git push 参考资料[如何把自己的代码上传到github上]https://blog.csdn.net/qq_43111389/article/details/125644132","raw":"---\ntitle: github 教程\ndate: 2022-10-29 13:40:28\ntags:\n---\n\n如何将自己的代码传到github上\n# 步骤一：注册账号\nhttps://github.com/\n\n\n# 步骤二：下载Git\nhttps://git-scm.com/downloads\n\n\n# 步骤三：生成ssh秘钥\ngit config --global user.name \"XXX\"\ngit config --global user.email \"XXX\"\n## 1.生成公钥：\ngit命令：ssh-keygen  -m [密钥格式]  -t [密钥类型]  -C[密钥注解] \n```\nssh-keygen -m PEM -t ed25519 -C \"your.email@example.com\" // 创建新的 SSH 私钥与公钥秘钥对，输入你的邮箱作为标签\nEnter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 推荐使用默认地址\nEnter passphrase (empty for no passphrase): // 此处直接回车即可；若设置密码，则每次使用 SSH 方式推送代码时都会要求输入密码\n```\n## 2.添加公钥\nwindows地址为（C:\\Users\\you\\.ssh\\id_ed25519.pub）\nlinux地址为（/home/user/.ssh/id_ed25519）\nlinux地址为（/root/.ssh/id_ed25519）\n打开上文中生成的秘钥对的地址（默认地址通常为 ~/.ssh/）找到后缀为 pub 的公钥文件，使用 cat 命令输出所有内容并复制。\n\n## 3.尝试使用ssh连接github\nssh -T git@github.com\n\n\n## 4.在github中添加秘钥\n1.右上角点击自己的头像\n2.setting\n3.SSH and GPG keys\n4.New SSH keys  \n\n\n\n# 步骤四：github上创建仓库\n\n\n\n# 步骤五：将仓库下载到本地\ngit clone [ssh地址]\n\n\n\n# 步骤六：上传代码\ngit add acm.cpp\ngit add .\n\n\ngit commit -m \"init\"\n\n\ngit push\n\n\n\n# 参考资料\n\n[如何把自己的代码上传到github上]https://blog.csdn.net/qq_43111389/article/details/125644132\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>如何将自己的代码传到github上</p>\n<h1 id=\"步骤一：注册账号\"><a href=\"#步骤一：注册账号\" class=\"headerlink\" title=\"步骤一：注册账号\"></a>步骤一：注册账号</h1><p><a href=\"https://github.com/\">https://github.com/</a></p>\n<h1 id=\"步骤二：下载Git\"><a href=\"#步骤二：下载Git\" class=\"headerlink\" title=\"步骤二：下载Git\"></a>步骤二：下载Git</h1><p><a href=\"https://git-scm.com/downloads\">https://git-scm.com/downloads</a></p>\n<h1 id=\"步骤三：生成ssh秘钥\"><a href=\"#步骤三：生成ssh秘钥\" class=\"headerlink\" title=\"步骤三：生成ssh秘钥\"></a>步骤三：生成ssh秘钥</h1><p>git config –global user.name “XXX”<br>git config –global user.email “XXX”</p>\n<h2 id=\"1-生成公钥：\"><a href=\"#1-生成公钥：\" class=\"headerlink\" title=\"1.生成公钥：\"></a>1.生成公钥：</h2><p>git命令：ssh-keygen  -m [密钥格式]  -t [密钥类型]  -C[密钥注解] </p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -m PEM -t ed25519 -C <span class=\"string\">&quot;your.email@example.com&quot;</span> <span class=\"regexp\">//</span> 创建新的 SSH 私钥与公钥秘钥对，输入你的邮箱作为标签</span><br><span class=\"line\">Enter file <span class=\"keyword\">in</span> which to save the key (<span class=\"regexp\">/Users/y</span>ou<span class=\"regexp\">/.ssh/i</span>d_rsa): [Press enter] <span class=\"regexp\">//</span> 推荐使用默认地址</span><br><span class=\"line\">Enter passphrase (empty <span class=\"keyword\">for</span> no passphrase): <span class=\"regexp\">//</span> 此处直接回车即可；若设置密码，则每次使用 SSH 方式推送代码时都会要求输入密码</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-添加公钥\"><a href=\"#2-添加公钥\" class=\"headerlink\" title=\"2.添加公钥\"></a>2.添加公钥</h2><p>windows地址为（C:\\Users\\you.ssh\\id_ed25519.pub）<br>linux地址为（&#x2F;home&#x2F;user&#x2F;.ssh&#x2F;id_ed25519）<br>linux地址为（&#x2F;root&#x2F;.ssh&#x2F;id_ed25519）<br>打开上文中生成的秘钥对的地址（默认地址通常为 ~&#x2F;.ssh&#x2F;）找到后缀为 pub 的公钥文件，使用 cat 命令输出所有内容并复制。</p>\n<h2 id=\"3-尝试使用ssh连接github\"><a href=\"#3-尝试使用ssh连接github\" class=\"headerlink\" title=\"3.尝试使用ssh连接github\"></a>3.尝试使用ssh连接github</h2><p>ssh -T <a href=\"mailto:&#103;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;\">&#103;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a></p>\n<h2 id=\"4-在github中添加秘钥\"><a href=\"#4-在github中添加秘钥\" class=\"headerlink\" title=\"4.在github中添加秘钥\"></a>4.在github中添加秘钥</h2><p>1.右上角点击自己的头像<br>2.setting<br>3.SSH and GPG keys<br>4.New SSH keys  </p>\n<h1 id=\"步骤四：github上创建仓库\"><a href=\"#步骤四：github上创建仓库\" class=\"headerlink\" title=\"步骤四：github上创建仓库\"></a>步骤四：github上创建仓库</h1><h1 id=\"步骤五：将仓库下载到本地\"><a href=\"#步骤五：将仓库下载到本地\" class=\"headerlink\" title=\"步骤五：将仓库下载到本地\"></a>步骤五：将仓库下载到本地</h1><p>git clone [ssh地址]</p>\n<h1 id=\"步骤六：上传代码\"><a href=\"#步骤六：上传代码\" class=\"headerlink\" title=\"步骤六：上传代码\"></a>步骤六：上传代码</h1><p>git add acm.cpp<br>git add .</p>\n<p>git commit -m “init”</p>\n<p>git push</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[如何把自己的代码上传到github上]<a href=\"https://blog.csdn.net/qq_43111389/article/details/125644132\">https://blog.csdn.net/qq_43111389/article/details/125644132</a></p>\n","slug":"Tutorial/github-tutorial","updated":"29/10/2022","comments":true,"link":"","permalink":"http://example.com/2022/10/29/Tutorial/github-tutorial/","excerpt":"","categories":[],"tags":[]},{"title":"mysql 教程","date":"27/10/2022","path":"2022/10/27/Tutorial/mysql-tutorial/","text":"show global variables like ‘port’; service mysql restart cat &#x2F;etc&#x2F;mysql&#x2F;debian.cnf mysql -udebian-sys-maint -pCljM3ZnVZ3n3sycv mysql -uroot -p123456 select User,Host from user; select user, plugin from mysql.user; select host,user from mysql.user; SELECT host,user,authentication_string FROM mysql.user; update mysql.user set authentication_string&#x3D;’’ where user&#x3D;’root’;UPDATE mysql.user SET authentication_string&#x3D;md5(‘123456’) WHERE User&#x3D;’root’ AND Host &#x3D;’localhost’;UPDATE mysql.user SET authentication_string&#x3D;sha1(‘123456’) WHERE User&#x3D;’root’ AND Host &#x3D;’localhost’;UPDATE mysql.user SET authentication_string&#x3D;’123’ WHERE User&#x3D;’root’ AND Host &#x3D;’localhost’;update mysql.user set authentication_string&#x3D;password(‘root’) where User&#x3D;’root’; update user set host&#x3D;’%’ where user&#x3D;’debian-sys-maint’; alter user‘root‘@’localhost’ identified by ‘123’; ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘12345’; ALTER USER ‘mysql.sys‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘123’; flush privileges; mysqld –console –skip-grant-tables –shared-memory； vi &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf dpkg –configure -a dpkg –list|grep mysql https://cloud.tencent.com/developer/article/1165127 [Ubuntu20.04 安装和卸载MySQL8]https://www.cnblogs.com/zhangxuel1ang/p/13456116.html","raw":"---\ntitle: mysql 教程\ndate: 2022-10-27 19:12:48\ntags:\n---\n\nshow global variables like 'port';\n\nservice mysql restart\n\ncat /etc/mysql/debian.cnf\n\nmysql -udebian-sys-maint -pCljM3ZnVZ3n3sycv\n\nmysql -uroot -p123456\n\n\nselect User,Host from user;\n\n\n\nselect user, plugin from mysql.user;\n\nselect host,user from mysql.user;\n\nSELECT host,user,authentication_string FROM mysql.user;\n\n\nupdate mysql.user set authentication_string='' where user='root';\nUPDATE mysql.user SET authentication_string=md5('123456') WHERE User='root'  AND Host ='localhost';\nUPDATE mysql.user SET authentication_string=sha1('123456') WHERE User='root'  AND Host ='localhost';\nUPDATE mysql.user SET authentication_string='123' WHERE User='root'  AND Host ='localhost';\nupdate mysql.user set authentication_string=password('root') where User='root';\n\nupdate user set host='%' where user='debian-sys-maint';\n\nalter user'root'@'localhost' identified by '123';\n\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '12345';\n\n\nALTER USER 'mysql.sys'@'localhost' IDENTIFIED WITH mysql_native_password BY '123';\n\n\nflush privileges;\n\n\n\nmysqld --console --skip-grant-tables --shared-memory；\n\n\n vi /etc/mysql/mysql.conf.d/mysqld.cnf\n\ndpkg --configure -a\n\n\n\n\ndpkg --list|grep mysql\n\n\n\n\nhttps://cloud.tencent.com/developer/article/1165127\n\n[Ubuntu20.04 安装和卸载MySQL8]https://www.cnblogs.com/zhangxuel1ang/p/13456116.html\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>show global variables like ‘port’;</p>\n<p>service mysql restart</p>\n<p>cat &#x2F;etc&#x2F;mysql&#x2F;debian.cnf</p>\n<p>mysql -udebian-sys-maint -pCljM3ZnVZ3n3sycv</p>\n<p>mysql -uroot -p123456</p>\n<p>select User,Host from user;</p>\n<p>select user, plugin from mysql.user;</p>\n<p>select host,user from mysql.user;</p>\n<p>SELECT host,user,authentication_string FROM mysql.user;</p>\n<p>update mysql.user set authentication_string&#x3D;’’ where user&#x3D;’root’;<br>UPDATE mysql.user SET authentication_string&#x3D;md5(‘123456’) WHERE User&#x3D;’root’  AND Host &#x3D;’localhost’;<br>UPDATE mysql.user SET authentication_string&#x3D;sha1(‘123456’) WHERE User&#x3D;’root’  AND Host &#x3D;’localhost’;<br>UPDATE mysql.user SET authentication_string&#x3D;’123’ WHERE User&#x3D;’root’  AND Host &#x3D;’localhost’;<br>update mysql.user set authentication_string&#x3D;password(‘root’) where User&#x3D;’root’;</p>\n<p>update user set host&#x3D;’%’ where user&#x3D;’debian-sys-maint’;</p>\n<p>alter user‘root‘@’localhost’ identified by ‘123’;</p>\n<p>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘12345’;</p>\n<p>ALTER USER ‘mysql.sys‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘123’;</p>\n<p>flush privileges;</p>\n<p>mysqld –console –skip-grant-tables –shared-memory；</p>\n<p> vi &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p>\n<p>dpkg –configure -a</p>\n<p>dpkg –list|grep mysql</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1165127\">https://cloud.tencent.com/developer/article/1165127</a></p>\n<p>[Ubuntu20.04 安装和卸载MySQL8]<a href=\"https://www.cnblogs.com/zhangxuel1ang/p/13456116.html\">https://www.cnblogs.com/zhangxuel1ang/p/13456116.html</a></p>\n","slug":"Tutorial/mysql-tutorial","updated":"27/10/2022","comments":true,"link":"","permalink":"http://example.com/2022/10/27/Tutorial/mysql-tutorial/","excerpt":"","categories":[],"tags":[]},{"title":"计算机网络","date":"20/10/2022","path":"2022/10/20/Course/Base/Computer_Network/","text":"1.2网络边缘1.2.1服务模式C&#x2F;S模式可扩展性较差P2P模式迅雷、电驴 1.2.2服务模式1.2.2.1面向连接的服务TCP 可靠的、按顺序的传送数据 流量控制 拥塞控制 1.2.2.2面向无连接的服务UDP 无连接 不可靠数据传输 无流量控制 无拥塞控制 1.3网络核心1.3.1电路交换1.3.1.2概述 独享资源：不同享 每个呼叫一旦建立起来就能够保证性能 如果呼叫没有数据发送，被分配的资源就会被浪费 (no sharing) 通常被传统电话网络采用 1.3.1.2分类 频分(Frequencydivision multiplexing) 时分(Time-division multiplexing) 波分(Wave-division multiplexing) 1.3.1.3缺点 连接建立时间长 计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多 即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用 可靠性不高？ 1.3.2分组交换1.3.2.1概述适合于对突发式数据传输资源共享 简单，不必建立呼叫过度使用会造成网络拥塞：分组延时和丢失 对可靠地数据传输需要协议来约束：拥塞控制Q: 怎样提供类似电路交换的服务？ 保证音频&#x2F;视频应用需要的带宽 一个仍未解决的问题(chapter 7) 1.3.2.2分类数据报 分组的目标地址决定下一跳 在不同的阶段，路由可以改变 在通信之前,无须建立起一个连接,有数据就传输 每一个分组都独立路由(路径不一样,可能会失序)虚电路 每个分组都带标签（虚电路标识 VC ID），标签决定下一跳 在呼叫建立时决定路径，在整个呼叫中路径保持不变 路由器维持每个呼叫的状态信息 X.25 和ATM","raw":"---\ntitle: 计算机网络\ndate: 2022-10-20 20:14:20\ntags:\n---\n\n\n## 1.2网络边缘\n\n\n### 1.2.1服务模式\nC/S模式\n可扩展性较差\nP2P模式\n迅雷、电驴\n\n\n\n### 1.2.2服务模式\n\n\n#### 1.2.2.1面向连接的服务\nTCP\n- 可靠的、按顺序的传送数据\n- 流量控制\n- 拥塞控制\n\n#### 1.2.2.2面向无连接的服务\nUDP \n- 无连接\n- 不可靠数据传输\n- 无流量控制\n- 无拥塞控制\n\n\n\n\n\n## 1.3网络核心\n\n### 1.3.1电路交换\n#### 1.3.1.2概述\n- 独享资源：不同享\n- 每个呼叫一旦建立起来就能够\n保证性能\n- 如果呼叫没有数据发送，被分配的资源就会被浪费 (no sharing)\n- 通常被传统电话网络采用\n#### 1.3.1.2分类\n- 频分(Frequencydivision multiplexing)\n- 时分(Time-division multiplexing)\n- 波分(Wave-division multiplexing)\n#### 1.3.1.3缺点\n- 连接建立时间长\n- 计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多\n- 即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用\n- 可靠性不高？\n\n### 1.3.2分组交换\n#### 1.3.2.1概述\n适合于对突发式数据传输\n资源共享\n- 简单，不必建立呼叫\n过度使用会造成网络拥塞：分组延时和丢失\n- 对可靠地数据传输需要协议来约束：拥塞控制\nQ: 怎样提供类似电路交换的服务？\n- 保证音频/视频应用需要的带宽\n- 一个仍未解决的问题(chapter 7)\n#### 1.3.2.2分类\n数据报\n- 分组的目标地址决定下一跳\n- 在不同的阶段，路由可以改变\n- 在通信之前,无须建立起一个连接,有数据就传输\n- 每一个分组都独立路由(路径不一样,可能会失序)\n虚电路\n- 每个分组都带标签（虚电路标识 VC ID），标签决定下一跳\n- 在呼叫建立时决定路径，在整个呼叫中路径保持不变\n- 路由器维持每个呼叫的状态信息\n- X.25 和ATM\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h2 id=\"1-2网络边缘\"><a href=\"#1-2网络边缘\" class=\"headerlink\" title=\"1.2网络边缘\"></a>1.2网络边缘</h2><h3 id=\"1-2-1服务模式\"><a href=\"#1-2-1服务模式\" class=\"headerlink\" title=\"1.2.1服务模式\"></a>1.2.1服务模式</h3><p>C&#x2F;S模式<br>可扩展性较差<br>P2P模式<br>迅雷、电驴</p>\n<h3 id=\"1-2-2服务模式\"><a href=\"#1-2-2服务模式\" class=\"headerlink\" title=\"1.2.2服务模式\"></a>1.2.2服务模式</h3><h4 id=\"1-2-2-1面向连接的服务\"><a href=\"#1-2-2-1面向连接的服务\" class=\"headerlink\" title=\"1.2.2.1面向连接的服务\"></a>1.2.2.1面向连接的服务</h4><p>TCP</p>\n<ul>\n<li>可靠的、按顺序的传送数据</li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n</ul>\n<h4 id=\"1-2-2-2面向无连接的服务\"><a href=\"#1-2-2-2面向无连接的服务\" class=\"headerlink\" title=\"1.2.2.2面向无连接的服务\"></a>1.2.2.2面向无连接的服务</h4><p>UDP </p>\n<ul>\n<li>无连接</li>\n<li>不可靠数据传输</li>\n<li>无流量控制</li>\n<li>无拥塞控制</li>\n</ul>\n<h2 id=\"1-3网络核心\"><a href=\"#1-3网络核心\" class=\"headerlink\" title=\"1.3网络核心\"></a>1.3网络核心</h2><h3 id=\"1-3-1电路交换\"><a href=\"#1-3-1电路交换\" class=\"headerlink\" title=\"1.3.1电路交换\"></a>1.3.1电路交换</h3><h4 id=\"1-3-1-2概述\"><a href=\"#1-3-1-2概述\" class=\"headerlink\" title=\"1.3.1.2概述\"></a>1.3.1.2概述</h4><ul>\n<li>独享资源：不同享</li>\n<li>每个呼叫一旦建立起来就能够<br>保证性能</li>\n<li>如果呼叫没有数据发送，被分配的资源就会被浪费 (no sharing)</li>\n<li>通常被传统电话网络采用</li>\n</ul>\n<h4 id=\"1-3-1-2分类\"><a href=\"#1-3-1-2分类\" class=\"headerlink\" title=\"1.3.1.2分类\"></a>1.3.1.2分类</h4><ul>\n<li>频分(Frequencydivision multiplexing)</li>\n<li>时分(Time-division multiplexing)</li>\n<li>波分(Wave-division multiplexing)</li>\n</ul>\n<h4 id=\"1-3-1-3缺点\"><a href=\"#1-3-1-3缺点\" class=\"headerlink\" title=\"1.3.1.3缺点\"></a>1.3.1.3缺点</h4><ul>\n<li>连接建立时间长</li>\n<li>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多</li>\n<li>即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用</li>\n<li>可靠性不高？</li>\n</ul>\n<h3 id=\"1-3-2分组交换\"><a href=\"#1-3-2分组交换\" class=\"headerlink\" title=\"1.3.2分组交换\"></a>1.3.2分组交换</h3><h4 id=\"1-3-2-1概述\"><a href=\"#1-3-2-1概述\" class=\"headerlink\" title=\"1.3.2.1概述\"></a>1.3.2.1概述</h4><p>适合于对突发式数据传输<br>资源共享</p>\n<ul>\n<li>简单，不必建立呼叫<br>过度使用会造成网络拥塞：分组延时和丢失</li>\n<li>对可靠地数据传输需要协议来约束：拥塞控制<br>Q: 怎样提供类似电路交换的服务？</li>\n<li>保证音频&#x2F;视频应用需要的带宽</li>\n<li>一个仍未解决的问题(chapter 7)</li>\n</ul>\n<h4 id=\"1-3-2-2分类\"><a href=\"#1-3-2-2分类\" class=\"headerlink\" title=\"1.3.2.2分类\"></a>1.3.2.2分类</h4><p>数据报</p>\n<ul>\n<li>分组的目标地址决定下一跳</li>\n<li>在不同的阶段，路由可以改变</li>\n<li>在通信之前,无须建立起一个连接,有数据就传输</li>\n<li>每一个分组都独立路由(路径不一样,可能会失序)<br>虚电路</li>\n<li>每个分组都带标签（虚电路标识 VC ID），标签决定下一跳</li>\n<li>在呼叫建立时决定路径，在整个呼叫中路径保持不变</li>\n<li>路由器维持每个呼叫的状态信息</li>\n<li>X.25 和ATM</li>\n</ul>\n","slug":"Course/Base/Computer_Network","updated":"21/10/2022","comments":true,"link":"","permalink":"http://example.com/2022/10/20/Course/Base/Computer_Network/","excerpt":"","categories":[],"tags":[]},{"title":"语义分割","date":"11/10/2022","path":"2022/10/11/Course/ML/Semantic_segmentation/","text":"语义分割(semantic segmentation)FCN实例分割( Instance segmentation)Mask R-CNN全景分割(Panoramic segmentation) Panoptic FPN 3-13采集数据的注意点 不要迎着光拍摄 最好有云台支持 需要增加人站着的识别 人不要太近 要考虑拍照的时间，白天还是下午，看起来最好是早上，阴天 需要考虑照相机摆放的位置 3-22采集数据的注意点 可以拍摄不同角度的，比如竖着的也拍摄一点 3.15下次拍照需要注意的： 脏数据的影响 标注中出现的问题训练的时候，IoU出现了Nan 学习率过大或过小：学习率过大会导致模型参数更新过快，模型无法收敛或者在训练过程中出现梯度爆炸、梯度消失等问题；学习率过小则可能导致模型收敛缓慢或者无法收敛，从而导致 IoU 变成 NaN。 数据集中出现空白区域：如果数据集中存在一些空白区域（即标注中的像素值全部为 0），那么计算 IoU 的时候可能会出现分母为 0 的情况，从而导致 IoU 变成 NaN。 模型架构或训练方式问题：如果模型架构设计不合理或者训练方式不当，可能会导致训练过程中出现梯度爆炸、梯度消失等问题，从而导致 IoU 变成 NaN。 数据集标注问题：数据集标注问题也可能导致 IoU 变成 NaN。比如，在数据集标注过程中出现了错误的标注，可能导致 IoU 计算错误。 出现了脏数据 语义分割评价指标混淆矩阵TP（True Positive）：真正例，模型预测为正例，实际是正例（模型预测为类别1，实际是类别1）FP（False Positive）：假正例，模型预测为正例，实际是反例 （模型预测为类别1，实际是类别2）FN（False Negative）：假反例，模型预测为反例，实际是正例 （模型预测为类别2，实际是类别1）TN（True Negative）：真反例，模型预测为反例，实际是反例 （模型预测为类别2，实际是类别2） 交并比（Intersection over Union，IoU）含义：模型对某一类别预测结果和真实值的交集与并集的比值 平均交并比（Mean Intersection over Union，MIoU）含义：模型对每一类预测的结果和真实值的交集与并集的比值，求和再平均的结果只有一个数值，对于每个类的IoU取平均 参考资料[机器学习开篇之机器学习的分类]https://blog.csdn.net/Lion_Dreams/article/details/125269215[计算机视觉 - 语义分割 （semantic segmentation）]https://blog.csdn.net/baidu_41617231/article/details/107739897[机器学习：mAP评价指标]https://blog.csdn.net/qq_40765537/article/details/106394103[PASCAL VOC2012数据集介绍]https://blog.csdn.net/qq_37541097/article/details/115787033[损失函数（loss function）]https://blog.csdn.net/EmilyHoward/article/details/118367495[标注工具的使用]https://www.bilibili.com/video/BV1ev411P7dR/?spm_id_from=333.999.0.0&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca[Labelme工具对应博文]https://blog.csdn.net/qq_37541097/article/details/120162702[安装labelme教程]https://blog.csdn.net/weixin_43427721/article/details/107122775[EISeg工具对应博文]https://blog.csdn.net/qq_37541097/article/details/120154543[batch size设置技巧]https://blog.csdn.net/zqx951102/article/details/88918948[Azure Kinect DK 深度相机]https://blog.csdn.net/denkywu/article/details/103177559【语义分割】评价指标：PA、CPA、MPA、IoU、MIoU详细总结和代码实现ADE20K 图像标定张正友标定法-完整学习笔记-从原理到实战生成标定纸","raw":"---\ntitle: 语义分割\ndate: 2022-10-11 16:16:20\ntags:\n- 课程\n---\n\n\n\n语义分割(semantic segmentation)FCN\n实例分割( Instance segmentation)Mask R-CNN\n全景分割(Panoramic segmentation) Panoptic FPN\n\n# 3-13采集数据的注意点\n1. 不要迎着光拍摄\n2. 最好有云台支持\n<!-- 3. 采集的图片，虽然分文件夹，但是文件名还是得处理，不然重名了 -->\n4. 需要增加人站着的识别\n   1. 人不要太近\n   2. \n5. 要考虑拍照的时间，白天还是下午，看起来最好是早上，阴天\n6. 需要考虑照相机摆放的位置\n\n\n# 3-22采集数据的注意点\n1. 可以拍摄不同角度的，比如竖着的也拍摄一点\n\n\n\n3.15下次拍照需要注意的：\n\n\n脏数据的影响\n\n# 标注中出现的问题\n训练的时候，IoU出现了Nan\n1. 学习率过大或过小：学习率过大会导致模型参数更新过快，模型无法收敛或者在训练过程中出现梯度爆炸、梯度消失等问题；学习率过小则可能导致模型收敛缓慢或者无法收敛，从而导致 IoU 变成 NaN。\n2. 数据集中出现空白区域：如果数据集中存在一些空白区域（即标注中的像素值全部为 0），那么计算 IoU 的时候可能会出现分母为 0 的情况，从而导致 IoU 变成 NaN。\n3. 模型架构或训练方式问题：如果模型架构设计不合理或者训练方式不当，可能会导致训练过程中出现梯度爆炸、梯度消失等问题，从而导致 IoU 变成 NaN。\n4. 数据集标注问题：数据集标注问题也可能导致 IoU 变成 NaN。比如，在数据集标注过程中出现了错误的标注，可能导致 IoU 计算错误。\n\n出现了脏数据\n\n\n\n\n# 语义分割评价指标\n\n## 混淆矩阵\n\nTP（True Positive）：真正例，模型预测为正例，实际是正例（模型预测为类别1，实际是类别1）\nFP（False Positive）：假正例，模型预测为正例，实际是反例 （模型预测为类别1，实际是类别2）\nFN（False Negative）：假反例，模型预测为反例，实际是正例 （模型预测为类别2，实际是类别1）\nTN（True Negative）：真反例，模型预测为反例，实际是反例 （模型预测为类别2，实际是类别2）\n\n## 交并比（Intersection over Union，IoU）\n含义：模型对某一类别预测结果和真实值的交集与并集的比值\n\n## 平均交并比（Mean Intersection over Union，MIoU）\n含义：模型对每一类预测的结果和真实值的交集与并集的比值，求和再平均的结果\n只有一个数值，对于每个类的IoU取平均\n\n\n\n\n\n# 参考资料\n[机器学习开篇之机器学习的分类]https://blog.csdn.net/Lion_Dreams/article/details/125269215\n[计算机视觉 - 语义分割 （semantic segmentation）]https://blog.csdn.net/baidu_41617231/article/details/107739897\n[机器学习：mAP评价指标]https://blog.csdn.net/qq_40765537/article/details/106394103\n[PASCAL VOC2012数据集介绍]https://blog.csdn.net/qq_37541097/article/details/115787033\n[损失函数（loss function）]https://blog.csdn.net/EmilyHoward/article/details/118367495\n[标注工具的使用]https://www.bilibili.com/video/BV1ev411P7dR/?spm_id_from=333.999.0.0&vd_source=76dff3ae3b42b00d067c0921bf6859ca\n[Labelme工具对应博文]https://blog.csdn.net/qq_37541097/article/details/120162702\n[安装labelme教程]https://blog.csdn.net/weixin_43427721/article/details/107122775\n[EISeg工具对应博文]https://blog.csdn.net/qq_37541097/article/details/120154543\n[batch size设置技巧]https://blog.csdn.net/zqx951102/article/details/88918948\n[Azure Kinect DK 深度相机]https://blog.csdn.net/denkywu/article/details/103177559\n[【语义分割】评价指标：PA、CPA、MPA、IoU、MIoU详细总结和代码实现](https://blog.csdn.net/sinat_29047129/article/details/103642140)\n[ADE20K](https://groups.csail.mit.edu/vision/datasets/ADE20K/)\n\n## 图像标定\n[张正友标定法-完整学习笔记-从原理到实战](https://zhuanlan.zhihu.com/p/136827980)\n[生成标定纸](https://calib.io/pages/camera-calibration-pattern-generator)\n\n\n\n","content":"<p>语义分割(semantic segmentation)FCN<br>实例分割( Instance segmentation)Mask R-CNN<br>全景分割(Panoramic segmentation) Panoptic FPN</p>\n<h1 id=\"3-13采集数据的注意点\"><a href=\"#3-13采集数据的注意点\" class=\"headerlink\" title=\"3-13采集数据的注意点\"></a>3-13采集数据的注意点</h1><ol>\n<li>不要迎着光拍摄</li>\n<li>最好有云台支持<!-- 3. 采集的图片，虽然分文件夹，但是文件名还是得处理，不然重名了 --></li>\n<li>需要增加人站着的识别<ol>\n<li>人不要太近</li>\n<li></li>\n</ol>\n</li>\n<li>要考虑拍照的时间，白天还是下午，看起来最好是早上，阴天</li>\n<li>需要考虑照相机摆放的位置</li>\n</ol>\n<h1 id=\"3-22采集数据的注意点\"><a href=\"#3-22采集数据的注意点\" class=\"headerlink\" title=\"3-22采集数据的注意点\"></a>3-22采集数据的注意点</h1><ol>\n<li>可以拍摄不同角度的，比如竖着的也拍摄一点</li>\n</ol>\n<p>3.15下次拍照需要注意的：</p>\n<p>脏数据的影响</p>\n<h1 id=\"标注中出现的问题\"><a href=\"#标注中出现的问题\" class=\"headerlink\" title=\"标注中出现的问题\"></a>标注中出现的问题</h1><p>训练的时候，IoU出现了Nan</p>\n<ol>\n<li>学习率过大或过小：学习率过大会导致模型参数更新过快，模型无法收敛或者在训练过程中出现梯度爆炸、梯度消失等问题；学习率过小则可能导致模型收敛缓慢或者无法收敛，从而导致 IoU 变成 NaN。</li>\n<li>数据集中出现空白区域：如果数据集中存在一些空白区域（即标注中的像素值全部为 0），那么计算 IoU 的时候可能会出现分母为 0 的情况，从而导致 IoU 变成 NaN。</li>\n<li>模型架构或训练方式问题：如果模型架构设计不合理或者训练方式不当，可能会导致训练过程中出现梯度爆炸、梯度消失等问题，从而导致 IoU 变成 NaN。</li>\n<li>数据集标注问题：数据集标注问题也可能导致 IoU 变成 NaN。比如，在数据集标注过程中出现了错误的标注，可能导致 IoU 计算错误。</li>\n</ol>\n<p>出现了脏数据</p>\n<h1 id=\"语义分割评价指标\"><a href=\"#语义分割评价指标\" class=\"headerlink\" title=\"语义分割评价指标\"></a>语义分割评价指标</h1><h2 id=\"混淆矩阵\"><a href=\"#混淆矩阵\" class=\"headerlink\" title=\"混淆矩阵\"></a>混淆矩阵</h2><p>TP（True Positive）：真正例，模型预测为正例，实际是正例（模型预测为类别1，实际是类别1）<br>FP（False Positive）：假正例，模型预测为正例，实际是反例 （模型预测为类别1，实际是类别2）<br>FN（False Negative）：假反例，模型预测为反例，实际是正例 （模型预测为类别2，实际是类别1）<br>TN（True Negative）：真反例，模型预测为反例，实际是反例 （模型预测为类别2，实际是类别2）</p>\n<h2 id=\"交并比（Intersection-over-Union，IoU）\"><a href=\"#交并比（Intersection-over-Union，IoU）\" class=\"headerlink\" title=\"交并比（Intersection over Union，IoU）\"></a>交并比（Intersection over Union，IoU）</h2><p>含义：模型对某一类别预测结果和真实值的交集与并集的比值</p>\n<h2 id=\"平均交并比（Mean-Intersection-over-Union，MIoU）\"><a href=\"#平均交并比（Mean-Intersection-over-Union，MIoU）\" class=\"headerlink\" title=\"平均交并比（Mean Intersection over Union，MIoU）\"></a>平均交并比（Mean Intersection over Union，MIoU）</h2><p>含义：模型对每一类预测的结果和真实值的交集与并集的比值，求和再平均的结果<br>只有一个数值，对于每个类的IoU取平均</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[机器学习开篇之机器学习的分类]<a href=\"https://blog.csdn.net/Lion_Dreams/article/details/125269215\">https://blog.csdn.net/Lion_Dreams/article/details/125269215</a><br>[计算机视觉 - 语义分割 （semantic segmentation）]<a href=\"https://blog.csdn.net/baidu_41617231/article/details/107739897\">https://blog.csdn.net/baidu_41617231/article/details/107739897</a><br>[机器学习：mAP评价指标]<a href=\"https://blog.csdn.net/qq_40765537/article/details/106394103\">https://blog.csdn.net/qq_40765537/article/details/106394103</a><br>[PASCAL VOC2012数据集介绍]<a href=\"https://blog.csdn.net/qq_37541097/article/details/115787033\">https://blog.csdn.net/qq_37541097/article/details/115787033</a><br>[损失函数（loss function）]<a href=\"https://blog.csdn.net/EmilyHoward/article/details/118367495\">https://blog.csdn.net/EmilyHoward/article/details/118367495</a><br>[标注工具的使用]<a href=\"https://www.bilibili.com/video/BV1ev411P7dR/?spm_id_from=333.999.0.0&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca\">https://www.bilibili.com/video/BV1ev411P7dR/?spm_id_from=333.999.0.0&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca</a><br>[Labelme工具对应博文]<a href=\"https://blog.csdn.net/qq_37541097/article/details/120162702\">https://blog.csdn.net/qq_37541097/article/details/120162702</a><br>[安装labelme教程]<a href=\"https://blog.csdn.net/weixin_43427721/article/details/107122775\">https://blog.csdn.net/weixin_43427721/article/details/107122775</a><br>[EISeg工具对应博文]<a href=\"https://blog.csdn.net/qq_37541097/article/details/120154543\">https://blog.csdn.net/qq_37541097/article/details/120154543</a><br>[batch size设置技巧]<a href=\"https://blog.csdn.net/zqx951102/article/details/88918948\">https://blog.csdn.net/zqx951102/article/details/88918948</a><br>[Azure Kinect DK 深度相机]<a href=\"https://blog.csdn.net/denkywu/article/details/103177559\">https://blog.csdn.net/denkywu/article/details/103177559</a><br><a href=\"https://blog.csdn.net/sinat_29047129/article/details/103642140\">【语义分割】评价指标：PA、CPA、MPA、IoU、MIoU详细总结和代码实现</a><br><a href=\"https://groups.csail.mit.edu/vision/datasets/ADE20K/\">ADE20K</a></p>\n<h2 id=\"图像标定\"><a href=\"#图像标定\" class=\"headerlink\" title=\"图像标定\"></a>图像标定</h2><p><a href=\"https://zhuanlan.zhihu.com/p/136827980\">张正友标定法-完整学习笔记-从原理到实战</a><br><a href=\"https://calib.io/pages/camera-calibration-pattern-generator\">生成标定纸</a></p>\n","slug":"Course/ML/Semantic_segmentation","updated":"05/04/2023","comments":true,"link":"","permalink":"http://example.com/2022/10/11/Course/ML/Semantic_segmentation/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"如何开始阅读论文","date":"30/09/2022","path":"2022/09/30/Others/science/","text":"文献阅读量 刚开始的时候可以先挑选看10篇论文，精度5篇 20-30篇的时候大概有改进思路 40篇的时候大概能知道怎么写了 注意的点老师说要大量的阅读文献并不是完全正确的，应该在自己的方向上大量阅读文献，尽快确定自己想要做的研究的点，在这个点上再多做扩展比如:想要做智能割草机，老师就和我说了路径规划，那么大概的思路是:1）如果是大方向的话，比如机器视觉，可以先找相关的综述，知网搜:机器视觉综述，看2-3篇综述判断大方向的依据就是综述能不能搜出来，比如割草机综述就没有，路径规划综述就有1）路径规划先看个5-6篇，知道有全覆盖的和局部的2）全覆盖的有牛耕法，波形法…..找全覆盖的论文5-6篇，每种方法1-2篇局部的路径规划，点对点的有A，D,DFS,智能算法有蚁群的，遗传算法的就每个找2-3篇那现在应该有大概20篇的论文量了，可以思考一下自己的论文准备怎么写3）想想自己的研究方向是什么，这个方向热点的研究方向是什么。热点的研究指的是最近2-3年内知网的发文频率是否比较高比如我看到了最近很多人智能算法的结合经常发水文，比如蚁群结合遗传，遗传结合粒子群，模拟退火结合dfs，那我现在也想做这个方向了4）大致敲定自己用什么方法，比如我首先先想用蚁群的结合什么不管，那我就起码找10篇及以上蚁群的论文，因为我现在就是要些这个东西，所以我必须要对这个方向做充分充分的了解，所以看再多的论文都不嫌多，感觉10是最最起码的数量了5）看完别人的思路，那就可以开始准备代码，开始做自己的实践了，可以先尝试把别人做的事情复现出来6）寻找创新点，现在不仅仅是要对这个领域有了解，而是要去找怎么去改进自己现在做的这个工作，我的话就是怎么去优化蚁群算法7）一篇水文搞完了 大量阅读的目的 大量阅读的目的就是为了知道当前领域内的同行都在干什么，他们做到什么程度了。 我最开始陷入了大量乱看的误区，机器学习看一点,slam看一点，路径规划看一点，导致每个领域都不深入，杂乱的明明看了20多篇了还是什么思路都没有，不知道对于割草机我可以做什么，我可以怎么改进 后来想着就做路径规划这个方向，就是对于同一个问题给机器人做路径规划这个我问题，看了很多人不同的解决方法，不同的人有不同的做法，都是做路径规划，大家都在相同的事物上用了不同方法，就慢慢有了思路 关于英文文献 英文文献的质量的确比较高，英文水平不够的情况下，阅读英文文献得性价比是很低的。 应该先看个10篇左右中文，了解这个领域大概有一些什么。对术语方法之类的有了了解，即使英文文章看不懂，看图，看表格，可以快速筛选出是不是自己想要的文章","raw":"---\ntitle: 如何开始阅读论文\ndate: 2022-09-30 18:16:43\ntags:\n- 其他\n---\n\n# 文献阅读量\n1. 刚开始的时候可以先挑选看10篇论文，精度5篇\n2. 20-30篇的时候大概有改进思路\n3. 40篇的时候大概能知道怎么写了\n\n# 注意的点\n老师说要大量的阅读文献并不是完全正确的，应该在自己的方向上大量阅读文献，尽快确定自己想要做的研究的点，在这个点上再多做扩展\n比如:想要做智能割草机，老师就和我说了路径规划，那么大概的思路是:\n1）如果是大方向的话，比如机器视觉，可以先找相关的综述，知网搜:机器视觉综述，看2-3篇综述\n判断大方向的依据就是综述能不能搜出来，比如割草机综述就没有，路径规划综述就有\n1）路径规划先看个5-6篇，知道有全覆盖的和局部的\n2）全覆盖的有牛耕法，波形法.....找全覆盖的论文5-6篇，每种方法1-2篇\n局部的路径规划，点对点的有A*，D*,DFS,智能算法有蚁群的，遗传算法的就每个找2-3篇\n那现在应该有大概20篇的论文量了，可以思考一下自己的论文准备怎么写\n3）想想自己的研究方向是什么，这个方向热点的研究方向是什么。热点的研究指的是最近2-3年内知网的发文频率是否比较高\n比如我看到了最近很多人智能算法的结合经常发水文，比如蚁群结合遗传，遗传结合粒子群，模拟退火结合dfs，那我现在也想做这个方向了\n4）大致敲定自己用什么方法，比如我首先先想用蚁群的结合什么不管，那我就起码找10篇及以上蚁群的论文，因为我现在就是要些这个东西，所以我必须要对这个方向做充分充分的了解，所以看再多的论文都不嫌多，感觉10是最最起码的数量了\n5）看完别人的思路，那就可以开始准备代码，开始做自己的实践了，可以先尝试把别人做的事情复现出来\n6）寻找创新点，现在不仅仅是要对这个领域有了解，而是要去找怎么去改进自己现在做的这个工作，我的话就是怎么去优化蚁群算法\n7）一篇水文搞完了\n\n\n# 大量阅读的目的\n1. 大量阅读的目的就是为了知道当前领域内的同行都在干什么，他们做到什么程度了。\n2. 我最开始陷入了大量乱看的误区，机器学习看一点,slam看一点，路径规划看一点，导致每个领域都不深入，杂乱的明明看了20多篇了还是什么思路都没有，不知道对于割草机我可以做什么，我可以怎么改进\n3. 后来想着就做路径规划这个方向，就是对于同一个问题给机器人做路径规划这个我问题，看了很多人不同的解决方法，不同的人有不同的做法，都是做路径规划，大家都在相同的事物上用了不同方法，就慢慢有了思路\n\n\n# 关于英文文献\n1. 英文文献的质量的确比较高，英文水平不够的情况下，阅读英文文献得性价比是很低的。\n2. 应该先看个10篇左右中文，了解这个领域大概有一些什么。对术语方法之类的有了了解，即使英文文章看不懂，看图，看表格，可以快速筛选出是不是自己想要的文章","content":"<h1 id=\"文献阅读量\"><a href=\"#文献阅读量\" class=\"headerlink\" title=\"文献阅读量\"></a>文献阅读量</h1><ol>\n<li>刚开始的时候可以先挑选看10篇论文，精度5篇</li>\n<li>20-30篇的时候大概有改进思路</li>\n<li>40篇的时候大概能知道怎么写了</li>\n</ol>\n<h1 id=\"注意的点\"><a href=\"#注意的点\" class=\"headerlink\" title=\"注意的点\"></a>注意的点</h1><p>老师说要大量的阅读文献并不是完全正确的，应该在自己的方向上大量阅读文献，尽快确定自己想要做的研究的点，在这个点上再多做扩展<br>比如:想要做智能割草机，老师就和我说了路径规划，那么大概的思路是:<br>1）如果是大方向的话，比如机器视觉，可以先找相关的综述，知网搜:机器视觉综述，看2-3篇综述<br>判断大方向的依据就是综述能不能搜出来，比如割草机综述就没有，路径规划综述就有<br>1）路径规划先看个5-6篇，知道有全覆盖的和局部的<br>2）全覆盖的有牛耕法，波形法…..找全覆盖的论文5-6篇，每种方法1-2篇<br>局部的路径规划，点对点的有A<em>，D</em>,DFS,智能算法有蚁群的，遗传算法的就每个找2-3篇<br>那现在应该有大概20篇的论文量了，可以思考一下自己的论文准备怎么写<br>3）想想自己的研究方向是什么，这个方向热点的研究方向是什么。热点的研究指的是最近2-3年内知网的发文频率是否比较高<br>比如我看到了最近很多人智能算法的结合经常发水文，比如蚁群结合遗传，遗传结合粒子群，模拟退火结合dfs，那我现在也想做这个方向了<br>4）大致敲定自己用什么方法，比如我首先先想用蚁群的结合什么不管，那我就起码找10篇及以上蚁群的论文，因为我现在就是要些这个东西，所以我必须要对这个方向做充分充分的了解，所以看再多的论文都不嫌多，感觉10是最最起码的数量了<br>5）看完别人的思路，那就可以开始准备代码，开始做自己的实践了，可以先尝试把别人做的事情复现出来<br>6）寻找创新点，现在不仅仅是要对这个领域有了解，而是要去找怎么去改进自己现在做的这个工作，我的话就是怎么去优化蚁群算法<br>7）一篇水文搞完了</p>\n<h1 id=\"大量阅读的目的\"><a href=\"#大量阅读的目的\" class=\"headerlink\" title=\"大量阅读的目的\"></a>大量阅读的目的</h1><ol>\n<li>大量阅读的目的就是为了知道当前领域内的同行都在干什么，他们做到什么程度了。</li>\n<li>我最开始陷入了大量乱看的误区，机器学习看一点,slam看一点，路径规划看一点，导致每个领域都不深入，杂乱的明明看了20多篇了还是什么思路都没有，不知道对于割草机我可以做什么，我可以怎么改进</li>\n<li>后来想着就做路径规划这个方向，就是对于同一个问题给机器人做路径规划这个我问题，看了很多人不同的解决方法，不同的人有不同的做法，都是做路径规划，大家都在相同的事物上用了不同方法，就慢慢有了思路</li>\n</ol>\n<h1 id=\"关于英文文献\"><a href=\"#关于英文文献\" class=\"headerlink\" title=\"关于英文文献\"></a>关于英文文献</h1><ol>\n<li>英文文献的质量的确比较高，英文水平不够的情况下，阅读英文文献得性价比是很低的。</li>\n<li>应该先看个10篇左右中文，了解这个领域大概有一些什么。对术语方法之类的有了了解，即使英文文章看不懂，看图，看表格，可以快速筛选出是不是自己想要的文章</li>\n</ol>\n","slug":"Others/science","updated":"30/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/09/30/Others/science/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"Wireshark 教程","date":"28/09/2022","path":"2022/09/28/Tutorial/Wireshark-tutorial/","text":"ip.addr &#x3D;&#x3D; 110.242.68.3 and icmpip.addr &#x3D;&#x3D; 192.168.1.9 and tcp.port &#x3D;&#x3D; 8888ip.addr &#x3D;&#x3D; 192.168.43.12 and tcp.port &#x3D;&#x3D; 8888 视图-&gt;着色规则绿色背景的是HTTP包灰色背景的是TCP包。黑色背景的是TCP错误包或者校验和错误的包 问题 安装的时候检测不到网卡 什么都捕捉不到用管理员方式启动 参考资料[wireshark抓包不显示结果，还是空白的]https://blog.csdn.net/WQLWWW/article/details/115488382","raw":"---\ntitle: Wireshark 教程\ndate: 2022-09-28 20:18:48\ntags:\n- 教程\n---\n\n\n\n\nip.addr == 110.242.68.3 and icmp\nip.addr == 192.168.1.9 and tcp.port == 8888\nip.addr == 192.168.43.12 and tcp.port == 8888\n\n视图->着色规则\n绿色背景的是HTTP包\n灰色背景的是TCP包。\n黑色背景的是TCP错误包或者校验和错误的包\n\n# 问题\n1. 安装的时候检测不到网卡\n2. 什么都捕捉不到\n用管理员方式启动\n\n# 参考资料\n[wireshark抓包不显示结果，还是空白的]https://blog.csdn.net/WQLWWW/article/details/115488382\n\n","content":"<p>ip.addr &#x3D;&#x3D; 110.242.68.3 and icmp<br>ip.addr &#x3D;&#x3D; 192.168.1.9 and tcp.port &#x3D;&#x3D; 8888<br>ip.addr &#x3D;&#x3D; 192.168.43.12 and tcp.port &#x3D;&#x3D; 8888</p>\n<p>视图-&gt;着色规则<br>绿色背景的是HTTP包<br>灰色背景的是TCP包。<br>黑色背景的是TCP错误包或者校验和错误的包</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>安装的时候检测不到网卡</li>\n<li>什么都捕捉不到<br>用管理员方式启动</li>\n</ol>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[wireshark抓包不显示结果，还是空白的]<a href=\"https://blog.csdn.net/WQLWWW/article/details/115488382\">https://blog.csdn.net/WQLWWW/article/details/115488382</a></p>\n","slug":"Tutorial/Wireshark-tutorial","updated":"23/10/2022","comments":true,"link":"","permalink":"http://example.com/2022/09/28/Tutorial/Wireshark-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"k8s命令","date":"25/09/2022","path":"2022/09/25/Course/k8s-commad/","text":"1. 命令式对象管理 kubectl命令1kubectl [command] [type] [name] [flags] comand：指定要对资源执行的操作，例如create、get、deletetype：指定资源类型，比如deployment、pod、servicename：指定资源的名称，名称大小写敏感flags：指定额外的可选参数 1.1 操作（command）kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令kubectl –help 经常使用的操作有下面这些： 命令分类 命令 翻译 命令作用 基本命令 create 创建 创建一个资源 edit 编辑 编辑一个资源 get 获取 获取一个资源 patch 更新 更新一个资源 delete 删除 删除一个资源 explain 解释 展示资源文档 运行和调试 run 运行 在集群中运行一个指定的镜像 expose 暴露 暴露资源为Service describe 描述 显示资源内部信息 logs 日志输出容器在 pod 中的日志 输出容器在 pod 中的日志 attach 缠绕进入运行中的容器 进入运行中的容器 exec 执行容器中的一个命令 执行容器中的一个命令 cp 复制 在Pod内外复制文件 rollout 首次展示 管理资源的发布 scale 规模 扩(缩)容Pod的数量 autoscale 自动调整 自动调整Pod的数量 高级命令 apply rc 通过文件对资源进行配置 label 标签 更新资源上的标签 其他命令 cluster-info 集群信息 显示集群信息 version 版本 显示当前Server和Client的版本 1.2 资源类型（type）kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看: 1kubectl api-resources 经常使用的资源有下面这些： 资源分类 资源名称 缩写 资源作用 集群级别资源 nodes no 集群组成部分 namespaces ns 隔离Pod pod资源 pods po 装载容器 pod资源控制器 replicationcontrollers rc 控制pod资源 replicasets rs 控制pod资源 deployments deploy 控制pod资源 daemonsets ds 控制pod资源 jobs 控制pod资源 cronjobs cj 控制pod资源 horizontalpodautoscalers hpa 控制pod资源 statefulsets sts 控制pod资源 服务发现资源 services svc 统一pod对外接口 ingress ing 统一pod对外接口 存储资源 volumeattachments 存储 persistentvolumes pv 存储 persistentvolumeclaims pvc 存储 配置资源 configmaps cm 配置 secrets 配置 1.3 应用示例123456kubectl create namespace dev # 创建一个namespacekubectl get ns # 获取namespacekubectl run pod --image=nginx:latest -n dev # 在此namespace下创建并运行一个nginx的Podkubectl get pod -n dev # 查看新创建的podkubectl delete pod pod-864f9875b9-pcw7x # 删除指定的podkubectl delete ns dev # 删除指定的namespace 2 常见资源2.1 namspace123456789101112131415161718# 查看所有的命名空间kubectl get namespacekubectl get nc# 查看指定的命名空间kubectl get namespace defaultkubectl get ns default# 指定命名空间的输出格式kubectl get ns default -o widekubectl get ns default -o jsonkubectl get ns default -o yaml# 查看命名空间的详情kubectl describe namespace defaultkubectl describe ns default# 创建命名空间kubectl create namespace devkubectl create ns dev# 除命名空间kubectl delete ns dev 3 Pod详解3.1 Pod的配置3.2 Pod的生命周期3.3 Pod的调度4 Pod控制器详解 在kubernetes中，按照Pod的创建方式可以将其分为两类： 自主式Pod：kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建。 控制器创建Pod：通过Pod控制器创建的Pod，这种Pod删除之后还会自动重建。 Pod控制器：Pod控制器是管理Pod的中间层，使用了Pod控制器之后，我们只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它就会创建出满足条件的Pod并确保每一个Pod处于用户期望的状态，如果Pod在运行中出现故障，控制器会基于指定的策略重启或重建Pod。 在kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些： ReplicationController：比较原始的Pod控制器，已经被废弃，由ReplicaSet替代。 ReplicaSet：保证指定数量的Pod运行，并支持Pod数量变更，镜像版本变更。 Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、版本回退。 Horizontal Pod Autoscaler：可以根据集群负载自动调整Pod的数量，实现削峰填谷。 DaemonSet：在集群中的指定Node上都运行一个副本，一般用于守护进程类的任务。 Job：它创建出来的Pod只要完成任务就立即退出，用于执行一次性任务。 CronJob：它创建的Pod会周期性的执行，用于执行周期性的任务。 StatefulSet：管理有状态的应用。 4.1 Pod控制器的介绍4.2 ReplicaSet（RS）4.3 Deployment（Deploy）4.4 Horizontal Pod Autoscaler（HPA）4.5 DaemonSet（DS）4.6 Job4.7 CronJob（CJ）4.8 StatefulSet（有状态）5 Service详解在kubernetes中，Pod是应用程序的载体，我们可以通过Pod的IP来访问应用程序，但是Pod的IP地址不是固定的，这就意味着不方便直接采用Pod的IP对服务进行访问。 spec.type的说明： ClusterIP：默认值，它是kubernetes系统自动分配的虚拟IP，只能在集群内部访问。 NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务。 LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境的支持。 ExternalName：把集群外部的服务引入集群内部，直接使用。 5.1 ClusterIP类型的Service5.2 HeadLiness类型的Service5.3 NodePort类型的Service5.4 LoadBalancer类型的Service5.5 ExternalName类型的Service5.1 Ingress介绍6 k8s的数据存储 在前面已经提到，容器的生命周期可能很短，会被频繁的创建和销毁。那么容器在销毁的时候，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器中的数据，kubernetes引入了Volume的概念。 Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命周期不和Pod中的单个容器的生命周期有关，当容器终止或者重启的时候，Volume中的数据也不会丢失。 kubernetes的Volume支持多种类型，比较常见的有下面的几个： 简单存储：EmptyDir、HostPath、NFS。 高级存储：PV、PVC。 配置存储：ConfigMap、Secret。 6.1 基本存储6.1.1 EmptyDir6.1.2 HostPath6.1.3 NFS6.2 高级存储6.1.2 PV6.1.3 PVC6.3 配置存储6.1.2 ConfigMap6.1.3 Secret7 高级部分（暂时不准备做）k8s的Helmk8s的安全认证搭建DashBoardkubeadm安装高可用k8s集群k8s的项目部署","raw":"---\ntitle: k8s命令\ndate: 2022-09-25 20:26:56\ntags:\n- 课程\n---\n\n\n# 1. 命令式对象管理 kubectl命令\n\n```\nkubectl [command] [type] [name] [flags]\n```\n**comand**：指定要对资源执行的操作，例如create、get、delete\n**type**：指定资源类型，比如deployment、pod、service\n**name**：指定资源的名称，名称大小写敏感\n**flags**：指定额外的可选参数\n\n## 1.1 操作（command）\n\nkubernetes允许对资源进行多种操作，可以通过--help查看详细的操作命令\nkubectl --help\n\n\n经常使用的操作有下面这些：\n\n| 命令分类   | 命令         | 翻译                        | 命令作用                     |\n| :--------- | :----------- | :-------------------------- | :--------------------------- |\n| 基本命令   | create       | 创建                        | 创建一个资源                 |\n|            | edit         | 编辑                        | 编辑一个资源                 |\n|            | get          | 获取                        | 获取一个资源                 |\n|            | patch        | 更新                        | 更新一个资源                 |\n|            | delete       | 删除                        | 删除一个资源                 |\n|            | explain      | 解释                        | 展示资源文档                 |\n| 运行和调试 | run          | 运行                        | 在集群中运行一个指定的镜像   |\n|            | expose       | 暴露                        | 暴露资源为Service            |\n|            | describe     | 描述                        | 显示资源内部信息             |\n|            | logs         | 日志输出容器在 pod 中的日志 | 输出容器在 pod 中的日志      |\n|            | attach       | 缠绕进入运行中的容器        | 进入运行中的容器             |\n|            | exec         | 执行容器中的一个命令        | 执行容器中的一个命令         |\n|            | cp           | 复制                        | 在Pod内外复制文件            |\n|            | rollout      | 首次展示                    | 管理资源的发布               |\n|            | scale        | 规模                        | 扩(缩)容Pod的数量            |\n|            | autoscale    | 自动调整                    | 自动调整Pod的数量            |\n| 高级命令   | apply        | rc                          | 通过文件对资源进行配置       |\n|            | label        | 标签                        | 更新资源上的标签             |\n| 其他命令   | cluster-info | 集群信息                    | 显示集群信息                 |\n|            | version      | 版本                        | 显示当前Server和Client的版本 |\n\n\n\n\n\n## 1.2 资源类型（type）\n\n\nkubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:\n\n```\nkubectl api-resources\n```\n经常使用的资源有下面这些：\n\n| 资源分类      | 资源名称                 | 缩写    | 资源作用        |\n| :------------ | :----------------------- | :------ | :-------------- |\n| 集群级别资源  | nodes                    | no      | 集群组成部分    |\n|               | namespaces    | ns      | 隔离Pod |                 |\n| pod资源       | pods                     | po      | 装载容器        |\n| pod资源控制器 | replicationcontrollers   | rc      | 控制pod资源     |\n|               | replicasets              | rs      | 控制pod资源     |\n|               | deployments              | deploy  | 控制pod资源     |\n|               | daemonsets               | ds      | 控制pod资源     |\n|               | jobs                     |         | 控制pod资源     |\n|               | cronjobs                 | cj      | 控制pod资源     |\n|               | horizontalpodautoscalers | hpa     | 控制pod资源     |\n|               | statefulsets             | sts     | 控制pod资源     |\n| 服务发现资源  | services                 | svc     | 统一pod对外接口 |\n|               | ingress                  | ing     | 统一pod对外接口 |\n| 存储资源      | volumeattachments        |         | 存储            |\n|               | persistentvolumes        | pv      | 存储            |\n|               | persistentvolumeclaims   | pvc     | 存储            |\n| 配置资源      | configmaps               | cm      | 配置            |\n|               | secrets                  |         | 配置            |\n\n\n## 1.3 应用示例\n```shell\nkubectl create namespace dev  # 创建一个namespace\nkubectl get ns # 获取namespace\nkubectl run pod --image=nginx:latest -n dev # 在此namespace下创建并运行一个nginx的Pod\nkubectl get pod -n dev # 查看新创建的pod\nkubectl delete pod pod-864f9875b9-pcw7x # 删除指定的pod\nkubectl delete ns dev # 删除指定的namespace\n```\n\n\n\n\n# 2 常见资源\n# 2.1 namspace\n\n```shell\n# 查看所有的命名空间\nkubectl get namespace\nkubectl get nc\n# 查看指定的命名空间\nkubectl get namespace default\nkubectl get ns default\n# 指定命名空间的输出格式\nkubectl get ns default -o wide\nkubectl get ns default -o json\nkubectl get ns default -o yaml\n# 查看命名空间的详情\nkubectl describe namespace default\nkubectl describe ns default\n# 创建命名空间\nkubectl create namespace dev\nkubectl create ns dev\n# 除命名空间\nkubectl delete ns dev\n```\n\n\n\n\n\n# 3 Pod详解\n\n## 3.1 Pod的配置\n\n\n\n## 3.2 Pod的生命周期\n## 3.3 Pod的调度\n\n\n# 4 Pod控制器详解\n\n- 在kubernetes中，按照Pod的创建方式可以将其分为两类：\n  - 自主式Pod：kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建。\n  - 控制器创建Pod：通过Pod控制器创建的Pod，这种Pod删除之后还会自动重建。\n- Pod控制器：Pod控制器是管理Pod的中间层，使用了Pod控制器之后，我们只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它就会创建出满足条件的Pod并确保每一个Pod处于用户期望的状态，如果Pod在运行中出现故障，控制器会基于指定的策略重启或重建Pod。\n- 在kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些：\n  - ReplicationController：比较原始的Pod控制器，已经被废弃，由ReplicaSet替代。\n  - ReplicaSet：保证指定数量的Pod运行，并支持Pod数量变更，镜像版本变更。\n  - Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、版本回退。\n  - Horizontal Pod Autoscaler：可以根据集群负载自动调整Pod的数量，实现削峰填谷。\n  - DaemonSet：在集群中的指定Node上都运行一个副本，一般用于守护进程类的任务。\n  - Job：它创建出来的Pod只要完成任务就立即退出，用于执行一次性任务。\n  - CronJob：它创建的Pod会周期性的执行，用于执行周期性的任务。\n  - StatefulSet：管理有状态的应用。\n\n## 4.1 Pod控制器的介绍\n## 4.2 ReplicaSet（RS）\n## 4.3 Deployment（Deploy）\n## 4.4 Horizontal Pod Autoscaler（HPA）\n## 4.5 DaemonSet（DS）\n## 4.6 Job\n## 4.7 CronJob（CJ）\n## 4.8 StatefulSet（有状态）\n\n\n\n# 5 Service详解\n在kubernetes中，Pod是应用程序的载体，我们可以通过Pod的IP来访问应用程序，但是Pod的IP地址不是固定的，这就意味着不方便直接采用Pod的IP对服务进行访问。\n\nspec.type的说明：\n- ClusterIP：默认值，它是kubernetes系统自动分配的虚拟IP，只能在集群内部访问。\n- NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务。\n- LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境的支持。\n- ExternalName：把集群外部的服务引入集群内部，直接使用。\n\n## 5.1 ClusterIP类型的Service\n## 5.2 HeadLiness类型的Service\n## 5.3 NodePort类型的Service\n## 5.4 LoadBalancer类型的Service\n## 5.5 ExternalName类型的Service\n\n## 5.1 Ingress介绍\n\n\n\n\n\n\n# 6 k8s的数据存储\n- 在前面已经提到，容器的生命周期可能很短，会被频繁的创建和销毁。那么容器在销毁的时候，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器中的数据，kubernetes引入了Volume的概念。\n- Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命周期不和Pod中的单个容器的生命周期有关，当容器终止或者重启的时候，Volume中的数据也不会丢失。\n- kubernetes的Volume支持多种类型，比较常见的有下面的几个：\n  - 简单存储：EmptyDir、HostPath、NFS。\n  - 高级存储：PV、PVC。\n  - 配置存储：ConfigMap、Secret。\n\n## 6.1 基本存储\n### 6.1.1 EmptyDir\n### 6.1.2 HostPath\n### 6.1.3 NFS\n\n## 6.2 高级存储\n### 6.1.2 PV\n### 6.1.3 PVC\n\n## 6.3 配置存储\n### 6.1.2 ConfigMap\n### 6.1.3 Secret\n\n\n\n# 7 高级部分（暂时不准备做）\n## k8s的Helm\n## k8s的安全认证\n## 搭建DashBoard\n## kubeadm安装高可用k8s集群\n## k8s的项目部署\n\n\n\n\n\n","content":"<h1 id=\"1-命令式对象管理-kubectl命令\"><a href=\"#1-命令式对象管理-kubectl命令\" class=\"headerlink\" title=\"1. 命令式对象管理 kubectl命令\"></a>1. 命令式对象管理 kubectl命令</h1><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl <span class=\"selector-attr\">[command]</span> <span class=\"selector-attr\">[type]</span> <span class=\"selector-attr\">[name]</span> <span class=\"selector-attr\">[flags]</span></span><br></pre></td></tr></table></figure>\n<p><strong>comand</strong>：指定要对资源执行的操作，例如create、get、delete<br><strong>type</strong>：指定资源类型，比如deployment、pod、service<br><strong>name</strong>：指定资源的名称，名称大小写敏感<br><strong>flags</strong>：指定额外的可选参数</p>\n<h2 id=\"1-1-操作（command）\"><a href=\"#1-1-操作（command）\" class=\"headerlink\" title=\"1.1 操作（command）\"></a>1.1 操作（command）</h2><p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令<br>kubectl –help</p>\n<p>经常使用的操作有下面这些：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">命令分类</th>\n<th align=\"left\">命令</th>\n<th align=\"left\">翻译</th>\n<th align=\"left\">命令作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">基本命令</td>\n<td align=\"left\">create</td>\n<td align=\"left\">创建</td>\n<td align=\"left\">创建一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">edit</td>\n<td align=\"left\">编辑</td>\n<td align=\"left\">编辑一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">get</td>\n<td align=\"left\">获取</td>\n<td align=\"left\">获取一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">patch</td>\n<td align=\"left\">更新</td>\n<td align=\"left\">更新一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">delete</td>\n<td align=\"left\">删除</td>\n<td align=\"left\">删除一个资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">explain</td>\n<td align=\"left\">解释</td>\n<td align=\"left\">展示资源文档</td>\n</tr>\n<tr>\n<td align=\"left\">运行和调试</td>\n<td align=\"left\">run</td>\n<td align=\"left\">运行</td>\n<td align=\"left\">在集群中运行一个指定的镜像</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">expose</td>\n<td align=\"left\">暴露</td>\n<td align=\"left\">暴露资源为Service</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">describe</td>\n<td align=\"left\">描述</td>\n<td align=\"left\">显示资源内部信息</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">logs</td>\n<td align=\"left\">日志输出容器在 pod 中的日志</td>\n<td align=\"left\">输出容器在 pod 中的日志</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">attach</td>\n<td align=\"left\">缠绕进入运行中的容器</td>\n<td align=\"left\">进入运行中的容器</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">exec</td>\n<td align=\"left\">执行容器中的一个命令</td>\n<td align=\"left\">执行容器中的一个命令</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">cp</td>\n<td align=\"left\">复制</td>\n<td align=\"left\">在Pod内外复制文件</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">rollout</td>\n<td align=\"left\">首次展示</td>\n<td align=\"left\">管理资源的发布</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">scale</td>\n<td align=\"left\">规模</td>\n<td align=\"left\">扩(缩)容Pod的数量</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">autoscale</td>\n<td align=\"left\">自动调整</td>\n<td align=\"left\">自动调整Pod的数量</td>\n</tr>\n<tr>\n<td align=\"left\">高级命令</td>\n<td align=\"left\">apply</td>\n<td align=\"left\">rc</td>\n<td align=\"left\">通过文件对资源进行配置</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">label</td>\n<td align=\"left\">标签</td>\n<td align=\"left\">更新资源上的标签</td>\n</tr>\n<tr>\n<td align=\"left\">其他命令</td>\n<td align=\"left\">cluster-info</td>\n<td align=\"left\">集群信息</td>\n<td align=\"left\">显示集群信息</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">version</td>\n<td align=\"left\">版本</td>\n<td align=\"left\">显示当前Server和Client的版本</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-2-资源类型（type）\"><a href=\"#1-2-资源类型（type）\" class=\"headerlink\" title=\"1.2 资源类型（type）\"></a>1.2 资源类型（type）</h2><p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">kubectl api-resources</span></span><br></pre></td></tr></table></figure>\n<p>经常使用的资源有下面这些：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">资源分类</th>\n<th align=\"left\">资源名称</th>\n<th align=\"left\">缩写</th>\n<th align=\"left\">资源作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">集群级别资源</td>\n<td align=\"left\">nodes</td>\n<td align=\"left\">no</td>\n<td align=\"left\">集群组成部分</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">namespaces</td>\n<td align=\"left\">ns</td>\n<td align=\"left\">隔离Pod</td>\n</tr>\n<tr>\n<td align=\"left\">pod资源</td>\n<td align=\"left\">pods</td>\n<td align=\"left\">po</td>\n<td align=\"left\">装载容器</td>\n</tr>\n<tr>\n<td align=\"left\">pod资源控制器</td>\n<td align=\"left\">replicationcontrollers</td>\n<td align=\"left\">rc</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">replicasets</td>\n<td align=\"left\">rs</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">deployments</td>\n<td align=\"left\">deploy</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">daemonsets</td>\n<td align=\"left\">ds</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">jobs</td>\n<td align=\"left\"></td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">cronjobs</td>\n<td align=\"left\">cj</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">horizontalpodautoscalers</td>\n<td align=\"left\">hpa</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">statefulsets</td>\n<td align=\"left\">sts</td>\n<td align=\"left\">控制pod资源</td>\n</tr>\n<tr>\n<td align=\"left\">服务发现资源</td>\n<td align=\"left\">services</td>\n<td align=\"left\">svc</td>\n<td align=\"left\">统一pod对外接口</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">ingress</td>\n<td align=\"left\">ing</td>\n<td align=\"left\">统一pod对外接口</td>\n</tr>\n<tr>\n<td align=\"left\">存储资源</td>\n<td align=\"left\">volumeattachments</td>\n<td align=\"left\"></td>\n<td align=\"left\">存储</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">persistentvolumes</td>\n<td align=\"left\">pv</td>\n<td align=\"left\">存储</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">persistentvolumeclaims</td>\n<td align=\"left\">pvc</td>\n<td align=\"left\">存储</td>\n</tr>\n<tr>\n<td align=\"left\">配置资源</td>\n<td align=\"left\">configmaps</td>\n<td align=\"left\">cm</td>\n<td align=\"left\">配置</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">secrets</td>\n<td align=\"left\"></td>\n<td align=\"left\">配置</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-3-应用示例\"><a href=\"#1-3-应用示例\" class=\"headerlink\" title=\"1.3 应用示例\"></a>1.3 应用示例</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace dev  # 创建一个namespace</span><br><span class=\"line\">kubectl get ns # 获取namespace</span><br><span class=\"line\">kubectl run pod --image=nginx:latest -n dev # 在此namespace下创建并运行一个nginx的Pod</span><br><span class=\"line\">kubectl get pod -n dev # 查看新创建的pod</span><br><span class=\"line\">kubectl delete pod pod-864f9875b9-pcw7x # 删除指定的pod</span><br><span class=\"line\">kubectl delete ns dev # 删除指定的namespace</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"2-常见资源\"><a href=\"#2-常见资源\" class=\"headerlink\" title=\"2 常见资源\"></a>2 常见资源</h1><h1 id=\"2-1-namspace\"><a href=\"#2-1-namspace\" class=\"headerlink\" title=\"2.1 namspace\"></a>2.1 namspace</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看所有的命名空间</span></span><br><span class=\"line\">kubectl get namespace</span><br><span class=\"line\">kubectl get nc</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看指定的命名空间</span></span><br><span class=\"line\">kubectl get namespace default</span><br><span class=\"line\">kubectl get ns default</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">指定命名空间的输出格式</span></span><br><span class=\"line\">kubectl get ns default -o wide</span><br><span class=\"line\">kubectl get ns default -o json</span><br><span class=\"line\">kubectl get ns default -o yaml</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看命名空间的详情</span></span><br><span class=\"line\">kubectl describe namespace default</span><br><span class=\"line\">kubectl describe ns default</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">创建命名空间</span></span><br><span class=\"line\">kubectl create namespace dev</span><br><span class=\"line\">kubectl create ns dev</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">除命名空间</span></span><br><span class=\"line\">kubectl delete ns dev</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"3-Pod详解\"><a href=\"#3-Pod详解\" class=\"headerlink\" title=\"3 Pod详解\"></a>3 Pod详解</h1><h2 id=\"3-1-Pod的配置\"><a href=\"#3-1-Pod的配置\" class=\"headerlink\" title=\"3.1 Pod的配置\"></a>3.1 Pod的配置</h2><h2 id=\"3-2-Pod的生命周期\"><a href=\"#3-2-Pod的生命周期\" class=\"headerlink\" title=\"3.2 Pod的生命周期\"></a>3.2 Pod的生命周期</h2><h2 id=\"3-3-Pod的调度\"><a href=\"#3-3-Pod的调度\" class=\"headerlink\" title=\"3.3 Pod的调度\"></a>3.3 Pod的调度</h2><h1 id=\"4-Pod控制器详解\"><a href=\"#4-Pod控制器详解\" class=\"headerlink\" title=\"4 Pod控制器详解\"></a>4 Pod控制器详解</h1><ul>\n<li>在kubernetes中，按照Pod的创建方式可以将其分为两类：<ul>\n<li>自主式Pod：kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建。</li>\n<li>控制器创建Pod：通过Pod控制器创建的Pod，这种Pod删除之后还会自动重建。</li>\n</ul>\n</li>\n<li>Pod控制器：Pod控制器是管理Pod的中间层，使用了Pod控制器之后，我们只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它就会创建出满足条件的Pod并确保每一个Pod处于用户期望的状态，如果Pod在运行中出现故障，控制器会基于指定的策略重启或重建Pod。</li>\n<li>在kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些：<ul>\n<li>ReplicationController：比较原始的Pod控制器，已经被废弃，由ReplicaSet替代。</li>\n<li>ReplicaSet：保证指定数量的Pod运行，并支持Pod数量变更，镜像版本变更。</li>\n<li>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、版本回退。</li>\n<li>Horizontal Pod Autoscaler：可以根据集群负载自动调整Pod的数量，实现削峰填谷。</li>\n<li>DaemonSet：在集群中的指定Node上都运行一个副本，一般用于守护进程类的任务。</li>\n<li>Job：它创建出来的Pod只要完成任务就立即退出，用于执行一次性任务。</li>\n<li>CronJob：它创建的Pod会周期性的执行，用于执行周期性的任务。</li>\n<li>StatefulSet：管理有状态的应用。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-1-Pod控制器的介绍\"><a href=\"#4-1-Pod控制器的介绍\" class=\"headerlink\" title=\"4.1 Pod控制器的介绍\"></a>4.1 Pod控制器的介绍</h2><h2 id=\"4-2-ReplicaSet（RS）\"><a href=\"#4-2-ReplicaSet（RS）\" class=\"headerlink\" title=\"4.2 ReplicaSet（RS）\"></a>4.2 ReplicaSet（RS）</h2><h2 id=\"4-3-Deployment（Deploy）\"><a href=\"#4-3-Deployment（Deploy）\" class=\"headerlink\" title=\"4.3 Deployment（Deploy）\"></a>4.3 Deployment（Deploy）</h2><h2 id=\"4-4-Horizontal-Pod-Autoscaler（HPA）\"><a href=\"#4-4-Horizontal-Pod-Autoscaler（HPA）\" class=\"headerlink\" title=\"4.4 Horizontal Pod Autoscaler（HPA）\"></a>4.4 Horizontal Pod Autoscaler（HPA）</h2><h2 id=\"4-5-DaemonSet（DS）\"><a href=\"#4-5-DaemonSet（DS）\" class=\"headerlink\" title=\"4.5 DaemonSet（DS）\"></a>4.5 DaemonSet（DS）</h2><h2 id=\"4-6-Job\"><a href=\"#4-6-Job\" class=\"headerlink\" title=\"4.6 Job\"></a>4.6 Job</h2><h2 id=\"4-7-CronJob（CJ）\"><a href=\"#4-7-CronJob（CJ）\" class=\"headerlink\" title=\"4.7 CronJob（CJ）\"></a>4.7 CronJob（CJ）</h2><h2 id=\"4-8-StatefulSet（有状态）\"><a href=\"#4-8-StatefulSet（有状态）\" class=\"headerlink\" title=\"4.8 StatefulSet（有状态）\"></a>4.8 StatefulSet（有状态）</h2><h1 id=\"5-Service详解\"><a href=\"#5-Service详解\" class=\"headerlink\" title=\"5 Service详解\"></a>5 Service详解</h1><p>在kubernetes中，Pod是应用程序的载体，我们可以通过Pod的IP来访问应用程序，但是Pod的IP地址不是固定的，这就意味着不方便直接采用Pod的IP对服务进行访问。</p>\n<p>spec.type的说明：</p>\n<ul>\n<li>ClusterIP：默认值，它是kubernetes系统自动分配的虚拟IP，只能在集群内部访问。</li>\n<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务。</li>\n<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境的支持。</li>\n<li>ExternalName：把集群外部的服务引入集群内部，直接使用。</li>\n</ul>\n<h2 id=\"5-1-ClusterIP类型的Service\"><a href=\"#5-1-ClusterIP类型的Service\" class=\"headerlink\" title=\"5.1 ClusterIP类型的Service\"></a>5.1 ClusterIP类型的Service</h2><h2 id=\"5-2-HeadLiness类型的Service\"><a href=\"#5-2-HeadLiness类型的Service\" class=\"headerlink\" title=\"5.2 HeadLiness类型的Service\"></a>5.2 HeadLiness类型的Service</h2><h2 id=\"5-3-NodePort类型的Service\"><a href=\"#5-3-NodePort类型的Service\" class=\"headerlink\" title=\"5.3 NodePort类型的Service\"></a>5.3 NodePort类型的Service</h2><h2 id=\"5-4-LoadBalancer类型的Service\"><a href=\"#5-4-LoadBalancer类型的Service\" class=\"headerlink\" title=\"5.4 LoadBalancer类型的Service\"></a>5.4 LoadBalancer类型的Service</h2><h2 id=\"5-5-ExternalName类型的Service\"><a href=\"#5-5-ExternalName类型的Service\" class=\"headerlink\" title=\"5.5 ExternalName类型的Service\"></a>5.5 ExternalName类型的Service</h2><h2 id=\"5-1-Ingress介绍\"><a href=\"#5-1-Ingress介绍\" class=\"headerlink\" title=\"5.1 Ingress介绍\"></a>5.1 Ingress介绍</h2><h1 id=\"6-k8s的数据存储\"><a href=\"#6-k8s的数据存储\" class=\"headerlink\" title=\"6 k8s的数据存储\"></a>6 k8s的数据存储</h1><ul>\n<li>在前面已经提到，容器的生命周期可能很短，会被频繁的创建和销毁。那么容器在销毁的时候，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器中的数据，kubernetes引入了Volume的概念。</li>\n<li>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命周期不和Pod中的单个容器的生命周期有关，当容器终止或者重启的时候，Volume中的数据也不会丢失。</li>\n<li>kubernetes的Volume支持多种类型，比较常见的有下面的几个：<ul>\n<li>简单存储：EmptyDir、HostPath、NFS。</li>\n<li>高级存储：PV、PVC。</li>\n<li>配置存储：ConfigMap、Secret。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-1-基本存储\"><a href=\"#6-1-基本存储\" class=\"headerlink\" title=\"6.1 基本存储\"></a>6.1 基本存储</h2><h3 id=\"6-1-1-EmptyDir\"><a href=\"#6-1-1-EmptyDir\" class=\"headerlink\" title=\"6.1.1 EmptyDir\"></a>6.1.1 EmptyDir</h3><h3 id=\"6-1-2-HostPath\"><a href=\"#6-1-2-HostPath\" class=\"headerlink\" title=\"6.1.2 HostPath\"></a>6.1.2 HostPath</h3><h3 id=\"6-1-3-NFS\"><a href=\"#6-1-3-NFS\" class=\"headerlink\" title=\"6.1.3 NFS\"></a>6.1.3 NFS</h3><h2 id=\"6-2-高级存储\"><a href=\"#6-2-高级存储\" class=\"headerlink\" title=\"6.2 高级存储\"></a>6.2 高级存储</h2><h3 id=\"6-1-2-PV\"><a href=\"#6-1-2-PV\" class=\"headerlink\" title=\"6.1.2 PV\"></a>6.1.2 PV</h3><h3 id=\"6-1-3-PVC\"><a href=\"#6-1-3-PVC\" class=\"headerlink\" title=\"6.1.3 PVC\"></a>6.1.3 PVC</h3><h2 id=\"6-3-配置存储\"><a href=\"#6-3-配置存储\" class=\"headerlink\" title=\"6.3 配置存储\"></a>6.3 配置存储</h2><h3 id=\"6-1-2-ConfigMap\"><a href=\"#6-1-2-ConfigMap\" class=\"headerlink\" title=\"6.1.2 ConfigMap\"></a>6.1.2 ConfigMap</h3><h3 id=\"6-1-3-Secret\"><a href=\"#6-1-3-Secret\" class=\"headerlink\" title=\"6.1.3 Secret\"></a>6.1.3 Secret</h3><h1 id=\"7-高级部分（暂时不准备做）\"><a href=\"#7-高级部分（暂时不准备做）\" class=\"headerlink\" title=\"7 高级部分（暂时不准备做）\"></a>7 高级部分（暂时不准备做）</h1><h2 id=\"k8s的Helm\"><a href=\"#k8s的Helm\" class=\"headerlink\" title=\"k8s的Helm\"></a>k8s的Helm</h2><h2 id=\"k8s的安全认证\"><a href=\"#k8s的安全认证\" class=\"headerlink\" title=\"k8s的安全认证\"></a>k8s的安全认证</h2><h2 id=\"搭建DashBoard\"><a href=\"#搭建DashBoard\" class=\"headerlink\" title=\"搭建DashBoard\"></a>搭建DashBoard</h2><h2 id=\"kubeadm安装高可用k8s集群\"><a href=\"#kubeadm安装高可用k8s集群\" class=\"headerlink\" title=\"kubeadm安装高可用k8s集群\"></a>kubeadm安装高可用k8s集群</h2><h2 id=\"k8s的项目部署\"><a href=\"#k8s的项目部署\" class=\"headerlink\" title=\"k8s的项目部署\"></a>k8s的项目部署</h2>","slug":"Course/k8s-commad","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/09/25/Course/k8s-commad/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"VScode 环境安装","date":"22/09/2022","path":"2022/09/22/Environment-Configuration/vscode-install-tutorial/","text":"一、官网下载vscode二、安装安装的时候记得把将”通过 code打开”操作添加到 Windows资源管理器文件上下文菜单打钩 三、常用的扩展 扩展名 功能 通用的 Chinese (Simplified) (简体中文) 中文翻译 Code Runner 展开全部代码 Markdown Preview Enhanced Markdown查看 C++相关 C&#x2F;C++ 写C++代码 C&#x2F;C++ Extension CMake CMake Tools C&#x2F;C++ Extension Pack HTML Auto Rename Tag 自动修改前后标签名 open in browser 在浏览器中打开 CSS Peek 追踪CSS样式 HTML CSS Support HTML样式支持 Vue Live Server 保存后动态显示 Git Git History 查看git历史提交记录 GitLens Git Graph GoLang go 语法支持 vscode-proto3 查看protobuf格式 Jinja2 Jinja jinja语法支持 Shell shell-format 格式化工具 shellman 代码提示工具 远程控制 Remote - SSH 远程ssh连接 Remote - Containers Remote - SSH: Editing Configuration Files 五、配置c&#x2F;c++环境 安装mingw ctl+shift+PC&#x2F;C++: Edit Configurations (UI)编译器路径D:\\MinGW\\bin\\gcc.exe c++调试的原理 先使用tasks.json来创建一个任务 tasks.json文件可以对程序进行编译，对于C++来说，可以使用gcc,g++,make,cmake,shell脚本 可以先测试task能否正常运行，这一步的测试就是测试程序是否能编译通过 通过launch.json调用想要使用的任务这是启动vscode的调试功能需要做一些配置再启动gdb调试器来进行调试 添加c_cpp_properties.json增加C++的语言支持 使用步骤创建一个.vscode文件夹 1.tasks.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;cplusplustest&quot;, //任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置 &quot;type&quot;: &quot;shell&quot;, // &quot;command&quot;: &quot;g++ ./123.cpp -o 123 -g -std=c++11&quot;, // 可以使用一行命令的方法，不需要下面添加参数 &quot;command&quot;: &quot;g++&quot;, // 或者就只写g++,下面添加参数 // &quot;args&quot;: [//编译时候的参数 // &quot;./123.cpp&quot;, // 想要调试的文件，可以写相对路径也可以写绝对路径 // &quot;-o&quot;, // 指定生成可执行文件的名称 // &quot;debug.exe&quot;, // 如果不加后缀名，自动会添加.exe // &quot;-g&quot;, // 添加gdb调试选项 // &quot;-std=c++11&quot; // 使用C++11标准 // ], &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, // 自动查找当前执行的文件 &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, // 设置生成的文件名，可以为中文 &quot;-std=c++11&quot;, // &quot;-fexec-charset=GBK&quot; //解决中文乱码问题,还没有遇到过 ], &quot;problemMatcher&quot;: &#123; // &quot;owner&quot;: &quot;cpp&quot;, // &quot;fileLocation&quot;: [ // &quot;relative&quot;, // &quot;$&#123;workspaceRoot&#125;&quot; // ], // &quot;pattern&quot;: &#123; // &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, // &quot;file&quot;: 1, // &quot;line&quot;: 2, // &quot;column&quot;: 3, // &quot;severity&quot;: 4, // &quot;message&quot;: 5 // &#125; &#125;, // 问题分析器,还不太会用 &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true //表示快捷键Ctrl+Shift+B可以运行该任务 &#125;, &#125; ]&#125; 2.launch.json12345678910111213141516171819202122232425262728293031323334&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;preLaunchTask&quot;: &quot;cplusplustest&quot;, //调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 &quot;name&quot;: &quot;(gdb) Debug&quot;, //配置文件的名字，可以随便起 &quot;type&quot;: &quot;cppdbg&quot;, //调试的类型，Vscode现在支持很多，我这里主要是C，所以只能是cppdbg &quot;request&quot;: &quot;launch&quot;, //配置文件的请求类型，有launch和attach两种，具体看官方文档 &quot;targetArchitecture&quot;: &quot;x64&quot;, //硬件内核架构，为64bit，如图设置 // &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/123.exe&quot;, //可执行文件的路径和文件名称 &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, //可执行文件的路径和文件名称 // 整个路径名中，必须全部是是英文名称才可以进行调试 &quot;args&quot;: [], //主函数调用时传入的参数 &quot;stopAtEntry&quot;: false, //设为true时程序将暂停在程序入口处 &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/1-Algorithm_test&quot;, //调试时的工作目录 &quot;environment&quot;: [], //不知道干嘛的 &quot;internalConsoleOptions&quot;: &quot;openOnSessionStart&quot;, &quot;externalConsole&quot;: false, //调试时是否显示控制台窗口 &quot;MIMode&quot;: &quot;gdb&quot;, //指定连接的调试器，可以省略不写 &quot;miDebuggerPath&quot;: &quot;D:/Qt/Qt5.9.9/Tools/mingw530_32/bin/gdb.exe&quot;, // 在windows调试的时候，需要加上gdb的路径 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; 3.c_cpp_properties.json12345678910111213141516171819202122232425262728293031323334// https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference//.vscode文件夹局部的配置c_cpp_properties.json&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ // 这个是使用头文件时候vscode查找的路径，如果路径没有包含进来，头文件会有红色波浪线 &quot;$&#123;workspaceFolder&#125;/**&quot;, // 当前工作目录下包含的所有文件 &quot;/vcpkg/x64-linux/installed/x64-linux/include/**&quot;, // 路径错误或者不存在看起来可以运行 &quot;D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**&quot; ], &quot;defines&quot;: [// 这里定义的头文件在程序中使用的时候，#ifndef的内容不会灰色 &quot;F_OS_LINUX&quot;, &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot;, &quot;LOCAL&quot; ], &quot;cStandard&quot;: &quot;c17&quot;, // 指定c语言使用的语法版本 &quot;cppStandard&quot;: &quot;c++17&quot;, // 指定c++使用的语法版本 &quot;intelliSenseMode&quot;: &quot;linux-gcc-x64&quot;, // 使用智能感知模式(IntelliSense)，映射到特定的体系 // &quot;intelliSenseMode&quot;: &quot;windows-gcc-x86&quot;, // windows中使用的配置 &quot;browse&quot;: &#123; // 浏览选项，主要用在转跳#include文件的时候，可以做一些模糊搜索 &quot;path&quot;: [ // 需要查找的路径 &quot;$&#123;workspaceFolder&#125;&quot;, &quot;D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**&quot;, ], &quot;limitSymbolsToIncludedHeaders&quot;: true, // 如果为true,只解析$&#123;workspaceFolder&#125;中的文件，false还会解析browse中的文件，存疑 &quot;databaseFilename&quot;: &quot;&quot; &#125; &#125; ], &quot;version&quot;: 4&#125; 关于调试的一些疑问 使用了C++11的语法，但是C++11的语句，比如auto还是会报错c_cpp_properties.json中添加12&quot;cStandard&quot;: &quot;c17&quot;,&quot;cppStandard&quot;: &quot;c++17&quot;, 使用了外部的库，比如opencv,QThread等库的时候，编译可以通过但是无法转跳没有在include中增加包含库的路径 四、卸载C:\\Users$用户名.vscodeC:\\Users$用户名\\AppData\\Roaming\\Code【注】这里的“$用户名”根据自己的用户名而定。 参考文献mingw安装教程VSCode 任务配置参数及任务结果分析-problemMatcher[VSCode配置C&#x2F;C++环境]https://zhuanlan.zhihu.com/p/87864677[VScode配置c&#x2F;c++环境（无数试错版本）]https://blog.csdn.net/Pretty_Anno/article/details/126978142[windwos11没有Hyper-V的解决方法]https://www.jianshu.com/p/96aa6eeacb56","raw":"---\ntitle: VScode 环境安装\ndate: 2022-09-22 16:30:31\ntags:\n- 环境配置\n---\n\n# 一、官网下载vscode\n\n# 二、安装\n\n安装的时候记得把\n将\"通过 code打开\"操作添加到 Windows资源管理器文件上下文菜单\n打钩\n\n# 三、常用的扩展\n\n| 扩展名 | 功能 | \n| ---- | ---- | \n| **通用的** | \n| Chinese (Simplified) (简体中文) | 中文翻译 | \n| Code Runner | 展开全部代码 | \n| Markdown Preview Enhanced | Markdown查看 | \n| C++相关 | |\n| **C/C++**| 写C++代码 | \n| C/C++ Extension | | \n| CMake |  | \n| CMake Tools |  | \n| C/C++ Extension Pack |  | \n| **HTML** | |\n| Auto Rename Tag | 自动修改前后标签名 | \n| open in browser | 在浏览器中打开 | \n| CSS Peek | 追踪CSS样式 | \n| HTML CSS Support | HTML样式支持 | \n| **Vue** | |\n| Live Server | 保存后动态显示 | \n| **Git** | |\n| Git History | 查看git历史提交记录 | \n| GitLens  |  | \n| Git Graph  |  | \n| **GoLang** | |\n| go | 语法支持 | \n| vscode-proto3  | 查看protobuf格式 | \n| **Jinja2** | |\n| Jinja | jinja语法支持 | \n| **Shell** | |\n| shell-format | 格式化工具 | \n| shellman | 代码提示工具 | \n| **远程控制** | |\n| Remote - SSH | 远程ssh连接 | \n| Remote - Containers |  | \n|Remote - SSH: Editing Configuration Files | |\n\n\n# 五、配置c/c++环境\n\n1. 安装mingw\n2. ctl+shift+P\nC/C++: Edit Configurations (UI)\n编译器路径\nD:\\MinGW\\bin\\gcc.exe\n\n## c++调试的原理\n1. 先使用tasks.json来创建一个任务\n- tasks.json文件可以对程序进行编译，对于C++来说，可以使用gcc,g++,make,cmake,shell脚本\n- 可以先测试task能否正常运行，这一步的测试就是测试程序是否能编译通过\n2. 通过launch.json调用想要使用的任务\n这是启动vscode的调试功能\n需要做一些配置\n再启动gdb调试器来进行调试\n3. 添加c_cpp_properties.json增加C++的语言支持\n\n## 使用步骤\n创建一个.vscode文件夹\n\n### 1.tasks.json\n```json\n{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558 \n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"cplusplustest\",   //任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置\n            \"type\": \"shell\",\n            // \"command\": \"g++ ./123.cpp -o 123 -g -std=c++11\", // 可以使用一行命令的方法，不需要下面添加参数\n            \"command\": \"g++\",   // 或者就只写g++,下面添加参数\n            // \"args\": [//编译时候的参数\n            //     \"./123.cpp\",    // 想要调试的文件，可以写相对路径也可以写绝对路径\n            //     \"-o\",           // 指定生成可执行文件的名称\n            //     \"debug.exe\",    // 如果不加后缀名，自动会添加.exe\n            //     \"-g\",           // 添加gdb调试选项\n            //     \"-std=c++11\"    // 使用C++11标准\n            // ],\n            \"args\": [\n                \"-g\",\n                \"${file}\",   // 自动查找当前执行的文件\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",   // 设置生成的文件名，可以为中文\n                \"-std=c++11\",\n                // \"-fexec-charset=GBK\" //解决中文乱码问题,还没有遇到过\n            ],\n            \"problemMatcher\": {\n                // \"owner\": \"cpp\",\n                // \"fileLocation\": [\n                //     \"relative\",\n                //     \"${workspaceRoot}\"\n                // ],\n                // \"pattern\": {\n                //     \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",\n                //     \"file\": 1,\n                //     \"line\": 2,\n                //     \"column\": 3,\n                //     \"severity\": 4,\n                //     \"message\": 5\n                // }\n            },   // 问题分析器,还不太会用\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true   //表示快捷键Ctrl+Shift+B可以运行该任务\n            },\n        }\n    ]\n}\n\n```\n\n### 2.launch.json\n```json\n{\n    // 使用 IntelliSense 了解相关属性。\n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"preLaunchTask\": \"cplusplustest\", //调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应\n            \"name\": \"(gdb) Debug\",       //配置文件的名字，可以随便起\n            \"type\": \"cppdbg\",           //调试的类型，Vscode现在支持很多，我这里主要是C，所以只能是cppdbg\n            \"request\": \"launch\",        //配置文件的请求类型，有launch和attach两种，具体看官方文档\n            \"targetArchitecture\": \"x64\", //硬件内核架构，为64bit，如图设置\n            // \"program\": \"${workspaceFolder}/123.exe\",   //可执行文件的路径和文件名称\n            \"program\": \"${fileDirname}/${fileBasenameNoExtension}.exe\",   //可执行文件的路径和文件名称\n            // 整个路径名中，必须全部是是英文名称才可以进行调试\n            \"args\": [],                 //主函数调用时传入的参数\n            \"stopAtEntry\": false,       //设为true时程序将暂停在程序入口处\n            \"cwd\": \"${workspaceFolder}/1-Algorithm_test\",    //调试时的工作目录\n            \"environment\": [],          //不知道干嘛的\n            \"internalConsoleOptions\": \"openOnSessionStart\",\n            \"externalConsole\": false,   //调试时是否显示控制台窗口\n            \"MIMode\": \"gdb\",            //指定连接的调试器，可以省略不写\n            \"miDebuggerPath\": \"D:/Qt/Qt5.9.9/Tools/mingw530_32/bin/gdb.exe\",    // 在windows调试的时候，需要加上gdb的路径\n            \"setupCommands\": [\n                {\n                    \"description\": \"为 gdb 启用整齐打印\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ]\n        }\n    ]\n}\n\n```\n\n### 3.c_cpp_properties.json\n```json\n// https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference\n//.vscode文件夹局部的配置c_cpp_properties.json\n{\n    \"configurations\": [\n        {\n            \"name\": \"Linux\",\n            \"includePath\": [            // 这个是使用头文件时候vscode查找的路径，如果路径没有包含进来，头文件会有红色波浪线\n                \"${workspaceFolder}/**\", // 当前工作目录下包含的所有文件\n                \"/vcpkg/x64-linux/installed/x64-linux/include/**\",  // 路径错误或者不存在看起来可以运行\n                \"D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**\"\n            ],\n            \"defines\": [// 这里定义的头文件在程序中使用的时候，#ifndef的内容不会灰色\n                \"F_OS_LINUX\",         \n                \"_DEBUG\",\n                \"UNICODE\",\n                \"_UNICODE\",\n                \"LOCAL\"\n            ],\n            \"cStandard\": \"c17\",       // 指定c语言使用的语法版本\n            \"cppStandard\": \"c++17\",   // 指定c++使用的语法版本\n            \"intelliSenseMode\": \"linux-gcc-x64\", // 使用智能感知模式(IntelliSense)，映射到特定的体系\n            // \"intelliSenseMode\": \"windows-gcc-x86\",   // windows中使用的配置\n            \"browse\": { // 浏览选项，主要用在转跳#include文件的时候，可以做一些模糊搜索\n                \"path\": [   // 需要查找的路径\n                    \"${workspaceFolder}\",\n                    \"D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**\",\n                ],\n                \"limitSymbolsToIncludedHeaders\": true,  // 如果为true,只解析${workspaceFolder}中的文件，false还会解析browse中的文件，存疑\n                \"databaseFilename\": \"\"\n            }\n        }\n    ],\n    \"version\": 4\n}\n```\n\n\n### 关于调试的一些疑问\n1. 使用了C++11的语法，但是C++11的语句，比如auto还是会报错\nc_cpp_properties.json中添加\n```json\n\"cStandard\": \"c17\",\n\"cppStandard\": \"c++17\",\n```\n2. 使用了外部的库，比如opencv,QThread等库的时候，编译可以通过但是无法转跳\n没有在include中增加包含库的路径\n\n# 四、卸载\nC:\\Users\\$用户名\\.vscode\nC:\\Users\\$用户名\\AppData\\Roaming\\Code【注】这里的“$用户名”根据自己的用户名而定。\n\n# 参考文献\n[mingw安装教程](https://www.cnblogs.com/LIJIH/p/12533926.html#:~:text=%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85mingw%E8%BD%AF%E4%BB%B6%201.%20%E8%BF%9B%E5%85%A5%E5%AE%98%E7%BD%91%20www.mingw.org%202.%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BDdownloads%203.%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E5%9B%BE%E6%A0%87%204.%E7%82%B9%E5%87%BBinstall%20z,Changes%204.%E7%82%B9%E5%87%BBapply%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%205.%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%9C%A8%E7%82%B9%E5%87%BBclose%E5%85%B3%E9%97%AD%E8%BD%AF%E4%BB%B6%EF%BC%8C%E5%88%B0%E8%BF%99%E9%87%8Cmingw%E5%B0%B1%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E4%BA%86%E3%80%82%20%E4%B8%8B%E9%9D%A2%E5%B0%B1%E6%98%AF%E9%85%8D%E7%BD%AE%20%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%201%E9%80%89%E6%8B%A9%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%EF%BC%8C%E5%8F%B3%E9%94%AE%E9%80%89%E6%8B%A9%E5%B1%9E%E6%80%A7%202.%E9%80%89%E6%8B%A9%E9%AB%98%E7%BA%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%203.%E9%80%89%E6%8B%A9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n[VSCode 任务配置参数及任务结果分析-problemMatcher](https://geek-docs.com/vscode/vscode-tutorials/vscode-task-configuration-parameters-and-task-results-analysis.html#:~:text=%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E7%94%B1%20tasks.json%20%E9%87%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%20problemMatcher,%E6%9D%A5%E6%8E%A7%E5%88%B6%E7%9A%84%E3%80%82%20%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%20VS%20Code%20%E5%86%85%E7%BD%AE%E7%9A%84%EF%BC%8C%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%8C%E7%94%9A%E8%87%B3%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E4%B9%A6%E5%86%99%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%99%A8%E6%9D%A5%E5%88%86%E6%9E%90%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E5%85%B6%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%E6%88%96%E8%80%85%E8%AD%A6%E5%91%8A%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%9C%A8%E9%97%AE%E9%A2%98%E9%9D%A2%E6%9D%BF%E4%B8%AD%E3%80%82)\n[VSCode配置C/C++环境]https://zhuanlan.zhihu.com/p/87864677\n[VScode配置c/c++环境（无数试错版本）]https://blog.csdn.net/Pretty_Anno/article/details/126978142\n[windwos11没有Hyper-V的解决方法]https://www.jianshu.com/p/96aa6eeacb56\n\n\n\n","content":"<h1 id=\"一、官网下载vscode\"><a href=\"#一、官网下载vscode\" class=\"headerlink\" title=\"一、官网下载vscode\"></a>一、官网下载vscode</h1><h1 id=\"二、安装\"><a href=\"#二、安装\" class=\"headerlink\" title=\"二、安装\"></a>二、安装</h1><p>安装的时候记得把<br>将”通过 code打开”操作添加到 Windows资源管理器文件上下文菜单<br>打钩</p>\n<h1 id=\"三、常用的扩展\"><a href=\"#三、常用的扩展\" class=\"headerlink\" title=\"三、常用的扩展\"></a>三、常用的扩展</h1><table>\n<thead>\n<tr>\n<th>扩展名</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>通用的</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Chinese (Simplified) (简体中文)</td>\n<td>中文翻译</td>\n</tr>\n<tr>\n<td>Code Runner</td>\n<td>展开全部代码</td>\n</tr>\n<tr>\n<td>Markdown Preview Enhanced</td>\n<td>Markdown查看</td>\n</tr>\n<tr>\n<td>C++相关</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>C&#x2F;C++</strong></td>\n<td>写C++代码</td>\n</tr>\n<tr>\n<td>C&#x2F;C++ Extension</td>\n<td></td>\n</tr>\n<tr>\n<td>CMake</td>\n<td></td>\n</tr>\n<tr>\n<td>CMake Tools</td>\n<td></td>\n</tr>\n<tr>\n<td>C&#x2F;C++ Extension Pack</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>HTML</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Auto Rename Tag</td>\n<td>自动修改前后标签名</td>\n</tr>\n<tr>\n<td>open in browser</td>\n<td>在浏览器中打开</td>\n</tr>\n<tr>\n<td>CSS Peek</td>\n<td>追踪CSS样式</td>\n</tr>\n<tr>\n<td>HTML CSS Support</td>\n<td>HTML样式支持</td>\n</tr>\n<tr>\n<td><strong>Vue</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Live Server</td>\n<td>保存后动态显示</td>\n</tr>\n<tr>\n<td><strong>Git</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Git History</td>\n<td>查看git历史提交记录</td>\n</tr>\n<tr>\n<td>GitLens</td>\n<td></td>\n</tr>\n<tr>\n<td>Git Graph</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>GoLang</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>go</td>\n<td>语法支持</td>\n</tr>\n<tr>\n<td>vscode-proto3</td>\n<td>查看protobuf格式</td>\n</tr>\n<tr>\n<td><strong>Jinja2</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Jinja</td>\n<td>jinja语法支持</td>\n</tr>\n<tr>\n<td><strong>Shell</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>shell-format</td>\n<td>格式化工具</td>\n</tr>\n<tr>\n<td>shellman</td>\n<td>代码提示工具</td>\n</tr>\n<tr>\n<td><strong>远程控制</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Remote - SSH</td>\n<td>远程ssh连接</td>\n</tr>\n<tr>\n<td>Remote - Containers</td>\n<td></td>\n</tr>\n<tr>\n<td>Remote - SSH: Editing Configuration Files</td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"五、配置c-x2F-c-环境\"><a href=\"#五、配置c-x2F-c-环境\" class=\"headerlink\" title=\"五、配置c&#x2F;c++环境\"></a>五、配置c&#x2F;c++环境</h1><ol>\n<li>安装mingw</li>\n<li>ctl+shift+P<br>C&#x2F;C++: Edit Configurations (UI)<br>编译器路径<br>D:\\MinGW\\bin\\gcc.exe</li>\n</ol>\n<h2 id=\"c-调试的原理\"><a href=\"#c-调试的原理\" class=\"headerlink\" title=\"c++调试的原理\"></a>c++调试的原理</h2><ol>\n<li>先使用tasks.json来创建一个任务</li>\n</ol>\n<ul>\n<li>tasks.json文件可以对程序进行编译，对于C++来说，可以使用gcc,g++,make,cmake,shell脚本</li>\n<li>可以先测试task能否正常运行，这一步的测试就是测试程序是否能编译通过</li>\n</ul>\n<ol start=\"2\">\n<li>通过launch.json调用想要使用的任务<br>这是启动vscode的调试功能<br>需要做一些配置<br>再启动gdb调试器来进行调试</li>\n<li>添加c_cpp_properties.json增加C++的语言支持</li>\n</ol>\n<h2 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h2><p>创建一个.vscode文件夹</p>\n<h3 id=\"1-tasks-json\"><a href=\"#1-tasks-json\" class=\"headerlink\" title=\"1.tasks.json\"></a>1.tasks.json</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span></span><br><span class=\"line\">    <span class=\"comment\">// for the documentation about the tasks.json format</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tasks&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;label&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cplusplustest&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">//任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;shell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;command&quot;: &quot;g++ ./123.cpp -o 123 -g -std=c++11&quot;, // 可以使用一行命令的方法，不需要下面添加参数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;g++&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 或者就只写g++,下面添加参数</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;args&quot;: [//编译时候的参数</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;./123.cpp&quot;,    // 想要调试的文件，可以写相对路径也可以写绝对路径</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;-o&quot;,           // 指定生成可执行文件的名称</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;debug.exe&quot;,    // 如果不加后缀名，自动会添加.exe</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;-g&quot;,           // 添加gdb调试选项</span></span><br><span class=\"line\">            <span class=\"comment\">//     &quot;-std=c++11&quot;    // 使用C++11标准</span></span><br><span class=\"line\">            <span class=\"comment\">// ],</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-g&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;file&#125;&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 自动查找当前执行的文件</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-o&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 设置生成的文件名，可以为中文</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-std=c++11&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"comment\">// &quot;-fexec-charset=GBK&quot; //解决中文乱码问题,还没有遇到过</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;problemMatcher&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"comment\">// &quot;owner&quot;: &quot;cpp&quot;,</span></span><br><span class=\"line\">                <span class=\"comment\">// &quot;fileLocation&quot;: [</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;relative&quot;,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;$&#123;workspaceRoot&#125;&quot;</span></span><br><span class=\"line\">                <span class=\"comment\">// ],</span></span><br><span class=\"line\">                <span class=\"comment\">// &quot;pattern&quot;: &#123;</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;file&quot;: 1,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;line&quot;: 2,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;column&quot;: 3,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;severity&quot;: 4,</span></span><br><span class=\"line\">                <span class=\"comment\">//     &quot;message&quot;: 5</span></span><br><span class=\"line\">                <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 问题分析器,还不太会用</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;group&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;kind&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;build&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;isDefault&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">true</span>   <span class=\"comment\">//表示快捷键Ctrl+Shift+B可以运行该任务</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-launch-json\"><a href=\"#2-launch-json\" class=\"headerlink\" title=\"2.launch.json\"></a>2.launch.json</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用 IntelliSense 了解相关属性。</span></span><br><span class=\"line\">    <span class=\"comment\">// 悬停以查看现有属性的描述。</span></span><br><span class=\"line\">    <span class=\"comment\">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.2.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;preLaunchTask&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cplusplustest&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">//调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;(gdb) Debug&quot;</span><span class=\"punctuation\">,</span>       <span class=\"comment\">//配置文件的名字，可以随便起</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cppdbg&quot;</span><span class=\"punctuation\">,</span>           <span class=\"comment\">//调试的类型，Vscode现在支持很多，我这里主要是C，所以只能是cppdbg</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;request&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;launch&quot;</span><span class=\"punctuation\">,</span>        <span class=\"comment\">//配置文件的请求类型，有launch和attach两种，具体看官方文档</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;targetArchitecture&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;x64&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">//硬件内核架构，为64bit，如图设置</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/123.exe&quot;,   //可执行文件的路径和文件名称</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;program&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">//可执行文件的路径和文件名称</span></span><br><span class=\"line\">            <span class=\"comment\">// 整个路径名中，必须全部是是英文名称才可以进行调试</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>                 <span class=\"comment\">//主函数调用时传入的参数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;stopAtEntry&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">false</span><span class=\"punctuation\">,</span>       <span class=\"comment\">//设为true时程序将暂停在程序入口处</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cwd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;workspaceFolder&#125;/1-Algorithm_test&quot;</span><span class=\"punctuation\">,</span>    <span class=\"comment\">//调试时的工作目录</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;environment&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>          <span class=\"comment\">//不知道干嘛的</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;internalConsoleOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;openOnSessionStart&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;externalConsole&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">false</span><span class=\"punctuation\">,</span>   <span class=\"comment\">//调试时是否显示控制台窗口</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;MIMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gdb&quot;</span><span class=\"punctuation\">,</span>            <span class=\"comment\">//指定连接的调试器，可以省略不写</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;miDebuggerPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/Qt/Qt5.9.9/Tools/mingw530_32/bin/gdb.exe&quot;</span><span class=\"punctuation\">,</span>    <span class=\"comment\">// 在windows调试的时候，需要加上gdb的路径</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;setupCommands&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;为 gdb 启用整齐打印&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;text&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;-enable-pretty-printing&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;ignoreFailures&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">true</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-c-cpp-properties-json\"><a href=\"#3-c-cpp-properties-json\" class=\"headerlink\" title=\"3.c_cpp_properties.json\"></a>3.c_cpp_properties.json</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference</span></span><br><span class=\"line\"><span class=\"comment\">//.vscode文件夹局部的配置c_cpp_properties.json</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Linux&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;includePath&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span>            <span class=\"comment\">// 这个是使用头文件时候vscode查找的路径，如果路径没有包含进来，头文件会有红色波浪线</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 当前工作目录下包含的所有文件</span></span><br><span class=\"line\">                <span class=\"string\">&quot;/vcpkg/x64-linux/installed/x64-linux/include/**&quot;</span><span class=\"punctuation\">,</span>  <span class=\"comment\">// 路径错误或者不存在看起来可以运行</span></span><br><span class=\"line\">                <span class=\"string\">&quot;D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;defines&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"comment\">// 这里定义的头文件在程序中使用的时候，#ifndef的内容不会灰色</span></span><br><span class=\"line\">                <span class=\"string\">&quot;F_OS_LINUX&quot;</span><span class=\"punctuation\">,</span>         </span><br><span class=\"line\">                <span class=\"string\">&quot;_DEBUG&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;UNICODE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;_UNICODE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;LOCAL&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c17&quot;</span><span class=\"punctuation\">,</span>       <span class=\"comment\">// 指定c语言使用的语法版本</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cppStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c++17&quot;</span><span class=\"punctuation\">,</span>   <span class=\"comment\">// 指定c++使用的语法版本</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;intelliSenseMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;linux-gcc-x64&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 使用智能感知模式(IntelliSense)，映射到特定的体系</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;intelliSenseMode&quot;: &quot;windows-gcc-x86&quot;,   // windows中使用的配置</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;browse&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> <span class=\"comment\">// 浏览选项，主要用在转跳#include文件的时候，可以做一些模糊搜索</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;path&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span>   <span class=\"comment\">// 需要查找的路径</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;D:\\\\MinGW\\\\lib\\\\gcc\\\\mingw32\\\\9.2.0\\\\**&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;limitSymbolsToIncludedHeaders&quot;</span><span class=\"punctuation\">:</span> <span class=\"keyword\">true</span><span class=\"punctuation\">,</span>  <span class=\"comment\">// 如果为true,只解析$&#123;workspaceFolder&#125;中的文件，false还会解析browse中的文件，存疑</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;databaseFilename&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"关于调试的一些疑问\"><a href=\"#关于调试的一些疑问\" class=\"headerlink\" title=\"关于调试的一些疑问\"></a>关于调试的一些疑问</h3><ol>\n<li>使用了C++11的语法，但是C++11的语句，比如auto还是会报错<br>c_cpp_properties.json中添加<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;cStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c17&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;cppStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c++17&quot;</span><span class=\"punctuation\">,</span></span><br></pre></td></tr></table></figure></li>\n<li>使用了外部的库，比如opencv,QThread等库的时候，编译可以通过但是无法转跳<br>没有在include中增加包含库的路径</li>\n</ol>\n<h1 id=\"四、卸载\"><a href=\"#四、卸载\" class=\"headerlink\" title=\"四、卸载\"></a>四、卸载</h1><p>C:\\Users$用户名.vscode<br>C:\\Users$用户名\\AppData\\Roaming\\Code【注】这里的“$用户名”根据自己的用户名而定。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://www.cnblogs.com/LIJIH/p/12533926.html#:~:text=%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85mingw%E8%BD%AF%E4%BB%B6%201.%20%E8%BF%9B%E5%85%A5%E5%AE%98%E7%BD%91%20www.mingw.org%202.%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BDdownloads%203.%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E5%9B%BE%E6%A0%87%204.%E7%82%B9%E5%87%BBinstall%20z,Changes%204.%E7%82%B9%E5%87%BBapply%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%205.%E7%AD%89%E5%BE%85%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%9C%A8%E7%82%B9%E5%87%BBclose%E5%85%B3%E9%97%AD%E8%BD%AF%E4%BB%B6%EF%BC%8C%E5%88%B0%E8%BF%99%E9%87%8Cmingw%E5%B0%B1%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E4%BA%86%E3%80%82%20%E4%B8%8B%E9%9D%A2%E5%B0%B1%E6%98%AF%E9%85%8D%E7%BD%AE%20%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%201%E9%80%89%E6%8B%A9%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%EF%BC%8C%E5%8F%B3%E9%94%AE%E9%80%89%E6%8B%A9%E5%B1%9E%E6%80%A7%202.%E9%80%89%E6%8B%A9%E9%AB%98%E7%BA%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%203.%E9%80%89%E6%8B%A9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">mingw安装教程</a><br><a href=\"https://geek-docs.com/vscode/vscode-tutorials/vscode-task-configuration-parameters-and-task-results-analysis.html#:~:text=%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E7%94%B1%20tasks.json%20%E9%87%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%20problemMatcher,%E6%9D%A5%E6%8E%A7%E5%88%B6%E7%9A%84%E3%80%82%20%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%20VS%20Code%20%E5%86%85%E7%BD%AE%E7%9A%84%EF%BC%8C%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%8C%E7%94%9A%E8%87%B3%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E4%B9%A6%E5%86%99%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%99%A8%E6%9D%A5%E5%88%86%E6%9E%90%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E5%85%B6%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%E6%88%96%E8%80%85%E8%AD%A6%E5%91%8A%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%9C%A8%E9%97%AE%E9%A2%98%E9%9D%A2%E6%9D%BF%E4%B8%AD%E3%80%82\">VSCode 任务配置参数及任务结果分析-problemMatcher</a><br>[VSCode配置C&#x2F;C++环境]<a href=\"https://zhuanlan.zhihu.com/p/87864677\">https://zhuanlan.zhihu.com/p/87864677</a><br>[VScode配置c&#x2F;c++环境（无数试错版本）]<a href=\"https://blog.csdn.net/Pretty_Anno/article/details/126978142\">https://blog.csdn.net/Pretty_Anno/article/details/126978142</a><br>[windwos11没有Hyper-V的解决方法]<a href=\"https://www.jianshu.com/p/96aa6eeacb56\">https://www.jianshu.com/p/96aa6eeacb56</a></p>\n","slug":"Environment-Configuration/vscode-install-tutorial","updated":"18/01/2023","comments":true,"link":"","permalink":"http://example.com/2022/09/22/Environment-Configuration/vscode-install-tutorial/","excerpt":"","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"leetcode题目分类","date":"19/09/2022","path":"2022/09/19/Interview-Q&A/leetcode-programe/","text":"字典树(Trie树、前缀树)模板题 实现 Trie (前缀树) 单词替换 添加与搜索单词 - 数据结构设计 键值映射 实现一个魔法字典 前缀和后缀搜索 字符串的前缀分数和 进阶：01字典树 环检测 &amp; 拓扑排序 课程表 课程表 II剑指 Offer II 115. 重建序列 回溯 划分为k个相等的子集 火柴拼正方形 公平分发饼干 思路：1.回溯前的准备2.要回溯什么回溯函数内3.终止条件4.进入和退出怎么搞 递推递归使用递归树的方法来判断问题 回溯-》记忆化搜索-》动态规划 动态规划思路： 确定dp数组以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序5. 举例推导dp数组 写代码顺序： 边界条件（最后考虑） 初始化 遍历 递推公式 返回 记忆化搜索 Leetcode 140 单词拆分 II Leetcode 472 连接词 10题正则表达式匹配 第37题解数独 区间dp 当问题可以分解为若干个子区间，并且子区间之间有一定的联系或者约束时，可以考虑用区间dp来求解 合并、匹配、划分 石子合并、括号匹配、回文串、邮局建设 合并石头的最低成本 而状态转移方程一般是枚举区间内的一个分割点 如dp [i] [j] &#x3D; min {dp [i] [k]+dp [k+1] [j]+cost} 能解决的问题： 1.求最大值&#x2F;最小值 最佳观光组合 买卖股票的最佳时机 买卖股票的最佳时机 II剑指 Offer 47. 礼物的最大价值剑指 Offer 42. 连续子数组的最大和 下降路径最小和 三角形最小路径和 2.求是否可以完成组合 单词拆分 3.求子数组 个数&#x2F;最大值&#x2F;长度 等差数列划分 4.组合总数剑指 Offer 10- II. 青蛙跳台阶问题剑指 Offer 46. 把数字翻译成字符串 5.最少操作数 编辑距离 贪心 跳跃游戏 跳跃游戏 II 测试用例的设计边界条件的测试0最大值 功能测试 前缀和 一维前缀和 二维前缀和 第一题就是基本的读入字符串排序，忘记细节了。 第二题是读入一01串，对应的下标为士兵的能力，0代表攻击士兵，1代表防守士兵，找到一个分割点，使得左侧攻击士兵和右侧防御士兵差的绝对值最小。这题直接用一个求和数组记录遍历就能过。 第三题是给定一个数组，删掉下标不为质数的值，然后合并起来循环操作，求最后一个数。这题是能找到规律，在某个区间的答案会是一个定值。直接暴力解了。 第四题是给多个环形链表的部分（可以重叠），把他们串起来然后切开形成最小字典序。这题主要是记录一下链表顺序，正逆比较一下就可以 第五题买股票进阶版，给定本金，每天都可以买入卖出1笔，而且可以手里留存多笔股票，求最大利润。这题不太会做，暴力DFS做的只过了50，蹲个大佬 做了4个半，最近一个月才开始补算法，难点的题就做不出来了，以及我是用python写的，可能时间复杂度要求和C++比会有些差别 参考资料[详解前缀树「TrieTree 汇总级别整理 🔥🔥🔥」]https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/前缀和 前缀异或Codeforces游玩攻略Codeforces快速精通ACM-高精度模板(综合篇)C++ lambda表达式与函数对象https://codeforces.com/blog/entry/66715https://codeforces.com/blog/entry/66909 区间dp(区间dp) 力扣区间dp 题集记录[力扣] DP问题分类汇总区间dp入门——总结+习题+解析OI Wiki 记忆化搜索LeetCode刷题总结 — 记忆化搜索框架","raw":"---\ntitle: leetcode题目分类\ndate: 2022-09-19 10:20:27\ntags:\n- 面试\n---\n\n\n## 字典树(Trie树、前缀树)\n### 模板题\n208. 实现 Trie (前缀树)\n648. 单词替换\n\n\n211. 添加与搜索单词 - 数据结构设计\n677. 键值映射\n676. 实现一个魔法字典\n745. 前缀和后缀搜索\n6183. 字符串的前缀分数和\n\n进阶：01字典树\n\n## 环检测 & 拓扑排序\n207. 课程表\n210. 课程表 II\n剑指 Offer II 115. 重建序列\n\n\n## 回溯\n698. 划分为k个相等的子集\n473. 火柴拼正方形\n2305. 公平分发饼干\n\n\n\n思路：\n1.回溯前的准备\n2.要回溯什么\n回溯函数内\n3.终止条件\n4.进入和退出怎么搞\n\n\n## 递推\n## 递归\n使用递归树的方法来判断问题\n\n\n回溯-》记忆化搜索-》动态规划\n## 动态规划\n\n\n思路：\n1. 确定dp数组以及下标的含义\n2. 确定递推公式\n3. dp数组如何初始化\n4. 确定遍历顺序\n~~5. 举例推导dp数组~~\n\n写代码顺序：\n\n0. 边界条件（最后考虑）\n1. 初始化\n2. 遍历\n3. 递推公式\n4. 返回\n\n\n1. 记忆化搜索\n   1. Leetcode 140 单词拆分 II\n   <!-- 2. Leetcode 329 矩阵中的最长递增路径 -->\n   3. Leetcode 472 连接词\n   4. 10题正则表达式匹配\n   5. 第37题解数独\n   <!-- 6. 397. 整数替换 -->\n2. 区间dp\n   1. 当问题可以分解为若干个子区间，并且子区间之间有一定的联系或者约束时，可以考虑用区间dp来求解\n   2. 合并、匹配、划分\n   3. 石子合并、括号匹配、回文串、邮局建设\n   4. 1000. 合并石头的最低成本\n   5. 而状态转移方程一般是枚举区间内的一个分割点\n      1. 如dp [i] [j] = min {dp [i] [k]+dp [k+1] [j]+cost}\n\n\n\n能解决的问题：\n## 1.求最大值/最小值\n1014. 最佳观光组合\n121. 买卖股票的最佳时机\n122. 买卖股票的最佳时机 II\n剑指 Offer 47. 礼物的最大价值\n剑指 Offer 42. 连续子数组的最大和\n931. 下降路径最小和\n120. 三角形最小路径和\n## 2.求是否可以完成组合\n139. 单词拆分\n## 3.求子数组 个数/最大值/长度\n413. 等差数列划分\n## 4.组合总数\n剑指 Offer 10- II. 青蛙跳台阶问题\n剑指 Offer 46. 把数字翻译成字符串\n\n## 5.最少操作数\n72. 编辑距离\n\n\n\n\n\n\n\n\n\n# 贪心\n55. 跳跃游戏\n45. 跳跃游戏 II\n\n\n\n\n\n## 测试用例的设计\n### 边界条件的测试\n0\n最大值\n### 功能测试\n\n\n\n\n\n\n\n\n\n\n\n[![不同算法的时间复杂度](https://s1.ax1x.com/2022/04/19/LBSN8S.png)](https://imgtu.com/i/LBSN8S)\n\n\n\n前缀和\n\n一维前缀和\n\n二维前缀和\n\n\n第一题就是基本的读入字符串排序，忘记细节了。\n\n第二题是读入一01串，对应的下标为士兵的能力，0代表攻击士兵，1代表防守士兵，找到一个分割点，使得左侧攻击士兵和右侧防御士兵差的绝对值最小。这题直接用一个求和数组记录遍历就能过。\n\n第三题是给定一个数组，删掉下标不为质数的值，然后合并起来循环操作，求最后一个数。这题是能找到规律，在某个区间的答案会是一个定值。直接暴力解了。\n\n第四题是给多个环形链表的部分（可以重叠），把他们串起来然后切开形成最小字典序。这题主要是记录一下链表顺序，正逆比较一下就可以\n\n第五题买股票进阶版，给定本金，每天都可以买入卖出1笔，而且可以手里留存多笔股票，求最大利润。这题不太会做，暴力DFS做的只过了50，蹲个大佬\n\n做了4个半，最近一个月才开始补算法，难点的题就做不出来了，以及我是用python写的，可能时间复杂度要求和C++比会有些差别\n\n# 参考资料\n[详解前缀树「TrieTree 汇总级别整理 🔥🔥🔥」]https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/\n[前缀和 ](https://blog.csdn.net/m0_46201544/article/details/122371482) \n[前缀异或](https://blog.csdn.net/weixin_50248461/article/details/117045421) \n[Codeforces游玩攻略](https://www.luogu.com.cn/blog/ezoixx130/codeforces-tutorial) \n[Codeforces快速精通](https://www.luogu.com.cn/blog/ezoixx130/codeforces-advanced-tutorial) \n[ACM-高精度模板(综合篇)](https://blog.csdn.net/u013615904/article/details/43373601) \n[C++ lambda表达式与函数对象](https://www.jianshu.com/p/d686ad9de817) \nhttps://codeforces.com/blog/entry/66715\nhttps://codeforces.com/blog/entry/66909\n\n# 区间dp\n[(区间dp) 力扣区间dp 题集记录](https://leetcode.cn/circle/article/BO520a/)\n[[力扣] DP问题分类汇总](https://zhuanlan.zhihu.com/p/126546914)\n[区间dp入门——总结+习题+解析](https://blog.csdn.net/qq_43472263/article/details/98337401)\n[OI Wiki](https://oi-wiki.org/dp/interval/)\n\n# 记忆化搜索\n[LeetCode刷题总结 --- 记忆化搜索框架](https://blog.csdn.net/qq_43472263/article/details/98337401)\n\n","content":"<h2 id=\"字典树-Trie树、前缀树\"><a href=\"#字典树-Trie树、前缀树\" class=\"headerlink\" title=\"字典树(Trie树、前缀树)\"></a>字典树(Trie树、前缀树)</h2><h3 id=\"模板题\"><a href=\"#模板题\" class=\"headerlink\" title=\"模板题\"></a>模板题</h3><ol start=\"208\">\n<li><p>实现 Trie (前缀树)</p>\n</li>\n<li><p>单词替换</p>\n</li>\n<li><p>添加与搜索单词 - 数据结构设计</p>\n</li>\n<li><p>键值映射</p>\n</li>\n<li><p>实现一个魔法字典</p>\n</li>\n<li><p>前缀和后缀搜索</p>\n</li>\n<li><p>字符串的前缀分数和</p>\n</li>\n</ol>\n<p>进阶：01字典树</p>\n<h2 id=\"环检测-amp-拓扑排序\"><a href=\"#环检测-amp-拓扑排序\" class=\"headerlink\" title=\"环检测 &amp; 拓扑排序\"></a>环检测 &amp; 拓扑排序</h2><ol start=\"207\">\n<li>课程表</li>\n<li>课程表 II<br>剑指 Offer II 115. 重建序列</li>\n</ol>\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2><ol start=\"698\">\n<li>划分为k个相等的子集</li>\n<li>火柴拼正方形</li>\n<li>公平分发饼干</li>\n</ol>\n<p>思路：<br>1.回溯前的准备<br>2.要回溯什么<br>回溯函数内<br>3.终止条件<br>4.进入和退出怎么搞</p>\n<h2 id=\"递推\"><a href=\"#递推\" class=\"headerlink\" title=\"递推\"></a>递推</h2><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>使用递归树的方法来判断问题</p>\n<p>回溯-》记忆化搜索-》动态规划</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>思路：</p>\n<ol>\n<li>确定dp数组以及下标的含义</li>\n<li>确定递推公式</li>\n<li>dp数组如何初始化</li>\n<li>确定遍历顺序<br><del>5. 举例推导dp数组</del></li>\n</ol>\n<p>写代码顺序：</p>\n<ol start=\"0\">\n<li><p>边界条件（最后考虑）</p>\n</li>\n<li><p>初始化</p>\n</li>\n<li><p>遍历</p>\n</li>\n<li><p>递推公式</p>\n</li>\n<li><p>返回</p>\n</li>\n<li><p>记忆化搜索</p>\n<ol>\n<li>Leetcode 140 单词拆分 II<!-- 2. Leetcode 329 矩阵中的最长递增路径 --></li>\n<li>Leetcode 472 连接词</li>\n<li>10题正则表达式匹配</li>\n<li>第37题解数独<!-- 6. 397. 整数替换 --></li>\n</ol>\n</li>\n<li><p>区间dp</p>\n<ol>\n<li>当问题可以分解为若干个子区间，并且子区间之间有一定的联系或者约束时，可以考虑用区间dp来求解</li>\n<li>合并、匹配、划分</li>\n<li>石子合并、括号匹配、回文串、邮局建设</li>\n<li><ol start=\"1000\">\n<li>合并石头的最低成本</li>\n</ol>\n</li>\n<li>而状态转移方程一般是枚举区间内的一个分割点<ol>\n<li>如dp [i] [j] &#x3D; min {dp [i] [k]+dp [k+1] [j]+cost}</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>能解决的问题：</p>\n<h2 id=\"1-求最大值-x2F-最小值\"><a href=\"#1-求最大值-x2F-最小值\" class=\"headerlink\" title=\"1.求最大值&#x2F;最小值\"></a>1.求最大值&#x2F;最小值</h2><ol start=\"1014\">\n<li>最佳观光组合</li>\n<li>买卖股票的最佳时机</li>\n<li>买卖股票的最佳时机 II<br>剑指 Offer 47. 礼物的最大价值<br>剑指 Offer 42. 连续子数组的最大和</li>\n<li>下降路径最小和</li>\n<li>三角形最小路径和</li>\n</ol>\n<h2 id=\"2-求是否可以完成组合\"><a href=\"#2-求是否可以完成组合\" class=\"headerlink\" title=\"2.求是否可以完成组合\"></a>2.求是否可以完成组合</h2><ol start=\"139\">\n<li>单词拆分</li>\n</ol>\n<h2 id=\"3-求子数组-个数-x2F-最大值-x2F-长度\"><a href=\"#3-求子数组-个数-x2F-最大值-x2F-长度\" class=\"headerlink\" title=\"3.求子数组 个数&#x2F;最大值&#x2F;长度\"></a>3.求子数组 个数&#x2F;最大值&#x2F;长度</h2><ol start=\"413\">\n<li>等差数列划分</li>\n</ol>\n<h2 id=\"4-组合总数\"><a href=\"#4-组合总数\" class=\"headerlink\" title=\"4.组合总数\"></a>4.组合总数</h2><p>剑指 Offer 10- II. 青蛙跳台阶问题<br>剑指 Offer 46. 把数字翻译成字符串</p>\n<h2 id=\"5-最少操作数\"><a href=\"#5-最少操作数\" class=\"headerlink\" title=\"5.最少操作数\"></a>5.最少操作数</h2><ol start=\"72\">\n<li>编辑距离</li>\n</ol>\n<h1 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h1><ol start=\"55\">\n<li>跳跃游戏</li>\n<li>跳跃游戏 II</li>\n</ol>\n<h2 id=\"测试用例的设计\"><a href=\"#测试用例的设计\" class=\"headerlink\" title=\"测试用例的设计\"></a>测试用例的设计</h2><h3 id=\"边界条件的测试\"><a href=\"#边界条件的测试\" class=\"headerlink\" title=\"边界条件的测试\"></a>边界条件的测试</h3><p>0<br>最大值</p>\n<h3 id=\"功能测试\"><a href=\"#功能测试\" class=\"headerlink\" title=\"功能测试\"></a>功能测试</h3><p><a href=\"https://imgtu.com/i/LBSN8S\"><img src=\"https://s1.ax1x.com/2022/04/19/LBSN8S.png\" alt=\"不同算法的时间复杂度\"></a></p>\n<p>前缀和</p>\n<p>一维前缀和</p>\n<p>二维前缀和</p>\n<p>第一题就是基本的读入字符串排序，忘记细节了。</p>\n<p>第二题是读入一01串，对应的下标为士兵的能力，0代表攻击士兵，1代表防守士兵，找到一个分割点，使得左侧攻击士兵和右侧防御士兵差的绝对值最小。这题直接用一个求和数组记录遍历就能过。</p>\n<p>第三题是给定一个数组，删掉下标不为质数的值，然后合并起来循环操作，求最后一个数。这题是能找到规律，在某个区间的答案会是一个定值。直接暴力解了。</p>\n<p>第四题是给多个环形链表的部分（可以重叠），把他们串起来然后切开形成最小字典序。这题主要是记录一下链表顺序，正逆比较一下就可以</p>\n<p>第五题买股票进阶版，给定本金，每天都可以买入卖出1笔，而且可以手里留存多笔股票，求最大利润。这题不太会做，暴力DFS做的只过了50，蹲个大佬</p>\n<p>做了4个半，最近一个月才开始补算法，难点的题就做不出来了，以及我是用python写的，可能时间复杂度要求和C++比会有些差别</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[详解前缀树「TrieTree 汇总级别整理 🔥🔥🔥」]<a href=\"https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/\">https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/</a><br><a href=\"https://blog.csdn.net/m0_46201544/article/details/122371482\">前缀和 </a><br><a href=\"https://blog.csdn.net/weixin_50248461/article/details/117045421\">前缀异或</a><br><a href=\"https://www.luogu.com.cn/blog/ezoixx130/codeforces-tutorial\">Codeforces游玩攻略</a><br><a href=\"https://www.luogu.com.cn/blog/ezoixx130/codeforces-advanced-tutorial\">Codeforces快速精通</a><br><a href=\"https://blog.csdn.net/u013615904/article/details/43373601\">ACM-高精度模板(综合篇)</a><br><a href=\"https://www.jianshu.com/p/d686ad9de817\">C++ lambda表达式与函数对象</a><br><a href=\"https://codeforces.com/blog/entry/66715\">https://codeforces.com/blog/entry/66715</a><br><a href=\"https://codeforces.com/blog/entry/66909\">https://codeforces.com/blog/entry/66909</a></p>\n<h1 id=\"区间dp\"><a href=\"#区间dp\" class=\"headerlink\" title=\"区间dp\"></a>区间dp</h1><p><a href=\"https://leetcode.cn/circle/article/BO520a/\">(区间dp) 力扣区间dp 题集记录</a><br><a href=\"https://zhuanlan.zhihu.com/p/126546914\">[力扣] DP问题分类汇总</a><br><a href=\"https://blog.csdn.net/qq_43472263/article/details/98337401\">区间dp入门——总结+习题+解析</a><br><a href=\"https://oi-wiki.org/dp/interval/\">OI Wiki</a></p>\n<h1 id=\"记忆化搜索\"><a href=\"#记忆化搜索\" class=\"headerlink\" title=\"记忆化搜索\"></a>记忆化搜索</h1><p><a href=\"https://blog.csdn.net/qq_43472263/article/details/98337401\">LeetCode刷题总结 — 记忆化搜索框架</a></p>\n","slug":"Interview-Q&A/leetcode-programe","updated":"04/04/2023","comments":true,"link":"","permalink":"http://example.com/2022/09/19/Interview-Q&A/leetcode-programe/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"机器学习","date":"16/09/2022","path":"2022/09/16/Course/ML/Machine_Course/","text":"实用机器学习-李沐1.2 如何获取数据找数据，生成数据 数据数据集——已经处理好的数据 MNIST:手写数据集ImageNet:引领深度学习，百万级，搜索引擎中找来的AudioSet:youtube声音切片Kinetics:声音切片KITTI：无人驾驶Amazon Review:亚马逊评论SQuAD:Wikipedia上问答LibriSpeech：有声读物 数据获取手段：网上爬取采集数据 paperswithcodes Datasets: academic datasets withleaderboardKaggle Datasets: ML datasets uploaded by datascientistsGoogle Dataset search: search datasets in the WebVarious toolkits datasets: tensorflow, huggingfaceVarious conference&#x2F;company ML competitionsOpen Data on AWS: 100+ large-scale raw dataData lakes in your own organizationddd 生成数据,GANs数据增强 1.3 网页数据抓取1.4 数据标注监督学习半监督学习自学习主动学习 弱监督学习——没钱没人——弱标号 2.1 探索性数据分析2.2 数据清洗图片分类目标检测语义分割 有监督学习，对每个像素进行分割 背景虚化 路面分割 4.1 评估指标准确率accuracy精度precision召回率recallF1AUCCTR lr学习率 loss: 0.5165 (0.7486)损失函数 损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越小，通常模型的性能越好。不同的模型用的损失函数一般也不一样。 5.2 BaggingBagging是并行式集成学习的最著名代表它是基于自助采样法（Boostrap sampleing），Bagging也是同理.给定包含m个样本的数据集，先随机抽取一个样本放入采样集中，再把该样本放回，使得下次采样时该样本仍有机会被选中，这样经过m次采样，我们便从原始是数据集中抽取样本得到一个数据量同为m的数据集.有放回的抽样，最后取平均 9.1 模型调参动手学习pytorch11 模型选择+过拟合、欠拟合超参数K-折交叉验证 参数名称 参数说明学习率α 用于调整梯度下降的步幅各层神经元数量Units 调整网络的宽度Mini-Batch大小 单步迭代的效果网络层数Layers 调整网络的深度过滤器参数 过滤器数量~尺寸、步长及是否填充边距等正则化方法 是否采用正则化，采用何种正则化方法训练代数Epochs 决定梯度下降的迭代步数和训练持久程度各层激励函数 影响模型各层之间的联系优化算法 根据问题需要比较优化算法的效果损失函数 评估模型误差的函数 10 多层感知机11 过拟合、欠拟合训练集是图片，标号是和他一样大小的图片，每个像素值对应标号 先过拟合了，然后再想办法把过拟合消除掉 46 语义分割和数据集实例分割 Pascal VOC2012 VOC格式 参考资料","raw":"---\ntitle: 机器学习\ndate: 2022-09-16 16:23:50\ntags:\n- 课程\n---\n\n# 实用机器学习-李沐\n## 1.2 如何获取数据\n    找数据，生成数据\n\n数据\n数据集——已经处理好的数据\n\nMNIST:手写数据集\nImageNet:引领深度学习，百万级，搜索引擎中找来的\nAudioSet:youtube声音切片\nKinetics:声音切片\nKITTI：无人驾驶\nAmazon Review:亚马逊评论\nSQuAD:Wikipedia上问答\nLibriSpeech：有声读物\n\n\n数据获取手段：\n网上爬取\n采集数据\n\n\npaperswithcodes Datasets: academic datasets withleaderboard\nKaggle Datasets: ML datasets uploaded by datascientists\nGoogle Dataset search: search datasets in the Web\nVarious toolkits datasets: tensorflow, huggingface\nVarious conference/company ML competitions\nOpen Data on AWS: 100+ large-scale raw data\nData lakes in your own organizationddd\n\n\n\n\n生成数据,GANs  \n数据增强\n\n## 1.3 网页数据抓取\n\n## 1.4 数据标注\n\n监督学习\n半监督学习\n自学习\n主动学习\n\n弱监督学习——没钱没人——弱标号\n\n\n\n\n## 2.1 探索性数据分析\n## 2.2 数据清洗\n\n图片分类\n目标检测\n语义分割\n    有监督学习，对每个像素进行分割\n    背景虚化\n    路面分割\n\n\n\n\n# 4.1 评估指标\n准确率accuracy\n精度precision\n召回率recall\nF1\nAUC\nCTR\n\nlr学习率\n\nloss: 0.5165 (0.7486)\n损失函数\n\n损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越小，通常模型的性能越好。不同的模型用的损失函数一般也不一样。\n\n\n# 5.2 Bagging\nBagging是并行式集成学习的最著名代表\n它是基于自助采样法（Boostrap sampleing），Bagging也是同理.给定包含m个样本的数据集，先随机抽取一个样本放入采样集中，再把该样本放回，使得下次采样时该样本仍有机会被选中，这样经过m次采样，我们便从原始是数据集中抽取样本得到一个数据量同为m的数据集.\n**有放回的抽样，最后取平均**\n\n# 9.1 模型调参\n\n\n\n# 动手学习pytorch\n## 11 模型选择+过拟合、欠拟合\n## 超参数\nK-折交叉验证\n\n\n参数名称 参数说明\n学习率α 用于调整梯度下降的步幅\n各层神经元数量Units 调整网络的宽度\nMini-Batch大小 单步迭代的效果\n网络层数Layers 调整网络的深度\n过滤器参数 过滤器数量~尺寸、步长及是否填充边距等\n正则化方法 是否采用正则化，采用何种正则化方法\n训练代数Epochs 决定梯度下降的迭代步数和训练持久程度\n各层激励函数 影响模型各层之间的联系\n优化算法 根据问题需要比较优化算法的效果\n损失函数 评估模型误差的函数\n\n\n# 10 多层感知机\n## 11 过拟合、欠拟合\n训练集是图片，标号是和他一样大小的图片，每个像素值对应标号\n\n先过拟合了，然后再想办法把过拟合消除掉\n\n\n\n# 46 语义分割和数据集\n实例分割\n\nPascal VOC2012\n\n\n\nVOC格式\n\n\n\n\n\n# 参考资料\n","content":"<h1 id=\"实用机器学习-李沐\"><a href=\"#实用机器学习-李沐\" class=\"headerlink\" title=\"实用机器学习-李沐\"></a>实用机器学习-李沐</h1><h2 id=\"1-2-如何获取数据\"><a href=\"#1-2-如何获取数据\" class=\"headerlink\" title=\"1.2 如何获取数据\"></a>1.2 如何获取数据</h2><pre><code>找数据，生成数据\n</code></pre>\n<p>数据<br>数据集——已经处理好的数据</p>\n<p>MNIST:手写数据集<br>ImageNet:引领深度学习，百万级，搜索引擎中找来的<br>AudioSet:youtube声音切片<br>Kinetics:声音切片<br>KITTI：无人驾驶<br>Amazon Review:亚马逊评论<br>SQuAD:Wikipedia上问答<br>LibriSpeech：有声读物</p>\n<p>数据获取手段：<br>网上爬取<br>采集数据</p>\n<p>paperswithcodes Datasets: academic datasets withleaderboard<br>Kaggle Datasets: ML datasets uploaded by datascientists<br>Google Dataset search: search datasets in the Web<br>Various toolkits datasets: tensorflow, huggingface<br>Various conference&#x2F;company ML competitions<br>Open Data on AWS: 100+ large-scale raw data<br>Data lakes in your own organizationddd</p>\n<p>生成数据,GANs<br>数据增强</p>\n<h2 id=\"1-3-网页数据抓取\"><a href=\"#1-3-网页数据抓取\" class=\"headerlink\" title=\"1.3 网页数据抓取\"></a>1.3 网页数据抓取</h2><h2 id=\"1-4-数据标注\"><a href=\"#1-4-数据标注\" class=\"headerlink\" title=\"1.4 数据标注\"></a>1.4 数据标注</h2><p>监督学习<br>半监督学习<br>自学习<br>主动学习</p>\n<p>弱监督学习——没钱没人——弱标号</p>\n<h2 id=\"2-1-探索性数据分析\"><a href=\"#2-1-探索性数据分析\" class=\"headerlink\" title=\"2.1 探索性数据分析\"></a>2.1 探索性数据分析</h2><h2 id=\"2-2-数据清洗\"><a href=\"#2-2-数据清洗\" class=\"headerlink\" title=\"2.2 数据清洗\"></a>2.2 数据清洗</h2><p>图片分类<br>目标检测<br>语义分割<br>    有监督学习，对每个像素进行分割<br>    背景虚化<br>    路面分割</p>\n<h1 id=\"4-1-评估指标\"><a href=\"#4-1-评估指标\" class=\"headerlink\" title=\"4.1 评估指标\"></a>4.1 评估指标</h1><p>准确率accuracy<br>精度precision<br>召回率recall<br>F1<br>AUC<br>CTR</p>\n<p>lr学习率</p>\n<p>loss: 0.5165 (0.7486)<br>损失函数</p>\n<p>损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越小，通常模型的性能越好。不同的模型用的损失函数一般也不一样。</p>\n<h1 id=\"5-2-Bagging\"><a href=\"#5-2-Bagging\" class=\"headerlink\" title=\"5.2 Bagging\"></a>5.2 Bagging</h1><p>Bagging是并行式集成学习的最著名代表<br>它是基于自助采样法（Boostrap sampleing），Bagging也是同理.给定包含m个样本的数据集，先随机抽取一个样本放入采样集中，再把该样本放回，使得下次采样时该样本仍有机会被选中，这样经过m次采样，我们便从原始是数据集中抽取样本得到一个数据量同为m的数据集.<br><strong>有放回的抽样，最后取平均</strong></p>\n<h1 id=\"9-1-模型调参\"><a href=\"#9-1-模型调参\" class=\"headerlink\" title=\"9.1 模型调参\"></a>9.1 模型调参</h1><h1 id=\"动手学习pytorch\"><a href=\"#动手学习pytorch\" class=\"headerlink\" title=\"动手学习pytorch\"></a>动手学习pytorch</h1><h2 id=\"11-模型选择-过拟合、欠拟合\"><a href=\"#11-模型选择-过拟合、欠拟合\" class=\"headerlink\" title=\"11 模型选择+过拟合、欠拟合\"></a>11 模型选择+过拟合、欠拟合</h2><h2 id=\"超参数\"><a href=\"#超参数\" class=\"headerlink\" title=\"超参数\"></a>超参数</h2><p>K-折交叉验证</p>\n<p>参数名称 参数说明<br>学习率α 用于调整梯度下降的步幅<br>各层神经元数量Units 调整网络的宽度<br>Mini-Batch大小 单步迭代的效果<br>网络层数Layers 调整网络的深度<br>过滤器参数 过滤器数量~尺寸、步长及是否填充边距等<br>正则化方法 是否采用正则化，采用何种正则化方法<br>训练代数Epochs 决定梯度下降的迭代步数和训练持久程度<br>各层激励函数 影响模型各层之间的联系<br>优化算法 根据问题需要比较优化算法的效果<br>损失函数 评估模型误差的函数</p>\n<h1 id=\"10-多层感知机\"><a href=\"#10-多层感知机\" class=\"headerlink\" title=\"10 多层感知机\"></a>10 多层感知机</h1><h2 id=\"11-过拟合、欠拟合\"><a href=\"#11-过拟合、欠拟合\" class=\"headerlink\" title=\"11 过拟合、欠拟合\"></a>11 过拟合、欠拟合</h2><p>训练集是图片，标号是和他一样大小的图片，每个像素值对应标号</p>\n<p>先过拟合了，然后再想办法把过拟合消除掉</p>\n<h1 id=\"46-语义分割和数据集\"><a href=\"#46-语义分割和数据集\" class=\"headerlink\" title=\"46 语义分割和数据集\"></a>46 语义分割和数据集</h1><p>实例分割</p>\n<p>Pascal VOC2012</p>\n<p>VOC格式</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1>","slug":"Course/ML/Machine_Course","updated":"07/03/2023","comments":true,"link":"","permalink":"http://example.com/2022/09/16/Course/ML/Machine_Course/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"实习的感受","date":"15/09/2022","path":"2022/09/15/Reflection/实习的感受/","text":"主要写一写实习的感受，为以后的实习做借鉴，并且对这个事情做一些总结 领导团队服务意识1.给团队设定超过现在能力的目标，但是还是要够一够才能到达 2.团队的领导者要作为团队的服务着，需要找到团队需要解决的问题 每周需要定期开组会，复盘这周完成的情况，这周遇到的问题需要如果去解决作为领导者，需要去协调解决组员的问题并且对这周做的内容，需要有一个拓展性的提高比如现在只能开80路的，但是要求到150路，最后不断努力可以到120路一定需要定时解决问题 完成了什么，现在还有什么问题 从多个角度考虑， 设计一个系统的时候，需要先逼着自己从最大的角度去考虑，需要哪几个方面的东西，然后再去细化如果东西太大，自己想不出来，那就先想到哪个点就做哪一个 如何平衡工作和生活刚刚开始到公司的时候 6-8月份，刚开始的时候无法接受公司里面的高强度工作，那就晚上回家以后多补课， 如何解决公司中学习的知识比较杂乱的情况 平时收集一些零散的东西，到了有大段空闲的时候，可以做总结 如何的最快的熟悉一个领域如何快速学习一门新的技术或者语言是什么，这个怎么用写一些小demo，看公司里面的工程代码找一些当前用到的典型场景，困难的回答，比如go的内存分配 读研之后发现自己和本科有什么区别 如何最快最好的解决一个问题，最好使用英文查询 小公司学不到东西，如何反驳 了解公司用的技术栈，我做的是后端，那我现在做的工作，我做的工作的前面有什么，后面有什么一起来的实习生在做什么，他做的东西我会做么，他做的东西我如何实现 常常保持好奇的心态，我虽然是后端，但是对于前端的技术，对于测试，产品，运维的相关知识，都是可以了解的 你要完成现在手头上的工作，是否会遇到问题，那么遇到问题的时候，比如看到raft算法，这是底层使用的东西，如果是有心去了解，那就会有更多可以发现的东西 如果完成了手头上的工作，可以用什么样的方法优化它 我觉得学不到东西，有着几种情况 你的技术栈，完全覆盖了这个公司，他们干的所有事情，你都可以单挑完成 或者是，你对这个行业，比如说我对销售行业，完全不感兴趣，但是公司里面干的是这个事情，那的确是学不到东西 有很多很多的杂活这个相对是更长的一段时间的感受，比如半年的时间，都是让你在东搞西搞，没有专心与一个技术栈，那这个公司对发展是不好的但是在短期看来，干很多杂事，如果能干好，还是可以提高自己的能力 干一些低技术的工作，自己都会，也是打杂，这就很没有发展前景 怎样快速融入一个项目 搭建环境，docker,k8s 让程序跑起来 了解调试方法 刚开始的起步阶段，最好能找到参考的程序，网络上的，工程里相关的，前辈写的代码 最开始是自己先造一些东西，看看能不能实现功能 再是修改 可以修改程序 最开始先了解一个模块，可以自己造一个独立的模块 然后了解联动的1-3个模块，了解这几个模块之间的相互关系（十分考验代码功底，需要静态查看，能做到不运行代码的情况下能看出程序是怎么运行的） 如果无法让一个程序运行，那就思考自己是哪一步出现了问题 搭建环境，docker,k8s搭建环境的时候遇到了什么问题，如何去解决 让程序跑起来程序中是否出现了错误代码，为什么无法改正，是语法不熟悉，还是这个特殊的用法没有了解到，还是别的计算机基础相关的知识 多从测试角度考虑，需要设计测试用例，对自己写的程序，要有测试的思路，什么情况会发生边界条件好几个程序一起的时候，会不会互相影响 想要提高代码能力，最好的方法，就是去一点一点的把代码写出来，只要自己写过的，能力就能提升只是看视频，提升是很慢的 提高搜索引擎关键词检索的效率 日常学习中，遇到的最大技术挑战是什么，你是如何解决的最大的困难是什么，或者最大的成果是什么，最大的成就感是什么？ 1.问题描述：1）简单介绍这个项目规模、背景，你在这中间充当的角色；2）什么情况下遇到什么样的问题2.你处理这个问题的过程及结果：1）遇到问题你如何思考；2）你如何执行的；3）处理结果如何3.通过处理这个问题，你学到了什么或者说通过这个问题，你看到了你们什么不足，后续动作（采用什么样的方式，在以后的项目中避免再出现这类问题 实习中，需要跨部门协调，外部支持，并且需要协调内部人手，时间比较紧张，领导寄予厚望，我希望用这个画上完美句号 对接人很强势，但是对面也给了很多帮助 结束实习，人手紧缺，需要留用一段时间 实习结束，安排的工作3-4周，实际给了2周 项目最忙的时候，别人部门的人希望帮忙","raw":"---\ntitle: 实习的感受\ndate: 2022-09-15 21:59:20\ntags:\n- 反思\n---\n\n主要写一写实习的感受，为以后的实习做借鉴，并且对这个事情做一些总结\n\n\n\n# 领导团队\n服务意识\n1.给团队设定超过现在能力的目标，但是还是要够一够才能到达\n\n2.团队的领导者要作为团队的服务着，需要找到团队需要解决的问题\n\n\n\n1. 每周需要定期开组会，复盘这周完成的情况，这周遇到的问题\n需要如果去解决\n作为领导者，需要去协调解决组员的问题\n并且对这周做的内容，需要有一个拓展性的提高\n比如现在只能开80路的，但是要求到150路，最后不断努力可以到120路\n**一定需要定时解决问题**\n\n完成了什么，现在还有什么问题\n\n\n2. 从多个角度考虑，\n\n\n3. 设计一个系统的时候，需要先逼着自己从最大的角度去考虑，需要哪几个方面的东西，然后再去细化\n如果东西太大，自己想不出来，那就先想到哪个点就做哪一个\n\n\n\n4. 如何平衡工作和生活\n刚刚开始到公司的时候\n\n\n\n6-8月份，刚开始的时候无法接受公司里面的高强度工作，那就晚上回家以后多补课，\n\n\n\n5. 如何解决公司中学习的知识比较杂乱的情况\n\n平时收集一些零散的东西，到了有大段空闲的时候，可以做总结\n\n\n6. 如何的最快的熟悉一个领域\n如何快速学习一门新的技术或者语言\n是什么，这个怎么用\n写一些小demo，\n看公司里面的工程代码\n找一些当前用到的典型场景，困难的回答，比如go的内存分配\n\n\n7. 读研之后发现自己和本科有什么区别\n\n7. 如何最快最好的解决一个问题，最好使用英文查询\n\n\n\n\n8. 小公司学不到东西，如何反驳\n\n- 1. 了解公司用的技术栈，我做的是后端，那我现在做的工作，我做的工作的前面有什么，后面有什么\n一起来的实习生在做什么，他做的东西我会做么，他做的东西我如何实现\n- 2. 常常保持好奇的心态，我虽然是后端，但是对于前端的技术，对于测试，产品，运维的相关知识，都是可以了解的\n- 3. 你要完成现在手头上的工作，是否会遇到问题，那么遇到问题的时候，比如看到raft算法，这是底层使用的东西，如果是有心去了解，那就会有更多可以发现的东西\n- 4. 如果完成了手头上的工作，可以用什么样的方法优化它\n\n\n\n\n我觉得学不到东西，有着几种情况\n1. 你的技术栈，完全覆盖了这个公司，他们干的所有事情，你都可以单挑完成\n- 或者是，你对这个行业，比如说我对销售行业，完全不感兴趣，但是公司里面干的是这个事情，那的确是学不到东西\n2. 有很多很多的杂活\n这个相对是更长的一段时间的感受，比如半年的时间，都是让你在东搞西搞，没有专心与一个技术栈，那这个公司对发展是不好的\n但是在短期看来，干很多杂事，如果能干好，还是可以提高自己的能力\n3. 干一些低技术的工作，自己都会，也是打杂，这就很没有发展前景\n\n\n\n\n\n\n9. 怎样快速融入一个项目\n\n- 1. 搭建环境，docker,k8s\n- 2. 让程序跑起来\n- 3. 了解调试方法\n- 刚开始的起步阶段，最好能找到参考的程序，网络上的，工程里相关的，前辈写的代码\n- 最开始是自己先造一些东西，看看能不能实现功能\n- 再是修改\n- 4. 可以修改程序\n- 最开始先了解一个模块，可以自己造一个独立的模块\n- 然后了解联动的1-3个模块，了解这几个模块之间的相互关系\n（十分考验代码功底，需要静态查看，能做到不运行代码的情况下能看出程序是怎么运行的）\n\n如果无法让一个程序运行，那就思考自己是哪一步出现了问题\n1. 搭建环境，docker,k8s\n搭建环境的时候遇到了什么问题，如何去解决\n- 2. 让程序跑起来\n程序中是否出现了错误代码，为什么无法改正，是语法不熟悉，还是这个特殊的用法没有了解到，还是别的计算机基础相关的知识\n\n\n\n\n\n\n9. 多从测试角度考虑，需要设计测试用例，对自己写的程序，要有测试的思路，什么情况会发生边界条件\n好几个程序一起的时候，会不会互相影响\n\n\n\n\n\n5. 想要提高代码能力，最好的方法，就是去一点一点的把代码写出来，只要自己写过的，能力就能提升\n只是看视频，提升是很慢的\n\n\n10. 提高搜索引擎关键词检索的效率\n\n\n11. 日常学习中，遇到的最大技术挑战是什么，你是如何解决的\n最大的困难是什么，或者最大的成果是什么，最大的成就感是什么？\n\n\n1.问题描述：1）简单介绍这个项目规模、背景，你在这中间充当的角色；2）什么情况下遇到什么样的问题\n2.你处理这个问题的过程及结果：1）遇到问题你如何思考；2）你如何执行的；3）处理结果如何\n3.通过处理这个问题，你学到了什么或者说通过这个问题，你看到了你们什么不足，后续动作（采用什么样的方式，在以后的项目中避免再出现这类问题\n\n\n9. 实习中，需要跨部门协调，外部支持，并且需要协调内部人手，时间比较紧张，领导寄予厚望，我希望用这个画上完美句号\n10. 对接人很强势，但是对面也给了很多帮助  \n    1.  \n11. 结束实习，人手紧缺，需要留用一段时间\n    1.  实习结束，安排的工作3-4周，实际给了2周\n    2.  项目最忙的时候，别人部门的人希望帮忙\n","content":"<p>主要写一写实习的感受，为以后的实习做借鉴，并且对这个事情做一些总结</p>\n<h1 id=\"领导团队\"><a href=\"#领导团队\" class=\"headerlink\" title=\"领导团队\"></a>领导团队</h1><p>服务意识<br>1.给团队设定超过现在能力的目标，但是还是要够一够才能到达</p>\n<p>2.团队的领导者要作为团队的服务着，需要找到团队需要解决的问题</p>\n<ol>\n<li>每周需要定期开组会，复盘这周完成的情况，这周遇到的问题<br>需要如果去解决<br>作为领导者，需要去协调解决组员的问题<br>并且对这周做的内容，需要有一个拓展性的提高<br>比如现在只能开80路的，但是要求到150路，最后不断努力可以到120路<br><strong>一定需要定时解决问题</strong></li>\n</ol>\n<p>完成了什么，现在还有什么问题</p>\n<ol start=\"2\">\n<li><p>从多个角度考虑，</p>\n</li>\n<li><p>设计一个系统的时候，需要先逼着自己从最大的角度去考虑，需要哪几个方面的东西，然后再去细化<br>如果东西太大，自己想不出来，那就先想到哪个点就做哪一个</p>\n</li>\n<li><p>如何平衡工作和生活<br>刚刚开始到公司的时候</p>\n</li>\n</ol>\n<p>6-8月份，刚开始的时候无法接受公司里面的高强度工作，那就晚上回家以后多补课，</p>\n<ol start=\"5\">\n<li>如何解决公司中学习的知识比较杂乱的情况</li>\n</ol>\n<p>平时收集一些零散的东西，到了有大段空闲的时候，可以做总结</p>\n<ol start=\"6\">\n<li><p>如何的最快的熟悉一个领域<br>如何快速学习一门新的技术或者语言<br>是什么，这个怎么用<br>写一些小demo，<br>看公司里面的工程代码<br>找一些当前用到的典型场景，困难的回答，比如go的内存分配</p>\n</li>\n<li><p>读研之后发现自己和本科有什么区别</p>\n</li>\n<li><p>如何最快最好的解决一个问题，最好使用英文查询</p>\n</li>\n<li><p>小公司学不到东西，如何反驳</p>\n</li>\n</ol>\n<ul>\n<li><ol>\n<li>了解公司用的技术栈，我做的是后端，那我现在做的工作，我做的工作的前面有什么，后面有什么<br>一起来的实习生在做什么，他做的东西我会做么，他做的东西我如何实现</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>常常保持好奇的心态，我虽然是后端，但是对于前端的技术，对于测试，产品，运维的相关知识，都是可以了解的</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>你要完成现在手头上的工作，是否会遇到问题，那么遇到问题的时候，比如看到raft算法，这是底层使用的东西，如果是有心去了解，那就会有更多可以发现的东西</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>如果完成了手头上的工作，可以用什么样的方法优化它</li>\n</ol>\n</li>\n</ul>\n<p>我觉得学不到东西，有着几种情况</p>\n<ol>\n<li>你的技术栈，完全覆盖了这个公司，他们干的所有事情，你都可以单挑完成</li>\n</ol>\n<ul>\n<li>或者是，你对这个行业，比如说我对销售行业，完全不感兴趣，但是公司里面干的是这个事情，那的确是学不到东西</li>\n</ul>\n<ol start=\"2\">\n<li><p>有很多很多的杂活<br>这个相对是更长的一段时间的感受，比如半年的时间，都是让你在东搞西搞，没有专心与一个技术栈，那这个公司对发展是不好的<br>但是在短期看来，干很多杂事，如果能干好，还是可以提高自己的能力</p>\n</li>\n<li><p>干一些低技术的工作，自己都会，也是打杂，这就很没有发展前景</p>\n</li>\n<li><p>怎样快速融入一个项目</p>\n</li>\n</ol>\n<ul>\n<li><ol>\n<li>搭建环境，docker,k8s</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>让程序跑起来</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>了解调试方法</li>\n</ol>\n</li>\n<li>刚开始的起步阶段，最好能找到参考的程序，网络上的，工程里相关的，前辈写的代码</li>\n<li>最开始是自己先造一些东西，看看能不能实现功能</li>\n<li>再是修改</li>\n<li><ol start=\"4\">\n<li>可以修改程序</li>\n</ol>\n</li>\n<li>最开始先了解一个模块，可以自己造一个独立的模块</li>\n<li>然后了解联动的1-3个模块，了解这几个模块之间的相互关系<br>（十分考验代码功底，需要静态查看，能做到不运行代码的情况下能看出程序是怎么运行的）</li>\n</ul>\n<p>如果无法让一个程序运行，那就思考自己是哪一步出现了问题</p>\n<ol>\n<li>搭建环境，docker,k8s<br>搭建环境的时候遇到了什么问题，如何去解决</li>\n</ol>\n<ul>\n<li><ol start=\"2\">\n<li>让程序跑起来<br>程序中是否出现了错误代码，为什么无法改正，是语法不熟悉，还是这个特殊的用法没有了解到，还是别的计算机基础相关的知识</li>\n</ol>\n</li>\n</ul>\n<ol start=\"9\">\n<li><p>多从测试角度考虑，需要设计测试用例，对自己写的程序，要有测试的思路，什么情况会发生边界条件<br>好几个程序一起的时候，会不会互相影响</p>\n</li>\n<li><p>想要提高代码能力，最好的方法，就是去一点一点的把代码写出来，只要自己写过的，能力就能提升<br>只是看视频，提升是很慢的</p>\n</li>\n<li><p>提高搜索引擎关键词检索的效率</p>\n</li>\n<li><p>日常学习中，遇到的最大技术挑战是什么，你是如何解决的<br>最大的困难是什么，或者最大的成果是什么，最大的成就感是什么？</p>\n</li>\n</ol>\n<p>1.问题描述：1）简单介绍这个项目规模、背景，你在这中间充当的角色；2）什么情况下遇到什么样的问题<br>2.你处理这个问题的过程及结果：1）遇到问题你如何思考；2）你如何执行的；3）处理结果如何<br>3.通过处理这个问题，你学到了什么或者说通过这个问题，你看到了你们什么不足，后续动作（采用什么样的方式，在以后的项目中避免再出现这类问题</p>\n<ol start=\"9\">\n<li>实习中，需要跨部门协调，外部支持，并且需要协调内部人手，时间比较紧张，领导寄予厚望，我希望用这个画上完美句号</li>\n<li>对接人很强势，但是对面也给了很多帮助  <ol>\n<li></li>\n</ol>\n</li>\n<li>结束实习，人手紧缺，需要留用一段时间<ol>\n<li>实习结束，安排的工作3-4周，实际给了2周</li>\n<li>项目最忙的时候，别人部门的人希望帮忙</li>\n</ol>\n</li>\n</ol>\n","slug":"Reflection/实习的感受","updated":"16/03/2023","comments":true,"link":"","permalink":"http://example.com/2022/09/15/Reflection/%E5%AE%9E%E4%B9%A0%E7%9A%84%E6%84%9F%E5%8F%97/","excerpt":"","categories":[],"tags":[{"name":"反思","slug":"反思","permalink":"http://example.com/tags/%E5%8F%8D%E6%80%9D/"}]},{"title":"小工具的使用","date":"23/08/2022","path":"2022/08/23/Tutorial/small_tool/","text":"Navicat12 Mysql可视化查看工具破解的时候需要关闭软件本身 需要在k8s中开放端口修改mysql开放及端口：开放：alias b&#x3D;”kubectl -n namespace” b edit svc mysql -n mysql 加spec-底部type: NodePort # 从ClusterIP改过来修改端口：ports-nodePort:31198 数据库：host&#x3D;[主机名],user&#x3D;[用户名],passwd&#x3D;[密码],db&#x3D;[想要访问的数据库],charset&#x3D;”utf8”,port&#x3D;[使用的端口] host&#x3D;”10.1.0.42”,user&#x3D;”pigg”,passwd&#x3D;”123456”,db&#x3D;”ggip”,charset&#x3D;”utf8”,port&#x3D;31198 查看表的情况”设计表“ 执行mysql语句以后的分析剖析： 1）Opening tables 这个是表示这个SQL拿到这个表的使用权所占用的时间，如果在一个SQL中过长，则有可能表示当前表被锁，被一些其他线程占用，可以查一下当前表的状态。2）Sending data包括两个部分，收集和发送数据。这里的关键是为什么要收集数据，原因在于：mysql使用“索引”完成查询结束后，mysql得到了一堆的行id，如果有的列并不在索引中，mysql需要重新到“数据行”上将需要返回的数据读取出来返回个客户端。如果这部分占用时间过程，有可能是索引问题，或者字段长度过大导致。 gRPC调试工具BloomRPC可以调试utilserver这个特别复杂的服务在调试的时候，需要把包含的文件，还有包含文件的包含文件全部导入 kdevelopCMake可视化调试工具 打开命令窗口: 安装gcc(编译器) sudo apt-get build-dep gcc sudo apt-get install build-essential 安装kdevelopsudo apt-get install kdevelop 安装cmake等sudo apt-get install automake autoconf g++ libtool cmake 打包工具inno setupfilepackNSIS参考文献[使用Navicat分析SQL性能]https://blog.csdn.net/weixin_43416686/article/details/121037223","raw":"---\ntitle: 小工具的使用\ndate: 2022-08-23 15:49:26\ntags:\n- 教程\n---\n\n# Navicat12 Mysql可视化查看工具\n\n破解的时候需要关闭软件本身\n\n需要在k8s中开放端口\n修改mysql开放及端口：\n开放：alias b=\"kubectl -n namespace\"\n         b edit svc mysql -n mysql\n      加spec-底部type: NodePort         # 从ClusterIP改过来\n修改端口：ports-nodePort:31198\n\n数据库：\nhost=[主机名],\nuser=[用户名],\npasswd=[密码],\ndb=[想要访问的数据库],\ncharset=\"utf8\",\nport=[使用的端口]\n\n\n\nhost=\"10.1.0.42\",\nuser=\"pigg\",\npasswd=\"123456\",\ndb=\"ggip\",\ncharset=\"utf8\",\nport=31198\n\n\n## 查看表的情况\n”设计表“\n## 执行mysql语句以后的分析\n剖析：\n\n1）Opening tables 这个是表示这个SQL拿到这个表的使用权所占用的时间，如果在一个SQL中过长，则有可能表示当前表被锁，被一些其他线程占用，可以查一下当前表的状态。\n2）Sending data包括两个部分，收集和发送数据。这里的关键是为什么要收集数据，原因在于：mysql使用“索引”完成查询结束后，mysql得到了一堆的行id，如果有的列并不在索引中，mysql需要重新到“数据行”上将需要返回的数据读取出来返回个客户端。如果这部分占用时间过程，有可能是索引问题，或者字段长度过大导致。\n\n\n# gRPC调试工具\n\nBloomRPC\n可以调试utilserver这个特别复杂的服务\n在调试的时候，需要把包含的文件，还有包含文件的包含文件全部导入\n\n\n\n# kdevelop\nCMake可视化调试工具\n\n\n打开命令窗口:\n1. 安装gcc(编译器)\n    sudo apt-get build-dep gcc\n    sudo apt-get install build-essential\n    \n2. 安装kdevelop\nsudo apt-get install kdevelop\n\n3. 安装cmake等\nsudo apt-get install automake autoconf g++ libtool cmake\n\n# 打包工具\n\n# inno setup\n\n# filepack\n\n# NSIS\n\n# 参考文献\n[使用Navicat分析SQL性能]https://blog.csdn.net/weixin_43416686/article/details/121037223\n\n\n\n\n\n","content":"<h1 id=\"Navicat12-Mysql可视化查看工具\"><a href=\"#Navicat12-Mysql可视化查看工具\" class=\"headerlink\" title=\"Navicat12 Mysql可视化查看工具\"></a>Navicat12 Mysql可视化查看工具</h1><p>破解的时候需要关闭软件本身</p>\n<p>需要在k8s中开放端口<br>修改mysql开放及端口：<br>开放：alias b&#x3D;”kubectl -n namespace”<br>         b edit svc mysql -n mysql<br>      加spec-底部type: NodePort         # 从ClusterIP改过来<br>修改端口：ports-nodePort:31198</p>\n<p>数据库：<br>host&#x3D;[主机名],<br>user&#x3D;[用户名],<br>passwd&#x3D;[密码],<br>db&#x3D;[想要访问的数据库],<br>charset&#x3D;”utf8”,<br>port&#x3D;[使用的端口]</p>\n<p>host&#x3D;”10.1.0.42”,<br>user&#x3D;”pigg”,<br>passwd&#x3D;”123456”,<br>db&#x3D;”ggip”,<br>charset&#x3D;”utf8”,<br>port&#x3D;31198</p>\n<h2 id=\"查看表的情况\"><a href=\"#查看表的情况\" class=\"headerlink\" title=\"查看表的情况\"></a>查看表的情况</h2><p>”设计表“</p>\n<h2 id=\"执行mysql语句以后的分析\"><a href=\"#执行mysql语句以后的分析\" class=\"headerlink\" title=\"执行mysql语句以后的分析\"></a>执行mysql语句以后的分析</h2><p>剖析：</p>\n<p>1）Opening tables 这个是表示这个SQL拿到这个表的使用权所占用的时间，如果在一个SQL中过长，则有可能表示当前表被锁，被一些其他线程占用，可以查一下当前表的状态。<br>2）Sending data包括两个部分，收集和发送数据。这里的关键是为什么要收集数据，原因在于：mysql使用“索引”完成查询结束后，mysql得到了一堆的行id，如果有的列并不在索引中，mysql需要重新到“数据行”上将需要返回的数据读取出来返回个客户端。如果这部分占用时间过程，有可能是索引问题，或者字段长度过大导致。</p>\n<h1 id=\"gRPC调试工具\"><a href=\"#gRPC调试工具\" class=\"headerlink\" title=\"gRPC调试工具\"></a>gRPC调试工具</h1><p>BloomRPC<br>可以调试utilserver这个特别复杂的服务<br>在调试的时候，需要把包含的文件，还有包含文件的包含文件全部导入</p>\n<h1 id=\"kdevelop\"><a href=\"#kdevelop\" class=\"headerlink\" title=\"kdevelop\"></a>kdevelop</h1><p>CMake可视化调试工具</p>\n<p>打开命令窗口:</p>\n<ol>\n<li><p>安装gcc(编译器)<br> sudo apt-get build-dep gcc<br> sudo apt-get install build-essential</p>\n</li>\n<li><p>安装kdevelop<br>sudo apt-get install kdevelop</p>\n</li>\n<li><p>安装cmake等<br>sudo apt-get install automake autoconf g++ libtool cmake</p>\n</li>\n</ol>\n<h1 id=\"打包工具\"><a href=\"#打包工具\" class=\"headerlink\" title=\"打包工具\"></a>打包工具</h1><h1 id=\"inno-setup\"><a href=\"#inno-setup\" class=\"headerlink\" title=\"inno setup\"></a>inno setup</h1><h1 id=\"filepack\"><a href=\"#filepack\" class=\"headerlink\" title=\"filepack\"></a>filepack</h1><h1 id=\"NSIS\"><a href=\"#NSIS\" class=\"headerlink\" title=\"NSIS\"></a>NSIS</h1><h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[使用Navicat分析SQL性能]<a href=\"https://blog.csdn.net/weixin_43416686/article/details/121037223\">https://blog.csdn.net/weixin_43416686/article/details/121037223</a></p>\n","slug":"Tutorial/small_tool","updated":"09/01/2023","comments":true,"link":"","permalink":"http://example.com/2022/08/23/Tutorial/small_tool/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"实习中学到的内容","date":"22/08/2022","path":"2022/08/22/Reflection/实习中用到的技术/","text":"实习中学到的新技术2022.3~2022.4 基于 Linux 的 TinyWebServer项目描述:该项目是为学习 Linux 网络编程知识，在 Linux 环境下使用 C++语言开发的轻量级多线程 HTTP服务器，服务器支持一定数量的客户端连接并及时响应，支持客户端访问服务器的图片、视频等资源。主要工作: 1、使用 Socket 实现不同主机之间的通信;2、使用 Epoll 技术实现 I&#x2F;O 多路复用，提高效率;3、使用有限状态机解析 HTTP 请求报文，对 GET 和 POST 请求进行处理4、利用多线程的机制，增加并行服务数量。项目难点: 1、实现线程池，提高吞吐量;2、编写主从状态机对 HTTP 报文进行解析; l个人收获: 1、在此项目中，使用 Makefile 进行编译，掌握一门全新的技术;2、对 HTTP 的服务过程以及 TCP 三次握手有了更深的了解﹔3、对于 Socket 通信以及 I&#x2F;0 复用有了一定的理解，对已有知识进行夯实 2021.12~2022.1 杭州大数云智科技有限公司1.通过学习 GitHub 上的开源项目 MotionPlanning，通过 python 实现一些路径规划的算法。。2.使用 Vscode 通过 ssh 连接调试塔克机器人小车，通过 Ubuntu16.04 虚拟机搭载 ROS Melodic ，连接小车，进行激光雷达、双目摄像头和深度相机的 SLAM 建模 2022.6~2022.8 杭州后起智能科技有限公司 C++后台开发实习工作描述：和公司团队一起开发灯塔AI视图分析系统主要职责：1.对灯塔系统中的档案文件实现档案查询，导出，删除的功能2.整合AI系统中模型生成个人收获：1.学习了公司的开发流程，了解了公司的一些业务设计思想1.加强了Git的各种使用方式 自己的全面总结：思想上： 了解了公司的运行流程，互联网公司的组成模式技术上： 语言： 5个go项目4个c++项目,三个都和shell相关3个数据库相关，MySQL5个shell项目，两个重度shellansible,k8s,dockerwsl 新学的技术dockerk8skubectlgrpcgit lfsgo语言 Protocol Buffer序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统结构体标签workpool HTTP 消息首部MIME 类型pocgorm中的事务，redis中事务 并发读写，并发锁sync.Mapredis-cli数据库 TIDB redis 存储 分布式存储GlusterFS TIKV minio linux的VFS内容etcd数据库备份Ansiblecfssl证书jinjacrontab自动执行原型软件axureBloomRPCC++技术 Snowflake算法 消息阻塞队列 对象池 CustomObjectPool ObjectPool GoLang grpc grom prototobuf 消息队列 分布式追踪系统 – Opentracingnavicate mysqlGUI工具nsqlookupd：高性能消息中间件 NSQ 解析NSQ——订阅摘要和推送摘要，日志流中间件消息队列 对一些内容的详细解释k8skubernetes IAAS——基础服务设施 PAAS——平台服务设施 docker——paas的下一代标准 k8s解决集群问题，每个机器里面都有一个docker 容器的集群化，资源管理器 apache——MESOS 分布式资源管理框架 2019 twitter不用了 推特在用，现在在用k8s docker swarm docker母公司 swarm集群 2019-7 阿里云宣布 docker swarm剔除 kubernetes goolgle 10年容器化基础架构 公司里面在用borg 现在用go写了一个borg 特点 轻量级，消耗的资源少 开源 弹性伸缩 负载均衡：IPVS框架 人群 软件工程师 测试、运维、产品经理 需要了解产品底层框架 SAAS raft算法 snap—— wal——日志持久化存储 分布式追踪系统 – OpentracingOpenTracing 于 2016 年 10 月加入 CNCF 基金会，是继 Kubernetes 和 Prometheus 之后，第三个加入 CNCF 的开源项目 可方便开发者在自己的服务中集成一种或多种分布式追踪的实现 Logging &amp; Metrics：可聚合的事件。例如分析某对象存储的 Nginx 日志，统计某段时间内 GET、PUT、DELETE、OPTIONS 操作的总数。 Metrics &amp; Tracing：单个请求中的可计量数据。例如 SQL 执行总时长、gRPC 调用总次数。 Tracing &amp; Logging：请求阶段的标签数据。例如在 Tracing 的信息中标记详细的错误原因。 Logging：ELK，近几年势头最猛的日志分析服务，无须多言。 Metrics：Prometheus，第二个加入 CNCF 的开源项目，非常好用。 Tracing：OpenTracing 和 Jaeger，Jaeger 是 Uber 开源的一个兼容 OpenTracing 标准的分布式追踪服务。目前 Jaeger 也加入了 CNCF。 SaaSSaaS是Software-as-a-Service的缩写名称，意思为软件即服务 Facebook，Twitter， Instagram。 Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting。 PaaS：Platform-as-a-Service（平台即服务）提供给消费者的服务是把客户采用提供的开发语言和工具（例如Java，python, .Net等）开发的或收购的应用程序部署到供应商的云计算基础设施上去。 MySQL，Mangodb，Java，Node.js IaaS： Infrastructure-as-a-Service（基础设施即服务）提供给消费者的服务是对所有计算基础设施的利用，包括处理CPU、内存、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。 NSQNSQ——订阅摘要和推送摘要，日志流中间件 NSQ是Go语言编写的一个开源的实时分布式内存消息队列，其性能十分优异。 分布式实时消息平台 NSQ 是实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。它具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征 适合小型项目使用,用来学习消息队列实现原理、学习 golang channel知识以及如何用 go 来写分布式，为什么说适合小型小型项目使用因为，nsq 如果没有能力进行二次开发的情况存在的问题还是很多的。 档案导出的流程 档案查询——查大顶堆优化mysql 查询的时候，每个项目的内容都非常的大，但是只需要用他们的一部分来排序所以使用大顶堆来进行插入，插入的时候同时完成了排序在需要使用的时候，直接将大顶堆读取出来就可以了 算法稳定性：堆排序是一种不稳定的排序方法。因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况 但是不需要兼顾这个方面，因为出现频率相同的人，随便怎么排在一起都没有关系 档案导出——查多用户，多线程。上下文取消，广播进度，哈希表优化minio 任务背景导出的命名格式为姓名-身份证由于下载的内容十分繁重，总体逻辑，保证单用户只有一个下载任务使用minio存储图片下载的目标数量极大，1000-1W的数量级档案中的人有1000个人，每个的档案，如果被布控的到，会有1-2K照片，每个照片20KB，jpg模式下载的内容分为，档案图，人脸图，场景图 档案导出主函数0.0 数据库初始化，在整个服务初始化的时候完成0.1 获取上下文，打印日志，填写requestid0.2 定义导出需要用到的接口 - 导出主程序接口 - 查询导出任务进度 - 删除导出任务1.验证用户输入是否正确 2.先查询当前任务状态，如果已经有任务在执行，那么直接返回 – 获取的下载目标，在数据库中无法存放数组，用字符串代替 – 如果不是运行中，可能是任务未开始、任务失败、任务成功，都删除一下当前任务 3.在数据库库中插入本次下载的记录4.串联上下文，将上下文信息传递到协程里面， 5.返回开始任务，进度为0%，接口运行结束 调试方法1.postman进行本地接口传入参数调试2.直接放到服务器上的k8s中进行运行，打印日志进行调试 协程中的内容 运行的过程中不停的更新进度的状态，进行进度广播 使用线程池加速下载，线程池里面开线程池？？不可以？？ 8核下载全部轨迹，从135s-&gt;20s 错误处理 使用哈希表，减少摄像头信息的存储 获取想要导出的目标的信息目标的，姓名-身份证如果需要导出的目标是空的，那还是建立一个空文件夹有时候，需要下载的内容过于庞大了，超过了gRPC单次传输的上限，所以就用分页的方法来获取数据，（获取数据调用的别的微服务，那个接口支持分页） 在本地建立需要导出目标的文件夹目录为，随机uuid 找到可执行目录 生成uuid uuid&#x2F;export&#x2F;建立业务文件夹导出的图片是存在minio里面的，从网上下载下来，放在目录里面，压缩打包再上传 对需要下载的每个目标进行下载更具业务需求，分情况讨论下载的过程中，使用base64对图片地址进行解密由于每个目标是独立的任务，所以可以使用线程池进行加速 需要调用其他的微服务，还获取图片数据 对生成的文件进行zip压缩 使用defer删除建立的临时压缩报 filepath.Walk来遍历文件压缩进去 将压缩包上传到minio，将minio的地址存到数据库中 上传中修改了minio存储的ContentDisposition,修改了http下载时候的文件名 档案删除——删查了redis 删除任务中，遇到了无法删除数据库内容的问题查找后发现，删除的时候使用了事务，这个事务里面需要同时删除三个数据库中的数据，但是在有一个删除操作中，删除的量过大的，导致删除终止，整个事务回滚，删除失败需要一次删除25w条数据，每条数据大概4000byte,25W条数据是极限了有一些10W条以下的小数据，删除成功了，但是之前使用的gorm的软删除，改为了直接删除 解决方法：先查询需要删除的数量，如果大于一定数量，就不使用事务，自己分批次删除 这个删除使用了代理模式，分为proxy，work,store三个层次proxy处理一些简单的外部响应，先删除外部的数据库真正的删除放在内部的store中，删除图片，redis,tidb tidb中有一个库的常用键值没有加索引，导致搜索的十分缓慢，所以加上了索引 定时任务使用管道和协程回调函数，来实现一个定时任务对两天前的老数据进行清理 为什么要用redis检测到的人的特征放在redis里面由于需要监控的人非常多，而且人需要存储的特征也非常多，并且总是需要使用到人的特征，所以放到redis里面需要保存轨迹点的数据，内容量很大，并且读写频率很高 [消息队列浅析]https://developer.aliyun.com/article/988780?spm=a2c6h.12873639.article-detail.40.167b2eefaMJqaj&amp;scm=20140722.ID_community@@article@@988780._.ID_community@@article@@988780-OR_rec-V_1[OpenTracing]https://blog.csdn.net/eight_eyes/article/details/117330608 [数据结构 - 堆的应用场景]https://blog.csdn.net/it_lihongmin/article/details/114528779?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=2[堆及堆的具体使用场景]https://www.jianshu.com/p/e8e267879b61","raw":"---\ntitle: 实习中学到的内容\ndate: 2022-08-22 20:02:55\ntags:\n- 反思\n---\n\n\n# 实习中学到的新技术\n\n2022.3~2022.4 基于 Linux 的 TinyWebServer\n项目描述:该项目是为学习 Linux 网络编程知识，在 Linux 环境下使用 C++语言开发的轻量级多线程 HTTP\n服务器，服务器支持一定数量的客户端连接并及时响应，支持客户端访问服务器的图片、视频等资源。\n主要工作: 1、使用 Socket 实现不同主机之间的通信;\n2、使用 Epoll 技术实现 I/O 多路复用，提高效率;\n3、使用有限状态机解析 HTTP 请求报文，对 GET 和 POST 请求进行处理4、利用多线程的机制，增加并行服务数量。\n项目难点: 1、实现线程池，提高吞吐量;\n2、编写主从状态机对 HTTP 报文进行解析; l\n个人收获: 1、在此项目中，使用 Makefile 进行编译，掌握一门全新的技术;\n2、对 HTTP 的服务过程以及 TCP 三次握手有了更深的了解﹔\n3、对于 Socket 通信以及 I/0 复用有了一定的理解，对已有知识进行夯实\n\n\n\n2021.12~2022.1 杭州大数云智科技有限公司\n1.通过学习 GitHub 上的开源项目 MotionPlanning，通过 python 实现一些路径规划的算法。。\n2.使用 Vscode 通过 ssh 连接调试塔克机器人小车，通过 Ubuntu16.04 虚拟机搭载 ROS Melodic ，连接\n小车，进行激光雷达、双目摄像头和深度相机的 SLAM 建模\n\n\n2022.6~2022.8 杭州后起智能科技有限公司  C++后台开发实习\n工作描述：和公司团队一起开发灯塔AI视图分析系统\n主要职责：\n1.对灯塔系统中的档案文件实现档案查询，导出，删除的功能\n2.整合AI系统中模型生成\n个人收获：\n1.学习了公司的开发流程，了解了公司的一些业务设计思想\n1.加强了Git的各种使用方式\n\n自己的全面总结：\n思想上：\n1. 了解了公司的运行流程，互联网公司的组成模式\n技术上：\n2. 语言：\n\n5个go项目\n4个c++项目,三个都和shell相关\n3个数据库相关，MySQL\n5个shell项目，两个重度shell\nansible,k8s,docker\n~~wsl~~\n\n\n\n\n# 新学的技术\n\ndocker\nk8s\nkubectl\ngrpc\ngit lfs\ngo语言\n\nProtocol Buffer\n序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统\n结构体标签\nworkpool\n\nHTTP 消息首部MIME 类型\npoc\ngorm中的事务，redis中事务\n\n\n并发读写，并发锁sync.Map\nredis-cli\n数据库\n    TIDB\n    redis\n\n存储\n    分布式存储GlusterFS\n    TIKV\n    minio\n\nlinux的VFS内容\netcd数据库备份\nAnsible\ncfssl证书\njinja\ncrontab自动执行\n原型软件axure\nBloomRPC\nC++技术\n    Snowflake算法\n    消息阻塞队列\n    对象池\n        CustomObjectPool\n        ObjectPool\n\n## GoLang\n- grpc\n- grom\n- prototobuf\n- 消息队列\n- 分布式追踪系统 -- Opentracing\nnavicate mysqlGUI工具\nnsqlookupd：高性能消息中间件 NSQ 解析\nNSQ——订阅摘要和推送摘要，日志流中间件\n消息队列\n\n\n    \n\n\n# 对一些内容的详细解释\n\n## k8s\n    kubernetes\n    IAAS——基础服务设施\n    PAAS——平台服务设施\n        docker——paas的下一代标准\n        k8s解决集群问题，每个机器里面都有一个docker\n        容器的集群化，资源管理器\n        apache——MESOS\n            分布式资源管理框架\n            2019 twitter不用了\n            推特在用，现在在用k8s\n\n        docker swarm\n            docker母公司\n            swarm集群\n            2019-7\n                阿里云宣布 docker swarm剔除\n\n\n        kubernetes\n            goolgle\n                10年容器化基础架构\n                公司里面在用borg\n                现在用go写了一个borg\n\n            特点\n                轻量级，消耗的资源少\n                开源\n                弹性伸缩\n                负载均衡：IPVS框架\n\n\n        人群\n            软件工程师\n            测试、运维、产品经理\n            需要了解产品底层框架\n\n\n    SAAS\n    raft算法\n    snap——\n    wal——日志持久化存储\n\n## 分布式追踪系统 -- Opentracing\n    OpenTracing 于 2016 年 10 月加入 CNCF 基金会，是继 Kubernetes 和 Prometheus 之后，第三个加入 CNCF 的开源项目\n    可方便开发者在自己的服务中集成一种或多种分布式追踪的实现\n    Logging & Metrics：可聚合的事件。例如分析某对象存储的 Nginx 日志，统计某段时间内\n    GET、PUT、DELETE、OPTIONS 操作的总数。 Metrics & Tracing：单个请求中的可计量数据。例如 SQL\n    执行总时长、gRPC 调用总次数。 Tracing & Logging：请求阶段的标签数据。例如在 Tracing\n    的信息中标记详细的错误原因。\n    Logging：ELK，近几年势头最猛的日志分析服务，无须多言。\n    Metrics：Prometheus，第二个加入 CNCF 的开源项目，非常好用。\n    Tracing：OpenTracing 和 Jaeger，Jaeger 是 Uber 开源的一个兼容 OpenTracing 标准的分布式追踪服务。目前 Jaeger 也加入了 CNCF。\n\n\n# SaaS\nSaaS是Software-as-a-Service的缩写名称，意思为软件即服务\n    Facebook，Twitter，  Instagram。 Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting。\n\nPaaS：Platform-as-a-Service（平台即服务）提供给消费者的服务是把客户采用提供的开发语言和工具（例如Java，python, .Net等）开发的或收购的应用程序部署到供应商的云计算基础设施上去。\n    MySQL，Mangodb，Java，Node.js\n\n IaaS： Infrastructure-as-a-Service（基础设施即服务）提供给消费者的服务是对所有计算基础设施的利用，包括处理CPU、内存、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。\n\n\n# NSQ\nNSQ——订阅摘要和推送摘要，日志流中间件\n    NSQ是Go语言编写的一个开源的实时分布式内存消息队列，其性能十分优异。\n    分布式实时消息平台\n    NSQ 是实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。它具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征\n    适合小型项目使用,用来学习消息队列实现原理、学习 golang channel知识以及如何用 go 来写分布式，为什么说适合小型小型项目使用因为，nsq 如果没有能力进行二次开发的情况存在的问题还是很多的。\n\n\n\n\n\n\n# 档案导出的流程\n\n<!-- # 档案导入——增 -->\n\n# 档案查询——查\n大顶堆\n优化mysql\n\n<!-- 分库分表？ -->\n\n查询的时候，每个项目的内容都非常的大，但是只需要用他们的一部分来排序\n所以使用大顶堆来进行插入，插入的时候同时完成了排序\n在需要使用的时候，直接将大顶堆读取出来就可以了\n\n\n## 算法稳定性：\n堆排序是一种不稳定的排序方法。\n因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，\n因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况\n\n但是不需要兼顾这个方面，因为出现频率相同的人，随便怎么排在一起都没有关系\n\n\n\n# 档案导出——查\n多用户，多线程。上下文取消，广播进度，哈希表优化\nminio\n\n\n## 任务背景\n导出的命名格式为姓名-身份证\n由于下载的内容十分繁重，总体逻辑，保证单用户只有一个下载任务\n使用minio存储图片\n下载的目标数量极大，1000-1W的数量级\n档案中的人有1000个人，每个的档案，如果被布控的到，会有1-2K照片，每个照片20KB，jpg模式\n下载的内容分为，档案图，人脸图，场景图\n## 档案导出主函数\n0.0 数据库初始化，在整个服务初始化的时候完成\n0.1 获取上下文，打印日志，填写requestid\n0.2 定义导出需要用到的接口\n    - 导出主程序接口\n    - 查询导出任务进度\n    - 删除导出任务\n1.验证用户输入是否正确\n\n\n2.先查询当前任务状态，如果已经有任务在执行，那么直接返回\n    -- 获取的下载目标，在数据库中无法存放数组，用字符串代替\n    -- 如果不是运行中，可能是任务未开始、任务失败、任务成功，都删除一下当前任务\n\n3.在数据库库中插入本次下载的记录\n4.串联上下文，将上下文信息传递到协程里面，\n\n5.返回开始任务，进度为0%，接口运行结束\n\n\n# 调试方法\n1.postman进行本地接口传入参数调试\n2.直接放到服务器上的k8s中进行运行，打印日志进行调试\n\n# 协程中的内容\n0. 运行的过程中不停的更新进度的状态，进行进度广播\n0. 使用线程池加速下载，线程池里面开线程池？？不可以？？\n    8核下载全部轨迹，从135s->20s\n0. 错误处理\n0. 使用哈希表，减少摄像头信息的存储\n1. 获取想要导出的目标的信息\n目标的，姓名-身份证\n如果需要导出的目标是空的，那还是建立一个空文件夹\n有时候，需要下载的内容过于庞大了，超过了gRPC单次传输的上限，所以就用分页的方法来获取数据，（获取数据调用的别的微服务，那个接口支持分页）\n2. 在本地建立需要导出目标的文件夹\n目录为，随机uuid\n    - 找到可执行目录\n    - 生成uuid\n    - uuid/export/建立业务文件夹\n导出的图片是存在minio里面的，从网上下载下来，放在目录里面，压缩打包再上传\n3. 对需要下载的每个目标进行下载\n更具业务需求，分情况讨论\n下载的过程中，使用base64对图片地址进行解密\n由于每个目标是独立的任务，所以可以使用线程池进行加速\n    - 需要调用其他的微服务，还获取图片数据\n4. 对生成的文件进行zip压缩\n- 使用defer删除建立的临时压缩报\n- filepath.Walk来遍历文件压缩进去\n5. 将压缩包上传到minio，将minio的地址存到数据库中\n    - 上传中修改了minio存储的ContentDisposition,修改了http下载时候的文件名\n\n\n# 档案删除——删\n查了redis\n\n\n删除任务中，遇到了无法删除数据库内容的问题\n查找后发现，删除的时候使用了事务，这个事务里面需要同时删除三个数据库中的数据，但是在有一个删除操作中，删除的量过大的，导致删除终止，整个事务回滚，删除失败\n需要一次删除25w条数据，每条数据大概4000byte,\n25W条数据是极限了\n有一些10W条以下的小数据，删除成功了，但是之前使用的gorm的软删除，改为了直接删除\n\n解决方法：先查询需要删除的数量，如果大于一定数量，就不使用事务，自己分批次删除\n\n\n这个删除使用了代理模式，分为proxy，work,store三个层次\nproxy处理一些简单的外部响应，先删除外部的数据库\n真正的删除放在内部的store中，删除图片，redis,tidb\n\ntidb中有一个库的常用键值没有加索引，导致搜索的十分缓慢，所以加上了索引\n\n\n\n\n\n### 定时任务\n使用管道和协程回调函数，来实现一个定时任务\n对两天前的老数据进行清理\n\n\n\n# 为什么要用redis\n检测到的人的特征放在redis里面\n由于需要监控的人非常多，而且人需要存储的特征也非常多，并且总是需要使用到人的特征，所以放到redis里面\n需要保存轨迹点的数据，内容量很大，并且读写频率很高\n\n\n\n\n\n\n\n\n\n[消息队列浅析]https://developer.aliyun.com/article/988780?spm=a2c6h.12873639.article-detail.40.167b2eefaMJqaj&scm=20140722.ID_community@@article@@988780._.ID_community@@article@@988780-OR_rec-V_1\n[OpenTracing]https://blog.csdn.net/eight_eyes/article/details/117330608\n\n[数据结构 - 堆的应用场景]https://blog.csdn.net/it_lihongmin/article/details/114528779?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&utm_relevant_index=2\n[堆及堆的具体使用场景]https://www.jianshu.com/p/e8e267879b61\n\n\n","content":"<h1 id=\"实习中学到的新技术\"><a href=\"#实习中学到的新技术\" class=\"headerlink\" title=\"实习中学到的新技术\"></a>实习中学到的新技术</h1><p>2022.3~2022.4 基于 Linux 的 TinyWebServer<br>项目描述:该项目是为学习 Linux 网络编程知识，在 Linux 环境下使用 C++语言开发的轻量级多线程 HTTP<br>服务器，服务器支持一定数量的客户端连接并及时响应，支持客户端访问服务器的图片、视频等资源。<br>主要工作: 1、使用 Socket 实现不同主机之间的通信;<br>2、使用 Epoll 技术实现 I&#x2F;O 多路复用，提高效率;<br>3、使用有限状态机解析 HTTP 请求报文，对 GET 和 POST 请求进行处理4、利用多线程的机制，增加并行服务数量。<br>项目难点: 1、实现线程池，提高吞吐量;<br>2、编写主从状态机对 HTTP 报文进行解析; l<br>个人收获: 1、在此项目中，使用 Makefile 进行编译，掌握一门全新的技术;<br>2、对 HTTP 的服务过程以及 TCP 三次握手有了更深的了解﹔<br>3、对于 Socket 通信以及 I&#x2F;0 复用有了一定的理解，对已有知识进行夯实</p>\n<p>2021.12~2022.1 杭州大数云智科技有限公司<br>1.通过学习 GitHub 上的开源项目 MotionPlanning，通过 python 实现一些路径规划的算法。。<br>2.使用 Vscode 通过 ssh 连接调试塔克机器人小车，通过 Ubuntu16.04 虚拟机搭载 ROS Melodic ，连接<br>小车，进行激光雷达、双目摄像头和深度相机的 SLAM 建模</p>\n<p>2022.6~2022.8 杭州后起智能科技有限公司  C++后台开发实习<br>工作描述：和公司团队一起开发灯塔AI视图分析系统<br>主要职责：<br>1.对灯塔系统中的档案文件实现档案查询，导出，删除的功能<br>2.整合AI系统中模型生成<br>个人收获：<br>1.学习了公司的开发流程，了解了公司的一些业务设计思想<br>1.加强了Git的各种使用方式</p>\n<p>自己的全面总结：<br>思想上：</p>\n<ol>\n<li>了解了公司的运行流程，互联网公司的组成模式<br>技术上：</li>\n<li>语言：</li>\n</ol>\n<p>5个go项目<br>4个c++项目,三个都和shell相关<br>3个数据库相关，MySQL<br>5个shell项目，两个重度shell<br>ansible,k8s,docker<br><del>wsl</del></p>\n<h1 id=\"新学的技术\"><a href=\"#新学的技术\" class=\"headerlink\" title=\"新学的技术\"></a>新学的技术</h1><p>docker<br>k8s<br>kubectl<br>grpc<br>git lfs<br>go语言</p>\n<p>Protocol Buffer<br>序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统<br>结构体标签<br>workpool</p>\n<p>HTTP 消息首部MIME 类型<br>poc<br>gorm中的事务，redis中事务</p>\n<p>并发读写，并发锁sync.Map<br>redis-cli<br>数据库<br>    TIDB<br>    redis</p>\n<p>存储<br>    分布式存储GlusterFS<br>    TIKV<br>    minio</p>\n<p>linux的VFS内容<br>etcd数据库备份<br>Ansible<br>cfssl证书<br>jinja<br>crontab自动执行<br>原型软件axure<br>BloomRPC<br>C++技术<br>    Snowflake算法<br>    消息阻塞队列<br>    对象池<br>        CustomObjectPool<br>        ObjectPool</p>\n<h2 id=\"GoLang\"><a href=\"#GoLang\" class=\"headerlink\" title=\"GoLang\"></a>GoLang</h2><ul>\n<li>grpc</li>\n<li>grom</li>\n<li>prototobuf</li>\n<li>消息队列</li>\n<li>分布式追踪系统 – Opentracing<br>navicate mysqlGUI工具<br>nsqlookupd：高性能消息中间件 NSQ 解析<br>NSQ——订阅摘要和推送摘要，日志流中间件<br>消息队列</li>\n</ul>\n<h1 id=\"对一些内容的详细解释\"><a href=\"#对一些内容的详细解释\" class=\"headerlink\" title=\"对一些内容的详细解释\"></a>对一些内容的详细解释</h1><h2 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h2><pre><code>kubernetes\nIAAS——基础服务设施\nPAAS——平台服务设施\n    docker——paas的下一代标准\n    k8s解决集群问题，每个机器里面都有一个docker\n    容器的集群化，资源管理器\n    apache——MESOS\n        分布式资源管理框架\n        2019 twitter不用了\n        推特在用，现在在用k8s\n\n    docker swarm\n        docker母公司\n        swarm集群\n        2019-7\n            阿里云宣布 docker swarm剔除\n\n\n    kubernetes\n        goolgle\n            10年容器化基础架构\n            公司里面在用borg\n            现在用go写了一个borg\n\n        特点\n            轻量级，消耗的资源少\n            开源\n            弹性伸缩\n            负载均衡：IPVS框架\n\n\n    人群\n        软件工程师\n        测试、运维、产品经理\n        需要了解产品底层框架\n\n\nSAAS\nraft算法\nsnap——\nwal——日志持久化存储\n</code></pre>\n<h2 id=\"分布式追踪系统-–-Opentracing\"><a href=\"#分布式追踪系统-–-Opentracing\" class=\"headerlink\" title=\"分布式追踪系统 – Opentracing\"></a>分布式追踪系统 – Opentracing</h2><pre><code>OpenTracing 于 2016 年 10 月加入 CNCF 基金会，是继 Kubernetes 和 Prometheus 之后，第三个加入 CNCF 的开源项目\n可方便开发者在自己的服务中集成一种或多种分布式追踪的实现\nLogging &amp; Metrics：可聚合的事件。例如分析某对象存储的 Nginx 日志，统计某段时间内\nGET、PUT、DELETE、OPTIONS 操作的总数。 Metrics &amp; Tracing：单个请求中的可计量数据。例如 SQL\n执行总时长、gRPC 调用总次数。 Tracing &amp; Logging：请求阶段的标签数据。例如在 Tracing\n的信息中标记详细的错误原因。\nLogging：ELK，近几年势头最猛的日志分析服务，无须多言。\nMetrics：Prometheus，第二个加入 CNCF 的开源项目，非常好用。\nTracing：OpenTracing 和 Jaeger，Jaeger 是 Uber 开源的一个兼容 OpenTracing 标准的分布式追踪服务。目前 Jaeger 也加入了 CNCF。\n</code></pre>\n<h1 id=\"SaaS\"><a href=\"#SaaS\" class=\"headerlink\" title=\"SaaS\"></a>SaaS</h1><p>SaaS是Software-as-a-Service的缩写名称，意思为软件即服务<br>    Facebook，Twitter，  Instagram。 Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting。</p>\n<p>PaaS：Platform-as-a-Service（平台即服务）提供给消费者的服务是把客户采用提供的开发语言和工具（例如Java，python, .Net等）开发的或收购的应用程序部署到供应商的云计算基础设施上去。<br>    MySQL，Mangodb，Java，Node.js</p>\n<p> IaaS： Infrastructure-as-a-Service（基础设施即服务）提供给消费者的服务是对所有计算基础设施的利用，包括处理CPU、内存、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。</p>\n<h1 id=\"NSQ\"><a href=\"#NSQ\" class=\"headerlink\" title=\"NSQ\"></a>NSQ</h1><p>NSQ——订阅摘要和推送摘要，日志流中间件<br>    NSQ是Go语言编写的一个开源的实时分布式内存消息队列，其性能十分优异。<br>    分布式实时消息平台<br>    NSQ 是实时的分布式消息处理平台，其设计的目的是用来大规模地处理每天数以十亿计级别的消息。它具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征<br>    适合小型项目使用,用来学习消息队列实现原理、学习 golang channel知识以及如何用 go 来写分布式，为什么说适合小型小型项目使用因为，nsq 如果没有能力进行二次开发的情况存在的问题还是很多的。</p>\n<h1 id=\"档案导出的流程\"><a href=\"#档案导出的流程\" class=\"headerlink\" title=\"档案导出的流程\"></a>档案导出的流程</h1><!-- # 档案导入——增 -->\n\n<h1 id=\"档案查询——查\"><a href=\"#档案查询——查\" class=\"headerlink\" title=\"档案查询——查\"></a>档案查询——查</h1><p>大顶堆<br>优化mysql</p>\n<!-- 分库分表？ -->\n\n<p>查询的时候，每个项目的内容都非常的大，但是只需要用他们的一部分来排序<br>所以使用大顶堆来进行插入，插入的时候同时完成了排序<br>在需要使用的时候，直接将大顶堆读取出来就可以了</p>\n<h2 id=\"算法稳定性：\"><a href=\"#算法稳定性：\" class=\"headerlink\" title=\"算法稳定性：\"></a>算法稳定性：</h2><p>堆排序是一种不稳定的排序方法。<br>因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，<br>因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况</p>\n<p>但是不需要兼顾这个方面，因为出现频率相同的人，随便怎么排在一起都没有关系</p>\n<h1 id=\"档案导出——查\"><a href=\"#档案导出——查\" class=\"headerlink\" title=\"档案导出——查\"></a>档案导出——查</h1><p>多用户，多线程。上下文取消，广播进度，哈希表优化<br>minio</p>\n<h2 id=\"任务背景\"><a href=\"#任务背景\" class=\"headerlink\" title=\"任务背景\"></a>任务背景</h2><p>导出的命名格式为姓名-身份证<br>由于下载的内容十分繁重，总体逻辑，保证单用户只有一个下载任务<br>使用minio存储图片<br>下载的目标数量极大，1000-1W的数量级<br>档案中的人有1000个人，每个的档案，如果被布控的到，会有1-2K照片，每个照片20KB，jpg模式<br>下载的内容分为，档案图，人脸图，场景图</p>\n<h2 id=\"档案导出主函数\"><a href=\"#档案导出主函数\" class=\"headerlink\" title=\"档案导出主函数\"></a>档案导出主函数</h2><p>0.0 数据库初始化，在整个服务初始化的时候完成<br>0.1 获取上下文，打印日志，填写requestid<br>0.2 定义导出需要用到的接口<br>    - 导出主程序接口<br>    - 查询导出任务进度<br>    - 删除导出任务<br>1.验证用户输入是否正确</p>\n<p>2.先查询当前任务状态，如果已经有任务在执行，那么直接返回<br>    – 获取的下载目标，在数据库中无法存放数组，用字符串代替<br>    – 如果不是运行中，可能是任务未开始、任务失败、任务成功，都删除一下当前任务</p>\n<p>3.在数据库库中插入本次下载的记录<br>4.串联上下文，将上下文信息传递到协程里面，</p>\n<p>5.返回开始任务，进度为0%，接口运行结束</p>\n<h1 id=\"调试方法\"><a href=\"#调试方法\" class=\"headerlink\" title=\"调试方法\"></a>调试方法</h1><p>1.postman进行本地接口传入参数调试<br>2.直接放到服务器上的k8s中进行运行，打印日志进行调试</p>\n<h1 id=\"协程中的内容\"><a href=\"#协程中的内容\" class=\"headerlink\" title=\"协程中的内容\"></a>协程中的内容</h1><ol start=\"0\">\n<li>运行的过程中不停的更新进度的状态，进行进度广播</li>\n<li>使用线程池加速下载，线程池里面开线程池？？不可以？？<br> 8核下载全部轨迹，从135s-&gt;20s</li>\n<li>错误处理</li>\n<li>使用哈希表，减少摄像头信息的存储</li>\n<li>获取想要导出的目标的信息<br>目标的，姓名-身份证<br>如果需要导出的目标是空的，那还是建立一个空文件夹<br>有时候，需要下载的内容过于庞大了，超过了gRPC单次传输的上限，所以就用分页的方法来获取数据，（获取数据调用的别的微服务，那个接口支持分页）</li>\n<li>在本地建立需要导出目标的文件夹<br>目录为，随机uuid<ul>\n<li>找到可执行目录</li>\n<li>生成uuid</li>\n<li>uuid&#x2F;export&#x2F;建立业务文件夹<br>导出的图片是存在minio里面的，从网上下载下来，放在目录里面，压缩打包再上传</li>\n</ul>\n</li>\n<li>对需要下载的每个目标进行下载<br>更具业务需求，分情况讨论<br>下载的过程中，使用base64对图片地址进行解密<br>由于每个目标是独立的任务，所以可以使用线程池进行加速<ul>\n<li>需要调用其他的微服务，还获取图片数据</li>\n</ul>\n</li>\n<li>对生成的文件进行zip压缩</li>\n</ol>\n<ul>\n<li>使用defer删除建立的临时压缩报</li>\n<li>filepath.Walk来遍历文件压缩进去</li>\n</ul>\n<ol start=\"5\">\n<li>将压缩包上传到minio，将minio的地址存到数据库中<ul>\n<li>上传中修改了minio存储的ContentDisposition,修改了http下载时候的文件名</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"档案删除——删\"><a href=\"#档案删除——删\" class=\"headerlink\" title=\"档案删除——删\"></a>档案删除——删</h1><p>查了redis</p>\n<p>删除任务中，遇到了无法删除数据库内容的问题<br>查找后发现，删除的时候使用了事务，这个事务里面需要同时删除三个数据库中的数据，但是在有一个删除操作中，删除的量过大的，导致删除终止，整个事务回滚，删除失败<br>需要一次删除25w条数据，每条数据大概4000byte,<br>25W条数据是极限了<br>有一些10W条以下的小数据，删除成功了，但是之前使用的gorm的软删除，改为了直接删除</p>\n<p>解决方法：先查询需要删除的数量，如果大于一定数量，就不使用事务，自己分批次删除</p>\n<p>这个删除使用了代理模式，分为proxy，work,store三个层次<br>proxy处理一些简单的外部响应，先删除外部的数据库<br>真正的删除放在内部的store中，删除图片，redis,tidb</p>\n<p>tidb中有一个库的常用键值没有加索引，导致搜索的十分缓慢，所以加上了索引</p>\n<h3 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h3><p>使用管道和协程回调函数，来实现一个定时任务<br>对两天前的老数据进行清理</p>\n<h1 id=\"为什么要用redis\"><a href=\"#为什么要用redis\" class=\"headerlink\" title=\"为什么要用redis\"></a>为什么要用redis</h1><p>检测到的人的特征放在redis里面<br>由于需要监控的人非常多，而且人需要存储的特征也非常多，并且总是需要使用到人的特征，所以放到redis里面<br>需要保存轨迹点的数据，内容量很大，并且读写频率很高</p>\n<p>[消息队列浅析]<a href=\"https://developer.aliyun.com/article/988780?spm=a2c6h.12873639.article-detail.40.167b2eefaMJqaj&amp;scm=20140722.ID_community@@article@@988780._.ID_community@@article@@988780-OR_rec-V_1\">https://developer.aliyun.com/article/988780?spm=a2c6h.12873639.article-detail.40.167b2eefaMJqaj&amp;scm=20140722.ID_community@@article@@988780._.ID_community@@article@@988780-OR_rec-V_1</a><br>[OpenTracing]<a href=\"https://blog.csdn.net/eight_eyes/article/details/117330608\">https://blog.csdn.net/eight_eyes/article/details/117330608</a></p>\n<p>[数据结构 - 堆的应用场景]<a href=\"https://blog.csdn.net/it_lihongmin/article/details/114528779?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=2\">https://blog.csdn.net/it_lihongmin/article/details/114528779?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114528779-blog-79371735.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=2</a><br>[堆及堆的具体使用场景]<a href=\"https://www.jianshu.com/p/e8e267879b61\">https://www.jianshu.com/p/e8e267879b61</a></p>\n","slug":"Reflection/实习中用到的技术","updated":"22/11/2022","comments":true,"link":"","permalink":"http://example.com/2022/08/22/Reflection/%E5%AE%9E%E4%B9%A0%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF/","excerpt":"","categories":[],"tags":[{"name":"反思","slug":"反思","permalink":"http://example.com/tags/%E5%8F%8D%E6%80%9D/"}]},{"title":"k8s教程","date":"11/08/2022","path":"2022/08/11/Course/k8s-tutorial/","text":"常见资源namspaceNamespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现多套环境的资源隔离或者多租户的资源隔离 kubectl get namespace kubectl get nc kubectl get rs my-name -n dev -o -wide -n 命名空间-o 查看pod节点详情 查看kubernetes的资源情况：kubectl get ns 查看kubernetes集群状态： kubectl get cs kubectl -n lookonce describe pods&#x2F;web-588rc查看pod的信息 Etcd 数据持久化和复制snap：用于存放快照数据。Etcd 为防止 WAL 文件过多会创建快照，snap 用于存储 Etcd 的快照数据状态。wal：用于存放预写式日志，其最大的作用是记录整个数据变化的全部历程。在 Etcd 中，所有数据的修改在提交前，都要先写入 WAL 中。使用 WAL 进行数据的存储使得 Etcd 拥有故障快速回复和数据回滚这两个重要功能。 删除podkubectl delete pod basic-pd-0 -n tidb-cluster Statefulsetkubectl -n tidb-cluster describe pod basic-pd-0 t edit StatefulSet basic-pd 查看一个pod的状态t describe pods basic-pd-0 重启策略restartPolicy: NeverAlways:容器失效时，自动重启该容器，这也是默认值OnFailure:容器终止运行且退出码不为0时重启Never :不论状态为何，都不重启该容器 钩子函数post startpre stop 钩子处理器支持使用下面三种方式定义动作： Exec命令：在容器内执行一次命令 …… lifecycle: postStart: exec: command: - cat - &#x2F;tmp&#x2F;healthy……TCPSocket：在当前容器尝试访问指定的socket …… lifecycle: postStart: tcpSocket: port: 8080……HTTPGet：在当前容器中向某url发起http请求 …… lifecycle: postStart: httpGet: path: &#x2F; #URI地址 port: 80 #端口号 host: 192.168.5.3 #主机地址 scheme: HTTP #支持的协议，http或者https…… 查看版本kubectl api-versions kubectl api-resources t get endpoints kubectl get pod -A 参考文献[大佬做的笔记]https://www.yuque.com/fairy-era/yg511q/szg74m备份etcd[kubernetes之StatefulSet详解]https://www.cnblogs.com/tylerzhou/p/11027559.html","raw":"---\ntitle: k8s教程\ndate: 2022-08-11 10:15:04\ntags:\n- 课程\n---\n\n\n\n# 常见资源\n## namspace\nNamespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现**多套环境的资源隔离**或者**多租户的资源隔离**\n\n\nkubectl get namespace\n\n\nkubectl get nc\n\n\n\nkubectl get rs my-name -n dev -o -wide \n\n\n-n 命名空间\n-o 查看pod节点详情\n\n# 查看kubernetes的资源情况：\nkubectl get ns\n\n# 查看kubernetes集群状态：\n kubectl get cs\n\nkubectl -n lookonce describe pods/web-588rc\n查看pod的信息\n\n# Etcd 数据持久化和复制\nsnap：用于存放快照数据。Etcd 为防止 WAL 文件过多会创建快照，snap 用于存储 Etcd 的快照数据状态。\nwal：用于存放预写式日志，其最大的作用是记录整个数据变化的全部历程。在 Etcd 中，所有数据的修改在提交前，都要先写入 WAL 中。使用 WAL 进行数据的存储使得 Etcd 拥有故障快速回复和数据回滚这两个重要功能。\n\n# 删除pod\nkubectl delete pod basic-pd-0 -n tidb-cluster\n\n\n# Statefulset\n\nkubectl -n tidb-cluster describe pod basic-pd-0\n\nt edit  StatefulSet basic-pd\n\n# 查看一个pod的状态\nt describe pods basic-pd-0\n\n\n重启策略\nrestartPolicy: Never\nAlways:容器失效时，自动重启该容器，这也是默认值\nOnFailure:容器终止运行且退出码不为0时重启\nNever :不论状态为何，都不重启该容器\n\n\n# 钩子函数\npost start\npre stop\n\n\n钩子处理器支持使用下面三种方式定义动作：\n\nExec命令：在容器内执行一次命令\n\n……\n  lifecycle:\n    postStart: \n      exec:\n        command:\n        - cat\n        - /tmp/healthy\n……\nTCPSocket：在当前容器尝试访问指定的socket\n\n……      \n  lifecycle:\n    postStart:\n      tcpSocket:\n        port: 8080\n……\nHTTPGet：在当前容器中向某url发起http请求\n\n……\n  lifecycle:\n    postStart:\n      httpGet:\n        path: / #URI地址\n        port: 80 #端口号\n        host: 192.168.5.3 #主机地址\n        scheme: HTTP #支持的协议，http或者https\n……\n\n\n# 查看版本\nkubectl api-versions\n\nkubectl api-resources\n\n\n\nt get endpoints\n\n\nkubectl get pod -A\n\n# 参考文献\n[大佬做的笔记]https://www.yuque.com/fairy-era/yg511q/szg74m\n[备份etcd](https://www.cnblogs.com/paul8339/p/15629241.html#:~:text=%E5%A4%87%E4%BB%BD%E6%93%8D%E4%BD%9C%E5%9C%A8etcd%E9%9B%86%E7%BE%A4%E7%9A%84%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E3%80%82%20%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFetcd%20v3%E7%9A%84api%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BB%8E%20k8s%201.13,%E5%BC%80%E5%A7%8B%EF%BC%8Ck8s%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%20v2%20%E7%89%88%E6%9C%AC%E7%9A%84%20etcd%EF%BC%8C%E5%8D%B3k8s%E7%9A%84%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E9%83%BD%E5%AD%98%E5%9C%A8%E4%BA%86v3%E7%89%88%E6%9C%AC%E7%9A%84etcd%E4%B8%AD%E3%80%82%20%E6%95%85%E5%A4%87%E4%BB%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%9F%E5%8F%AA%E5%A4%87%E4%BB%BD%E4%BA%86%E4%BD%BF%E7%94%A8v3%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%EF%BC%8Cv2%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%E6%98%AF%E6%B2%A1%E6%9C%89%E5%81%9A%E5%A4%87%E4%BB%BD%E7%9A%84%E3%80%82)\n[kubernetes之StatefulSet详解]https://www.cnblogs.com/tylerzhou/p/11027559.html\n","content":"<h1 id=\"常见资源\"><a href=\"#常见资源\" class=\"headerlink\" title=\"常见资源\"></a>常见资源</h1><h2 id=\"namspace\"><a href=\"#namspace\" class=\"headerlink\" title=\"namspace\"></a>namspace</h2><p>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现<strong>多套环境的资源隔离</strong>或者<strong>多租户的资源隔离</strong></p>\n<p>kubectl get namespace</p>\n<p>kubectl get nc</p>\n<p>kubectl get rs my-name -n dev -o -wide </p>\n<p>-n 命名空间<br>-o 查看pod节点详情</p>\n<h1 id=\"查看kubernetes的资源情况：\"><a href=\"#查看kubernetes的资源情况：\" class=\"headerlink\" title=\"查看kubernetes的资源情况：\"></a>查看kubernetes的资源情况：</h1><p>kubectl get ns</p>\n<h1 id=\"查看kubernetes集群状态：\"><a href=\"#查看kubernetes集群状态：\" class=\"headerlink\" title=\"查看kubernetes集群状态：\"></a>查看kubernetes集群状态：</h1><p> kubectl get cs</p>\n<p>kubectl -n lookonce describe pods&#x2F;web-588rc<br>查看pod的信息</p>\n<h1 id=\"Etcd-数据持久化和复制\"><a href=\"#Etcd-数据持久化和复制\" class=\"headerlink\" title=\"Etcd 数据持久化和复制\"></a>Etcd 数据持久化和复制</h1><p>snap：用于存放快照数据。Etcd 为防止 WAL 文件过多会创建快照，snap 用于存储 Etcd 的快照数据状态。<br>wal：用于存放预写式日志，其最大的作用是记录整个数据变化的全部历程。在 Etcd 中，所有数据的修改在提交前，都要先写入 WAL 中。使用 WAL 进行数据的存储使得 Etcd 拥有故障快速回复和数据回滚这两个重要功能。</p>\n<h1 id=\"删除pod\"><a href=\"#删除pod\" class=\"headerlink\" title=\"删除pod\"></a>删除pod</h1><p>kubectl delete pod basic-pd-0 -n tidb-cluster</p>\n<h1 id=\"Statefulset\"><a href=\"#Statefulset\" class=\"headerlink\" title=\"Statefulset\"></a>Statefulset</h1><p>kubectl -n tidb-cluster describe pod basic-pd-0</p>\n<p>t edit  StatefulSet basic-pd</p>\n<h1 id=\"查看一个pod的状态\"><a href=\"#查看一个pod的状态\" class=\"headerlink\" title=\"查看一个pod的状态\"></a>查看一个pod的状态</h1><p>t describe pods basic-pd-0</p>\n<p>重启策略<br>restartPolicy: Never<br>Always:容器失效时，自动重启该容器，这也是默认值<br>OnFailure:容器终止运行且退出码不为0时重启<br>Never :不论状态为何，都不重启该容器</p>\n<h1 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h1><p>post start<br>pre stop</p>\n<p>钩子处理器支持使用下面三种方式定义动作：</p>\n<p>Exec命令：在容器内执行一次命令</p>\n<p>……<br>  lifecycle:<br>    postStart:<br>      exec:<br>        command:<br>        - cat<br>        - &#x2F;tmp&#x2F;healthy<br>……<br>TCPSocket：在当前容器尝试访问指定的socket</p>\n<p>……<br>  lifecycle:<br>    postStart:<br>      tcpSocket:<br>        port: 8080<br>……<br>HTTPGet：在当前容器中向某url发起http请求</p>\n<p>……<br>  lifecycle:<br>    postStart:<br>      httpGet:<br>        path: &#x2F; #URI地址<br>        port: 80 #端口号<br>        host: 192.168.5.3 #主机地址<br>        scheme: HTTP #支持的协议，http或者https<br>……</p>\n<h1 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h1><p>kubectl api-versions</p>\n<p>kubectl api-resources</p>\n<p>t get endpoints</p>\n<p>kubectl get pod -A</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[大佬做的笔记]<a href=\"https://www.yuque.com/fairy-era/yg511q/szg74m\">https://www.yuque.com/fairy-era/yg511q/szg74m</a><br><a href=\"https://www.cnblogs.com/paul8339/p/15629241.html#:~:text=%E5%A4%87%E4%BB%BD%E6%93%8D%E4%BD%9C%E5%9C%A8etcd%E9%9B%86%E7%BE%A4%E7%9A%84%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E3%80%82%20%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFetcd%20v3%E7%9A%84api%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BB%8E%20k8s%201.13,%E5%BC%80%E5%A7%8B%EF%BC%8Ck8s%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%20v2%20%E7%89%88%E6%9C%AC%E7%9A%84%20etcd%EF%BC%8C%E5%8D%B3k8s%E7%9A%84%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E9%83%BD%E5%AD%98%E5%9C%A8%E4%BA%86v3%E7%89%88%E6%9C%AC%E7%9A%84etcd%E4%B8%AD%E3%80%82%20%E6%95%85%E5%A4%87%E4%BB%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%9F%E5%8F%AA%E5%A4%87%E4%BB%BD%E4%BA%86%E4%BD%BF%E7%94%A8v3%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%EF%BC%8Cv2%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%E6%98%AF%E6%B2%A1%E6%9C%89%E5%81%9A%E5%A4%87%E4%BB%BD%E7%9A%84%E3%80%82\">备份etcd</a><br>[kubernetes之StatefulSet详解]<a href=\"https://www.cnblogs.com/tylerzhou/p/11027559.html\">https://www.cnblogs.com/tylerzhou/p/11027559.html</a></p>\n","slug":"Course/k8s-tutorial","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/08/11/Course/k8s-tutorial/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"做饭相关","date":"25/07/2022","path":"2022/07/25/Others/cooking-knowledge/","text":"可乐鸡翅 鱼香肉丝、糖醋排骨、锅包肉紫菜皮蛋汤虾仁炒蛋青椒塞肉炸茄子 可乐鸡翅的改进步骤一：生姜、料酒，浸泡20分钟步骤二：焯水鸡翅切开树叶、八角、葱，料酒放到水里面煮到没有泡沫出来用冷水还是热水开始煮？？？步骤三：炒出糖色放八角、树叶、料酒、蒜、大葱炒到两面金黄，一直用大火放生抽、老抽、盐（一点）最后放入可乐，小火开始炖，可乐不要太多，要没过鸡翅就可以了，可乐可以分多次加炖20分钟，汤汁烧干汤汁烧干以后，打开锅盖，烧到出泡泡装盘 需要炒出糖色来 没有粘稠的感觉，感觉像是汤 可乐加的有点多 糖醋排骨主材料：排骨辅助材料：葱、大蒜、红尖椒调味料：盐 步骤一：备料 切排骨 放在清水中，放盐、淀粉，用手抓清洗，10min 焯水：冷水，生姜、葱、排骨、料酒不断的捞出泡沫 准备调味料： 料酒 生抽 香醋冰糖、 焯水之后用温水洗干净 步骤二：开始烧5. 排骨放到锅里面，家常做法用油煎，水分炒出来，炒到金黄，拿出来6. 炒糖色，放入冰糖，大火熬化，变成枣红色，开小火，开始冒小泡，放入排骨加入调料，香叶、两个八角、葱段、桂皮7. 把嫩汁炒成糖色，放入料酒，生抽，放醋8. 加入温水或热水，水没过排骨，放入冰糖9. 炖半个小时，小料拿出来，调出香料，开大火收汁，7-8分钟，自然芡10. 汤汁粘稠，放入米醋&#x2F;香醋 红烧茄子基础做法一：主材料：圆茄子辅助材料：葱、大蒜、红尖椒 切掉头，滚刀切块 茄子切好，放在碗里，放盐搅拌，腌制10分钟 调味料 生抽 老抽 白糖 盐 清水 耗油 淀粉 葱、大蒜、尖椒 茄子用手挤出水分，挤干（为了防止吸油）加入淀粉搅拌均匀 先炒（炸）茄子，开大火，油温要高表面焦黄、倒入蒜末，炒出香味倒入汤汁收干汤汁，加入葱花 进阶做法二：主材料：圆茄子次要材料：西红柿、青椒辅助材料：葱、大蒜 前4步相同 开始炒的时候不同5. 用宽油，先开大火炸茄子，炸酥脆以后捞出来6. 油温到7-8成以后，再放进去炸一遍，把青椒也放进去炸7. 炸好以后捞出来，开始烧新的，烧西红柿加入调味料，炒出汁水8. 放入刚刚炸过的茄子 下周计划鱼香肉丝茄子","raw":"---\ntitle: 做饭相关\ndate: 2022-07-25 00:49:09\ntags:\n- 其他\n---\n\n\n\n\n\n可乐鸡翅\n\n\n鱼香肉丝、糖醋排骨、锅包肉\n紫菜皮蛋汤\n虾仁炒蛋\n青椒塞肉\n炸茄子\n\n### 可乐鸡翅的改进\n\n\n步骤一：\n生姜、料酒，浸泡20分钟\n步骤二：\n焯水\n鸡翅切开\n树叶、八角、葱，料酒放到水里面煮到没有泡沫出来\n用冷水还是热水开始煮？？？\n步骤三：\n炒出糖色\n放八角、树叶、料酒、蒜、大葱\n炒到两面金黄，一直用大火\n放生抽、老抽、盐（一点）\n最后放入可乐，小火开始炖，可乐不要太多，要没过鸡翅就可以了，可乐可以分多次加\n炖20分钟，汤汁烧干\n汤汁烧干以后，打开锅盖，烧到出泡泡\n装盘\n\n\n\n\n1. 需要炒出糖色来\n2. 没有粘稠的感觉，感觉像是汤\n3. 可乐加的有点多\n\n### 糖醋排骨\n主材料：排骨\n辅助材料：葱、大蒜、红尖椒\n调味料：盐\n\n步骤一：备料\n1. 切排骨\n2. 放在清水中，放盐、淀粉，用手抓清洗，10min\n3. 焯水：冷水，生姜、葱、排骨、料酒\n不断的捞出泡沫\n4. 准备调味料：\n- 料酒\n- 生抽\n- 香醋\n冰糖、\n5. 焯水之后用温水洗干净\n\n步骤二：开始烧\n5. 排骨放到锅里面，家常做法用油煎，水分炒出来，炒到金黄，拿出来\n6. 炒糖色，放入冰糖，大火熬化，变成枣红色，开小火，开始冒小泡，放入排骨\n加入调料，香叶、两个八角、葱段、桂皮\n7. 把嫩汁炒成糖色，放入料酒，生抽，放醋\n8. 加入温水或热水，水没过排骨，放入冰糖\n9. 炖半个小时，小料拿出来，调出香料，开大火收汁，7-8分钟，自然芡\n10. 汤汁粘稠，放入米醋/香醋\n\n\n### 红烧茄子\n\n#### 基础做法一：\n主材料：圆茄子\n辅助材料：葱、大蒜、红尖椒\n\n1. 切掉头，滚刀切块\n2. 茄子切好，放在碗里，放盐搅拌，腌制10分钟\n3. 调味料\n- 生抽\n- 老抽\n- 白糖\n- 盐   \n- 清水\n- [ ] 耗油\n- [ ] 淀粉\n\n葱、大蒜、尖椒\n\n4. 茄子用手挤出水分，挤干（为了防止吸油）\n加入淀粉搅拌均匀\n\n5. 先炒（炸）茄子，开大火，油温要高\n表面焦黄、倒入蒜末，炒出香味\n倒入汤汁\n收干汤汁，加入葱花\n\n#### 进阶做法二：\n主材料：圆茄子\n次要材料：西红柿、青椒\n辅助材料：葱、大蒜\n\n\n前4步相同\n\n开始炒的时候不同\n5. 用宽油，先开大火炸茄子，炸酥脆以后捞出来\n6. 油温到7-8成以后，再放进去炸一遍，把青椒也放进去炸\n7. 炸好以后捞出来，开始烧新的，烧西红柿\n加入调味料，炒出汁水\n8. 放入刚刚炸过的茄子\n\n\n## 下周计划\n\n鱼香肉丝\n茄子\n\n","content":"<p>可乐鸡翅</p>\n<p>鱼香肉丝、糖醋排骨、锅包肉<br>紫菜皮蛋汤<br>虾仁炒蛋<br>青椒塞肉<br>炸茄子</p>\n<h3 id=\"可乐鸡翅的改进\"><a href=\"#可乐鸡翅的改进\" class=\"headerlink\" title=\"可乐鸡翅的改进\"></a>可乐鸡翅的改进</h3><p>步骤一：<br>生姜、料酒，浸泡20分钟<br>步骤二：<br>焯水<br>鸡翅切开<br>树叶、八角、葱，料酒放到水里面煮到没有泡沫出来<br>用冷水还是热水开始煮？？？<br>步骤三：<br>炒出糖色<br>放八角、树叶、料酒、蒜、大葱<br>炒到两面金黄，一直用大火<br>放生抽、老抽、盐（一点）<br>最后放入可乐，小火开始炖，可乐不要太多，要没过鸡翅就可以了，可乐可以分多次加<br>炖20分钟，汤汁烧干<br>汤汁烧干以后，打开锅盖，烧到出泡泡<br>装盘</p>\n<ol>\n<li>需要炒出糖色来</li>\n<li>没有粘稠的感觉，感觉像是汤</li>\n<li>可乐加的有点多</li>\n</ol>\n<h3 id=\"糖醋排骨\"><a href=\"#糖醋排骨\" class=\"headerlink\" title=\"糖醋排骨\"></a>糖醋排骨</h3><p>主材料：排骨<br>辅助材料：葱、大蒜、红尖椒<br>调味料：盐</p>\n<p>步骤一：备料</p>\n<ol>\n<li>切排骨</li>\n<li>放在清水中，放盐、淀粉，用手抓清洗，10min</li>\n<li>焯水：冷水，生姜、葱、排骨、料酒<br>不断的捞出泡沫</li>\n<li>准备调味料：</li>\n</ol>\n<ul>\n<li>料酒</li>\n<li>生抽</li>\n<li>香醋<br>冰糖、</li>\n</ul>\n<ol start=\"5\">\n<li>焯水之后用温水洗干净</li>\n</ol>\n<p>步骤二：开始烧<br>5. 排骨放到锅里面，家常做法用油煎，水分炒出来，炒到金黄，拿出来<br>6. 炒糖色，放入冰糖，大火熬化，变成枣红色，开小火，开始冒小泡，放入排骨<br>加入调料，香叶、两个八角、葱段、桂皮<br>7. 把嫩汁炒成糖色，放入料酒，生抽，放醋<br>8. 加入温水或热水，水没过排骨，放入冰糖<br>9. 炖半个小时，小料拿出来，调出香料，开大火收汁，7-8分钟，自然芡<br>10. 汤汁粘稠，放入米醋&#x2F;香醋</p>\n<h3 id=\"红烧茄子\"><a href=\"#红烧茄子\" class=\"headerlink\" title=\"红烧茄子\"></a>红烧茄子</h3><h4 id=\"基础做法一：\"><a href=\"#基础做法一：\" class=\"headerlink\" title=\"基础做法一：\"></a>基础做法一：</h4><p>主材料：圆茄子<br>辅助材料：葱、大蒜、红尖椒</p>\n<ol>\n<li>切掉头，滚刀切块</li>\n<li>茄子切好，放在碗里，放盐搅拌，腌制10分钟</li>\n<li>调味料</li>\n</ol>\n<ul>\n<li>生抽</li>\n<li>老抽</li>\n<li>白糖</li>\n<li>盐   </li>\n<li>清水</li>\n<li><input disabled=\"\" type=\"checkbox\"> 耗油</li>\n<li><input disabled=\"\" type=\"checkbox\"> 淀粉</li>\n</ul>\n<p>葱、大蒜、尖椒</p>\n<ol start=\"4\">\n<li><p>茄子用手挤出水分，挤干（为了防止吸油）<br>加入淀粉搅拌均匀</p>\n</li>\n<li><p>先炒（炸）茄子，开大火，油温要高<br>表面焦黄、倒入蒜末，炒出香味<br>倒入汤汁<br>收干汤汁，加入葱花</p>\n</li>\n</ol>\n<h4 id=\"进阶做法二：\"><a href=\"#进阶做法二：\" class=\"headerlink\" title=\"进阶做法二：\"></a>进阶做法二：</h4><p>主材料：圆茄子<br>次要材料：西红柿、青椒<br>辅助材料：葱、大蒜</p>\n<p>前4步相同</p>\n<p>开始炒的时候不同<br>5. 用宽油，先开大火炸茄子，炸酥脆以后捞出来<br>6. 油温到7-8成以后，再放进去炸一遍，把青椒也放进去炸<br>7. 炸好以后捞出来，开始烧新的，烧西红柿<br>加入调味料，炒出汁水<br>8. 放入刚刚炸过的茄子</p>\n<h2 id=\"下周计划\"><a href=\"#下周计划\" class=\"headerlink\" title=\"下周计划\"></a>下周计划</h2><p>鱼香肉丝<br>茄子</p>\n","slug":"Others/cooking-knowledge","updated":"30/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/07/25/Others/cooking-knowledge/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"截图工具","date":"25/07/2022","path":"2022/07/25/Project/Screenshot-tool/","text":"需求分析看看市面上的截图工具 QQ截图独立版：https://bbs.pediy.com/thread-271332.htmSnipaste官网：https://zh.snipaste.com/eSearch官网：https://esearch.vercel.app/PicPick官网：https://picpick.app/zh/FastStone Capture官网：https://www.faststone.org/FSCaptureDetail.htmShareX官网：https://getsharex.com/ 自己想要什么功能","raw":"---\ntitle: 截图工具\ndate: 2022-07-25 00:44:29\ntags:\n- 项目\n---\n\n\n# 需求分析\n\n看看市面上的截图工具\n\nQQ截图独立版：https://bbs.pediy.com/thread-271332.htm\nSnipaste官网：https://zh.snipaste.com/\neSearch官网：https://esearch.vercel.app/\nPicPick官网：https://picpick.app/zh/\nFastStone Capture官网：https://www.faststone.org/FSCaptureDetail.htm\nShareX官网：https://getsharex.com/\n\n自己想要什么功能\n\n\n\n\n\n\n","content":"<h1 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h1><p>看看市面上的截图工具</p>\n<p>QQ截图独立版：<a href=\"https://bbs.pediy.com/thread-271332.htm\">https://bbs.pediy.com/thread-271332.htm</a><br>Snipaste官网：<a href=\"https://zh.snipaste.com/\">https://zh.snipaste.com/</a><br>eSearch官网：<a href=\"https://esearch.vercel.app/\">https://esearch.vercel.app/</a><br>PicPick官网：<a href=\"https://picpick.app/zh/\">https://picpick.app/zh/</a><br>FastStone Capture官网：<a href=\"https://www.faststone.org/FSCaptureDetail.htm\">https://www.faststone.org/FSCaptureDetail.htm</a><br>ShareX官网：<a href=\"https://getsharex.com/\">https://getsharex.com/</a></p>\n<p>自己想要什么功能</p>\n","slug":"Project/Screenshot-tool","updated":"19/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/07/25/Project/Screenshot-tool/","excerpt":"","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"webserver","date":"25/07/2022","path":"2022/07/25/Project/webserver/","text":"2022-7-24 task.josn和lanch.json可以跑起来了，可以用vscode远程连接调试 使用cmake进行编译 cmake编译中添加了mysql,可以操作数据库了 2022-7-25 学习了namespace和share_ptr是怎么使用的 2022-7-30 之前发现使用语句，但是日志无法写入fix:使用阻塞队列插入，但是自己还没有实现阻塞队列的内容，导致一直是空实现，就没法写进去了 遗留的问题：单例模式在vscode中如何调试，因为进去就是一个instant()函数了 改进使用vcpkg做包管理cmake中使用vcpkg使用httplib库使用jsoncpp库接口测试方法压力测试方法 epoll_eventEPOLLIN The associated file is available for read(2) operations. EPOLLOUT The associated file is available for write(2) operations. EPOLLRDHUP (since Linux 2.6.17) # 读取到一半连接关闭 # 读关闭 在使用 epoll 时，对端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件。在低于 2.6.17 版本的内核中，这个 epoll 事件一般是 EPOLLIN，即 0x1，代表连接可读。 返回到上层以后，上层读取会EOF，报告错误。 现在增加了这个以后，客户端断开连接，就可以在底层处理了 Stream socket peer closed connection, or shut down writing half of connection. (This flag is especially useful for writing simple code to detect peer shutdown when using Edge Triggered monitoring.) EPOLLERR # EPOLLERR 是服务器这边出错 相关文件描述符上发生错误情况。 这个 当读取结束时，管道的写入结束也会报告事件 已被关闭。 epoll_wait(2) 将始终报告此事件； 它 没有必要在事件中设置它。 Error condition happened on the associated file descriptor. This event is also reported for the write end of a pipe when the read end has been closed. epoll_wait(2) will always report for this event; it is not necessary to set it in events. EPOLLHUP # 读写都关闭 Hang up happened on the associated file descriptor. epoll_wait(2) will always wait for this event; it is not necessary to set it in events. Note that when reading from a channel such as a pipe or a stream socket, this event merely indicates that the peer closed its end of the channel. Subsequent reads from the channel will return 0 (end of file) only after all outstanding data in the channel has been con‐ sumed. 如果你想写一个高性能的C++服务器，以下是一些建议： 选择正确的框架：选择一个高性能的框架，例如Boost.Asio、libevent或者libuv。这些框架可以帮助你管理网络连接、事件处理和多线程。 使用异步IO：异步IO可以提高服务器的响应速度和吞吐量。使用异步IO可以避免线程阻塞，提高服务器的效率。优化内存管理：使用内存池和对象池可以减少内存分配和释放的开销。另外，避免使用过多的动态内存分配，因为它们会导致内存碎片和性能下降。 多线程：使用多线程可以充分利用多核CPU的性能。但是，要注意避免线程间的竞争条件，例如锁等待和死锁。 优化算法：使用高效的算法可以减少CPU的负载，提高服务器的性能。例如，使用哈希表代替线性搜索可以提高查询速度。 代码优化：使用编译器优化和代码优化技术可以提高代码的执行效率。例如，使用内联函数可以避免函数调用的开销。 测试和性能优化：使用性能分析工具和压力测试工具可以发现性能瓶颈和优化点。使用这些工具可以帮助你优化服务器的性能，提高用户体验。 大体的高性能C++服务器的框架通常包括以下组件： 网络层：负责处理网络连接和数据传输。常用的网络库包括Boost.Asio、libevent和libuv等。 多线程管理：负责管理多线程和线程池。多线程可以提高服务器的并发处理能力，但是需要注意避免线程间的竞争条件。 协议处理：负责解析和处理客户端发送的协议。常用的协议包括HTTP、WebSocket、TCP和UDP等。 数据库访问：负责与数据库交互，包括查询、插入、更新和删除等操作。常用的数据库包括MySQL、PostgreSQL和MongoDB等。 缓存管理：负责管理缓存，例如Redis、Memcached等。缓存可以提高服务器的读取速度和响应速度。 日志管理：负责记录服务器的运行日志，包括错误日志、访问日志等。 安全管理：负责保障服务器的安全性，包括防止DDoS攻击、SQL注入等。 以上组件可以根据具体业务需求进行选择和定制。同时，高性能C++服务器的框架需要考虑以下因素： 高并发：需要支持高并发的处理能力，避免线程阻塞和死锁。 高效率：需要尽可能地利用CPU和内存资源，避免资源浪费。 可扩展性：需要支持水平和垂直扩展，以应对不同的业务需求。 可靠性：需要具备高可靠性和容错能力，避免因为单点故障导致整个服务不可用。 易用性：需要具备易用性和易维护性，方便开发人员进行开发和维护。 防止DDoS攻击是一个复杂的话题，需要综合考虑许多因素，包括网络安全、服务器性能、负载均衡等。以下是一些基本的防御措施，您可以在C++服务器中实现它们： 限制连接速率：通过限制每个IP地址的连接速率来减轻服务器的负载。可以使用令牌桶算法或漏桶算法来实现这个功能。 IP黑名单：通过检测攻击流量的来源IP地址并将它们添加到黑名单中来减轻服务器的负载。 限制请求大小：通过限制每个请求的大小来防止攻击者发送大量的请求，从而导致服务器负载过高。 使用CDN：使用内容分发网络（CDN）可以将流量分散到多个地理位置的服务器，从而减轻攻击的影响。 负载均衡：通过使用负载均衡技术，可以将流量分散到多个服务器上，从而减轻攻击的影响。 DDoS防护软件：使用专门的DDoS防护软件，可以自动检测和过滤攻击流量。请注意，这些措施只是一些基本的防御措施，无法完全保护服务器免受DDoS攻击。因此，建议您与网络安全专家合作，制定更全面的防御策略。 令牌桶算法是一种常用的限流算法，可以用于限制每个IP地址的连接速率。以下是一个简单的C++实现令牌桶算法的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;using namespace std::chrono;class TokenBucket &#123;public: TokenBucket(int capacity, int rate) : capacity_(capacity), rate_(rate), tokens_(0) &#123; last_refill_time_ = steady_clock::now(); &#125; bool TryConsume(int tokens) &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); Refill(); if (tokens_ &gt;= tokens) &#123; tokens_ -= tokens; return true; &#125; else &#123; return false; &#125; &#125;private: void Refill() &#123; auto now = steady_clock::now(); auto time_since_last_refill = now - last_refill_time_; last_refill_time_ = now; int tokens_to_add = duration_cast&lt;milliseconds&gt;(time_since_last_refill).count() * rate_ / 1000; tokens_ = std::min(tokens_ + tokens_to_add, capacity_); &#125; int capacity_; int rate_; int tokens_; std::mutex mutex_; std::condition_variable cv_; std::chrono::steady_clock::time_point last_refill_time_;&#125;;int main() &#123; TokenBucket bucket(10, 2); for (int i = 0; i &lt; 20; i++) &#123; std::this_thread::sleep_for(milliseconds(500)); if (bucket.TryConsume(1)) &#123; std::cout &lt;&lt; &quot;Request &quot; &lt;&lt; i &lt;&lt; &quot; accepted.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Request &quot; &lt;&lt; i &lt;&lt; &quot; rejected.&quot; &lt;&lt; std::endl; &#125; &#125; return 0;&#125; 在这个例子中，TokenBucket类维护了桶的容量、速率和当前的令牌数量。当一个请求到达时，它将尝试从桶中消耗指定数量的令牌。如果桶中有足够的令牌，请求将被接受，否则请求将被拒绝。 在TryConsume方法中，首先调用Refill方法以确保桶中有足够的令牌。然后，如果桶中有足够的令牌，它将扣除指定数量的令牌并返回true，否则它将返回false。 在Refill方法中，它计算从上次刷新以来的时间，并根据速率计算应该添加的令牌数量。然后，它将令牌数量限制在桶的容量内。 在main函数中，我们创建一个容量为10，速率为2的TokenBucket对象，并模拟20个请求，每500毫秒到达一个请求。如果请求被接受，它将输出“Request i accepted.”，否则它将输出“Request i rejected.”。 这个例子只是一个简单的演示，您可以根据自己的需求进行修改和扩展。 防止SQL注入攻击是编写安全的数据库应用程序的重要方面。以下是一个使用参数化查询防止SQL注入攻击的C++示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;mysql/mysql.h&gt;int main() &#123; MYSQL mysql; mysql_init(&amp;mysql); if (!mysql_real_connect(&amp;mysql, &quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;, &quot;database&quot;, 0, NULL, 0)) &#123; std::cerr &lt;&lt; &quot;Failed to connect to database: &quot; &lt;&lt; mysql_error(&amp;mysql) &lt;&lt; std::endl; return 1; &#125; std::string username = &quot;Alice&quot;; std::string password = &quot;pass123&quot;; MYSQL_STMT *stmt; MYSQL_BIND params[2]; stmt = mysql_stmt_init(&amp;mysql); if (!stmt) &#123; std::cerr &lt;&lt; &quot;Failed to initialize statement: &quot; &lt;&lt; mysql_error(&amp;mysql) &lt;&lt; std::endl; return 1; &#125; if (mysql_stmt_prepare(stmt, &quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;, -1) != 0) &#123; std::cerr &lt;&lt; &quot;Failed to prepare statement: &quot; &lt;&lt; mysql_stmt_error(stmt) &lt;&lt; std::endl; return 1; &#125; memset(params, 0, sizeof(params)); params[0].buffer_type = MYSQL_TYPE_STRING; params[0].buffer = (void *)username.c_str(); params[0].buffer_length = username.length(); params[1].buffer_type = MYSQL_TYPE_STRING; params[1].buffer = (void *)password.c_str(); params[1].buffer_length = password.length(); if (mysql_stmt_bind_param(stmt, params) != 0) &#123; std::cerr &lt;&lt; &quot;Failed to bind parameters: &quot; &lt;&lt; mysql_stmt_error(stmt) &lt;&lt; std::endl; return 1; &#125; if (mysql_stmt_execute(stmt) != 0) &#123; std::cerr &lt;&lt; &quot;Failed to execute statement: &quot; &lt;&lt; mysql_stmt_error(stmt) &lt;&lt; std::endl; return 1; &#125; MYSQL_RES *result = mysql_stmt_result_metadata(stmt); if (result) &#123; int num_fields = mysql_num_fields(result); MYSQL_FIELD *fields = mysql_fetch_fields(result); MYSQL_BIND bind[num_fields]; memset(bind, 0, sizeof(bind)); for (int i = 0; i &lt; num_fields; i++) &#123; bind[i].buffer_type = fields[i].type; bind[i].buffer = malloc(fields[i].length); bind[i].buffer_length = fields[i].length; &#125; if (mysql_stmt_bind_result(stmt, bind) != 0) &#123; std::cerr &lt;&lt; &quot;Failed to bind result: &quot; &lt;&lt; mysql_stmt_error(stmt) &lt;&lt; std::endl; return 1; &#125; if (mysql_stmt_store_result(stmt) != 0) &#123; std::cerr &lt;&lt; &quot;Failed to store result: &quot; &lt;&lt; mysql_stmt_error(stmt) &lt;&lt; std::endl; return 1; &#125; while (mysql_stmt_fetch(stmt) == 0) &#123; for (int i = 0; i &lt; num_fields; i++) &#123; std::cout &lt;&lt; fields[i].name &lt;&lt; &quot;: &quot;; switch (bind[i].buffer_type) &#123; case MYSQL_TYPE_LONG: std::cout &lt;&lt; *((int *)bind[i].buffer); break; case MYSQL_TYPE_STRING: std::cout &lt;&lt; (char *)bind[i].buffer; break; default: std::cout &lt;&lt; &quot;unknown type&quot;; break; &#125; std::cout &lt;&lt; std::endl; &#125; &#125; mysql_free_result(result); for (int i = 0; i &lt; num_fields; i++) &#123; free(bind[i].buffer); &#125; &#125; mysql_stmt_close(stmt); mysql_close(&amp;mysql); return 0;&#125; 在这个例子中，我们使用MySQL C API连接到数据库。我们将用户名和密码作为参数传递给查询，以防止SQL注入攻击。我们使用mysql_stmt_prepare函数准备查询并使用mysql_stmt_bind_param函数绑定参数。 我们使用MYSQL_BIND结构体来表示绑定参数和结果集。我们使用memset函数将其初始化为零，并设置每个参数的类型、缓冲区和缓冲区长度。 我们使用mysql_stmt_execute函数执行查询，并使用mysql_stmt_result_metadata函数获取结果集的元数据。如果结果集不为空，我们使用mysql_fetch_fields函数获取每个字段的元数据，并使用mysql_stmt_bind_result函数将结果绑定到MYSQL_BIND结构体中。 我们使用mysql_stmt_fetch函数获取每一行的结果，并将它们输出到控制台上。 最后，我们释放绑定缓冲区和关闭语句和数据库连接。 通过使用参数化查询，我们可以防止SQL注入攻击。 如果你想开始学习FFmpeg，以下是一些步骤： 了解FFmpeg的基本概念和术语，例如：编解码器、格式、滤镜、muxer、demuxer等等。 下载FFmpeg的源代码或预编译版本。你可以从FFmpeg官方网站或其他可靠的下载站点获取。 安装FFmpeg。如果你下载的是源代码，你需要编译和安装它。如果你下载的是预编译版本，则可以直接解压缩并安装。 学习如何使用FFmpeg。你可以从官方文档、教程、博客、视频教程等资源中获取信息。 练习使用FFmpeg。尝试使用不同的命令行选项和参数，以及不同的输入和输出格式。你可以使用一些示例文件进行测试。 加入FFmpeg社区。你可以参与FFmpeg的邮件列表、IRC频道、论坛等社区，与其他用户交流和分享经验。 总之，学习FFmpeg需要耐心和实践，如果你坚持下去，你会逐渐掌握它的技能并成为一个专业的视频处理人员。 以下是一些学习FFmpeg的参考资料： FFmpeg官方文档：https://ffmpeg.org/documentation.html FFmpeg官方wiki：https://trac.ffmpeg.org/wiki FFmpeg命令行参数手册：https://ffmpeg.org/ffmpeg.html FFmpeg格式和编解码器支持列表：https://ffmpeg.org/general.html#Supported-File-Formats-Codecs-and-Protocols FFmpeg滤镜手册：https://ffmpeg.org/ffmpeg-filters.html FFmpeg教程和示例代码：https://www.ffmpeg.org/documentation.html#Examples FFmpeg中文文档：https://www.ffmpeg.org.cn/ FFmpeg视频处理实战：https://github.com/leandromoreira/ffmpeg-libav-tutorial FFmpeg常见问题解答：https://trac.ffmpeg.org/wiki/FAQ 希望这些资料对你有所帮助，祝学习愉快！ 如果你想阅读 FFmpeg 的源代码，可以按照以下步骤开始： 先从官方网站下载最新的 FFmpeg 源代码。 阅读 FFmpeg 的文档，了解 FFmpeg 的基本概念、编译方式、命令行参数等。 阅读 FFmpeg 的主要源文件，包括 libavcodec、libavformat、libavutil 等。 学习 FFmpeg 的 API，了解如何使用 FFmpeg 的库函数来实现音视频的编解码、格式转换等功能。 阅读 FFmpeg 的示例代码，了解如何使用 FFmpeg 的 API 来实现常见的音视频处理任务。 参考 FFmpeg 的开发文档，了解如何贡献代码、提交补丁等。 总之，要深入理解 FFmpeg 的源代码，需要花费大量的时间和精力，需要掌握 C 语言、音视频编解码、多媒体格式等多个领域的知识。 libavcodec是FFmpeg中的一个库，它是一个编解码器库，提供了对各种音视频编码和解码的支持。它包含了多种音视频编解码器，如H.264、MPEG-4、MPEG-2、VP9、AAC、MP3等。在FFmpeg中，libavcodec是非常重要的一部分，它提供了FFmpeg的核心功能之一，即音视频的编解码功能。 libavcodec可以将各种不同格式的音视频数据解码成FFmpeg内部的统一格式，也可以将FFmpeg内部的统一格式编码成各种不同格式的音视频数据，支持多种音视频编解码标准，同时具有高度的可扩展性和灵活性。此外，libavcodec还提供了一些优化的编解码实现，可以提高音视频编解码的效率。 在使用libavcodec时，我们可以通过调用其提供的API来完成音视频的编解码工作，同时也可以进行一些高级的音视频处理，如滤波、裁剪、缩放、色彩空间转换等。总之，libavcodec是FFmpeg中非常重要的一部分，它为FFmpeg提供了强大的音视频编解码能力，是众多音视频应用的重要基础。 libavcodec中有很多重要的函数，以下是一些主要的函数： avcodec_find_decoder()：根据编码器ID查找解码器。 avcodec_find_encoder()：根据编码器ID查找编码器。 avcodec_open2()：打开解码器或编码器。 avcodec_close()：关闭解码器或编码器。 avcodec_send_packet()：将待解码或编码的数据包发送给解码器或编码器。 avcodec_receive_frame()：从解码器中获取解码后的视频帧或音频样本。 avcodec_send_frame()：将待编码的视频帧或音频样本发送给编码器。 avcodec_receive_packet()：从编码器中获取编码后的数据包。 avcodec_parameters_to_context()：将音视频参数填充到解码器或编码器上下文中。 avcodec_alloc_frame()：分配一个AVFrame对象。 以上是一些主要的函数，还有很多其他的函数，可以根据自己的需要选择使用。 有很多业务可以让您的MySQL存储更多的数据，以下是一些想法： 用户注册和信息管理：除了用户名和密码，您可以让用户输入更多的信息，例如电子邮件，电话号码，地址等等。这些信息可以存储在MySQL数据库中，以便您可以随时检索和更新。 商品管理：如果您有一个在线商店，您可以创建一个MySQL表来存储您的商品信息，例如名称，描述，价格，库存等等。 订单管理：如果您有一个在线商店，您可以创建一个MySQL表来存储您的订单信息，例如订单号，客户信息，商品信息，数量，总价等等。 日志管理：您可以创建一个MySQL表来存储您的应用程序日志，例如错误消息，警告消息和其他重要事件。 聊天记录：如果您有一个聊天应用程序，您可以创建一个MySQL表来存储聊天记录，以便您可以随时检索和查看以前的聊天记录。 这些只是一些想法，您可以根据自己的业务需求来扩展MySQL的内容。 如果您想要做一个视频播放网站，以下是一些您可能需要存储在MySQL中的业务信息： 视频信息：您可以创建一个MySQL表来存储您的视频信息，例如名称，描述，时长，上传日期，标签等等。 用户信息：您可以创建一个MySQL表来存储您的用户信息，例如用户名，密码，电子邮件，个人资料等等。 视频分类：您可以创建一个MySQL表来存储您的视频分类信息，例如电影，电视剧，综艺节目等等。 视频评论：您可以创建一个MySQL表来存储您的视频评论信息，例如评论内容，评论日期，用户信息等等。 视频收藏：您可以创建一个MySQL表来存储您的用户收藏视频信息，例如用户ID，视频ID，收藏日期等等。 视频播放记录：您可以创建一个MySQL表来存储您的用户播放视频记录，例如用户ID，视频ID，播放进度，播放日期等等。 这些只是一些想法，您可以根据自己的业务需求来扩展MySQL的内容。 如果您想要使用更现代的方式来处理CGI，以下是一些您可以参考的方式： FastCGI：FastCGI是一种快速且高效的CGI处理方式，它可以在Web服务器和CGI应用程序之间建立一个持久连接，从而提高性能和吞吐量。FastCGI支持多个并发请求，可以在同一个进程中处理多个请求。 SCGI：SCGI也是一种快速和高效的CGI处理方式，它可以在Web服务器和CGI应用程序之间建立一个持久连接，从而提高性能和吞吐量。与FastCGI不同的是，SCGI是一种更简单的协议，易于实现和维护。 uWSGI：uWSGI是一个Web服务器和应用程序服务器，支持多种语言和多种协议，包括CGI，FastCGI和SCGI。它可以高效地处理大量的并发请求，提供可靠的性能和可扩展性。 CGI++：CGI++是一个基于C++的CGI框架，提供了一组高级API，可以帮助您更轻松地开发和维护CGI应用程序。它支持多线程和多进程，并提供了内存池和线程池等高级功能，以提高性能和可靠性。 这些都是一些比较好的CGI处理方式，您可以根据自己的需求选择其中的一种或多种。 当然，以下是一些您可以参考的C++ CGI处理仓库： CGI++：CGI++是一个基于C++的CGI框架，提供了一组高级API，可以帮助您更轻松地开发和维护CGI应用程序。它支持多线程和多进程，并提供了内存池和线程池等高级功能，以提高性能和可靠性。 CppCMS：CppCMS是一个高性能的Web开发框架，支持CGI，FastCGI和HTTP协议。它基于C++11标准，提供了许多高级功能，例如会话管理，缓存，模板引擎等等。 Wt：Wt是一个开源的Web开发框架，支持C++，JavaScript和CSS。它提供了一个基于组件的架构，可以帮助您更轻松地开发Web应用程序。Wt支持CGI，FastCGI和HTTP协议，并提供了一组高级API，以提高性能和可靠性。 Crow：Crow是一个微型C++ Web框架，支持CGI，FastCGI和HTTP协议。它基于C++11标准，提供了一组简单而强大的API，可以帮助您更轻松地开发Web应用程序。 这些都是一些比较好的C++ CGI处理仓库，您可以根据自己的需求选择其中的一种或多种。 好的，如果您要做一个视频播放的网站，以下是一些设计建议和功能建议： 设计建议： 界面美观：一个好的视频播放网站应该有一个美观的界面，吸引用户的注意力。 响应式设计：由于用户可能会在不同的设备上访问您的网站，因此您应该设计一个响应式的界面，可以适应不同的设备屏幕大小。 用户友好：您的网站应该易于使用和导航，用户应该可以轻松地找到他们想要的内容。 快速加载：视频需要大量的带宽和资源，因此您的网站应该快速加载，以提供更好的用户体验。 功能建议： 视频搜索：用户应该可以使用关键字搜索您的视频库中的视频。 视频分类：您的网站应该将视频按照不同的类别进行分类，例如电影，电视节目，音乐视频等。 视频播放：您的网站应该提供一个视频播放器，可以播放不同格式的视频，例如MP4，AVI等。 视频上传：您的网站应该允许用户上传他们自己的视频，以增加您的视频库。 评论和评级：您的网站应该允许用户对视频进行评论和评级，以帮助其他用户找到高质量的视频。 用户账户：您的网站应该提供一个用户账户系统，用户可以在其中创建和管理他们自己的个人资料和视频列表。 推荐系统：您的网站应该提供一个推荐系统，可以向用户推荐他们可能感兴趣的视频。 希望这些建议可以帮助您设计和实现一个成功的视频播放网站。 当然，以下是一些好的视频播放网站的例子，您可以参考： YouTube：YouTube是全球最大的视频分享网站之一，支持用户上传、分享和观看视频。它提供了一个强大的搜索引擎和推荐系统，使用户可以轻松地找到他们喜欢的视频。 Vimeo：Vimeo是另一个受欢迎的视频分享网站，它更加注重高质量的视频内容和创意。它提供了一个类似于YouTube的界面，但更加专业和艺术化。 Netflix：Netflix是一个流媒体视频服务，提供了大量的电影和电视节目。它的界面非常简洁和易于使用，用户可以轻松地搜索和浏览不同的视频内容。 Hulu：Hulu是另一个流媒体视频服务，提供了大量的电影和电视节目。它的界面类似于一个电视机顶盒的界面，用户可以轻松地选择他们想要观看的内容。 Dailymotion：Dailymotion是一个视频分享网站，类似于YouTube。它提供了一个简单和易于使用的界面，用户可以上传、分享和观看视频。 这些都是一些非常成功的视频播放网站，您可以从中学习他们的设计和功能，以帮助您设计和实现自己的视频播放网站。 如果您用C++搭建视频播放网站的后台，以下是一些核心功能和需要学习的知识： 核心功能： 视频编解码：视频需要进行编解码以便于存储和播放，您需要学习有关视频编解码的知识，例如H.264，HEVC等。 视频存储：您需要学习有关数据库和文件系统的知识，以便于存储和管理大量的视频文件。 视频传输：您需要学习有关网络传输和协议的知识，以便于将视频流传输到用户的设备上。 视频播放器：您需要实现一个视频播放器，可以解码和播放不同格式的视频，例如MP4，AVI等。 用户认证和授权：您需要实现一个用户认证和授权系统，可以管理用户的访问权限和保护视频内容。 开发一个视频播放网站的时间取决于很多因素，例如网站的规模、功能、设计复杂度等等。因此，我无法给出确切的时间估计。但是，以下是一个大致的开发进度安排，供您参考： 第一周（4.13-4.19）： 规划网站功能和设计，制定开发计划。 学习有关视频编解码、数据库和网络编程的知识。 搭建基础框架，实现用户认证和授权功能。 第二周（4.20-4.26）： 学习有关视频存储和传输的知识。 实现视频上传和存储功能。 实现视频播放器，可以解码和播放不同格式的视频。 第三周（4.27-5.3）： 学习有关多线程编程和并发控制的知识。 实现视频编解码和传输功能，保证视频流畅播放。 完善网站的用户界面和功能。 第四周（5.4-5.10）： 学习有关安全和加密的知识。 实现安全和加密功能，保护视频内容和用户隐私。 进行网站测试和调试，修复漏洞和bug。 第五周（5.11-5.17）： 上线网站，发布测试版。 收集用户反馈和意见，优化网站设计和功能。 准备正式发布，宣传和推广网站。 以上是一个大致的开发进度安排，具体时间取决于您的开发经验和技能、项目复杂度等因素。在开发过程中，及时调整进度安排，根据实际情况进行优化和改进，以保证项目的成功开发和上线。 实现一个比Bilibili和YouTube更好的视频网站是一项非常具有挑战性的任务。以下是一些可能的亮点功能： 强大的视频推荐算法：使用机器学习和人工智能技术，为用户提供个性化的视频推荐服务，更好地满足用户需求。 优质内容的筛选和审核：通过对视频内容的严格审核和筛选，保证网站上的内容质量，提高用户体验。 社交功能的增强：除了基本的评论和点赞功能外，还可以增加更多的社交功能，例如私信、关注、分享等，让用户更好地互动和交流。 更好的视频播放体验：提供更快的视频加载速度、更流畅的播放体验和更高的画质，让用户享受更好的观看体验。 多语言支持和跨平台兼容性：支持多种语言和跨平台兼容性，使更多的用户可以轻松访问和使用网站。 创新的商业模式：除了广告和会员等传统的商业模式外，可以尝试一些新的商业模式，例如增值服务、虚拟商品等，创造更多的商业价值。 以上是一些可能的亮点功能，当然还有很多其他的创新点和亮点可以探索和尝试。重要的是要不断地了解用户需求和市场变化，不断优化和改进网站的功能和服务。 这些运维技能都可以帮助你更好地搭建、部署和管理视频播放网站。以下是一些可能的搭配运用方式： 使用Nginx作为反向代理服务器，实现负载均衡和高可用性。Nginx可以将请求分发到多个服务器上，提高网站的访问速度和可靠性。 使用Docker将应用程序和依赖项打包成容器，方便部署和管理。Docker可以快速创建和销毁容器，避免了环境配置和依赖项问题，提高了开发效率。 使用Kubernetes（K8s）进行容器编排和管理，实现自动扩展和负载均衡。K8s可以自动调整容器数量，根据流量自动扩展和缩减容器，提高了网站的可伸缩性和弹性。 使用Jenkins进行持续集成和持续部署（CI&#x2F;CD），实现自动化构建、测试和部署。Jenkins可以自动化执行构建、测试和部署任务，减少了手动操作，提高了开发效率和质量。 进行日志分析和监控，使用ELK（Elasticsearch、Logstash和Kibana）等工具进行日志分析和监控。ELK可以对网站的日志进行收集、分析和可视化，帮助你快速定位和解决问题，提高了网站的可靠性和稳定性。 以上是一些可能的搭配运用方式，具体的应用场景和运用方式需要根据你的具体需求和情况来选择和决定。 有很多优秀的前端页面模板可以参考，以下是一些比较好的学生管理系统前端页面模板： AdminLTE：一个开源的后台管理模板，提供了丰富的UI组件、表格、图表等功能，适合用于学生管理系统的后台管理页面。 Material Dashboard：一个基于Google Material Design的模板，提供了漂亮的UI设计和丰富的组件，适合用于学生管理系统的前台页面。 Metronic：一个功能强大的后台管理模板，提供了多种布局和主题，适合用于学生管理系统的后台管理页面。 SB Admin 2：一个简洁美观的后台管理模板，提供了响应式设计和多种组件，适合用于学生管理系统的后台管理页面。 Bootstrap Admin Template：一个基于Bootstrap的后台管理模板，提供了丰富的UI组件和布局，适合用于学生管理系统的后台管理页面。 以上模板都可以在Github上找到源码和使用文档，可以根据自己的需求进行定制和修改。 以下是一些比较好的ffmpeg和C++结合的视频播放器的Github仓库： mpv-player&#x2F;mpv：一个基于FFmpeg和OpenGL的视频播放器，支持多种视频格式和音频格式，可以在Linux、Windows和macOS系统上运行。 VideoLAN&#x2F;VLC：一个开源的跨平台媒体播放器，支持各种视频和音频格式，可以在Windows、Linux、macOS、Android和iOS等平台上运行。 Bilibili&#x2F;ijkplayer：一个基于FFmpeg的Android&#x2F;iOS视频播放器，支持多种视频格式和音频格式，提供了丰富的API和示例代码。 FFmpegPlayer&#x2F;FFmpegPlayer：一个基于FFmpeg和SDL的视频播放器，支持多种视频格式和音频格式，提供了简单易用的API和示例代码。 这些仓库都提供了丰富的文档、示例代码和API，可以根据自己的需求进行定制和修改。 参考文献[日志系统]https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650122657&amp;idx=1&amp;sn=c5ce1d8059c40e4cd6deb42a34f8fe49&amp;chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&amp;scene=21#wechat_redirect[Reactor模型和Proactor模型]https://cloud.tencent.com/developer/article/1488120[Reactor模型]https://www.cnblogs.com/CodeBear/p/12567022.html[epoll 事件之 EPOLLRDHUP]https://yangwenbo.com/articles/epoll-event-epollrdhup.html","raw":"---\ntitle: webserver\ndate: 2022-07-25 00:41:31\ntags:\n- 项目\n---\n\n\n## 2022-7-24\n\n1. task.josn和lanch.json可以跑起来了，可以用vscode远程连接调试\n2. 使用cmake进行编译\n3. cmake编译中添加了mysql,可以操作数据库了\n\n\n## 2022-7-25\n\n1. 学习了namespace和share_ptr是怎么使用的\n\n\n\n# 2022-7-30\n1. 之前发现使用语句，但是日志无法写入\nfix:使用阻塞队列插入，但是自己还没有实现阻塞队列的内容，导致一直是空实现，就没法写进去了\n\n2. 遗留的问题：单例模式在vscode中如何调试，因为进去就是一个instant()函数了\n\n\n\n\n\n# 改进\n使用vcpkg做包管理\ncmake中使用vcpkg\n使用httplib库\n使用jsoncpp库\n接口测试方法\n压力测试方法\n\n\n# epoll_event\n\nEPOLLIN\n        The associated file is available for read(2) operations.\n\nEPOLLOUT\n        The associated file is available for write(2) operations.\n\nEPOLLRDHUP (since Linux 2.6.17) # 读取到一半连接关闭\n        # 读关闭\n        在使用 epoll 时，对端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件。在低于 2.6.17 版本的内核中，这个 epoll 事件一般是 EPOLLIN，即 0x1，代表连接可读。\n        返回到上层以后，上层读取会EOF，报告错误。\n        现在增加了这个以后，客户端断开连接，就可以在底层处理了\n        Stream socket peer closed connection, or shut  down  writing  half  of\n        connection.   (This  flag is especially useful for writing simple code\n        to detect peer shutdown when using Edge Triggered monitoring.)\n\nEPOLLERR\n        # EPOLLERR 是服务器这边出错\n        相关文件描述符上发生错误情况。 这个\n         当读取结束时，管道的写入结束也会报告事件\n         已被关闭。 epoll_wait(2) 将始终报告此事件； 它\n         没有必要在事件中设置它。\n        Error  condition  happened  on  the  associated file descriptor.  This\n        event is also reported for the write end of a pipe when the  read  end\n        has  been closed.  epoll_wait(2) will always report for this event; it\n        is not necessary to set it in events.\n\nEPOLLHUP\n        # 读写都关闭\n        Hang up happened on the  associated  file  descriptor.   epoll_wait(2)\n        will  always  wait  for  this  event; it is not necessary to set it in\n        events.\n\n        Note that when reading from a channel such  as  a  pipe  or  a  stream\n        socket,  this  event  merely indicates that the peer closed its end of\n        the channel.  Subsequent reads from the channel will return 0 (end  of\n        file)  only  after  all  outstanding data in the channel has been con‐\n        sumed.\n\n\n\n如果你想写一个高性能的C++服务器，以下是一些建议：\n\n1. 选择正确的框架：选择一个高性能的框架，例如Boost.Asio、libevent或者libuv。这些框架可以帮助你管理网络连接、事件处理和多线程。\n2. 使用异步IO：异步IO可以提高服务器的响应速度和吞吐量。使用异步IO可以避免线程阻塞，提高服务器的效率。优化内存管理：使用内存池和对象池可以减少内存分配和释放的开销。另外，避免使用过多的动态内存分配，因为它们会导致内存碎片和性能下降。\n3. 多线程：使用多线程可以充分利用多核CPU的性能。但是，要注意避免线程间的竞争条件，例如锁等待和死锁。\n4. 优化算法：使用高效的算法可以减少CPU的负载，提高服务器的性能。例如，使用哈希表代替线性搜索可以提高查询速度。\n5. 代码优化：使用编译器优化和代码优化技术可以提高代码的执行效率。例如，使用内联函数可以避免函数调用的开销。\n6. 测试和性能优化：使用性能分析工具和压力测试工具可以发现性能瓶颈和优化点。使用这些工具可以帮助你优化服务器的性能，提高用户体验。\n\n\n\n\n大体的高性能C++服务器的框架通常包括以下组件：\n\n1. 网络层：负责处理网络连接和数据传输。常用的网络库包括Boost.Asio、libevent和libuv等。\n2. 多线程管理：负责管理多线程和线程池。多线程可以提高服务器的并发处理能力，但是需要注意避免线程间的竞争条件。\n3. 协议处理：负责解析和处理客户端发送的协议。常用的协议包括HTTP、WebSocket、TCP和UDP等。\n4. 数据库访问：负责与数据库交互，包括查询、插入、更新和删除等操作。常用的数据库包括MySQL、PostgreSQL和MongoDB等。\n5. 缓存管理：负责管理缓存，例如Redis、Memcached等。缓存可以提高服务器的读取速度和响应速度。\n6. 日志管理：负责记录服务器的运行日志，包括错误日志、访问日志等。\n7. 安全管理：负责保障服务器的安全性，包括防止DDoS攻击、SQL注入等。\n\n以上组件可以根据具体业务需求进行选择和定制。同时，高性能C++服务器的框架需要考虑以下因素：\n\n1. 高并发：需要支持高并发的处理能力，避免线程阻塞和死锁。\n2. 高效率：需要尽可能地利用CPU和内存资源，避免资源浪费。\n3. 可扩展性：需要支持水平和垂直扩展，以应对不同的业务需求。\n4. 可靠性：需要具备高可靠性和容错能力，避免因为单点故障导致整个服务不可用。\n5. 易用性：需要具备易用性和易维护性，方便开发人员进行开发和维护。\n\n\n\n防止DDoS攻击是一个复杂的话题，需要综合考虑许多因素，包括网络安全、服务器性能、负载均衡等。以下是一些基本的防御措施，您可以在C++服务器中实现它们：\n1. 限制连接速率：通过限制每个IP地址的连接速率来减轻服务器的负载。可以使用令牌桶算法或漏桶算法来实现这个功能。\n2. IP黑名单：通过检测攻击流量的来源IP地址并将它们添加到黑名单中来减轻服务器的负载。\n3. 限制请求大小：通过限制每个请求的大小来防止攻击者发送大量的请求，从而导致服务器负载过高。\n4. 使用CDN：使用内容分发网络（CDN）可以将流量分散到多个地理位置的服务器，从而减轻攻击的影响。\n5. 负载均衡：通过使用负载均衡技术，可以将流量分散到多个服务器上，从而减轻攻击的影响。\n6. DDoS防护软件：使用专门的DDoS防护软件，可以自动检测和过滤攻击流量。\n请注意，这些措施只是一些基本的防御措施，无法完全保护服务器免受DDoS攻击。因此，建议您与网络安全专家合作，制定更全面的防御策略。\n\n\n\n\n令牌桶算法是一种常用的限流算法，可以用于限制每个IP地址的连接速率。以下是一个简单的C++实现令牌桶算法的例子：\n```c++\n#include <iostream>\n#include <chrono>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n\nusing namespace std::chrono;\n\nclass TokenBucket {\npublic:\n    TokenBucket(int capacity, int rate) : capacity_(capacity), rate_(rate), tokens_(0) {\n        last_refill_time_ = steady_clock::now();\n    }\n\n    bool TryConsume(int tokens) {\n        std::unique_lock<std::mutex> lock(mutex_); \n\n        Refill();\n\n        if (tokens_ >= tokens) {\n            tokens_ -= tokens;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\nprivate:\n    void Refill() {\n        auto now = steady_clock::now();\n        auto time_since_last_refill = now - last_refill_time_;\n        last_refill_time_ = now;\n\n        int tokens_to_add = duration_cast<milliseconds>(time_since_last_refill).count() * rate_ / 1000;\n        tokens_ = std::min(tokens_ + tokens_to_add, capacity_);\n    }\n\n    int capacity_;\n    int rate_;\n    int tokens_;\n    std::mutex mutex_;\n    std::condition_variable cv_;\n    std::chrono::steady_clock::time_point last_refill_time_;\n};\n\nint main() {\n    TokenBucket bucket(10, 2);\n\n    for (int i = 0; i < 20; i++) {\n        std::this_thread::sleep_for(milliseconds(500));\n\n        if (bucket.TryConsume(1)) {\n            std::cout << \"Request \" << i << \" accepted.\" << std::endl;\n        } else {\n            std::cout << \"Request \" << i << \" rejected.\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n```\n在这个例子中，`TokenBucket`类维护了桶的容量、速率和当前的令牌数量。当一个请求到达时，它将尝试从桶中消耗指定数量的令牌。如果桶中有足够的令牌，请求将被接受，否则请求将被拒绝。\n\n在`TryConsume`方法中，首先调用`Refill`方法以确保桶中有足够的令牌。然后，如果桶中有足够的令牌，它将扣除指定数量的令牌并返回`true`，否则它将返回`false`。\n\n在`Refill`方法中，它计算从上次刷新以来的时间，并根据速率计算应该添加的令牌数量。然后，它将令牌数量限制在桶的容量内。\n\n在`main`函数中，我们创建一个容量为10，速率为2的`TokenBucket`对象，并模拟20个请求，每500毫秒到达一个请求。如果请求被接受，它将输出“Request i accepted.”，否则它将输出“Request i rejected.”。\n\n这个例子只是一个简单的演示，您可以根据自己的需求进行修改和扩展。\n\n\n\n\n\n\n\n\n\n\n\n\n防止SQL注入攻击是编写安全的数据库应用程序的重要方面。以下是一个使用参数化查询防止SQL注入攻击的C++示例：\n\n```c++\n#include <iostream>\n#include <string>\n#include <mysql/mysql.h>\n\nint main() {\n    MYSQL mysql;\n    mysql_init(&mysql);\n\n    if (!mysql_real_connect(&mysql, \"localhost\", \"username\", \"password\", \"database\", 0, NULL, 0)) {\n        std::cerr << \"Failed to connect to database: \" << mysql_error(&mysql) << std::endl;\n        return 1;\n    }\n\n    std::string username = \"Alice\";\n    std::string password = \"pass123\";\n\n    MYSQL_STMT *stmt;\n    MYSQL_BIND params[2];\n\n    stmt = mysql_stmt_init(&mysql);\n\n    if (!stmt) {\n        std::cerr << \"Failed to initialize statement: \" << mysql_error(&mysql) << std::endl;\n        return 1;\n    }\n\n    if (mysql_stmt_prepare(stmt, \"SELECT * FROM users WHERE username = ? AND password = ?\", -1) != 0) {\n        std::cerr << \"Failed to prepare statement: \" << mysql_stmt_error(stmt) << std::endl;\n        return 1;\n    }\n\n    memset(params, 0, sizeof(params));\n\n    params[0].buffer_type = MYSQL_TYPE_STRING;\n    params[0].buffer = (void *)username.c_str();\n    params[0].buffer_length = username.length();\n\n    params[1].buffer_type = MYSQL_TYPE_STRING;\n    params[1].buffer = (void *)password.c_str();\n    params[1].buffer_length = password.length();\n\n    if (mysql_stmt_bind_param(stmt, params) != 0) {\n        std::cerr << \"Failed to bind parameters: \" << mysql_stmt_error(stmt) << std::endl;\n        return 1;\n    }\n\n    if (mysql_stmt_execute(stmt) != 0) {\n        std::cerr << \"Failed to execute statement: \" << mysql_stmt_error(stmt) << std::endl;\n        return 1;\n    }\n\n    MYSQL_RES *result = mysql_stmt_result_metadata(stmt);\n\n    if (result) {\n        int num_fields = mysql_num_fields(result);\n        MYSQL_FIELD *fields = mysql_fetch_fields(result);\n\n        MYSQL_BIND bind[num_fields];\n        memset(bind, 0, sizeof(bind));\n\n        for (int i = 0; i < num_fields; i++) {\n            bind[i].buffer_type = fields[i].type;\n            bind[i].buffer = malloc(fields[i].length);\n            bind[i].buffer_length = fields[i].length;\n        }\n\n        if (mysql_stmt_bind_result(stmt, bind) != 0) {\n            std::cerr << \"Failed to bind result: \" << mysql_stmt_error(stmt) << std::endl;\n            return 1;\n        }\n\n        if (mysql_stmt_store_result(stmt) != 0) {\n            std::cerr << \"Failed to store result: \" << mysql_stmt_error(stmt) << std::endl;\n            return 1;\n        }\n\n        while (mysql_stmt_fetch(stmt) == 0) {\n            for (int i = 0; i < num_fields; i++) {\n                std::cout << fields[i].name << \": \";\n\n                switch (bind[i].buffer_type) {\n                    case MYSQL_TYPE_LONG:\n                        std::cout << *((int *)bind[i].buffer);\n                        break;\n                    case MYSQL_TYPE_STRING:\n                        std::cout << (char *)bind[i].buffer;\n                        break;\n                    default:\n                        std::cout << \"unknown type\";\n                        break;\n                }\n\n                std::cout << std::endl;\n            }\n        }\n\n        mysql_free_result(result);\n\n        for (int i = 0; i < num_fields; i++) {\n            free(bind[i].buffer);\n        }\n    }\n\n    mysql_stmt_close(stmt);\n    mysql_close(&mysql);\n\n    return 0;\n}\n```\n\n在这个例子中，我们使用MySQL C API连接到数据库。我们将用户名和密码作为参数传递给查询，以防止SQL注入攻击。我们使用`mysql_stmt_prepare`函数准备查询并使用`mysql_stmt_bind_param`函数绑定参数。\n\n我们使用`MYSQL_BIND`结构体来表示绑定参数和结果集。我们使用`memset`函数将其初始化为零，并设置每个参数的类型、缓冲区和缓冲区长度。\n\n我们使用`mysql_stmt_execute`函数执行查询，并使用`mysql_stmt_result_metadata`函数获取结果集的元数据。如果结果集不为空，我们使用`mysql_fetch_fields`函数获取每个字段的元数据，并使用`mysql_stmt_bind_result`函数将结果绑定到`MYSQL_BIND`结构体中。\n\n我们使用`mysql_stmt_fetch`函数获取每一行的结果，并将它们输出到控制台上。\n\n最后，我们释放绑定缓冲区和关闭语句和数据库连接。\n\n通过使用参数化查询，我们可以防止SQL注入攻击。\n\n\n\n\n\n如果你想开始学习FFmpeg，以下是一些步骤：\n\n1. 了解FFmpeg的基本概念和术语，例如：编解码器、格式、滤镜、muxer、demuxer等等。\n\n2. 下载FFmpeg的源代码或预编译版本。你可以从FFmpeg官方网站或其他可靠的下载站点获取。\n\n3. 安装FFmpeg。如果你下载的是源代码，你需要编译和安装它。如果你下载的是预编译版本，则可以直接解压缩并安装。\n\n4. 学习如何使用FFmpeg。你可以从官方文档、教程、博客、视频教程等资源中获取信息。\n\n5. 练习使用FFmpeg。尝试使用不同的命令行选项和参数，以及不同的输入和输出格式。你可以使用一些示例文件进行测试。\n\n6. 加入FFmpeg社区。你可以参与FFmpeg的邮件列表、IRC频道、论坛等社区，与其他用户交流和分享经验。\n\n总之，学习FFmpeg需要耐心和实践，如果你坚持下去，你会逐渐掌握它的技能并成为一个专业的视频处理人员。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n以下是一些学习FFmpeg的参考资料：\n\n1. FFmpeg官方文档：https://ffmpeg.org/documentation.html\n\n2. FFmpeg官方wiki：https://trac.ffmpeg.org/wiki\n\n3. FFmpeg命令行参数手册：https://ffmpeg.org/ffmpeg.html\n\n4. FFmpeg格式和编解码器支持列表：https://ffmpeg.org/general.html#Supported-File-Formats-Codecs-and-Protocols\n\n5. FFmpeg滤镜手册：https://ffmpeg.org/ffmpeg-filters.html\n\n6. FFmpeg教程和示例代码：https://www.ffmpeg.org/documentation.html#Examples\n\n7. FFmpeg中文文档：https://www.ffmpeg.org.cn/\n\n8. FFmpeg视频处理实战：https://github.com/leandromoreira/ffmpeg-libav-tutorial\n\n9. FFmpeg常见问题解答：https://trac.ffmpeg.org/wiki/FAQ\n\n希望这些资料对你有所帮助，祝学习愉快！\n\n\n\n\n\n\n\n\n\n\n\n如果你想阅读 FFmpeg 的源代码，可以按照以下步骤开始：\n\n1. 先从官方网站下载最新的 FFmpeg 源代码。\n\n2. 阅读 FFmpeg 的文档，了解 FFmpeg 的基本概念、编译方式、命令行参数等。\n\n3. 阅读 FFmpeg 的主要源文件，包括 libavcodec、libavformat、libavutil 等。\n\n4. 学习 FFmpeg 的 API，了解如何使用 FFmpeg 的库函数来实现音视频的编解码、格式转换等功能。\n\n5. 阅读 FFmpeg 的示例代码，了解如何使用 FFmpeg 的 API 来实现常见的音视频处理任务。\n\n6. 参考 FFmpeg 的开发文档，了解如何贡献代码、提交补丁等。\n\n总之，要深入理解 FFmpeg 的源代码，需要花费大量的时间和精力，需要掌握 C 语言、音视频编解码、多媒体格式等多个领域的知识。\n\n\n\n\n\n\n\nlibavcodec是FFmpeg中的一个库，它是一个编解码器库，提供了对各种音视频编码和解码的支持。它包含了多种音视频编解码器，如H.264、MPEG-4、MPEG-2、VP9、AAC、MP3等。在FFmpeg中，libavcodec是非常重要的一部分，它提供了FFmpeg的核心功能之一，即音视频的编解码功能。\n\nlibavcodec可以将各种不同格式的音视频数据解码成FFmpeg内部的统一格式，也可以将FFmpeg内部的统一格式编码成各种不同格式的音视频数据，支持多种音视频编解码标准，同时具有高度的可扩展性和灵活性。此外，libavcodec还提供了一些优化的编解码实现，可以提高音视频编解码的效率。\n\n在使用libavcodec时，我们可以通过调用其提供的API来完成音视频的编解码工作，同时也可以进行一些高级的音视频处理，如滤波、裁剪、缩放、色彩空间转换等。总之，libavcodec是FFmpeg中非常重要的一部分，它为FFmpeg提供了强大的音视频编解码能力，是众多音视频应用的重要基础。\n\n\n\n\n\n\n\nlibavcodec中有很多重要的函数，以下是一些主要的函数：\n\n1. avcodec_find_decoder()：根据编码器ID查找解码器。\n\n2. avcodec_find_encoder()：根据编码器ID查找编码器。\n\n3. avcodec_open2()：打开解码器或编码器。\n\n4. avcodec_close()：关闭解码器或编码器。\n\n5. avcodec_send_packet()：将待解码或编码的数据包发送给解码器或编码器。\n\n6. avcodec_receive_frame()：从解码器中获取解码后的视频帧或音频样本。\n\n7. avcodec_send_frame()：将待编码的视频帧或音频样本发送给编码器。\n\n8. avcodec_receive_packet()：从编码器中获取编码后的数据包。\n\n9. avcodec_parameters_to_context()：将音视频参数填充到解码器或编码器上下文中。\n\n10. avcodec_alloc_frame()：分配一个AVFrame对象。\n\n以上是一些主要的函数，还有很多其他的函数，可以根据自己的需要选择使用。\n\n\n\n\n\n\n有很多业务可以让您的MySQL存储更多的数据，以下是一些想法：\n\n1. 用户注册和信息管理：除了用户名和密码，您可以让用户输入更多的信息，例如电子邮件，电话号码，地址等等。这些信息可以存储在MySQL数据库中，以便您可以随时检索和更新。\n\n2. 商品管理：如果您有一个在线商店，您可以创建一个MySQL表来存储您的商品信息，例如名称，描述，价格，库存等等。\n\n3. 订单管理：如果您有一个在线商店，您可以创建一个MySQL表来存储您的订单信息，例如订单号，客户信息，商品信息，数量，总价等等。\n\n4. 日志管理：您可以创建一个MySQL表来存储您的应用程序日志，例如错误消息，警告消息和其他重要事件。\n\n5. 聊天记录：如果您有一个聊天应用程序，您可以创建一个MySQL表来存储聊天记录，以便您可以随时检索和查看以前的聊天记录。\n\n这些只是一些想法，您可以根据自己的业务需求来扩展MySQL的内容。\n\n\n\n\n\n\n如果您想要做一个视频播放网站，以下是一些您可能需要存储在MySQL中的业务信息：\n\n1. 视频信息：您可以创建一个MySQL表来存储您的视频信息，例如名称，描述，时长，上传日期，标签等等。\n\n2. 用户信息：您可以创建一个MySQL表来存储您的用户信息，例如用户名，密码，电子邮件，个人资料等等。\n\n3. 视频分类：您可以创建一个MySQL表来存储您的视频分类信息，例如电影，电视剧，综艺节目等等。\n\n4. 视频评论：您可以创建一个MySQL表来存储您的视频评论信息，例如评论内容，评论日期，用户信息等等。\n\n5. 视频收藏：您可以创建一个MySQL表来存储您的用户收藏视频信息，例如用户ID，视频ID，收藏日期等等。\n\n6. 视频播放记录：您可以创建一个MySQL表来存储您的用户播放视频记录，例如用户ID，视频ID，播放进度，播放日期等等。\n\n这些只是一些想法，您可以根据自己的业务需求来扩展MySQL的内容。\n\n\n\n\n如果您想要使用更现代的方式来处理CGI，以下是一些您可以参考的方式：\n\n1. FastCGI：FastCGI是一种快速且高效的CGI处理方式，它可以在Web服务器和CGI应用程序之间建立一个持久连接，从而提高性能和吞吐量。FastCGI支持多个并发请求，可以在同一个进程中处理多个请求。\n\n2. SCGI：SCGI也是一种快速和高效的CGI处理方式，它可以在Web服务器和CGI应用程序之间建立一个持久连接，从而提高性能和吞吐量。与FastCGI不同的是，SCGI是一种更简单的协议，易于实现和维护。\n\n3. uWSGI：uWSGI是一个Web服务器和应用程序服务器，支持多种语言和多种协议，包括CGI，FastCGI和SCGI。它可以高效地处理大量的并发请求，提供可靠的性能和可扩展性。\n\n4. CGI++：CGI++是一个基于C++的CGI框架，提供了一组高级API，可以帮助您更轻松地开发和维护CGI应用程序。它支持多线程和多进程，并提供了内存池和线程池等高级功能，以提高性能和可靠性。\n\n这些都是一些比较好的CGI处理方式，您可以根据自己的需求选择其中的一种或多种。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n当然，以下是一些您可以参考的C++ CGI处理仓库：\n\n1. CGI++：CGI++是一个基于C++的CGI框架，提供了一组高级API，可以帮助您更轻松地开发和维护CGI应用程序。它支持多线程和多进程，并提供了内存池和线程池等高级功能，以提高性能和可靠性。\n\n2. CppCMS：CppCMS是一个高性能的Web开发框架，支持CGI，FastCGI和HTTP协议。它基于C++11标准，提供了许多高级功能，例如会话管理，缓存，模板引擎等等。\n\n3. Wt：Wt是一个开源的Web开发框架，支持C++，JavaScript和CSS。它提供了一个基于组件的架构，可以帮助您更轻松地开发Web应用程序。Wt支持CGI，FastCGI和HTTP协议，并提供了一组高级API，以提高性能和可靠性。\n\n4. Crow：Crow是一个微型C++ Web框架，支持CGI，FastCGI和HTTP协议。它基于C++11标准，提供了一组简单而强大的API，可以帮助您更轻松地开发Web应用程序。\n\n这些都是一些比较好的C++ CGI处理仓库，您可以根据自己的需求选择其中的一种或多种。\n\n\n\n\n\n\n\n\n好的，如果您要做一个视频播放的网站，以下是一些设计建议和功能建议：\n\n设计建议：\n\n1. 界面美观：一个好的视频播放网站应该有一个美观的界面，吸引用户的注意力。\n\n2. 响应式设计：由于用户可能会在不同的设备上访问您的网站，因此您应该设计一个响应式的界面，可以适应不同的设备屏幕大小。\n\n3. 用户友好：您的网站应该易于使用和导航，用户应该可以轻松地找到他们想要的内容。\n\n4. 快速加载：视频需要大量的带宽和资源，因此您的网站应该快速加载，以提供更好的用户体验。\n\n功能建议：\n\n1. 视频搜索：用户应该可以使用关键字搜索您的视频库中的视频。\n\n2. 视频分类：您的网站应该将视频按照不同的类别进行分类，例如电影，电视节目，音乐视频等。\n\n3. 视频播放：您的网站应该提供一个视频播放器，可以播放不同格式的视频，例如MP4，AVI等。\n\n4. 视频上传：您的网站应该允许用户上传他们自己的视频，以增加您的视频库。\n\n5. 评论和评级：您的网站应该允许用户对视频进行评论和评级，以帮助其他用户找到高质量的视频。\n\n6. 用户账户：您的网站应该提供一个用户账户系统，用户可以在其中创建和管理他们自己的个人资料和视频列表。\n\n7. 推荐系统：您的网站应该提供一个推荐系统，可以向用户推荐他们可能感兴趣的视频。\n\n希望这些建议可以帮助您设计和实现一个成功的视频播放网站。\n\n\n\n\n\n当然，以下是一些好的视频播放网站的例子，您可以参考：\n\n1. YouTube：YouTube是全球最大的视频分享网站之一，支持用户上传、分享和观看视频。它提供了一个强大的搜索引擎和推荐系统，使用户可以轻松地找到他们喜欢的视频。\n\n2. Vimeo：Vimeo是另一个受欢迎的视频分享网站，它更加注重高质量的视频内容和创意。它提供了一个类似于YouTube的界面，但更加专业和艺术化。\n\n3. Netflix：Netflix是一个流媒体视频服务，提供了大量的电影和电视节目。它的界面非常简洁和易于使用，用户可以轻松地搜索和浏览不同的视频内容。\n\n4. Hulu：Hulu是另一个流媒体视频服务，提供了大量的电影和电视节目。它的界面类似于一个电视机顶盒的界面，用户可以轻松地选择他们想要观看的内容。\n\n5. Dailymotion：Dailymotion是一个视频分享网站，类似于YouTube。它提供了一个简单和易于使用的界面，用户可以上传、分享和观看视频。\n\n这些都是一些非常成功的视频播放网站，您可以从中学习他们的设计和功能，以帮助您设计和实现自己的视频播放网站。\n\n\n\n\n\n\n\n如果您用C++搭建视频播放网站的后台，以下是一些核心功能和需要学习的知识：\n\n核心功能：\n\n1. 视频编解码：视频需要进行编解码以便于存储和播放，您需要学习有关视频编解码的知识，例如H.264，HEVC等。\n\n2. 视频存储：您需要学习有关数据库和文件系统的知识，以便于存储和管理大量的视频文件。\n\n3. 视频传输：您需要学习有关网络传输和协议的知识，以便于将视频流传输到用户的设备上。\n\n4. 视频播放器：您需要实现一个视频播放器，可以解码和播放不同格式的视频，例如MP4，AVI等。\n\n5. 用户认证和授权：您需要实现一个用户认证和授权系统，可以管理用户的访问权限和保护视频内容。\n\n\n\n\n\n\n\n\n\n\n\n\n\n开发一个视频播放网站的时间取决于很多因素，例如网站的规模、功能、设计复杂度等等。因此，我无法给出确切的时间估计。但是，以下是一个大致的开发进度安排，供您参考：\n\n第一周（4.13-4.19）：\n\n1. 规划网站功能和设计，制定开发计划。\n2. 学习有关视频编解码、数据库和网络编程的知识。\n3. 搭建基础框架，实现用户认证和授权功能。\n\n第二周（4.20-4.26）：\n\n1. 学习有关视频存储和传输的知识。\n2. 实现视频上传和存储功能。\n3. 实现视频播放器，可以解码和播放不同格式的视频。\n\n第三周（4.27-5.3）：\n\n1. 学习有关多线程编程和并发控制的知识。\n2. 实现视频编解码和传输功能，保证视频流畅播放。\n3. 完善网站的用户界面和功能。\n\n第四周（5.4-5.10）：\n\n1. 学习有关安全和加密的知识。\n2. 实现安全和加密功能，保护视频内容和用户隐私。\n3. 进行网站测试和调试，修复漏洞和bug。\n\n第五周（5.11-5.17）：\n\n1. 上线网站，发布测试版。\n2. 收集用户反馈和意见，优化网站设计和功能。\n3. 准备正式发布，宣传和推广网站。\n\n以上是一个大致的开发进度安排，具体时间取决于您的开发经验和技能、项目复杂度等因素。在开发过程中，及时调整进度安排，根据实际情况进行优化和改进，以保证项目的成功开发和上线。\n\n\n\n\n\n\n\n实现一个比Bilibili和YouTube更好的视频网站是一项非常具有挑战性的任务。以下是一些可能的亮点功能：\n\n1. 强大的视频推荐算法：使用机器学习和人工智能技术，为用户提供个性化的视频推荐服务，更好地满足用户需求。\n\n2. 优质内容的筛选和审核：通过对视频内容的严格审核和筛选，保证网站上的内容质量，提高用户体验。\n\n3. 社交功能的增强：除了基本的评论和点赞功能外，还可以增加更多的社交功能，例如私信、关注、分享等，让用户更好地互动和交流。\n\n4. 更好的视频播放体验：提供更快的视频加载速度、更流畅的播放体验和更高的画质，让用户享受更好的观看体验。\n\n5. 多语言支持和跨平台兼容性：支持多种语言和跨平台兼容性，使更多的用户可以轻松访问和使用网站。\n\n6. 创新的商业模式：除了广告和会员等传统的商业模式外，可以尝试一些新的商业模式，例如增值服务、虚拟商品等，创造更多的商业价值。\n\n以上是一些可能的亮点功能，当然还有很多其他的创新点和亮点可以探索和尝试。重要的是要不断地了解用户需求和市场变化，不断优化和改进网站的功能和服务。\n\n\n\n\n\n\n\n\n\n这些运维技能都可以帮助你更好地搭建、部署和管理视频播放网站。以下是一些可能的搭配运用方式：\n\n1. 使用Nginx作为反向代理服务器，实现负载均衡和高可用性。Nginx可以将请求分发到多个服务器上，提高网站的访问速度和可靠性。\n\n2. 使用Docker将应用程序和依赖项打包成容器，方便部署和管理。Docker可以快速创建和销毁容器，避免了环境配置和依赖项问题，提高了开发效率。\n\n3. 使用Kubernetes（K8s）进行容器编排和管理，实现自动扩展和负载均衡。K8s可以自动调整容器数量，根据流量自动扩展和缩减容器，提高了网站的可伸缩性和弹性。\n\n4. 使用Jenkins进行持续集成和持续部署（CI/CD），实现自动化构建、测试和部署。Jenkins可以自动化执行构建、测试和部署任务，减少了手动操作，提高了开发效率和质量。\n\n5. 进行日志分析和监控，使用ELK（Elasticsearch、Logstash和Kibana）等工具进行日志分析和监控。ELK可以对网站的日志进行收集、分析和可视化，帮助你快速定位和解决问题，提高了网站的可靠性和稳定性。\n\n以上是一些可能的搭配运用方式，具体的应用场景和运用方式需要根据你的具体需求和情况来选择和决定。\n\n\n\n\n有很多优秀的前端页面模板可以参考，以下是一些比较好的学生管理系统前端页面模板：\n\n1. AdminLTE：一个开源的后台管理模板，提供了丰富的UI组件、表格、图表等功能，适合用于学生管理系统的后台管理页面。\n\n2. Material Dashboard：一个基于Google Material Design的模板，提供了漂亮的UI设计和丰富的组件，适合用于学生管理系统的前台页面。\n\n3. Metronic：一个功能强大的后台管理模板，提供了多种布局和主题，适合用于学生管理系统的后台管理页面。\n\n4. SB Admin 2：一个简洁美观的后台管理模板，提供了响应式设计和多种组件，适合用于学生管理系统的后台管理页面。\n\n5. Bootstrap Admin Template：一个基于Bootstrap的后台管理模板，提供了丰富的UI组件和布局，适合用于学生管理系统的后台管理页面。\n\n以上模板都可以在Github上找到源码和使用文档，可以根据自己的需求进行定制和修改。\n\n\n\n以下是一些比较好的ffmpeg和C++结合的视频播放器的Github仓库：\n\n1. mpv-player/mpv：一个基于FFmpeg和OpenGL的视频播放器，支持多种视频格式和音频格式，可以在Linux、Windows和macOS系统上运行。\n\n2. VideoLAN/VLC：一个开源的跨平台媒体播放器，支持各种视频和音频格式，可以在Windows、Linux、macOS、Android和iOS等平台上运行。\n\n3. Bilibili/ijkplayer：一个基于FFmpeg的Android/iOS视频播放器，支持多种视频格式和音频格式，提供了丰富的API和示例代码。\n\n4. FFmpegPlayer/FFmpegPlayer：一个基于FFmpeg和SDL的视频播放器，支持多种视频格式和音频格式，提供了简单易用的API和示例代码。\n\n这些仓库都提供了丰富的文档、示例代码和API，可以根据自己的需求进行定制和修改。\n\n\n# 参考文献\n\n[日志系统]https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650122657&idx=1&sn=c5ce1d8059c40e4cd6deb42a34f8fe49&chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&scene=21#wechat_redirect\n[Reactor模型和Proactor模型]https://cloud.tencent.com/developer/article/1488120\n[Reactor模型]https://www.cnblogs.com/CodeBear/p/12567022.html\n[epoll 事件之 EPOLLRDHUP]https://yangwenbo.com/articles/epoll-event-epollrdhup.html\n\n","content":"<h2 id=\"2022-7-24\"><a href=\"#2022-7-24\" class=\"headerlink\" title=\"2022-7-24\"></a>2022-7-24</h2><ol>\n<li>task.josn和lanch.json可以跑起来了，可以用vscode远程连接调试</li>\n<li>使用cmake进行编译</li>\n<li>cmake编译中添加了mysql,可以操作数据库了</li>\n</ol>\n<h2 id=\"2022-7-25\"><a href=\"#2022-7-25\" class=\"headerlink\" title=\"2022-7-25\"></a>2022-7-25</h2><ol>\n<li>学习了namespace和share_ptr是怎么使用的</li>\n</ol>\n<h1 id=\"2022-7-30\"><a href=\"#2022-7-30\" class=\"headerlink\" title=\"2022-7-30\"></a>2022-7-30</h1><ol>\n<li><p>之前发现使用语句，但是日志无法写入<br>fix:使用阻塞队列插入，但是自己还没有实现阻塞队列的内容，导致一直是空实现，就没法写进去了</p>\n</li>\n<li><p>遗留的问题：单例模式在vscode中如何调试，因为进去就是一个instant()函数了</p>\n</li>\n</ol>\n<h1 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h1><p>使用vcpkg做包管理<br>cmake中使用vcpkg<br>使用httplib库<br>使用jsoncpp库<br>接口测试方法<br>压力测试方法</p>\n<h1 id=\"epoll-event\"><a href=\"#epoll-event\" class=\"headerlink\" title=\"epoll_event\"></a>epoll_event</h1><p>EPOLLIN<br>        The associated file is available for read(2) operations.</p>\n<p>EPOLLOUT<br>        The associated file is available for write(2) operations.</p>\n<p>EPOLLRDHUP (since Linux 2.6.17) # 读取到一半连接关闭<br>        # 读关闭<br>        在使用 epoll 时，对端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件。在低于 2.6.17 版本的内核中，这个 epoll 事件一般是 EPOLLIN，即 0x1，代表连接可读。<br>        返回到上层以后，上层读取会EOF，报告错误。<br>        现在增加了这个以后，客户端断开连接，就可以在底层处理了<br>        Stream socket peer closed connection, or shut  down  writing  half  of<br>        connection.   (This  flag is especially useful for writing simple code<br>        to detect peer shutdown when using Edge Triggered monitoring.)</p>\n<p>EPOLLERR<br>        # EPOLLERR 是服务器这边出错<br>        相关文件描述符上发生错误情况。 这个<br>         当读取结束时，管道的写入结束也会报告事件<br>         已被关闭。 epoll_wait(2) 将始终报告此事件； 它<br>         没有必要在事件中设置它。<br>        Error  condition  happened  on  the  associated file descriptor.  This<br>        event is also reported for the write end of a pipe when the  read  end<br>        has  been closed.  epoll_wait(2) will always report for this event; it<br>        is not necessary to set it in events.</p>\n<p>EPOLLHUP<br>        # 读写都关闭<br>        Hang up happened on the  associated  file  descriptor.   epoll_wait(2)<br>        will  always  wait  for  this  event; it is not necessary to set it in<br>        events.</p>\n<pre><code>    Note that when reading from a channel such  as  a  pipe  or  a  stream\n    socket,  this  event  merely indicates that the peer closed its end of\n    the channel.  Subsequent reads from the channel will return 0 (end  of\n    file)  only  after  all  outstanding data in the channel has been con‐\n    sumed.\n</code></pre>\n<p>如果你想写一个高性能的C++服务器，以下是一些建议：</p>\n<ol>\n<li>选择正确的框架：选择一个高性能的框架，例如Boost.Asio、libevent或者libuv。这些框架可以帮助你管理网络连接、事件处理和多线程。</li>\n<li>使用异步IO：异步IO可以提高服务器的响应速度和吞吐量。使用异步IO可以避免线程阻塞，提高服务器的效率。优化内存管理：使用内存池和对象池可以减少内存分配和释放的开销。另外，避免使用过多的动态内存分配，因为它们会导致内存碎片和性能下降。</li>\n<li>多线程：使用多线程可以充分利用多核CPU的性能。但是，要注意避免线程间的竞争条件，例如锁等待和死锁。</li>\n<li>优化算法：使用高效的算法可以减少CPU的负载，提高服务器的性能。例如，使用哈希表代替线性搜索可以提高查询速度。</li>\n<li>代码优化：使用编译器优化和代码优化技术可以提高代码的执行效率。例如，使用内联函数可以避免函数调用的开销。</li>\n<li>测试和性能优化：使用性能分析工具和压力测试工具可以发现性能瓶颈和优化点。使用这些工具可以帮助你优化服务器的性能，提高用户体验。</li>\n</ol>\n<p>大体的高性能C++服务器的框架通常包括以下组件：</p>\n<ol>\n<li>网络层：负责处理网络连接和数据传输。常用的网络库包括Boost.Asio、libevent和libuv等。</li>\n<li>多线程管理：负责管理多线程和线程池。多线程可以提高服务器的并发处理能力，但是需要注意避免线程间的竞争条件。</li>\n<li>协议处理：负责解析和处理客户端发送的协议。常用的协议包括HTTP、WebSocket、TCP和UDP等。</li>\n<li>数据库访问：负责与数据库交互，包括查询、插入、更新和删除等操作。常用的数据库包括MySQL、PostgreSQL和MongoDB等。</li>\n<li>缓存管理：负责管理缓存，例如Redis、Memcached等。缓存可以提高服务器的读取速度和响应速度。</li>\n<li>日志管理：负责记录服务器的运行日志，包括错误日志、访问日志等。</li>\n<li>安全管理：负责保障服务器的安全性，包括防止DDoS攻击、SQL注入等。</li>\n</ol>\n<p>以上组件可以根据具体业务需求进行选择和定制。同时，高性能C++服务器的框架需要考虑以下因素：</p>\n<ol>\n<li>高并发：需要支持高并发的处理能力，避免线程阻塞和死锁。</li>\n<li>高效率：需要尽可能地利用CPU和内存资源，避免资源浪费。</li>\n<li>可扩展性：需要支持水平和垂直扩展，以应对不同的业务需求。</li>\n<li>可靠性：需要具备高可靠性和容错能力，避免因为单点故障导致整个服务不可用。</li>\n<li>易用性：需要具备易用性和易维护性，方便开发人员进行开发和维护。</li>\n</ol>\n<p>防止DDoS攻击是一个复杂的话题，需要综合考虑许多因素，包括网络安全、服务器性能、负载均衡等。以下是一些基本的防御措施，您可以在C++服务器中实现它们：</p>\n<ol>\n<li>限制连接速率：通过限制每个IP地址的连接速率来减轻服务器的负载。可以使用令牌桶算法或漏桶算法来实现这个功能。</li>\n<li>IP黑名单：通过检测攻击流量的来源IP地址并将它们添加到黑名单中来减轻服务器的负载。</li>\n<li>限制请求大小：通过限制每个请求的大小来防止攻击者发送大量的请求，从而导致服务器负载过高。</li>\n<li>使用CDN：使用内容分发网络（CDN）可以将流量分散到多个地理位置的服务器，从而减轻攻击的影响。</li>\n<li>负载均衡：通过使用负载均衡技术，可以将流量分散到多个服务器上，从而减轻攻击的影响。</li>\n<li>DDoS防护软件：使用专门的DDoS防护软件，可以自动检测和过滤攻击流量。<br>请注意，这些措施只是一些基本的防御措施，无法完全保护服务器免受DDoS攻击。因此，建议您与网络安全专家合作，制定更全面的防御策略。</li>\n</ol>\n<p>令牌桶算法是一种常用的限流算法，可以用于限制每个IP地址的连接速率。以下是一个简单的C++实现令牌桶算法的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std::chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TokenBucket</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">TokenBucket</span>(<span class=\"type\">int</span> capacity, <span class=\"type\">int</span> rate) : <span class=\"built_in\">capacity_</span>(capacity), <span class=\"built_in\">rate_</span>(rate), <span class=\"built_in\">tokens_</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        last_refill_time_ = steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">TryConsume</span><span class=\"params\">(<span class=\"type\">int</span> tokens)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_lock&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">Refill</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tokens_ &gt;= tokens) &#123;</span><br><span class=\"line\">            tokens_ -= tokens;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Refill</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> now = steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> time_since_last_refill = now - last_refill_time_;</span><br><span class=\"line\">        last_refill_time_ = now;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> tokens_to_add = <span class=\"built_in\">duration_cast</span>&lt;milliseconds&gt;(time_since_last_refill).<span class=\"built_in\">count</span>() * rate_ / <span class=\"number\">1000</span>;</span><br><span class=\"line\">        tokens_ = std::<span class=\"built_in\">min</span>(tokens_ + tokens_to_add, capacity_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> capacity_;</span><br><span class=\"line\">    <span class=\"type\">int</span> rate_;</span><br><span class=\"line\">    <span class=\"type\">int</span> tokens_;</span><br><span class=\"line\">    std::mutex mutex_;</span><br><span class=\"line\">    std::condition_variable cv_;</span><br><span class=\"line\">    std::chrono::steady_clock::time_point last_refill_time_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">TokenBucket <span class=\"title\">bucket</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">        std::this_thread::<span class=\"built_in\">sleep_for</span>(<span class=\"built_in\">milliseconds</span>(<span class=\"number\">500</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bucket.<span class=\"built_in\">TryConsume</span>(<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;Request &quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot; accepted.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;Request &quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot; rejected.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>TokenBucket</code>类维护了桶的容量、速率和当前的令牌数量。当一个请求到达时，它将尝试从桶中消耗指定数量的令牌。如果桶中有足够的令牌，请求将被接受，否则请求将被拒绝。</p>\n<p>在<code>TryConsume</code>方法中，首先调用<code>Refill</code>方法以确保桶中有足够的令牌。然后，如果桶中有足够的令牌，它将扣除指定数量的令牌并返回<code>true</code>，否则它将返回<code>false</code>。</p>\n<p>在<code>Refill</code>方法中，它计算从上次刷新以来的时间，并根据速率计算应该添加的令牌数量。然后，它将令牌数量限制在桶的容量内。</p>\n<p>在<code>main</code>函数中，我们创建一个容量为10，速率为2的<code>TokenBucket</code>对象，并模拟20个请求，每500毫秒到达一个请求。如果请求被接受，它将输出“Request i accepted.”，否则它将输出“Request i rejected.”。</p>\n<p>这个例子只是一个简单的演示，您可以根据自己的需求进行修改和扩展。</p>\n<p>防止SQL注入攻击是编写安全的数据库应用程序的重要方面。以下是一个使用参数化查询防止SQL注入攻击的C++示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mysql/mysql.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    MYSQL mysql;</span><br><span class=\"line\">    <span class=\"built_in\">mysql_init</span>(&amp;mysql);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">mysql_real_connect</span>(&amp;mysql, <span class=\"string\">&quot;localhost&quot;</span>, <span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;database&quot;</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Failed to connect to database: &quot;</span> &lt;&lt; <span class=\"built_in\">mysql_error</span>(&amp;mysql) &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::string username = <span class=\"string\">&quot;Alice&quot;</span>;</span><br><span class=\"line\">    std::string password = <span class=\"string\">&quot;pass123&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    MYSQL_STMT *stmt;</span><br><span class=\"line\">    MYSQL_BIND params[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    stmt = <span class=\"built_in\">mysql_stmt_init</span>(&amp;mysql);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!stmt) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Failed to initialize statement: &quot;</span> &lt;&lt; <span class=\"built_in\">mysql_error</span>(&amp;mysql) &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">mysql_stmt_prepare</span>(stmt, <span class=\"string\">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>, <span class=\"number\">-1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Failed to prepare statement: &quot;</span> &lt;&lt; <span class=\"built_in\">mysql_stmt_error</span>(stmt) &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(params, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(params));</span><br><span class=\"line\"></span><br><span class=\"line\">    params[<span class=\"number\">0</span>].buffer_type = MYSQL_TYPE_STRING;</span><br><span class=\"line\">    params[<span class=\"number\">0</span>].buffer = (<span class=\"type\">void</span> *)username.<span class=\"built_in\">c_str</span>();</span><br><span class=\"line\">    params[<span class=\"number\">0</span>].buffer_length = username.<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    params[<span class=\"number\">1</span>].buffer_type = MYSQL_TYPE_STRING;</span><br><span class=\"line\">    params[<span class=\"number\">1</span>].buffer = (<span class=\"type\">void</span> *)password.<span class=\"built_in\">c_str</span>();</span><br><span class=\"line\">    params[<span class=\"number\">1</span>].buffer_length = password.<span class=\"built_in\">length</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">mysql_stmt_bind_param</span>(stmt, params) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Failed to bind parameters: &quot;</span> &lt;&lt; <span class=\"built_in\">mysql_stmt_error</span>(stmt) &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">mysql_stmt_execute</span>(stmt) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Failed to execute statement: &quot;</span> &lt;&lt; <span class=\"built_in\">mysql_stmt_error</span>(stmt) &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    MYSQL_RES *result = <span class=\"built_in\">mysql_stmt_result_metadata</span>(stmt);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> num_fields = <span class=\"built_in\">mysql_num_fields</span>(result);</span><br><span class=\"line\">        MYSQL_FIELD *fields = <span class=\"built_in\">mysql_fetch_fields</span>(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        MYSQL_BIND bind[num_fields];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(bind, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(bind));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num_fields; i++) &#123;</span><br><span class=\"line\">            bind[i].buffer_type = fields[i].type;</span><br><span class=\"line\">            bind[i].buffer = <span class=\"built_in\">malloc</span>(fields[i].length);</span><br><span class=\"line\">            bind[i].buffer_length = fields[i].length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">mysql_stmt_bind_result</span>(stmt, bind) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            std::cerr &lt;&lt; <span class=\"string\">&quot;Failed to bind result: &quot;</span> &lt;&lt; <span class=\"built_in\">mysql_stmt_error</span>(stmt) &lt;&lt; std::endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">mysql_stmt_store_result</span>(stmt) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            std::cerr &lt;&lt; <span class=\"string\">&quot;Failed to store result: &quot;</span> &lt;&lt; <span class=\"built_in\">mysql_stmt_error</span>(stmt) &lt;&lt; std::endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">mysql_stmt_fetch</span>(stmt) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num_fields; i++) &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; fields[i].name &lt;&lt; <span class=\"string\">&quot;: &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (bind[i].buffer_type) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> MYSQL_TYPE_LONG:</span><br><span class=\"line\">                        std::cout &lt;&lt; *((<span class=\"type\">int</span> *)bind[i].buffer);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> MYSQL_TYPE_STRING:</span><br><span class=\"line\">                        std::cout &lt;&lt; (<span class=\"type\">char</span> *)bind[i].buffer;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                        std::cout &lt;&lt; <span class=\"string\">&quot;unknown type&quot;</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">mysql_free_result</span>(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num_fields; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(bind[i].buffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">mysql_stmt_close</span>(stmt);</span><br><span class=\"line\">    <span class=\"built_in\">mysql_close</span>(&amp;mysql);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们使用MySQL C API连接到数据库。我们将用户名和密码作为参数传递给查询，以防止SQL注入攻击。我们使用<code>mysql_stmt_prepare</code>函数准备查询并使用<code>mysql_stmt_bind_param</code>函数绑定参数。</p>\n<p>我们使用<code>MYSQL_BIND</code>结构体来表示绑定参数和结果集。我们使用<code>memset</code>函数将其初始化为零，并设置每个参数的类型、缓冲区和缓冲区长度。</p>\n<p>我们使用<code>mysql_stmt_execute</code>函数执行查询，并使用<code>mysql_stmt_result_metadata</code>函数获取结果集的元数据。如果结果集不为空，我们使用<code>mysql_fetch_fields</code>函数获取每个字段的元数据，并使用<code>mysql_stmt_bind_result</code>函数将结果绑定到<code>MYSQL_BIND</code>结构体中。</p>\n<p>我们使用<code>mysql_stmt_fetch</code>函数获取每一行的结果，并将它们输出到控制台上。</p>\n<p>最后，我们释放绑定缓冲区和关闭语句和数据库连接。</p>\n<p>通过使用参数化查询，我们可以防止SQL注入攻击。</p>\n<p>如果你想开始学习FFmpeg，以下是一些步骤：</p>\n<ol>\n<li><p>了解FFmpeg的基本概念和术语，例如：编解码器、格式、滤镜、muxer、demuxer等等。</p>\n</li>\n<li><p>下载FFmpeg的源代码或预编译版本。你可以从FFmpeg官方网站或其他可靠的下载站点获取。</p>\n</li>\n<li><p>安装FFmpeg。如果你下载的是源代码，你需要编译和安装它。如果你下载的是预编译版本，则可以直接解压缩并安装。</p>\n</li>\n<li><p>学习如何使用FFmpeg。你可以从官方文档、教程、博客、视频教程等资源中获取信息。</p>\n</li>\n<li><p>练习使用FFmpeg。尝试使用不同的命令行选项和参数，以及不同的输入和输出格式。你可以使用一些示例文件进行测试。</p>\n</li>\n<li><p>加入FFmpeg社区。你可以参与FFmpeg的邮件列表、IRC频道、论坛等社区，与其他用户交流和分享经验。</p>\n</li>\n</ol>\n<p>总之，学习FFmpeg需要耐心和实践，如果你坚持下去，你会逐渐掌握它的技能并成为一个专业的视频处理人员。</p>\n<p>以下是一些学习FFmpeg的参考资料：</p>\n<ol>\n<li><p>FFmpeg官方文档：<a href=\"https://ffmpeg.org/documentation.html\">https://ffmpeg.org/documentation.html</a></p>\n</li>\n<li><p>FFmpeg官方wiki：<a href=\"https://trac.ffmpeg.org/wiki\">https://trac.ffmpeg.org/wiki</a></p>\n</li>\n<li><p>FFmpeg命令行参数手册：<a href=\"https://ffmpeg.org/ffmpeg.html\">https://ffmpeg.org/ffmpeg.html</a></p>\n</li>\n<li><p>FFmpeg格式和编解码器支持列表：<a href=\"https://ffmpeg.org/general.html#Supported-File-Formats-Codecs-and-Protocols\">https://ffmpeg.org/general.html#Supported-File-Formats-Codecs-and-Protocols</a></p>\n</li>\n<li><p>FFmpeg滤镜手册：<a href=\"https://ffmpeg.org/ffmpeg-filters.html\">https://ffmpeg.org/ffmpeg-filters.html</a></p>\n</li>\n<li><p>FFmpeg教程和示例代码：<a href=\"https://www.ffmpeg.org/documentation.html#Examples\">https://www.ffmpeg.org/documentation.html#Examples</a></p>\n</li>\n<li><p>FFmpeg中文文档：<a href=\"https://www.ffmpeg.org.cn/\">https://www.ffmpeg.org.cn/</a></p>\n</li>\n<li><p>FFmpeg视频处理实战：<a href=\"https://github.com/leandromoreira/ffmpeg-libav-tutorial\">https://github.com/leandromoreira/ffmpeg-libav-tutorial</a></p>\n</li>\n<li><p>FFmpeg常见问题解答：<a href=\"https://trac.ffmpeg.org/wiki/FAQ\">https://trac.ffmpeg.org/wiki/FAQ</a></p>\n</li>\n</ol>\n<p>希望这些资料对你有所帮助，祝学习愉快！</p>\n<p>如果你想阅读 FFmpeg 的源代码，可以按照以下步骤开始：</p>\n<ol>\n<li><p>先从官方网站下载最新的 FFmpeg 源代码。</p>\n</li>\n<li><p>阅读 FFmpeg 的文档，了解 FFmpeg 的基本概念、编译方式、命令行参数等。</p>\n</li>\n<li><p>阅读 FFmpeg 的主要源文件，包括 libavcodec、libavformat、libavutil 等。</p>\n</li>\n<li><p>学习 FFmpeg 的 API，了解如何使用 FFmpeg 的库函数来实现音视频的编解码、格式转换等功能。</p>\n</li>\n<li><p>阅读 FFmpeg 的示例代码，了解如何使用 FFmpeg 的 API 来实现常见的音视频处理任务。</p>\n</li>\n<li><p>参考 FFmpeg 的开发文档，了解如何贡献代码、提交补丁等。</p>\n</li>\n</ol>\n<p>总之，要深入理解 FFmpeg 的源代码，需要花费大量的时间和精力，需要掌握 C 语言、音视频编解码、多媒体格式等多个领域的知识。</p>\n<p>libavcodec是FFmpeg中的一个库，它是一个编解码器库，提供了对各种音视频编码和解码的支持。它包含了多种音视频编解码器，如H.264、MPEG-4、MPEG-2、VP9、AAC、MP3等。在FFmpeg中，libavcodec是非常重要的一部分，它提供了FFmpeg的核心功能之一，即音视频的编解码功能。</p>\n<p>libavcodec可以将各种不同格式的音视频数据解码成FFmpeg内部的统一格式，也可以将FFmpeg内部的统一格式编码成各种不同格式的音视频数据，支持多种音视频编解码标准，同时具有高度的可扩展性和灵活性。此外，libavcodec还提供了一些优化的编解码实现，可以提高音视频编解码的效率。</p>\n<p>在使用libavcodec时，我们可以通过调用其提供的API来完成音视频的编解码工作，同时也可以进行一些高级的音视频处理，如滤波、裁剪、缩放、色彩空间转换等。总之，libavcodec是FFmpeg中非常重要的一部分，它为FFmpeg提供了强大的音视频编解码能力，是众多音视频应用的重要基础。</p>\n<p>libavcodec中有很多重要的函数，以下是一些主要的函数：</p>\n<ol>\n<li><p>avcodec_find_decoder()：根据编码器ID查找解码器。</p>\n</li>\n<li><p>avcodec_find_encoder()：根据编码器ID查找编码器。</p>\n</li>\n<li><p>avcodec_open2()：打开解码器或编码器。</p>\n</li>\n<li><p>avcodec_close()：关闭解码器或编码器。</p>\n</li>\n<li><p>avcodec_send_packet()：将待解码或编码的数据包发送给解码器或编码器。</p>\n</li>\n<li><p>avcodec_receive_frame()：从解码器中获取解码后的视频帧或音频样本。</p>\n</li>\n<li><p>avcodec_send_frame()：将待编码的视频帧或音频样本发送给编码器。</p>\n</li>\n<li><p>avcodec_receive_packet()：从编码器中获取编码后的数据包。</p>\n</li>\n<li><p>avcodec_parameters_to_context()：将音视频参数填充到解码器或编码器上下文中。</p>\n</li>\n<li><p>avcodec_alloc_frame()：分配一个AVFrame对象。</p>\n</li>\n</ol>\n<p>以上是一些主要的函数，还有很多其他的函数，可以根据自己的需要选择使用。</p>\n<p>有很多业务可以让您的MySQL存储更多的数据，以下是一些想法：</p>\n<ol>\n<li><p>用户注册和信息管理：除了用户名和密码，您可以让用户输入更多的信息，例如电子邮件，电话号码，地址等等。这些信息可以存储在MySQL数据库中，以便您可以随时检索和更新。</p>\n</li>\n<li><p>商品管理：如果您有一个在线商店，您可以创建一个MySQL表来存储您的商品信息，例如名称，描述，价格，库存等等。</p>\n</li>\n<li><p>订单管理：如果您有一个在线商店，您可以创建一个MySQL表来存储您的订单信息，例如订单号，客户信息，商品信息，数量，总价等等。</p>\n</li>\n<li><p>日志管理：您可以创建一个MySQL表来存储您的应用程序日志，例如错误消息，警告消息和其他重要事件。</p>\n</li>\n<li><p>聊天记录：如果您有一个聊天应用程序，您可以创建一个MySQL表来存储聊天记录，以便您可以随时检索和查看以前的聊天记录。</p>\n</li>\n</ol>\n<p>这些只是一些想法，您可以根据自己的业务需求来扩展MySQL的内容。</p>\n<p>如果您想要做一个视频播放网站，以下是一些您可能需要存储在MySQL中的业务信息：</p>\n<ol>\n<li><p>视频信息：您可以创建一个MySQL表来存储您的视频信息，例如名称，描述，时长，上传日期，标签等等。</p>\n</li>\n<li><p>用户信息：您可以创建一个MySQL表来存储您的用户信息，例如用户名，密码，电子邮件，个人资料等等。</p>\n</li>\n<li><p>视频分类：您可以创建一个MySQL表来存储您的视频分类信息，例如电影，电视剧，综艺节目等等。</p>\n</li>\n<li><p>视频评论：您可以创建一个MySQL表来存储您的视频评论信息，例如评论内容，评论日期，用户信息等等。</p>\n</li>\n<li><p>视频收藏：您可以创建一个MySQL表来存储您的用户收藏视频信息，例如用户ID，视频ID，收藏日期等等。</p>\n</li>\n<li><p>视频播放记录：您可以创建一个MySQL表来存储您的用户播放视频记录，例如用户ID，视频ID，播放进度，播放日期等等。</p>\n</li>\n</ol>\n<p>这些只是一些想法，您可以根据自己的业务需求来扩展MySQL的内容。</p>\n<p>如果您想要使用更现代的方式来处理CGI，以下是一些您可以参考的方式：</p>\n<ol>\n<li><p>FastCGI：FastCGI是一种快速且高效的CGI处理方式，它可以在Web服务器和CGI应用程序之间建立一个持久连接，从而提高性能和吞吐量。FastCGI支持多个并发请求，可以在同一个进程中处理多个请求。</p>\n</li>\n<li><p>SCGI：SCGI也是一种快速和高效的CGI处理方式，它可以在Web服务器和CGI应用程序之间建立一个持久连接，从而提高性能和吞吐量。与FastCGI不同的是，SCGI是一种更简单的协议，易于实现和维护。</p>\n</li>\n<li><p>uWSGI：uWSGI是一个Web服务器和应用程序服务器，支持多种语言和多种协议，包括CGI，FastCGI和SCGI。它可以高效地处理大量的并发请求，提供可靠的性能和可扩展性。</p>\n</li>\n<li><p>CGI++：CGI++是一个基于C++的CGI框架，提供了一组高级API，可以帮助您更轻松地开发和维护CGI应用程序。它支持多线程和多进程，并提供了内存池和线程池等高级功能，以提高性能和可靠性。</p>\n</li>\n</ol>\n<p>这些都是一些比较好的CGI处理方式，您可以根据自己的需求选择其中的一种或多种。</p>\n<p>当然，以下是一些您可以参考的C++ CGI处理仓库：</p>\n<ol>\n<li><p>CGI++：CGI++是一个基于C++的CGI框架，提供了一组高级API，可以帮助您更轻松地开发和维护CGI应用程序。它支持多线程和多进程，并提供了内存池和线程池等高级功能，以提高性能和可靠性。</p>\n</li>\n<li><p>CppCMS：CppCMS是一个高性能的Web开发框架，支持CGI，FastCGI和HTTP协议。它基于C++11标准，提供了许多高级功能，例如会话管理，缓存，模板引擎等等。</p>\n</li>\n<li><p>Wt：Wt是一个开源的Web开发框架，支持C++，JavaScript和CSS。它提供了一个基于组件的架构，可以帮助您更轻松地开发Web应用程序。Wt支持CGI，FastCGI和HTTP协议，并提供了一组高级API，以提高性能和可靠性。</p>\n</li>\n<li><p>Crow：Crow是一个微型C++ Web框架，支持CGI，FastCGI和HTTP协议。它基于C++11标准，提供了一组简单而强大的API，可以帮助您更轻松地开发Web应用程序。</p>\n</li>\n</ol>\n<p>这些都是一些比较好的C++ CGI处理仓库，您可以根据自己的需求选择其中的一种或多种。</p>\n<p>好的，如果您要做一个视频播放的网站，以下是一些设计建议和功能建议：</p>\n<p>设计建议：</p>\n<ol>\n<li><p>界面美观：一个好的视频播放网站应该有一个美观的界面，吸引用户的注意力。</p>\n</li>\n<li><p>响应式设计：由于用户可能会在不同的设备上访问您的网站，因此您应该设计一个响应式的界面，可以适应不同的设备屏幕大小。</p>\n</li>\n<li><p>用户友好：您的网站应该易于使用和导航，用户应该可以轻松地找到他们想要的内容。</p>\n</li>\n<li><p>快速加载：视频需要大量的带宽和资源，因此您的网站应该快速加载，以提供更好的用户体验。</p>\n</li>\n</ol>\n<p>功能建议：</p>\n<ol>\n<li><p>视频搜索：用户应该可以使用关键字搜索您的视频库中的视频。</p>\n</li>\n<li><p>视频分类：您的网站应该将视频按照不同的类别进行分类，例如电影，电视节目，音乐视频等。</p>\n</li>\n<li><p>视频播放：您的网站应该提供一个视频播放器，可以播放不同格式的视频，例如MP4，AVI等。</p>\n</li>\n<li><p>视频上传：您的网站应该允许用户上传他们自己的视频，以增加您的视频库。</p>\n</li>\n<li><p>评论和评级：您的网站应该允许用户对视频进行评论和评级，以帮助其他用户找到高质量的视频。</p>\n</li>\n<li><p>用户账户：您的网站应该提供一个用户账户系统，用户可以在其中创建和管理他们自己的个人资料和视频列表。</p>\n</li>\n<li><p>推荐系统：您的网站应该提供一个推荐系统，可以向用户推荐他们可能感兴趣的视频。</p>\n</li>\n</ol>\n<p>希望这些建议可以帮助您设计和实现一个成功的视频播放网站。</p>\n<p>当然，以下是一些好的视频播放网站的例子，您可以参考：</p>\n<ol>\n<li><p>YouTube：YouTube是全球最大的视频分享网站之一，支持用户上传、分享和观看视频。它提供了一个强大的搜索引擎和推荐系统，使用户可以轻松地找到他们喜欢的视频。</p>\n</li>\n<li><p>Vimeo：Vimeo是另一个受欢迎的视频分享网站，它更加注重高质量的视频内容和创意。它提供了一个类似于YouTube的界面，但更加专业和艺术化。</p>\n</li>\n<li><p>Netflix：Netflix是一个流媒体视频服务，提供了大量的电影和电视节目。它的界面非常简洁和易于使用，用户可以轻松地搜索和浏览不同的视频内容。</p>\n</li>\n<li><p>Hulu：Hulu是另一个流媒体视频服务，提供了大量的电影和电视节目。它的界面类似于一个电视机顶盒的界面，用户可以轻松地选择他们想要观看的内容。</p>\n</li>\n<li><p>Dailymotion：Dailymotion是一个视频分享网站，类似于YouTube。它提供了一个简单和易于使用的界面，用户可以上传、分享和观看视频。</p>\n</li>\n</ol>\n<p>这些都是一些非常成功的视频播放网站，您可以从中学习他们的设计和功能，以帮助您设计和实现自己的视频播放网站。</p>\n<p>如果您用C++搭建视频播放网站的后台，以下是一些核心功能和需要学习的知识：</p>\n<p>核心功能：</p>\n<ol>\n<li><p>视频编解码：视频需要进行编解码以便于存储和播放，您需要学习有关视频编解码的知识，例如H.264，HEVC等。</p>\n</li>\n<li><p>视频存储：您需要学习有关数据库和文件系统的知识，以便于存储和管理大量的视频文件。</p>\n</li>\n<li><p>视频传输：您需要学习有关网络传输和协议的知识，以便于将视频流传输到用户的设备上。</p>\n</li>\n<li><p>视频播放器：您需要实现一个视频播放器，可以解码和播放不同格式的视频，例如MP4，AVI等。</p>\n</li>\n<li><p>用户认证和授权：您需要实现一个用户认证和授权系统，可以管理用户的访问权限和保护视频内容。</p>\n</li>\n</ol>\n<p>开发一个视频播放网站的时间取决于很多因素，例如网站的规模、功能、设计复杂度等等。因此，我无法给出确切的时间估计。但是，以下是一个大致的开发进度安排，供您参考：</p>\n<p>第一周（4.13-4.19）：</p>\n<ol>\n<li>规划网站功能和设计，制定开发计划。</li>\n<li>学习有关视频编解码、数据库和网络编程的知识。</li>\n<li>搭建基础框架，实现用户认证和授权功能。</li>\n</ol>\n<p>第二周（4.20-4.26）：</p>\n<ol>\n<li>学习有关视频存储和传输的知识。</li>\n<li>实现视频上传和存储功能。</li>\n<li>实现视频播放器，可以解码和播放不同格式的视频。</li>\n</ol>\n<p>第三周（4.27-5.3）：</p>\n<ol>\n<li>学习有关多线程编程和并发控制的知识。</li>\n<li>实现视频编解码和传输功能，保证视频流畅播放。</li>\n<li>完善网站的用户界面和功能。</li>\n</ol>\n<p>第四周（5.4-5.10）：</p>\n<ol>\n<li>学习有关安全和加密的知识。</li>\n<li>实现安全和加密功能，保护视频内容和用户隐私。</li>\n<li>进行网站测试和调试，修复漏洞和bug。</li>\n</ol>\n<p>第五周（5.11-5.17）：</p>\n<ol>\n<li>上线网站，发布测试版。</li>\n<li>收集用户反馈和意见，优化网站设计和功能。</li>\n<li>准备正式发布，宣传和推广网站。</li>\n</ol>\n<p>以上是一个大致的开发进度安排，具体时间取决于您的开发经验和技能、项目复杂度等因素。在开发过程中，及时调整进度安排，根据实际情况进行优化和改进，以保证项目的成功开发和上线。</p>\n<p>实现一个比Bilibili和YouTube更好的视频网站是一项非常具有挑战性的任务。以下是一些可能的亮点功能：</p>\n<ol>\n<li><p>强大的视频推荐算法：使用机器学习和人工智能技术，为用户提供个性化的视频推荐服务，更好地满足用户需求。</p>\n</li>\n<li><p>优质内容的筛选和审核：通过对视频内容的严格审核和筛选，保证网站上的内容质量，提高用户体验。</p>\n</li>\n<li><p>社交功能的增强：除了基本的评论和点赞功能外，还可以增加更多的社交功能，例如私信、关注、分享等，让用户更好地互动和交流。</p>\n</li>\n<li><p>更好的视频播放体验：提供更快的视频加载速度、更流畅的播放体验和更高的画质，让用户享受更好的观看体验。</p>\n</li>\n<li><p>多语言支持和跨平台兼容性：支持多种语言和跨平台兼容性，使更多的用户可以轻松访问和使用网站。</p>\n</li>\n<li><p>创新的商业模式：除了广告和会员等传统的商业模式外，可以尝试一些新的商业模式，例如增值服务、虚拟商品等，创造更多的商业价值。</p>\n</li>\n</ol>\n<p>以上是一些可能的亮点功能，当然还有很多其他的创新点和亮点可以探索和尝试。重要的是要不断地了解用户需求和市场变化，不断优化和改进网站的功能和服务。</p>\n<p>这些运维技能都可以帮助你更好地搭建、部署和管理视频播放网站。以下是一些可能的搭配运用方式：</p>\n<ol>\n<li><p>使用Nginx作为反向代理服务器，实现负载均衡和高可用性。Nginx可以将请求分发到多个服务器上，提高网站的访问速度和可靠性。</p>\n</li>\n<li><p>使用Docker将应用程序和依赖项打包成容器，方便部署和管理。Docker可以快速创建和销毁容器，避免了环境配置和依赖项问题，提高了开发效率。</p>\n</li>\n<li><p>使用Kubernetes（K8s）进行容器编排和管理，实现自动扩展和负载均衡。K8s可以自动调整容器数量，根据流量自动扩展和缩减容器，提高了网站的可伸缩性和弹性。</p>\n</li>\n<li><p>使用Jenkins进行持续集成和持续部署（CI&#x2F;CD），实现自动化构建、测试和部署。Jenkins可以自动化执行构建、测试和部署任务，减少了手动操作，提高了开发效率和质量。</p>\n</li>\n<li><p>进行日志分析和监控，使用ELK（Elasticsearch、Logstash和Kibana）等工具进行日志分析和监控。ELK可以对网站的日志进行收集、分析和可视化，帮助你快速定位和解决问题，提高了网站的可靠性和稳定性。</p>\n</li>\n</ol>\n<p>以上是一些可能的搭配运用方式，具体的应用场景和运用方式需要根据你的具体需求和情况来选择和决定。</p>\n<p>有很多优秀的前端页面模板可以参考，以下是一些比较好的学生管理系统前端页面模板：</p>\n<ol>\n<li><p>AdminLTE：一个开源的后台管理模板，提供了丰富的UI组件、表格、图表等功能，适合用于学生管理系统的后台管理页面。</p>\n</li>\n<li><p>Material Dashboard：一个基于Google Material Design的模板，提供了漂亮的UI设计和丰富的组件，适合用于学生管理系统的前台页面。</p>\n</li>\n<li><p>Metronic：一个功能强大的后台管理模板，提供了多种布局和主题，适合用于学生管理系统的后台管理页面。</p>\n</li>\n<li><p>SB Admin 2：一个简洁美观的后台管理模板，提供了响应式设计和多种组件，适合用于学生管理系统的后台管理页面。</p>\n</li>\n<li><p>Bootstrap Admin Template：一个基于Bootstrap的后台管理模板，提供了丰富的UI组件和布局，适合用于学生管理系统的后台管理页面。</p>\n</li>\n</ol>\n<p>以上模板都可以在Github上找到源码和使用文档，可以根据自己的需求进行定制和修改。</p>\n<p>以下是一些比较好的ffmpeg和C++结合的视频播放器的Github仓库：</p>\n<ol>\n<li><p>mpv-player&#x2F;mpv：一个基于FFmpeg和OpenGL的视频播放器，支持多种视频格式和音频格式，可以在Linux、Windows和macOS系统上运行。</p>\n</li>\n<li><p>VideoLAN&#x2F;VLC：一个开源的跨平台媒体播放器，支持各种视频和音频格式，可以在Windows、Linux、macOS、Android和iOS等平台上运行。</p>\n</li>\n<li><p>Bilibili&#x2F;ijkplayer：一个基于FFmpeg的Android&#x2F;iOS视频播放器，支持多种视频格式和音频格式，提供了丰富的API和示例代码。</p>\n</li>\n<li><p>FFmpegPlayer&#x2F;FFmpegPlayer：一个基于FFmpeg和SDL的视频播放器，支持多种视频格式和音频格式，提供了简单易用的API和示例代码。</p>\n</li>\n</ol>\n<p>这些仓库都提供了丰富的文档、示例代码和API，可以根据自己的需求进行定制和修改。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[日志系统]<a href=\"https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650122657&amp;idx=1&amp;sn=c5ce1d8059c40e4cd6deb42a34f8fe49&amp;chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650122657&amp;idx=1&amp;sn=c5ce1d8059c40e4cd6deb42a34f8fe49&amp;chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&amp;scene=21#wechat_redirect</a><br>[Reactor模型和Proactor模型]<a href=\"https://cloud.tencent.com/developer/article/1488120\">https://cloud.tencent.com/developer/article/1488120</a><br>[Reactor模型]<a href=\"https://www.cnblogs.com/CodeBear/p/12567022.html\">https://www.cnblogs.com/CodeBear/p/12567022.html</a><br>[epoll 事件之 EPOLLRDHUP]<a href=\"https://yangwenbo.com/articles/epoll-event-epollrdhup.html\">https://yangwenbo.com/articles/epoll-event-epollrdhup.html</a></p>\n","slug":"Project/webserver","updated":"15/04/2023","comments":true,"link":"","permalink":"http://example.com/2022/07/25/Project/webserver/","excerpt":"","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"Golang 面试","date":"27/06/2022","path":"2022/06/27/Interview-Q&A/Golang-Q&A/","text":"Go实现了两种并发形式第一种是，多线程共享内存。就是C++中实现的并发模型，他们线程间通信都是通过共享内存的方式来进行的。在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问。Go中也实现了传统的线程并发模型。另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。 Go的CSP并发模型，是通过goroutine和channel来实现的。 goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。 GMP模型介绍一下go runtinue使用了一个MPG模型来实现M指的是Machine，一个M直接关联了一个内核线程。所有的G(goroutine)任务最终都会在M上执行。P指的是processor，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。1．代表一个处理器，每个运行的M都必须绑定一个P。P的个数是GOMAXPOCS，最大为256，在程序启动时固定，一般不去修改。2.GOMAXPOCS默认值是当前电脑的核心数，单核CPU就只能设置为1，如果设置&gt;1，在GOMAXPOCS函数中也会被修改为1。3.M和P的个数不一定一样多，M&gt;&#x3D;P，每一个P都会保存本地的G任务队列，另外还有一个全局的G任务队列。G任务队列可以认为线程池中的线程队列。 G指的是Goroutine，代表一个goroutine对象，每次go调用的时候都会创建一个G对象，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。 go rutine调度流程 启动一个goroutine也就是创建一个G对象，然后加入到本地队列或者全局队列中 goroutineฎ按照抢占式进⾏调度，一个goroutine最多执行10ms就会换下一个2. 查找是否有空闲的P如果没有就直接返回如果有，就用系统API创建一个M(线程)3. 由这个刚创建的M循环执行能找到的G任务4. G任务执行的循序先从本地队列找，本地没有找到就从全局队列找，如果还没有找到就去其他P中找5. 所有的G任务的执行是按照go的调用顺序执行的6. 如果一个系统调用或者G任务执行的时间太长，就会一直占用这个线程 slice 底层和扩容defer 应用和底层内存管理垃圾回收熟悉docker，k8s，了解两者基本原理，了解devops实施方案，CICD，服务发现，灰度发布等 语法关键点defer关键字defer和go一样都是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。一般采用如下模式：defer是在return之前执行的。这个在 官方文档中是明确说明了的。要使用defer时不踩坑，最重要的一点就是要明白，return xxx这一条语句并不是一条原子指令!函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html make关键字chan关键字 反射机制 多进程go机制 参考文献[全面的golang教程]http://c.biancheng.net/golang/[defer关键字]https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html[GORM docs]https://gorm.io/zh_CN/docs/index.html","raw":"---\ntitle: Golang 面试\ndate: 2022-06-27 23:29:24\ntags:\n- 面试\n---\n\n\n\nGo实现了两种并发形式\n第一种是，多线程共享内存。就是C++中实现的并发模型，他们线程间通信都是通过共享内存的方式来进行的。在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问。Go中也实现了传统的线程并发模型。\n另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。\n\n\nGo的CSP并发模型，是通过goroutine和channel来实现的。\n\ngoroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。\nchannel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。\n\n\n\n\n# GMP模型介绍一下\ngo runtinue使用了一个MPG模型来实现\nM指的是Machine，一个M直接关联了一个内核线程。所有的G(goroutine)任务最终都会在M上执行。\nP指的是processor，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。\n1．代表一个处理器，每个运行的M都必须绑定一个P。P的个数是GOMAXPOCS，最大为256，在程序启动时固\n定，一般不去修改。\n2.GOMAXPOCS默认值是当前电脑的核心数，单核CPU就只能设置为1，如果设置>1，在GOMAXPOCS函数中\n也会被修改为1。\n3.M和P的个数不一定一样多，M>=P，每一个P都会保存本地的G任务队列，另外还有一个全局的G任务队列。G\n任务队列可以认为线程池中的线程队列。\n\nG指的是Goroutine，代表一个goroutine对象，每次go调用的时候都会创建一个G对象，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。\n\n# go rutine调度流程\n1. 启动一个goroutine\n也就是创建一个G对象，然后加入到本地队列或者全局队列中\n\ngoroutineฎ按照抢占式进⾏调度，一个goroutine最多执行10ms就会换下一个\n2. 查找是否有空闲的P\n如果没有就直接返回\n如果有，就用系统API创建一个M(线程)\n3. 由这个刚创建的M循环执行能找到的G任务\n4. G任务执行的循序\n先从本地队列找，本地没有找到就从全局队列找，如果还没有找到就去其他P中找\n5. 所有的G任务的执行是按照go的调用顺序执行的\n6. 如果一个系统调用或者G任务执行的时间太长，就会一直占用这个线程\n\n\n\n# slice 底层和扩容\n\n# defer 应用和底层\n\n# 内存管理\n\n# 垃圾回收\n\n# \n\n熟悉docker，k8s，了解两者基本原理，了解devops实施方案，CICD，服务发现，灰度发布等\n\n# 语法关键点\n\ndefer关键字\ndefer和go一样都是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。一般采用如下模式：\ndefer是在return之前执行的。这个在 官方文档中是明确说明了的。要使用defer时不踩坑，最重要的一点就是要明白，return xxx这一条语句并不是一条原子指令!\n函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。\ndefer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。\nhttps://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\n\nmake关键字\nchan关键字\n\n反射机制\n\n多进程go机制\n\n\n# 参考文献\n[全面的golang教程]http://c.biancheng.net/golang/\n[defer关键字]https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\n[GORM docs]https://gorm.io/zh_CN/docs/index.html\n\n\n\n","content":"<p>Go实现了两种并发形式<br>第一种是，多线程共享内存。就是C++中实现的并发模型，他们线程间通信都是通过共享内存的方式来进行的。在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问。Go中也实现了传统的线程并发模型。<br>另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。</p>\n<p>Go的CSP并发模型，是通过goroutine和channel来实现的。</p>\n<p>goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。<br>channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。</p>\n<h1 id=\"GMP模型介绍一下\"><a href=\"#GMP模型介绍一下\" class=\"headerlink\" title=\"GMP模型介绍一下\"></a>GMP模型介绍一下</h1><p>go runtinue使用了一个MPG模型来实现<br>M指的是Machine，一个M直接关联了一个内核线程。所有的G(goroutine)任务最终都会在M上执行。<br>P指的是processor，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。<br>1．代表一个处理器，每个运行的M都必须绑定一个P。P的个数是GOMAXPOCS，最大为256，在程序启动时固<br>定，一般不去修改。<br>2.GOMAXPOCS默认值是当前电脑的核心数，单核CPU就只能设置为1，如果设置&gt;1，在GOMAXPOCS函数中<br>也会被修改为1。<br>3.M和P的个数不一定一样多，M&gt;&#x3D;P，每一个P都会保存本地的G任务队列，另外还有一个全局的G任务队列。G<br>任务队列可以认为线程池中的线程队列。</p>\n<p>G指的是Goroutine，代表一个goroutine对象，每次go调用的时候都会创建一个G对象，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。</p>\n<h1 id=\"go-rutine调度流程\"><a href=\"#go-rutine调度流程\" class=\"headerlink\" title=\"go rutine调度流程\"></a>go rutine调度流程</h1><ol>\n<li>启动一个goroutine<br>也就是创建一个G对象，然后加入到本地队列或者全局队列中</li>\n</ol>\n<p>goroutineฎ按照抢占式进⾏调度，一个goroutine最多执行10ms就会换下一个<br>2. 查找是否有空闲的P<br>如果没有就直接返回<br>如果有，就用系统API创建一个M(线程)<br>3. 由这个刚创建的M循环执行能找到的G任务<br>4. G任务执行的循序<br>先从本地队列找，本地没有找到就从全局队列找，如果还没有找到就去其他P中找<br>5. 所有的G任务的执行是按照go的调用顺序执行的<br>6. 如果一个系统调用或者G任务执行的时间太长，就会一直占用这个线程</p>\n<h1 id=\"slice-底层和扩容\"><a href=\"#slice-底层和扩容\" class=\"headerlink\" title=\"slice 底层和扩容\"></a>slice 底层和扩容</h1><h1 id=\"defer-应用和底层\"><a href=\"#defer-应用和底层\" class=\"headerlink\" title=\"defer 应用和底层\"></a>defer 应用和底层</h1><h1 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h1><h1 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h1><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><p>熟悉docker，k8s，了解两者基本原理，了解devops实施方案，CICD，服务发现，灰度发布等</p>\n<h1 id=\"语法关键点\"><a href=\"#语法关键点\" class=\"headerlink\" title=\"语法关键点\"></a>语法关键点</h1><p>defer关键字<br>defer和go一样都是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。一般采用如下模式：<br>defer是在return之前执行的。这个在 官方文档中是明确说明了的。要使用defer时不踩坑，最重要的一点就是要明白，return xxx这一条语句并不是一条原子指令!<br>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。<br>defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。<br><a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a></p>\n<p>make关键字<br>chan关键字</p>\n<p>反射机制</p>\n<p>多进程go机制</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[全面的golang教程]<a href=\"http://c.biancheng.net/golang/\">http://c.biancheng.net/golang/</a><br>[defer关键字]<a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a><br>[GORM docs]<a href=\"https://gorm.io/zh_CN/docs/index.html\">https://gorm.io/zh_CN/docs/index.html</a></p>\n","slug":"Interview-Q&A/Golang-Q&A","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/27/Interview-Q&A/Golang-Q&A/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"百度和谷歌的比较","date":"22/06/2022","path":"2022/06/22/Others/Comparison-of-Baidu-an-Google/","text":"很多人都觉得百度也将就能用，之前我也是这么觉得的，后来能用谷歌以后，才发现区别是这么大，特地开一篇文章来对比谷歌和百度的搜索结果。以前四个页面搜索到为标准，如果还没有找到合适的答案，那么就选择正确的回回答 一、关键词：win11没有hyper-v百度： 百度回答1：看起来是个可以用的回答，但是这个命令的格式有点问题，有中文符号在里面，作为一个小白的话，直接粘贴肯定是没有效果的 百度回答2：怎么还是一样的回答，还是一样的错误格式 百度回答3：还是一样的错误格式 百度回答3：百度自家的内容，这种回答一般情况都是垃圾，这次也还是不知道哪里抄的回答，还是一样的格式错误 百度回答5：终于有了一个靠谱的回答，可以粘贴了 谷歌： 谷歌回答1：第一个回答就直接是格式正确的，并且作者还附上了下载链接，不会用的直接下载就可以，第一个答案就直接解决了 谷歌回答2：一个微软官方的回答，看起来比较靠谱，可以作为第一种无效的试一试的方案 谷歌回答3：又是一个正确的格式的回答，可以直接粘贴解决问题","raw":"---\ntitle: 百度和谷歌的比较\ndate: 2022-06-22 23:22:01\ntags:\n- 其他\n---\n\n\n很多人都觉得百度也将就能用，之前我也是这么觉得的，后来能用谷歌以后，才发现区别是这么大，特地开一篇文章来对比谷歌和百度的搜索结果。\n以前四个页面搜索到为标准，如果还没有找到合适的答案，那么就选择正确的回回答\n\n# 一、关键词：win11没有hyper-v\n百度：\n[![j9IRd1.png](https://s1.ax1x.com/2022/06/22/j9IRd1.png)](https://imgtu.com/i/j9IRd1)\n\n百度回答1：\n看起来是个可以用的回答，但是这个命令的格式有点问题，有中文符号在里面，作为一个小白的话，直接粘贴肯定是没有效果的\n[![j9o00A.png](https://s1.ax1x.com/2022/06/22/j9o00A.png)](https://imgtu.com/i/j9o00A)\n\n百度回答2：\n怎么还是一样的回答，还是一样的错误格式\n[![j9orkt.png](https://s1.ax1x.com/2022/06/22/j9orkt.png)](https://imgtu.com/i/j9orkt)\n\n百度回答3：\n还是一样的错误格式\n[![j9o26g.png](https://s1.ax1x.com/2022/06/22/j9o26g.png)](https://imgtu.com/i/j9o26g)\n\n百度回答3：\n百度自家的内容，这种回答一般情况都是垃圾，这次也还是不知道哪里抄的回答，还是一样的格式错误\n[![j9ostP.png](https://s1.ax1x.com/2022/06/22/j9ostP.png)](https://imgtu.com/i/j9ostP)\n\n百度回答5：\n终于有了一个靠谱的回答，可以粘贴了\n[![j9oBTI.png](https://s1.ax1x.com/2022/06/22/j9oBTI.png)](https://imgtu.com/i/j9oBTI)\n\n谷歌：\n[![j9I2ZR.png](https://s1.ax1x.com/2022/06/22/j9I2ZR.png)](https://imgtu.com/i/j9I2ZR)\n\n谷歌回答1：\n第一个回答就直接是格式正确的，并且作者还附上了下载链接，不会用的直接下载就可以，第一个答案就直接解决了\n[![j9oyff.png](https://s1.ax1x.com/2022/06/22/j9oyff.png)](https://imgtu.com/i/j9oyff)\n\n谷歌回答2：\n一个微软官方的回答，看起来比较靠谱，可以作为第一种无效的试一试的方案\n[![j9ocp8.png](https://s1.ax1x.com/2022/06/22/j9ocp8.png)](https://imgtu.com/i/j9ocp8)\n\n谷歌回答3：\n又是一个正确的格式的回答，可以直接粘贴解决问题\n[![j9og1S.png](https://s1.ax1x.com/2022/06/22/j9og1S.png)](https://imgtu.com/i/j9og1S)","content":"<p>很多人都觉得百度也将就能用，之前我也是这么觉得的，后来能用谷歌以后，才发现区别是这么大，特地开一篇文章来对比谷歌和百度的搜索结果。<br>以前四个页面搜索到为标准，如果还没有找到合适的答案，那么就选择正确的回回答</p>\n<h1 id=\"一、关键词：win11没有hyper-v\"><a href=\"#一、关键词：win11没有hyper-v\" class=\"headerlink\" title=\"一、关键词：win11没有hyper-v\"></a>一、关键词：win11没有hyper-v</h1><p>百度：<br><a href=\"https://imgtu.com/i/j9IRd1\"><img src=\"https://s1.ax1x.com/2022/06/22/j9IRd1.png\" alt=\"j9IRd1.png\"></a></p>\n<p>百度回答1：<br>看起来是个可以用的回答，但是这个命令的格式有点问题，有中文符号在里面，作为一个小白的话，直接粘贴肯定是没有效果的<br><a href=\"https://imgtu.com/i/j9o00A\"><img src=\"https://s1.ax1x.com/2022/06/22/j9o00A.png\" alt=\"j9o00A.png\"></a></p>\n<p>百度回答2：<br>怎么还是一样的回答，还是一样的错误格式<br><a href=\"https://imgtu.com/i/j9orkt\"><img src=\"https://s1.ax1x.com/2022/06/22/j9orkt.png\" alt=\"j9orkt.png\"></a></p>\n<p>百度回答3：<br>还是一样的错误格式<br><a href=\"https://imgtu.com/i/j9o26g\"><img src=\"https://s1.ax1x.com/2022/06/22/j9o26g.png\" alt=\"j9o26g.png\"></a></p>\n<p>百度回答3：<br>百度自家的内容，这种回答一般情况都是垃圾，这次也还是不知道哪里抄的回答，还是一样的格式错误<br><a href=\"https://imgtu.com/i/j9ostP\"><img src=\"https://s1.ax1x.com/2022/06/22/j9ostP.png\" alt=\"j9ostP.png\"></a></p>\n<p>百度回答5：<br>终于有了一个靠谱的回答，可以粘贴了<br><a href=\"https://imgtu.com/i/j9oBTI\"><img src=\"https://s1.ax1x.com/2022/06/22/j9oBTI.png\" alt=\"j9oBTI.png\"></a></p>\n<p>谷歌：<br><a href=\"https://imgtu.com/i/j9I2ZR\"><img src=\"https://s1.ax1x.com/2022/06/22/j9I2ZR.png\" alt=\"j9I2ZR.png\"></a></p>\n<p>谷歌回答1：<br>第一个回答就直接是格式正确的，并且作者还附上了下载链接，不会用的直接下载就可以，第一个答案就直接解决了<br><a href=\"https://imgtu.com/i/j9oyff\"><img src=\"https://s1.ax1x.com/2022/06/22/j9oyff.png\" alt=\"j9oyff.png\"></a></p>\n<p>谷歌回答2：<br>一个微软官方的回答，看起来比较靠谱，可以作为第一种无效的试一试的方案<br><a href=\"https://imgtu.com/i/j9ocp8\"><img src=\"https://s1.ax1x.com/2022/06/22/j9ocp8.png\" alt=\"j9ocp8.png\"></a></p>\n<p>谷歌回答3：<br>又是一个正确的格式的回答，可以直接粘贴解决问题<br><a href=\"https://imgtu.com/i/j9og1S\"><img src=\"https://s1.ax1x.com/2022/06/22/j9og1S.png\" alt=\"j9og1S.png\"></a></p>\n","slug":"Others/Comparison-of-Baidu-an-Google","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/22/Others/Comparison-of-Baidu-an-Google/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"docker安装教程","date":"22/06/2022","path":"2022/06/22/Environment-Configuration/docker-Installation-tutorial/","text":"在windows中安装docker desktop win11家庭版，没有开启hyper-v功能选项在桌面新建txt文件，复制下面代码，然后改名hyper-v.cmd，管理员方式执行 12345pushd &quot;%~dp0&quot;dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\\servicing\\Packages\\%%i&quot;del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 右键开始图标-&gt;应用和功能-&gt;左侧应用-&gt;可选功能-&gt;更多windows功能-&gt;hyper-v开启 参考文献[windwos11没有Hyper-V的解决方法]https://www.jianshu.com/p/96aa6eeacb56","raw":"---\ntitle: docker安装教程\ndate: 2022-06-22 23:16:36\ntags:\n- 环境配置\n---\n\n在windows中安装docker desktop\n\nwin11家庭版，没有开启hyper-v功能选项\n在桌面新建txt文件，复制下面代码，然后改名hyper-v.cmd，**管理员方式**执行\n```\npushd \"%~dp0\"\ndir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum >hyper-v.txt\nfor /f %%i in ('findstr /i . hyper-v.txt 2^>nul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\"\ndel hyper-v.txt\nDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL\n```\n右键开始图标->应用和功能->左侧应用->可选功能->更多windows功能->hyper-v开启\n\n\n\n\n\n# 参考文献\n\n[windwos11没有Hyper-V的解决方法]https://www.jianshu.com/p/96aa6eeacb56\n\n\n\n","content":"<p>在windows中安装docker desktop</p>\n<p>win11家庭版，没有开启hyper-v功能选项<br>在桌面新建txt文件，复制下面代码，然后改名hyper-v.cmd，<strong>管理员方式</strong>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">pushd</span> <span class=\"string\">&quot;%~dp0&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span> /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class=\"line\"><span class=\"keyword\">for</span> /f %%i <span class=\"keyword\">in</span> (<span class=\"string\">&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;</span>) <span class=\"keyword\">do</span> dism /online /norestart /add-package:<span class=\"string\">&quot;%SystemRoot%\\servicing\\Packages\\%%i&quot;</span></span><br><span class=\"line\">del hyper-v.txt</span><br><span class=\"line\">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure>\n<p>右键开始图标-&gt;应用和功能-&gt;左侧应用-&gt;可选功能-&gt;更多windows功能-&gt;hyper-v开启</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[windwos11没有Hyper-V的解决方法]<a href=\"https://www.jianshu.com/p/96aa6eeacb56\">https://www.jianshu.com/p/96aa6eeacb56</a></p>\n","slug":"Environment-Configuration/docker-Installation-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/22/Environment-Configuration/docker-Installation-tutorial/","excerpt":"","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Golang 语法","date":"21/06/2022","path":"2022/06/21/Grammar/Golang-Grammar/","text":"实习中用到的技术点常用的框架minio分布式存储gRPCGORMcontext包context上下文包解析 go 1.7以后才支持 用在协程里面 控制并发两种方式 使用 WaitGroup 使用Context 通用场景，多个goroutine执行同一件事情 主动通知停止channel + select 如果有多个goroutine,或者goroutine里面又有goroutine 需要使用context控制 client -&gt; server#1 -&gt; server#2请求 req应答 res 用户中间中断请求，那么中间的资源全部浪费了，当用户切断的时候，能马上停止 ctx :&#x3D; context.Backgroud() context.WithCancle(ctx)d 参考文献[语法介绍]https://www.topgoer.com/[Golang 的 time.Now() 给你的是什么时间？]https://www.jianshu.com/p/896cc3f4ee82 Go by Example 项目 · Go语言中文文档 (topgoer.com) Go by Example 中文版 (gobyexample-cn.github.io)","raw":"---\ntitle: Golang 语法\ndate: 2022-06-21 00:03:01\ntags:\n- 语法\n---\n\n\n\n# 实习中用到的技术点\n\n\n\n# 常用的框架\n\n## minio分布式存储\n\n## gRPC\n\n## GORM\n\n# context包\ncontext上下文包解析\n\ngo 1.7以后才支持\n\n用在协程里面\n\n控制并发两种方式\n\t使用 WaitGroup\n\t使用Context\n\n通用场景，多个goroutine执行同一件事情\n\n主动通知停止\nchannel + select\n\n如果有多个goroutine,或者goroutine里面又有goroutine\n\n需要使用context控制\n\n\nclient -> server#1 -> server#2\n请求 req\n应答 res\n\n用户中间中断请求，那么中间的资源全部浪费了，当用户切断的时候，能马上停止\n\n\nctx := context.Backgroud()\n\ncontext.WithCancle(ctx)d\n\n\n# 参考文献\n\n[语法介绍]https://www.topgoer.com/\n[Golang 的 time.Now() 给你的是什么时间？]https://www.jianshu.com/p/896cc3f4ee82\n\n[Go by Example](https://gobyexample.com/)\n\n[项目 · Go语言中文文档 (topgoer.com)](https://www.topgoer.com/%E9%A1%B9%E7%9B%AE/)\n\n[Go by Example 中文版 (gobyexample-cn.github.io)](https://gobyexample-cn.github.io/)","content":"<h1 id=\"实习中用到的技术点\"><a href=\"#实习中用到的技术点\" class=\"headerlink\" title=\"实习中用到的技术点\"></a>实习中用到的技术点</h1><h1 id=\"常用的框架\"><a href=\"#常用的框架\" class=\"headerlink\" title=\"常用的框架\"></a>常用的框架</h1><h2 id=\"minio分布式存储\"><a href=\"#minio分布式存储\" class=\"headerlink\" title=\"minio分布式存储\"></a>minio分布式存储</h2><h2 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h2><h2 id=\"GORM\"><a href=\"#GORM\" class=\"headerlink\" title=\"GORM\"></a>GORM</h2><h1 id=\"context包\"><a href=\"#context包\" class=\"headerlink\" title=\"context包\"></a>context包</h1><p>context上下文包解析</p>\n<p>go 1.7以后才支持</p>\n<p>用在协程里面</p>\n<p>控制并发两种方式<br>    使用 WaitGroup<br>    使用Context</p>\n<p>通用场景，多个goroutine执行同一件事情</p>\n<p>主动通知停止<br>channel + select</p>\n<p>如果有多个goroutine,或者goroutine里面又有goroutine</p>\n<p>需要使用context控制</p>\n<p>client -&gt; server#1 -&gt; server#2<br>请求 req<br>应答 res</p>\n<p>用户中间中断请求，那么中间的资源全部浪费了，当用户切断的时候，能马上停止</p>\n<p>ctx :&#x3D; context.Backgroud()</p>\n<p>context.WithCancle(ctx)d</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[语法介绍]<a href=\"https://www.topgoer.com/\">https://www.topgoer.com/</a><br>[Golang 的 time.Now() 给你的是什么时间？]<a href=\"https://www.jianshu.com/p/896cc3f4ee82\">https://www.jianshu.com/p/896cc3f4ee82</a></p>\n<p><a href=\"https://gobyexample.com/\">Go by Example</a></p>\n<p><a href=\"https://www.topgoer.com/%E9%A1%B9%E7%9B%AE/\">项目 · Go语言中文文档 (topgoer.com)</a></p>\n<p><a href=\"https://gobyexample-cn.github.io/\">Go by Example 中文版 (gobyexample-cn.github.io)</a></p>\n","slug":"Grammar/Golang-Grammar","updated":"12/11/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/21/Grammar/Golang-Grammar/","excerpt":"","categories":[],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"实习内容","date":"19/06/2022","path":"2022/06/19/Reflection/Intern-Log/","text":"2022.6.13-6.19 本周的工作内容，周一安装环境，了解docker周二了解docker，可以把docker的镜像跑起来周三出现了巨大问题，程序一直没有弄明白，也没有问别人周四还是在做周三做的事情，而且效率很底下周五完成任务，得到了新的任务 总结和反思：1.当自己有问题解决不了的，分析问题的原因，来自自己，还是来自别人，接下来，我解决这个问题，需要寻求别人的帮助，还是自己去找方法解决2.下午后半段的工作效率不高，在中午的时候，以3:00区分，规划一下下午的3点前后的任务。在3:00的时候应该对自己当前的工作状况进行反思，看一下现在自己状态好不好，设计一下接下来干什么3.当自己程序看不懂的时候，很大情况下是自己知识点的欠缺，需要去补足，先把东西学会，再去做东西，效率会更高4.应该一直做同一个工作，不要总是换来换去 需要加强的：构建docker镜像的能力，只是会用docker命令，还是没有具体了解docker内部的情况 202.6.20-6.24本周内容：周一熟悉gorm,gRPC，看代码，还没有跑起来周二得到需求，分析需求，搭调试环境，学postman周三实现导出名字和身份证周四读取图片，不会连接轨迹服务器周五花了一天的时间连接轨迹服务器，终于连上了 不足的：1.遇到业务上无法解决的问题，应该及时的提问2.写业务的时候，可以先构思需要的函数的输入输出是什么，然后把每个子函数都写好，然后再去写内容（封装的思想）3.对一个新语言的不熟悉，就是要手打代码段一点一点的多敲才能熟悉，不要总是粘贴4.大佬写的代码总是能一气呵成，修改比较少，自己的代码就是需要反复的修改，所以特别慢，并且这次是新语言，新框架，而且要用数据库，所以写起来，试错的时间更加长了5.总结一下：语法不熟悉、对业务的把控能力很弱、对代码的把控能力很弱（不知道要怎么开这些函数） postman 的问题如果实际的proto没有更新，但是自己在发送框里面写了内容，实际上是没有发出去的 思考和总结 思考一个问题，准备开发一个项目的时候，考虑的方式应该是”先大后小再大“以档案导出为例来说明 先大——先从最大的角度考利，档案导出需要什么样的接口，导出的时候会会遇到什么样的问题，先确定最主要的三个接口，导出档案，查询进度，删除档案但是也不用特别的大，要有范围，给一定的总体的布局时间 后小——真正开始写项目了，就需要落到细节处理，思考这个具体的功能应该如何实现， 全部写完以后，从头到尾开始审查，这个项目现在还有什么问题，需要怎么去解决比如全都写完以后做错误处理4）交给测试 参考文献[mysql和sqlserver删除指定条数的数据记录，mysql delete limit和sqlserver delete top]https://blog.csdn.net/guangmo0123/article/details/109353553[mysql 中数据表 DATA_LENGTH &amp; INDEX_LENGTH]http://dbaselife.com/project-7/doc-1112/[mySQL 数据类型]https://www.runoob.com/mysql/mysql-data-types.html [Amazon S3]https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax[mysql 官方文档]https://www.mysqlzh.com/doc/65.html[mysql 中 创建索引很慢，怎么解决]https://www.debugease.com/mysql/282296.html[TIDB 的书]https://book.tidb.io/[从一个简单的Delete删数据场景谈TiDB数据库开发规范的重要性]https://zhuanlan.zhihu.com/p/427227246","raw":"---\ntitle: 实习内容\ndate: 2022-06-19 23:43:01\ntags:\n- 反思\n---\n\n2022.6.13-6.19\n\n本周的工作内容，\n周一安装环境，了解docker\n周二了解docker，可以把docker的镜像跑起来\n周三出现了巨大问题，程序一直没有弄明白，也没有问别人\n周四还是在做周三做的事情，而且效率很底下\n周五完成任务，得到了新的任务\n\n总结和反思：\n1.当自己有问题解决不了的，分析问题的原因，来自自己，还是来自别人，接下来，我解决这个问题，需要寻求别人的帮助，还是自己去找方法解决\n2.下午后半段的工作效率不高，在中午的时候，以3:00区分，规划一下下午的3点前后的任务。\n在3:00的时候应该对自己当前的工作状况进行反思，看一下现在自己状态好不好，设计一下接下来干什么\n3.当自己程序看不懂的时候，很大情况下是自己知识点的欠缺，需要去补足，先把东西学会，再去做东西，效率会更高\n4.应该一直做同一个工作，不要总是换来换去\n\n\n需要加强的：\n构建docker镜像的能力，只是会用docker命令，还是没有具体了解docker内部的情况\n\n\n202.6.20-6.24\n本周内容：\n周一熟悉gorm,gRPC，看代码，还没有跑起来\n周二得到需求，分析需求，搭调试环境，学postman\n周三实现导出名字和身份证\n周四读取图片，不会连接轨迹服务器\n周五花了一天的时间连接轨迹服务器，终于连上了\n\n不足的：\n1.遇到业务上无法解决的问题，应该及时的提问\n2.写业务的时候，可以先构思需要的函数的输入输出是什么，然后把每个子函数都写好，然后再去写内容（封装的思想）\n3.对一个新语言的不熟悉，就是要手打代码段一点一点的多敲才能熟悉，不要总是粘贴\n4.大佬写的代码总是能一气呵成，修改比较少，自己的代码就是需要反复的修改，所以特别慢，并且这次是新语言，新框架，而且要用数据库，所以写起来，试错的时间更加长了\n5.总结一下：语法不熟悉、对业务的把控能力很弱、对代码的把控能力很弱（不知道要怎么开这些函数）\n\n\n\n# postman 的问题\n如果实际的proto没有更新，但是自己在发送框里面写了内容，实际上是没有发出去的\n\n\n\n# 思考和总结\n1. 思考一个问题，准备开发一个项目的时候，考虑的方式应该是”先大后小再大“\n以档案导出为例来说明\n1) 先大——先从最大的角度考利，档案导出需要什么样的接口，导出的时候会会遇到什么样的问题，先确定最主要的三个接口，导出档案，查询进度，删除档案\n但是也不用特别的大，要有范围，给一定的总体的布局时间\n2) 后小——真正开始写项目了，就需要落到细节处理，思考这个具体的功能应该如何实现，\n3) 全部写完以后，从头到尾开始审查，这个项目现在还有什么问题，需要怎么去解决\n比如全都写完以后做错误处理\n4）交给测试\n\n\n\n\n# 参考文献\n[mysql和sqlserver删除指定条数的数据记录，mysql delete limit和sqlserver delete top]https://blog.csdn.net/guangmo0123/article/details/109353553\n[mysql 中数据表 DATA_LENGTH & INDEX_LENGTH]http://dbaselife.com/project-7/doc-1112/\n[mySQL 数据类型]https://www.runoob.com/mysql/mysql-data-types.html\n\n[Amazon S3]https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax\n[mysql 官方文档]https://www.mysqlzh.com/doc/65.html\n[mysql 中 创建索引很慢，怎么解决]https://www.debugease.com/mysql/282296.html\n[TIDB 的书]https://book.tidb.io/\n[从一个简单的Delete删数据场景谈TiDB数据库开发规范的重要性]https://zhuanlan.zhihu.com/p/427227246\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>2022.6.13-6.19</p>\n<p>本周的工作内容，<br>周一安装环境，了解docker<br>周二了解docker，可以把docker的镜像跑起来<br>周三出现了巨大问题，程序一直没有弄明白，也没有问别人<br>周四还是在做周三做的事情，而且效率很底下<br>周五完成任务，得到了新的任务</p>\n<p>总结和反思：<br>1.当自己有问题解决不了的，分析问题的原因，来自自己，还是来自别人，接下来，我解决这个问题，需要寻求别人的帮助，还是自己去找方法解决<br>2.下午后半段的工作效率不高，在中午的时候，以3:00区分，规划一下下午的3点前后的任务。<br>在3:00的时候应该对自己当前的工作状况进行反思，看一下现在自己状态好不好，设计一下接下来干什么<br>3.当自己程序看不懂的时候，很大情况下是自己知识点的欠缺，需要去补足，先把东西学会，再去做东西，效率会更高<br>4.应该一直做同一个工作，不要总是换来换去</p>\n<p>需要加强的：<br>构建docker镜像的能力，只是会用docker命令，还是没有具体了解docker内部的情况</p>\n<p>202.6.20-6.24<br>本周内容：<br>周一熟悉gorm,gRPC，看代码，还没有跑起来<br>周二得到需求，分析需求，搭调试环境，学postman<br>周三实现导出名字和身份证<br>周四读取图片，不会连接轨迹服务器<br>周五花了一天的时间连接轨迹服务器，终于连上了</p>\n<p>不足的：<br>1.遇到业务上无法解决的问题，应该及时的提问<br>2.写业务的时候，可以先构思需要的函数的输入输出是什么，然后把每个子函数都写好，然后再去写内容（封装的思想）<br>3.对一个新语言的不熟悉，就是要手打代码段一点一点的多敲才能熟悉，不要总是粘贴<br>4.大佬写的代码总是能一气呵成，修改比较少，自己的代码就是需要反复的修改，所以特别慢，并且这次是新语言，新框架，而且要用数据库，所以写起来，试错的时间更加长了<br>5.总结一下：语法不熟悉、对业务的把控能力很弱、对代码的把控能力很弱（不知道要怎么开这些函数）</p>\n<h1 id=\"postman-的问题\"><a href=\"#postman-的问题\" class=\"headerlink\" title=\"postman 的问题\"></a>postman 的问题</h1><p>如果实际的proto没有更新，但是自己在发送框里面写了内容，实际上是没有发出去的</p>\n<h1 id=\"思考和总结\"><a href=\"#思考和总结\" class=\"headerlink\" title=\"思考和总结\"></a>思考和总结</h1><ol>\n<li>思考一个问题，准备开发一个项目的时候，考虑的方式应该是”先大后小再大“<br>以档案导出为例来说明</li>\n</ol>\n<ol>\n<li>先大——先从最大的角度考利，档案导出需要什么样的接口，导出的时候会会遇到什么样的问题，先确定最主要的三个接口，导出档案，查询进度，删除档案<br>但是也不用特别的大，要有范围，给一定的总体的布局时间</li>\n<li>后小——真正开始写项目了，就需要落到细节处理，思考这个具体的功能应该如何实现，</li>\n<li>全部写完以后，从头到尾开始审查，这个项目现在还有什么问题，需要怎么去解决<br>比如全都写完以后做错误处理<br>4）交给测试</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[mysql和sqlserver删除指定条数的数据记录，mysql delete limit和sqlserver delete top]<a href=\"https://blog.csdn.net/guangmo0123/article/details/109353553\">https://blog.csdn.net/guangmo0123/article/details/109353553</a><br>[mysql 中数据表 DATA_LENGTH &amp; INDEX_LENGTH]<a href=\"http://dbaselife.com/project-7/doc-1112/\">http://dbaselife.com/project-7/doc-1112/</a><br>[mySQL 数据类型]<a href=\"https://www.runoob.com/mysql/mysql-data-types.html\">https://www.runoob.com/mysql/mysql-data-types.html</a></p>\n<p>[Amazon S3]<a href=\"https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax\">https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax</a><br>[mysql 官方文档]<a href=\"https://www.mysqlzh.com/doc/65.html\">https://www.mysqlzh.com/doc/65.html</a><br>[mysql 中 创建索引很慢，怎么解决]<a href=\"https://www.debugease.com/mysql/282296.html\">https://www.debugease.com/mysql/282296.html</a><br>[TIDB 的书]<a href=\"https://book.tidb.io/\">https://book.tidb.io/</a><br>[从一个简单的Delete删数据场景谈TiDB数据库开发规范的重要性]<a href=\"https://zhuanlan.zhihu.com/p/427227246\">https://zhuanlan.zhihu.com/p/427227246</a></p>\n","slug":"Reflection/Intern-Log","updated":"22/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/19/Reflection/Intern-Log/","excerpt":"","categories":[],"tags":[{"name":"反思","slug":"反思","permalink":"http://example.com/tags/%E5%8F%8D%E6%80%9D/"}]},{"title":"docker 教程","date":"19/06/2022","path":"2022/06/19/Course/docker-tutorial/","text":"docker 安装教程一、docker 镜像命令镜像查看docker images -a #列出本地所有的镜像docker images -q #只显示镜像IDdocker images –digests #显示镜像的摘要信息docker images –no-trunc #显示完整的镜像信息 NAME #名称DESCRIPTION #描述STARS #点赞，关注度，类似GitHubOFFICIAL #是否官方AUTOMATED #是否自动构建 请确认输入了正确的用户名和密码。 镜像下载docker pull tomcat #从Docker Hub上下载tomcat镜像，默认是最新版本。等价于：docker pull tomcat:latestdocker pull tomcat:8 # 选择指定版本下载 镜像运行此时从镜像变成了容器docker run 镜像名docker run 镜像名:Tag –name&#x3D;”nginx-lb”: 为容器指定一个名称；-P：随机映射 -P后不能指定参数，随机选一个对外端口映射出去-p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -p 8888:6379 -p 8888:6379 解析 将容器内部的 6379端口与docker 宿主机（docker装在哪太服务器 那台服务器 就是其数组机）8888 端口进行映射 那通过外部访问宿主机8888端口 即可访问到 docker 容器 6379 端口了-d: 后台运行容器，并返回容器ID；-i: 以交互模式运行容器，通常与 -t 同时使用；-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –privileged 大约在0.6版，privileged被引入docker。 使用该参数，container内的root拥有真正的root权限。 否则，container内的root只是外部的一个普通用户权限。 privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。 甚至允许你在docker容器中启动docker容器 docker run -it –privileged -v D:\\test:&#x2F;output -d -p 8010:22 -p 50001:50051 -p 50002:50052 -p 50005:55555 e9e8789a3024 docker run -it –name&#x3D;”u1” -v $PWD:&#x2F;myapp ubuntu:latest &#x2F;bin&#x2F;bash 在端口映射以后，需要测试一下映射是否成功ssh &#114;&#x6f;&#x6f;&#116;&#64;&#49;&#50;&#55;&#x2e;&#48;&#x2e;&#48;&#x2e;&#49; -p 8010 镜像删除docker rmi java#强制删除(删除正在运行的镜像，注：以后台方式运行的不能被强制删除)docker rmi -f java#多个镜像删除，不同镜像间以空格间隔docker rmi -f java tomcat nginx#删除本地全部镜像docker rmi -f $(docker images -q) 二、docker 容器命令查看容器查看正在运行容器列表docker ps查看所有容器 —–包含正在运行 和已停止的docker ps -a 停止容器docker stop 容器名&#x2F;容器ID 进入容器docker exec -it 容器名&#x2F;容器ID &#x2F;bin&#x2F;bashdocker exec -it test01 &#x2F;bin&#x2F;bash 启动容器docker start 容器ID&#x2F;容器名docker start t1 删除容器#删除一个容器docker rm -f 容器名&#x2F;容器ID#删除多个容器 空格隔开要删除的容器名或容器IDdocker rm -f 容器名&#x2F;容器ID 容器名&#x2F;容器ID 容器名&#x2F;容器ID#删除全部容器docker rm -f $(docker ps -aq) 查看容器端口映射docker port [容器名]需要这个容器被启动，才能查看到他的端口映射情况 参考资料[Ubuntu20.04安装docker]https://blog.csdn.net/m0_59092234/article/details/123816391#:~:text=Ubuntu20.04%20%E5%AE%89%E8%A3%85Docker%201859%20%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%201%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E5%BA%93%E6%BA%90%20sudo%20apt-get%20update,2%E3%80%81%E7%84%B6%20%E5%90%8E%20%E7%9B%B4%E6%8E%A5%20sudo%20apt%20install%20docker.io%20%2F3%E3%80%82[docker hub]https://hub.docker.com/","raw":"---\ntitle: docker 教程\ndate: 2022-06-19 23:39:25\ntags:\n- 课程\n---\n\n\n# docker 安装教程\n\n# 一、docker 镜像命令\n\n## 镜像查看\ndocker images -a            #列出本地所有的镜像\ndocker images -q            #只显示镜像ID\ndocker images --digests     #显示镜像的摘要信息\ndocker images --no-trunc    #显示完整的镜像信息\n\nNAME            #名称\nDESCRIPTION     #描述\nSTARS           #点赞，关注度，类似GitHub\nOFFICIAL        #是否官方\nAUTOMATED       #是否自动构建 请确认输入了正确的用户名和密码。\n\n## 镜像下载\ndocker pull tomcat      #从Docker Hub上下载tomcat镜像，默认是最新版本。等价于：docker pull tomcat:latest\ndocker pull tomcat:8  # 选择指定版本下载\n\n## 镜像运行\n此时从镜像变成了容器\ndocker run 镜像名\ndocker run 镜像名:Tag\n\n--name=\"nginx-lb\": 为容器指定一个名称；\n-P：随机映射\n    -P后不能指定参数，随机选一个对外端口映射出去\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n    -p 8888:6379\n    -p 8888:6379 解析 将容器内部的 6379端口与docker 宿主机（docker装在哪太服务器 那台服务器 就是其数组机）8888 端口进行映射 那通过外部访问宿主机8888端口 即可访问到 docker 容器 6379 端口了\n-d: 后台运行容器，并返回容器ID；\n-i: 以交互模式运行容器，通常与 -t 同时使用；\n-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n --privileged\n    大约在0.6版，privileged被引入docker。\n    使用该参数，container内的root拥有真正的root权限。\n    否则，container内的root只是外部的一个普通用户权限。\n    privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。\n    甚至允许你在docker容器中启动docker容器\n\ndocker run -it --privileged -v D:\\test\\:/output -d -p 8010:22 -p 50001:50051 -p 50002:50052 -p 50005:55555 e9e8789a3024\n\ndocker run -it --name=\"u1\" -v $PWD:/myapp ubuntu:latest /bin/bash\n\n在端口映射以后，需要测试一下映射是否成功\nssh root@127.0.0.1 -p 8010\n\n## 镜像删除\ndocker rmi java\n#强制删除(删除正在运行的镜像，注：以后台方式运行的不能被强制删除)\ndocker rmi -f java\n#多个镜像删除，不同镜像间以空格间隔\ndocker rmi -f java tomcat nginx\n#删除本地全部镜像\ndocker rmi -f $(docker images -q)\n\n# 二、docker 容器命令\n\n## 查看容器\n查看正在运行容器列表\ndocker ps\n查看所有容器 -----包含正在运行 和已停止的\ndocker ps -a\n\n\n## 停止容器\ndocker stop 容器名/容器ID\n\n## 进入容器\ndocker exec -it 容器名/容器ID /bin/bash\ndocker exec -it test01 /bin/bash\n\n## 启动容器\ndocker start 容器ID/容器名\ndocker start t1\n\n\n## 删除容器\n#删除一个容器\ndocker rm -f 容器名/容器ID\n#删除多个容器 空格隔开要删除的容器名或容器ID\ndocker rm -f 容器名/容器ID 容器名/容器ID 容器名/容器ID\n#删除全部容器\ndocker rm -f $(docker ps -aq)\n\n## 查看容器端口映射\n\ndocker port [容器名]\n需要这个容器被启动，才能查看到他的端口映射情况\n\n\n\n# 参考资料\n[Ubuntu20.04安装docker]https://blog.csdn.net/m0_59092234/article/details/123816391#:~:text=Ubuntu20.04%20%E5%AE%89%E8%A3%85Docker%201859%20%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%201%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E5%BA%93%E6%BA%90%20sudo%20apt-get%20update,2%E3%80%81%E7%84%B6%20%E5%90%8E%20%E7%9B%B4%E6%8E%A5%20sudo%20apt%20install%20docker.io%20%2F3%E3%80%82\n[docker hub]https://hub.docker.com/\n\n\n","content":"<h1 id=\"docker-安装教程\"><a href=\"#docker-安装教程\" class=\"headerlink\" title=\"docker 安装教程\"></a>docker 安装教程</h1><h1 id=\"一、docker-镜像命令\"><a href=\"#一、docker-镜像命令\" class=\"headerlink\" title=\"一、docker 镜像命令\"></a>一、docker 镜像命令</h1><h2 id=\"镜像查看\"><a href=\"#镜像查看\" class=\"headerlink\" title=\"镜像查看\"></a>镜像查看</h2><p>docker images -a            #列出本地所有的镜像<br>docker images -q            #只显示镜像ID<br>docker images –digests     #显示镜像的摘要信息<br>docker images –no-trunc    #显示完整的镜像信息</p>\n<p>NAME            #名称<br>DESCRIPTION     #描述<br>STARS           #点赞，关注度，类似GitHub<br>OFFICIAL        #是否官方<br>AUTOMATED       #是否自动构建 请确认输入了正确的用户名和密码。</p>\n<h2 id=\"镜像下载\"><a href=\"#镜像下载\" class=\"headerlink\" title=\"镜像下载\"></a>镜像下载</h2><p>docker pull tomcat      #从Docker Hub上下载tomcat镜像，默认是最新版本。等价于：docker pull tomcat:latest<br>docker pull tomcat:8  # 选择指定版本下载</p>\n<h2 id=\"镜像运行\"><a href=\"#镜像运行\" class=\"headerlink\" title=\"镜像运行\"></a>镜像运行</h2><p>此时从镜像变成了容器<br>docker run 镜像名<br>docker run 镜像名:Tag</p>\n<p>–name&#x3D;”nginx-lb”: 为容器指定一个名称；<br>-P：随机映射<br>    -P后不能指定参数，随机选一个对外端口映射出去<br>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>    -p 8888:6379<br>    -p 8888:6379 解析 将容器内部的 6379端口与docker 宿主机（docker装在哪太服务器 那台服务器 就是其数组机）8888 端口进行映射 那通过外部访问宿主机8888端口 即可访问到 docker 容器 6379 端口了<br>-d: 后台运行容器，并返回容器ID；<br>-i: 以交互模式运行容器，通常与 -t 同时使用；<br>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br> –privileged<br>    大约在0.6版，privileged被引入docker。<br>    使用该参数，container内的root拥有真正的root权限。<br>    否则，container内的root只是外部的一个普通用户权限。<br>    privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。<br>    甚至允许你在docker容器中启动docker容器</p>\n<p>docker run -it –privileged -v D:\\test:&#x2F;output -d -p 8010:22 -p 50001:50051 -p 50002:50052 -p 50005:55555 e9e8789a3024</p>\n<p>docker run -it –name&#x3D;”u1” -v $PWD:&#x2F;myapp ubuntu:latest &#x2F;bin&#x2F;bash</p>\n<p>在端口映射以后，需要测试一下映射是否成功<br>ssh <a href=\"mailto:&#114;&#x6f;&#x6f;&#116;&#64;&#49;&#50;&#55;&#x2e;&#48;&#x2e;&#48;&#x2e;&#49;\">&#114;&#x6f;&#x6f;&#116;&#64;&#49;&#50;&#55;&#x2e;&#48;&#x2e;&#48;&#x2e;&#49;</a> -p 8010</p>\n<h2 id=\"镜像删除\"><a href=\"#镜像删除\" class=\"headerlink\" title=\"镜像删除\"></a>镜像删除</h2><p>docker rmi java<br>#强制删除(删除正在运行的镜像，注：以后台方式运行的不能被强制删除)<br>docker rmi -f java<br>#多个镜像删除，不同镜像间以空格间隔<br>docker rmi -f java tomcat nginx<br>#删除本地全部镜像<br>docker rmi -f $(docker images -q)</p>\n<h1 id=\"二、docker-容器命令\"><a href=\"#二、docker-容器命令\" class=\"headerlink\" title=\"二、docker 容器命令\"></a>二、docker 容器命令</h1><h2 id=\"查看容器\"><a href=\"#查看容器\" class=\"headerlink\" title=\"查看容器\"></a>查看容器</h2><p>查看正在运行容器列表<br>docker ps<br>查看所有容器 —–包含正在运行 和已停止的<br>docker ps -a</p>\n<h2 id=\"停止容器\"><a href=\"#停止容器\" class=\"headerlink\" title=\"停止容器\"></a>停止容器</h2><p>docker stop 容器名&#x2F;容器ID</p>\n<h2 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h2><p>docker exec -it 容器名&#x2F;容器ID &#x2F;bin&#x2F;bash<br>docker exec -it test01 &#x2F;bin&#x2F;bash</p>\n<h2 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h2><p>docker start 容器ID&#x2F;容器名<br>docker start t1</p>\n<h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><p>#删除一个容器<br>docker rm -f 容器名&#x2F;容器ID<br>#删除多个容器 空格隔开要删除的容器名或容器ID<br>docker rm -f 容器名&#x2F;容器ID 容器名&#x2F;容器ID 容器名&#x2F;容器ID<br>#删除全部容器<br>docker rm -f $(docker ps -aq)</p>\n<h2 id=\"查看容器端口映射\"><a href=\"#查看容器端口映射\" class=\"headerlink\" title=\"查看容器端口映射\"></a>查看容器端口映射</h2><p>docker port [容器名]<br>需要这个容器被启动，才能查看到他的端口映射情况</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[Ubuntu20.04安装docker]<a href=\"https://blog.csdn.net/m0_59092234/article/details/123816391#:~:text=Ubuntu20.04%20%E5%AE%89%E8%A3%85Docker%201859%20%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%201%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E5%BA%93%E6%BA%90%20sudo%20apt-get%20update,2%E3%80%81%E7%84%B6%20%E5%90%8E%20%E7%9B%B4%E6%8E%A5%20sudo%20apt%20install%20docker.io%20%2F3%E3%80%82\">https://blog.csdn.net/m0_59092234/article/details/123816391#:~:text=Ubuntu20.04%20%E5%AE%89%E8%A3%85Docker%201859%20%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%201%E3%80%81%E5%85%88%E6%9B%B4%E6%96%B0%E5%BA%93%E6%BA%90%20sudo%20apt-get%20update,2%E3%80%81%E7%84%B6%20%E5%90%8E%20%E7%9B%B4%E6%8E%A5%20sudo%20apt%20install%20docker.io%20%2F3%E3%80%82</a><br>[docker hub]<a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></p>\n","slug":"Course/docker-tutorial","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/06/19/Course/docker-tutorial/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"设计模式学习","date":"15/05/2022","path":"2022/05/15/Course/Design-Patterns/","text":"面向对象的设计原则，五个SOLID指代了面向对象编程和面向对象设计的五个基本原则 名称 缩写 全称 解释 单一职责原则 SRP Single Responsibility Principle 每个类的职责单一 开闭原则 OCP Open Closed Principle 类的改动，增加代码是好的，修改源代码是不好的 里氏替换原则 LSP Liskov Substitution Principle 多态 接口隔离原则 ISP Interface Segregation Principle 接口隔离 依赖倒置原则 DIP Dependence Inversion Principle 依赖抽象接口 —— —— —— —— 迪米特法则 LoD Law of Demeter 一个对象应当对其他对象少了解 组合&#x2F;聚合复用原则 CRP Composite&#x2F;Aggregate Reuse Principle 继承不好，组合好的 总体原则：高聚合，低耦合 6.迪米特法则解释：去公司找人修电脑，不应该去找某个具体的小李、小张来修，应该抽象出一个接口类，IT部门，找IT部门修，用抽象接口再去对接实际的类，不然找小张解决不了问题，找小李解决不了问题。结论：迪米特法则强调了类之间的松耦合关系，类之间的耦合越松，越有利于复用。 简单工厂模式概述：本来每个类都需要new出来，现在是通过一个工厂来创建 优点：1.客户端和具体实现类解耦2.对于某些对象创建过程比较复杂情况，我们不用考虑这些了 缺点：1.简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则2.这个类职责过重，这个类发生问题，会影响很多实用这个工厂的模块 使用场景：1.工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中个的业务逻辑太过复杂。2.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。解释：用在不需要关心创建过程，读取什么文件，什么什么的，就想要用这个类比如创建过程很复杂，但是我只是想用这个类，那我就用这个简单工厂创建一下就行，具体的创建过程都放在工厂里面 工厂模式概述：对于每一个类，都对应一个具体创建的工厂类，然后再定义一个抽象工厂作为接口简单工厂模式 + “开闭原则” &#x3D; 工厂方法模式 优点：1.不需要记住具体类名，甚至连具体参数都不用记忆（因为用的是抽象的工厂接口）2.实现了对象创建和使用的分离。3.系统的可扩展性也就变得非常好，无需修改接口和原类。（符合开闭原则） 缺点：1.增加系统中类的个数，复杂度和理解度增加。2.增加了系统的抽象性和理解难度。 适用场景1.客户端不知道它所需要的对象的类。2.抽象工厂类通过其子类来指定创建哪个对象。 参考文献https://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482","raw":"---\ntitle: 设计模式学习\ndate: 2022-05-15 15:08:04\ntags:\n- 课程\n---\n\n# 面向对象的设计原则，五个\nSOLID指代了**面向对象编程**和**面向对象设计**的五个基本原则\n| 名称 | 缩写 | 全称 | 解释 |\n| ------ | ------ | ------ |------ |\n|单一职责原则       |SRP        |Single Responsibility Principle        |每个类的职责单一|\n|**开闭原则**          |OCP       |Open Closed Principle               |类的改动，增加代码是好的，修改源代码是不好的|\n|里氏替换原则       |LSP        |Liskov Substitution Principle       |多态|\n|接口隔离原则\t    |ISP        |Interface Segregation Principle    |接口隔离|\n|**依赖倒置原则**\t    |DIP        |Dependence Inversion Principle   |依赖抽象接口|\n| ------ | ------ | ------ |------ |\n|迪米特法则         |LoD        |Law of Demeter                         |一个对象应当对其他对象少了解|\n|组合/聚合复用原则   |CRP   |Composite/Aggregate Reuse Principle            |继承不好，组合好的|\n\n总体原则：高聚合，低耦合\n\n\n# 6.迪米特法则\n解释：\n去公司找人修电脑，不应该去找某个具体的小李、小张来修，应该抽象出一个接口类，IT部门，找IT部门修，用抽象接口再去对接实际的类，不然找小张解决不了问题，找小李解决不了问题。\n结论：迪米特法则强调了类之间的松耦合关系，类之间的耦合越松，越有利于复用。\n\n\n\n# 简单工厂模式\n## 概述：\n本来每个类都需要new出来，现在是通过一个工厂来创建\n## 优点：\n1.客户端和具体实现类解耦\n2.对于某些对象创建过程比较复杂情况，我们不用考虑这些了\n## 缺点：\n1.简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则\n2.这个类职责过重，这个类发生问题，会影响很多实用这个工厂的模块\n## 使用场景：\n1.工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中个的业务逻辑太过复杂。\n2.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。\n**解释**：用在不需要关心创建过程，读取什么文件，什么什么的，就想要用这个类\n比如创建过程很复杂，但是我只是想用这个类，那我就用这个简单工厂创建一下就行，具体的创建过程都放在工厂里面\n\n\n\n\n\n# 工厂模式\n## 概述：\n对于每一个类，都对应一个具体创建的工厂类，然后再定义一个抽象工厂作为接口\n简单工厂模式 + “开闭原则” = 工厂方法模式\n## 优点：\n1.不需要记住具体类名，甚至连具体参数都不用记忆（因为用的是抽象的工厂接口）\n2.实现了对象创建和使用的分离。\n3.系统的可扩展性也就变得非常好，无需修改接口和原类。（符合开闭原则）\n## 缺点：\n1.增加系统中类的个数，复杂度和理解度增加。\n2.增加了系统的抽象性和理解难度。\n## 适用场景\n1.客户端不知道它所需要的对象的类。\n2.抽象工厂类通过其子类来指定创建哪个对象。\n\n\n\n# 参考文献\nhttps://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"面向对象的设计原则，五个\"><a href=\"#面向对象的设计原则，五个\" class=\"headerlink\" title=\"面向对象的设计原则，五个\"></a>面向对象的设计原则，五个</h1><p>SOLID指代了<strong>面向对象编程</strong>和<strong>面向对象设计</strong>的五个基本原则</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>缩写</th>\n<th>全称</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单一职责原则</td>\n<td>SRP</td>\n<td>Single Responsibility Principle</td>\n<td>每个类的职责单一</td>\n</tr>\n<tr>\n<td><strong>开闭原则</strong></td>\n<td>OCP</td>\n<td>Open Closed Principle</td>\n<td>类的改动，增加代码是好的，修改源代码是不好的</td>\n</tr>\n<tr>\n<td>里氏替换原则</td>\n<td>LSP</td>\n<td>Liskov Substitution Principle</td>\n<td>多态</td>\n</tr>\n<tr>\n<td>接口隔离原则</td>\n<td>ISP</td>\n<td>Interface Segregation Principle</td>\n<td>接口隔离</td>\n</tr>\n<tr>\n<td><strong>依赖倒置原则</strong></td>\n<td>DIP</td>\n<td>Dependence Inversion Principle</td>\n<td>依赖抽象接口</td>\n</tr>\n<tr>\n<td>——</td>\n<td>——</td>\n<td>——</td>\n<td>——</td>\n</tr>\n<tr>\n<td>迪米特法则</td>\n<td>LoD</td>\n<td>Law of Demeter</td>\n<td>一个对象应当对其他对象少了解</td>\n</tr>\n<tr>\n<td>组合&#x2F;聚合复用原则</td>\n<td>CRP</td>\n<td>Composite&#x2F;Aggregate Reuse Principle</td>\n<td>继承不好，组合好的</td>\n</tr>\n</tbody></table>\n<p>总体原则：高聚合，低耦合</p>\n<h1 id=\"6-迪米特法则\"><a href=\"#6-迪米特法则\" class=\"headerlink\" title=\"6.迪米特法则\"></a>6.迪米特法则</h1><p>解释：<br>去公司找人修电脑，不应该去找某个具体的小李、小张来修，应该抽象出一个接口类，IT部门，找IT部门修，用抽象接口再去对接实际的类，不然找小张解决不了问题，找小李解决不了问题。<br>结论：迪米特法则强调了类之间的松耦合关系，类之间的耦合越松，越有利于复用。</p>\n<h1 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h1><h2 id=\"概述：\"><a href=\"#概述：\" class=\"headerlink\" title=\"概述：\"></a>概述：</h2><p>本来每个类都需要new出来，现在是通过一个工厂来创建</p>\n<h2 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>1.客户端和具体实现类解耦<br>2.对于某些对象创建过程比较复杂情况，我们不用考虑这些了</p>\n<h2 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>1.简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则<br>2.这个类职责过重，这个类发生问题，会影响很多实用这个工厂的模块</p>\n<h2 id=\"使用场景：\"><a href=\"#使用场景：\" class=\"headerlink\" title=\"使用场景：\"></a>使用场景：</h2><p>1.工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中个的业务逻辑太过复杂。<br>2.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。<br><strong>解释</strong>：用在不需要关心创建过程，读取什么文件，什么什么的，就想要用这个类<br>比如创建过程很复杂，但是我只是想用这个类，那我就用这个简单工厂创建一下就行，具体的创建过程都放在工厂里面</p>\n<h1 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h1><h2 id=\"概述：-1\"><a href=\"#概述：-1\" class=\"headerlink\" title=\"概述：\"></a>概述：</h2><p>对于每一个类，都对应一个具体创建的工厂类，然后再定义一个抽象工厂作为接口<br>简单工厂模式 + “开闭原则” &#x3D; 工厂方法模式</p>\n<h2 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>1.不需要记住具体类名，甚至连具体参数都不用记忆（因为用的是抽象的工厂接口）<br>2.实现了对象创建和使用的分离。<br>3.系统的可扩展性也就变得非常好，无需修改接口和原类。（符合开闭原则）</p>\n<h2 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>1.增加系统中类的个数，复杂度和理解度增加。<br>2.增加了系统的抽象性和理解难度。</p>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>1.客户端不知道它所需要的对象的类。<br>2.抽象工厂类通过其子类来指定创建哪个对象。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482\">https://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482</a></p>\n","slug":"Course/Design-Patterns","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/05/15/Course/Design-Patterns/","excerpt":"","categories":[],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"PPT制作要点","date":"23/04/2022","path":"2022/04/23/Others/PPT-production-points/","text":"以“除草智能装备及机器人”为题目，制作一个PPT 构思： 首先接到一个做PPT的需求 思考从哪几个方面开始写注意：由于是刚刚接触到这个题目，一般是十分的陌生，所以第一个任务就是找出哪几个点去写，但是一般情况下，刚刚提出的都是有问题的但是一定要找到几个要点，先提出来，再后面的不断思考中，会不断改进，自然就会优化了 举例： 发展现状 机械介绍 算法介绍 未来展望 写一个大纲主要内容：大的点，2-3条每个大点里面找要展开来讲的点，3-4条 举例： 发展现状 农田割草机 技术情况 市场情况 国内 国外 机械介绍 有什么 算法介绍 路径规划 点到点 全覆盖 未来展望 ROS、SLAM 多机器人 不规则地块 开始制作： 确定主题颜色，从要讲述的东西中，选取2-3个主题颜色 从头开始对每个点进行扩充，查找图片和相关资料，多找GIF先把内容都填充到PPT中，不用考虑排版差不多半天，比如19:00-22:00这么长时间，可以完成对个大点内容的填充 设计每个页面的排版将页面精简，从大段文字中提取出主要内容这个步骤完成后，主要内容已经制作完成了 设计动画：7. 给每个页面加上动画设计每个段落之间的逻辑关系 反复看整个PPT的演示效果 自己复述，设计改怎么表述 PPT设计要点： 减少大段文字的出现，大段文字总结成小标题，或者小标题配和一小段文字 必须出现一小段文字，用红字加粗主要内容 空荡荡的字放在那里很空虚，最后放一个背景框 给小标题加上一条线 没有边框的图标，柱状图，饼图，用框框框起来 纯白的背景很单调，后面添加一半的纯色背景 能用图片代替文字就尽量用图片代替 动画要点 强调重点的时候，不止用红框框 图片+扩展图形放大凸显 放大镜凸显 后面加阴影，前面放大 增加时间轴的表现形式 设计封面的时候，用动画将主要要讲述的物体突出 红圈，用轮子效果 半透明形状 参考资料图标下载,ICON(PNG&#x2F;ICO&#x2F;SVG&#x2F;矢量) easyicon 免费下载 - 爱给网 (aigei.com) NN SVG (alexlenail.me) 画神经网络 Make A Gif - Animated Gifs Maker, Free Gif Creator Online DataV.GeoAtlas地理小工具系列 (aliyun.com) 在线抠图软件_图片去除背景 | remove.bg – remove.bg 佐糖-免费在线抠图神器_证件照换底色_照片修复_无损压缩创意图像平台-PicWish","raw":"---\ntitle: PPT制作要点\ndate: 2022-04-23 16:34:57\ntags:\n- 其他\n---\n\n\n以“除草智能装备及机器人”为题目，制作一个PPT\n\n构思：\n1. 首先接到一个做PPT的需求\n\n2. 思考从哪几个方面开始写\n注意：由于是刚刚接触到这个题目，一般是十分的陌生，所以第一个任务就是找出哪几个点去写，但是一般情况下，刚刚提出的都是有问题的\n但是一定要找到几个要点，先提出来，再后面的不断思考中，会不断改进，自然就会优化了\n\n举例：\n- 发展现状\n- 机械介绍\n- 算法介绍\n- 未来展望\n\n3. 写一个大纲\n主要内容：\n大的点，2-3条\n每个大点里面找要展开来讲的点，3-4条\n\n举例：\n- 发展现状\n    - 农田割草机\n    - 技术情况\n    - 市场情况\n    - 国内\n    - 国外\n- 机械介绍\n    - 有什么\n- 算法介绍\n    - 路径规划\n    - 点到点\n    - 全覆盖\n- 未来展望\n    - ROS、SLAM\n    - 多机器人\n    - 不规则地块\n------------------------------------------------------\n开始制作：\n\n4. 确定主题颜色，从要讲述的东西中，选取2-3个主题颜色\n\n\n5. 从头开始\n对每个点进行扩充，查找图片和相关资料，多找GIF\n先把内容都填充到PPT中，不用考虑排版\n差不多半天，比如19:00-22:00这么长时间，可以完成对个大点内容的填充\n\n6. 设计每个页面的排版\n将页面精简，从大段文字中提取出主要内容\n这个步骤完成后，主要内容已经制作完成了\n\n------------------------------------------------------\n\n设计动画：\n7. 给每个页面加上动画\n设计每个段落之间的逻辑关系\n\n\n8. 反复看整个PPT的演示效果\n\n------------------------------------------------------\n\n自己复述，设计改怎么表述\n\n\n\n\n\n\n\n\n\n------------------------------------------------------\nPPT设计要点：\n1. 减少大段文字的出现，大段文字总结成小标题，或者小标题配和一小段文字\n2. 必须出现一小段文字，用红字加粗主要内容\n3. 空荡荡的字放在那里很空虚，最后放一个背景框\n4. 给小标题加上一条线\n5. 没有边框的图标，柱状图，饼图，用框框框起来\n6. 纯白的背景很单调，后面添加一半的纯色背景\n7. 能用图片代替文字就尽量用图片代替\n\n动画要点\n1. 强调重点的时候，不止用红框框\n    - 图片+扩展图形放大凸显\n    - 放大镜凸显\n    - 后面加阴影，前面放大\n2. 增加时间轴的表现形式\n3. 设计封面的时候，用动画将主要要讲述的物体突出\n4. 红圈，用轮子效果\n5. 半透明形状\n\n\n\n# 参考资料\n\n[图标下载,ICON(PNG/ICO/SVG/矢量) easyicon 免费下载 - 爱给网 (aigei.com)](https://www.aigei.com/icon/class/)\n\n[NN SVG (alexlenail.me)](http://alexlenail.me/NN-SVG/AlexNet.html)\n\n[画神经网络](https://cbovar.github.io/ConvNetDraw/)\n\n[Make A Gif - Animated Gifs Maker, Free Gif Creator Online](https://makeagif.com/)\n\n[DataV.GeoAtlas地理小工具系列 (aliyun.com)](http://datav.aliyun.com/portal/school/atlas/area_selector)\n\n[在线抠图软件_图片去除背景 | remove.bg – remove.bg](https://www.remove.bg/zh)\n\n[佐糖-免费在线抠图神器_证件照换底色_照片修复_无损压缩创意图像平台-PicWish](https://picwish.cn/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>以“除草智能装备及机器人”为题目，制作一个PPT</p>\n<p>构思：</p>\n<ol>\n<li><p>首先接到一个做PPT的需求</p>\n</li>\n<li><p>思考从哪几个方面开始写<br>注意：由于是刚刚接触到这个题目，一般是十分的陌生，所以第一个任务就是找出哪几个点去写，但是一般情况下，刚刚提出的都是有问题的<br>但是一定要找到几个要点，先提出来，再后面的不断思考中，会不断改进，自然就会优化了</p>\n</li>\n</ol>\n<p>举例：</p>\n<ul>\n<li>发展现状</li>\n<li>机械介绍</li>\n<li>算法介绍</li>\n<li>未来展望</li>\n</ul>\n<ol start=\"3\">\n<li>写一个大纲<br>主要内容：<br>大的点，2-3条<br>每个大点里面找要展开来讲的点，3-4条</li>\n</ol>\n<p>举例：</p>\n<ul>\n<li>发展现状<ul>\n<li>农田割草机</li>\n<li>技术情况</li>\n<li>市场情况</li>\n<li>国内</li>\n<li>国外</li>\n</ul>\n</li>\n<li>机械介绍<ul>\n<li>有什么</li>\n</ul>\n</li>\n<li>算法介绍<ul>\n<li>路径规划</li>\n<li>点到点</li>\n<li>全覆盖</li>\n</ul>\n</li>\n<li>未来展望<ul>\n<li>ROS、SLAM</li>\n<li>多机器人</li>\n<li>不规则地块</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>开始制作：</p>\n<ol start=\"4\">\n<li><p>确定主题颜色，从要讲述的东西中，选取2-3个主题颜色</p>\n</li>\n<li><p>从头开始<br>对每个点进行扩充，查找图片和相关资料，多找GIF<br>先把内容都填充到PPT中，不用考虑排版<br>差不多半天，比如19:00-22:00这么长时间，可以完成对个大点内容的填充</p>\n</li>\n<li><p>设计每个页面的排版<br>将页面精简，从大段文字中提取出主要内容<br>这个步骤完成后，主要内容已经制作完成了</p>\n</li>\n</ol>\n<hr>\n<p>设计动画：<br>7. 给每个页面加上动画<br>设计每个段落之间的逻辑关系</p>\n<ol start=\"8\">\n<li>反复看整个PPT的演示效果</li>\n</ol>\n<hr>\n<p>自己复述，设计改怎么表述</p>\n<hr>\n<p>PPT设计要点：</p>\n<ol>\n<li>减少大段文字的出现，大段文字总结成小标题，或者小标题配和一小段文字</li>\n<li>必须出现一小段文字，用红字加粗主要内容</li>\n<li>空荡荡的字放在那里很空虚，最后放一个背景框</li>\n<li>给小标题加上一条线</li>\n<li>没有边框的图标，柱状图，饼图，用框框框起来</li>\n<li>纯白的背景很单调，后面添加一半的纯色背景</li>\n<li>能用图片代替文字就尽量用图片代替</li>\n</ol>\n<p>动画要点</p>\n<ol>\n<li>强调重点的时候，不止用红框框<ul>\n<li>图片+扩展图形放大凸显</li>\n<li>放大镜凸显</li>\n<li>后面加阴影，前面放大</li>\n</ul>\n</li>\n<li>增加时间轴的表现形式</li>\n<li>设计封面的时候，用动画将主要要讲述的物体突出</li>\n<li>红圈，用轮子效果</li>\n<li>半透明形状</li>\n</ol>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.aigei.com/icon/class/\">图标下载,ICON(PNG&#x2F;ICO&#x2F;SVG&#x2F;矢量) easyicon 免费下载 - 爱给网 (aigei.com)</a></p>\n<p><a href=\"http://alexlenail.me/NN-SVG/AlexNet.html\">NN SVG (alexlenail.me)</a></p>\n<p><a href=\"https://cbovar.github.io/ConvNetDraw/\">画神经网络</a></p>\n<p><a href=\"https://makeagif.com/\">Make A Gif - Animated Gifs Maker, Free Gif Creator Online</a></p>\n<p><a href=\"http://datav.aliyun.com/portal/school/atlas/area_selector\">DataV.GeoAtlas地理小工具系列 (aliyun.com)</a></p>\n<p><a href=\"https://www.remove.bg/zh\">在线抠图软件_图片去除背景 | remove.bg – remove.bg</a></p>\n<p><a href=\"https://picwish.cn/\">佐糖-免费在线抠图神器_证件照换底色_照片修复_无损压缩创意图像平台-PicWish</a></p>\n","slug":"Others/PPT-production-points","updated":"08/11/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/23/Others/PPT-production-points/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"makefile 教程","date":"05/04/2022","path":"2022/04/05/Tutorial/linux-dev-env/makefile-tutorial/","text":"自动化变量 说明 $* 表示目标文件的名称，不包含目标文件的扩展名 $+ 也是所有依赖目标的集合,这些依赖文件用空格分开，按照出现的先后为顺序，只是它不去除重复的依赖目标 $&lt; 规则中的第一个相关文件名 $? 规则中日期新于目标的所有相关文件的列表，以空格分割 $@ 规则的目标所对应的文件名 $^ 规则中所有相关文件的列表，以空格分割 $(@D) 目标文件的目录部分 $(@F) 目标文件的文件名部分 常用变量 说明 默认值 AR 归档维护程序 ar AS 汇编程序 as CPP c预处理程序 cpp CC c编译程序 cc CXX c++编译程序 g++ RM 文件删除程序 rm -f ARFLAGS 传给归档维护程序的标志 rv ASFLAGS 传给汇编程序的标志 无默认值 CFLAGS 传给c编译程序的标志 无默认值 CPPFLAGS 传给c预处理程序的标志 无默认值 CXXFLAGS 传给c++编译器的标志 无默认值 LDFLAGS 传给链接程序（ld）的标志 无默认值 模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为5）。 如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下： %.o : %.c markdown中的函数 BIN_SRCS :&#x3D; $(wildcard bin&#x2F;*.cc)获取匹配模式的文件名 wildcardsrc &#x3D; $(wildcard *.c)wildcard把 指定目录 .&#x2F; 和 .&#x2F;sub&#x2F; 下的所有后缀是c的文件全部展开。 模式替换函数 patsubst 循环函数 foreach g++ -Wall -std&#x3D;c++11 -pthread -O2 -g -iquote include&#x2F; -I..&#x2F; -I&#x2F;usr&#x2F;local&#x2F;include -L lib&#x2F; -L&#x2F;usr&#x2F;local&#x2F;lib -ltpc bin&#x2F;echo_client.cc lib&#x2F;libtpc.a -o bin&#x2F;echo_client 输出信息$(info “info here”)$(info “$(CFLAGS)”) 输出变量$(warning “CFLAGS &#x3D; $(CFLAGS)”)， 生成静态库文件g++ test -cg++ test -oar -rcs libtest.a 常见编译选项12BIN_SRCS := $(wildcard bin/*.cc) # 选择所有文件BIN_SRCS := $(filter-out bin/test.cc, $(BIN_SRCS)) # 单独去掉bin/test.cc 参考文献https://blog.csdn.net/yi412/article/details/69941791https://blog.csdn.net/marc07/article/details/62885868","raw":"---\ntitle: makefile 教程\ndate: 2022-04-05 20:34:26\ntags:\n- 教程\n---\n\n\n\n|自动化变量                        |   说明|\n| ------ | ------ |\n|$*                             |表示目标文件的名称，不包含目标文件的扩展名|\n|$+                                |也是所有依赖目标的集合,这些依赖文件用空格分开，按照出现的先后为顺序，只是它不去除重复的依赖目标|\n|$<                            |  规则中的第一个相关文件名|\n|$?                            |  规则中日期新于目标的所有相关文件的列表，以空格分割|\n|$@                            |  规则的目标所对应的文件名|\n|$^                            |  规则中所有相关文件的列表，以空格分割|\n|$(@D)                          | 目标文件的目录部分|\n|$(@F)                         |  目标文件的文件名部分|\n\n\n\n\n|常用变量                            | 说明  |默认值\n| ------ | ------ |------ |\n|AR                              | 归档维护程序         |ar  |\n|AS                              | 汇编程序             |as  |\n|CPP                            |  c预处理程序          |cpp  |\n|CC                              |   c编译程序          |cc  |\n|CXX                              |   c++编译程序          |g++  |                        \n|RM                              | 文件删除程序         |rm -f  |\n|ARFLAGS                         |  传给归档维护程序的标志|rv  |\n|ASFLAGS                         | 传给汇编程序的标志   |无默认值  |\n|CFLAGS                          | 传给c编译程序的标志  |无默认值  |\n|CPPFLAGS                        | 传给c预处理程序的标志    |无默认值  |\n|CXXFLAGS                        |  传给c++编译器的标志     |无默认值|\n|LDFLAGS                         |传给链接程序（ld）的标志|无默认值  |\n\n\n\n模式规则中，至少在规则的目标定义中要包含\"%\"，否则，就是一般的规则。目标中的\"%\"定义表示对文件名的匹配，\"%\"表示长度任意的非空字符串。例如：\"%.c\"表示以\".c\"结尾的文件名（文件名的长度至少为3），而\"s.%.c\"则表示以\"s.\"开头，\".c\"结尾的文件名（文件名的长度至少为5）。\n\n如果\"%\"定义在目标中，那么，目标中的\"%\"的值决定了依赖目标中的\"%\"的值，也就是说，目标中的模式的\"%\"决定了依赖目标中\"%\"的样子。例如有一个模式规则如下：\n    %.o : %.c \n\n\nmarkdown中的函数\n\n\nBIN_SRCS := $(wildcard bin/*.cc)\n获取匹配模式的文件名 wildcard\nsrc = $(wildcard *.c)\nwildcard把 指定目录 ./ 和 ./sub/ 下的所有后缀是c的文件全部展开。\n\n\n模式替换函数 patsubst\n\n\n循环函数 foreach\n\n\n\ng++ -Wall -std=c++11 -pthread -O2 -g -iquote include/ -I../ -I/usr/local/include  -L lib/ -L/usr/local/lib -ltpc  bin/echo_client.cc lib/libtpc.a   -o bin/echo_client\n\n\n# 输出信息\n$(info \"info here\")\n$(info \"$(CFLAGS)\")\n# 输出变量\n$(warning \"CFLAGS = $(CFLAGS)\")，\n\n\n# 生成静态库文件\ng++ test -c \ng++ test -o\nar -rcs libtest.a\n\n\n\n# 常见编译选项\n```makefile\nBIN_SRCS := $(wildcard bin/*.cc)  # 选择所有文件\nBIN_SRCS := $(filter-out bin/test.cc, $(BIN_SRCS)) # 单独去掉bin/test.cc\n```\n\n\n# 参考文献\nhttps://blog.csdn.net/yi412/article/details/69941791\nhttps://blog.csdn.net/marc07/article/details/62885868\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<table>\n<thead>\n<tr>\n<th>自动化变量</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$*</td>\n<td>表示目标文件的名称，不包含目标文件的扩展名</td>\n</tr>\n<tr>\n<td>$+</td>\n<td>也是所有依赖目标的集合,这些依赖文件用空格分开，按照出现的先后为顺序，只是它不去除重复的依赖目标</td>\n</tr>\n<tr>\n<td>$&lt;</td>\n<td>规则中的第一个相关文件名</td>\n</tr>\n<tr>\n<td>$?</td>\n<td>规则中日期新于目标的所有相关文件的列表，以空格分割</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>规则的目标所对应的文件名</td>\n</tr>\n<tr>\n<td>$^</td>\n<td>规则中所有相关文件的列表，以空格分割</td>\n</tr>\n<tr>\n<td>$(@D)</td>\n<td>目标文件的目录部分</td>\n</tr>\n<tr>\n<td>$(@F)</td>\n<td>目标文件的文件名部分</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>常用变量</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AR</td>\n<td>归档维护程序</td>\n<td>ar</td>\n</tr>\n<tr>\n<td>AS</td>\n<td>汇编程序</td>\n<td>as</td>\n</tr>\n<tr>\n<td>CPP</td>\n<td>c预处理程序</td>\n<td>cpp</td>\n</tr>\n<tr>\n<td>CC</td>\n<td>c编译程序</td>\n<td>cc</td>\n</tr>\n<tr>\n<td>CXX</td>\n<td>c++编译程序</td>\n<td>g++</td>\n</tr>\n<tr>\n<td>RM</td>\n<td>文件删除程序</td>\n<td>rm -f</td>\n</tr>\n<tr>\n<td>ARFLAGS</td>\n<td>传给归档维护程序的标志</td>\n<td>rv</td>\n</tr>\n<tr>\n<td>ASFLAGS</td>\n<td>传给汇编程序的标志</td>\n<td>无默认值</td>\n</tr>\n<tr>\n<td>CFLAGS</td>\n<td>传给c编译程序的标志</td>\n<td>无默认值</td>\n</tr>\n<tr>\n<td>CPPFLAGS</td>\n<td>传给c预处理程序的标志</td>\n<td>无默认值</td>\n</tr>\n<tr>\n<td>CXXFLAGS</td>\n<td>传给c++编译器的标志</td>\n<td>无默认值</td>\n</tr>\n<tr>\n<td>LDFLAGS</td>\n<td>传给链接程序（ld）的标志</td>\n<td>无默认值</td>\n</tr>\n</tbody></table>\n<p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为5）。</p>\n<p>如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：<br>    %.o : %.c </p>\n<p>markdown中的函数</p>\n<p>BIN_SRCS :&#x3D; $(wildcard bin&#x2F;*.cc)<br>获取匹配模式的文件名 wildcard<br>src &#x3D; $(wildcard *.c)<br>wildcard把 指定目录 .&#x2F; 和 .&#x2F;sub&#x2F; 下的所有后缀是c的文件全部展开。</p>\n<p>模式替换函数 patsubst</p>\n<p>循环函数 foreach</p>\n<p>g++ -Wall -std&#x3D;c++11 -pthread -O2 -g -iquote include&#x2F; -I..&#x2F; -I&#x2F;usr&#x2F;local&#x2F;include  -L lib&#x2F; -L&#x2F;usr&#x2F;local&#x2F;lib -ltpc  bin&#x2F;echo_client.cc lib&#x2F;libtpc.a   -o bin&#x2F;echo_client</p>\n<h1 id=\"输出信息\"><a href=\"#输出信息\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h1><p>$(info “info here”)<br>$(info “$(CFLAGS)”)</p>\n<h1 id=\"输出变量\"><a href=\"#输出变量\" class=\"headerlink\" title=\"输出变量\"></a>输出变量</h1><p>$(warning “CFLAGS &#x3D; $(CFLAGS)”)，</p>\n<h1 id=\"生成静态库文件\"><a href=\"#生成静态库文件\" class=\"headerlink\" title=\"生成静态库文件\"></a>生成静态库文件</h1><p>g++ test -c<br>g++ test -o<br>ar -rcs libtest.a</p>\n<h1 id=\"常见编译选项\"><a href=\"#常见编译选项\" class=\"headerlink\" title=\"常见编译选项\"></a>常见编译选项</h1><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BIN_SRCS := <span class=\"variable\">$(<span class=\"built_in\">wildcard</span> bin/*.cc)</span>  <span class=\"comment\"># 选择所有文件</span></span><br><span class=\"line\">BIN_SRCS := <span class=\"variable\">$(<span class=\"built_in\">filter</span>-out bin/test.cc, <span class=\"variable\">$(BIN_SRCS)</span>)</span> <span class=\"comment\"># 单独去掉bin/test.cc</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://blog.csdn.net/yi412/article/details/69941791\">https://blog.csdn.net/yi412/article/details/69941791</a><br><a href=\"https://blog.csdn.net/marc07/article/details/62885868\">https://blog.csdn.net/marc07/article/details/62885868</a></p>\n","slug":"Tutorial/linux-dev-env/makefile-tutorial","updated":"02/11/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/05/Tutorial/linux-dev-env/makefile-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"VSCode 教程","date":"05/04/2022","path":"2022/04/05/Tutorial/VSCode_tutorial/","text":"代码里的左侧颜色标识:红色，未加入版本控制; (刚clone到本地)绿色，已经加入版本控制暂未提交; (新增部分)蓝色，加入版本控制，已提交，有改动； (修改部分)白色，加入版本控制，已提交，无改动；灰色：版本控制已忽略文件。 git文件标识:M: 文件的内容被修改了U: 文件没有被合并(你需要完成合并才能进行提交)D: 删除的一个文件 A: 增加的文件.C: 文件的一个新拷贝.R: 文件名被修改了。T: 文件的类型被修改了。X: 未知状态 使用VSCode远程调试linux 准备工作1234apt-get updateapt-get install sudoapt-get install vimpasswd # 修改密码 安装opensshapt-get install openssh-serverapt-get install openssh-client 修改ssh配置文件sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_configPermitRootLogin yes（默认为#PermitRootLogin prohibit-password）前面的#号要放开 启动服务&#x2F;etc&#x2F;init.d&#x2F;ssh restart 连接测试ssh user@[ip] -p [端口]ssh &#117;&#115;&#x65;&#x72;&#x40;&#x31;&#57;&#50;&#46;&#49;&#x36;&#56;&#x2e;&#48;&#46;&#51; -p 22 vscode配置123Host 192.168.0.3 HostName 192.168.0.3 User username 使用VSCode远程调试linux中的容器 需要把容器的端口映射出来 容器内的ssh修改需要把root登录打开sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_configPermitRootLogin yes重启，连接测试，可以连接 12345Host 15.1.0.89 # 显示的名字 HostName 15.1.0.89 User root Port 38529 # 使用的端口号 IdentityFile ~\\.ssh\\id_rsa 快捷键 快捷键 功能 ctl + k + 0 快速收缩全部代码 ctl + k + j 展开全部代码 ctl + shift + [ 收缩当前代码 ctl + shift + ] 展开当前代码 alt + left 向后 alt + left 向前 ctl + g 跳到指定行 ctl + b 关闭左侧栏 ctl + j 关闭下面栏 ctl + K + T 换主题颜色 一些设置C++不报错C_Cpp.errorSquiggles code runner在命令行中运行，可以接受输入Code-runner: Run In Terminal 前端使用的插件快捷键开头按输入!,自动填充基础内容 Live Server保存以后会自动更新alt+KO可以打开新页面 代码滚动时候进行附着sticky scroll打开以后会把函数名进行附着 参考文献[在VScode中，代码提示左边的图标各自代表的含义]https://blog.csdn.net/qq_42838904/article/details/108222619[Sticky Scroll in vscode]https://dev.to/this-is-learning/sticky-scroll-in-vscode-44h2","raw":"---\ntitle: VSCode 教程\ndate: 2022-04-05 20:33:12\ntags:\n- 教程\n---\n# 代码里的左侧颜色标识:\n\n红色，未加入版本控制; (刚clone到本地)\n绿色，已经加入版本控制暂未提交; (新增部分)\n蓝色，加入版本控制，已提交，有改动； (修改部分)\n白色，加入版本控制，已提交，无改动；\n灰色：版本控制已忽略文件。\n\ngit文件标识:\nM: 文件的内容被修改了\nU: 文件没有被合并(你需要完成合并才能进行提交)\nD: 删除的一个文件\n\nA: 增加的文件.\nC: 文件的一个新拷贝.\nR: 文件名被修改了。\nT: 文件的类型被修改了。\nX: 未知状态\n\n# 使用VSCode远程调试linux\n\n1. 准备工作\n```\napt-get update\napt-get install sudo\napt-get install vim\npasswd # 修改密码\n```\n2. 安装openssh\napt-get install openssh-server\napt-get install openssh-client\n3. 修改ssh配置文件 \nsudo vi /etc/ssh/sshd_config\nPermitRootLogin yes \n（默认为#PermitRootLogin prohibit-password）前面的#号要放开\n4. 启动服务\n/etc/init.d/ssh restart\n5. 连接测试\nssh user@[ip] -p [端口]\nssh user@192.168.0.3 -p 22\n6. vscode配置\n```\nHost 192.168.0.3\n  HostName 192.168.0.3\n  User username\n```\n\n\n# 使用VSCode远程调试linux中的容器\n\n1. 需要把容器的端口映射出来\n\n容器内的ssh修改需要把root登录打开\nsudo vi /etc/ssh/sshd_config\nPermitRootLogin yes \n重启，连接测试，可以连接\n\n```\nHost 15.1.0.89      # 显示的名字\n  HostName 15.1.0.89\n  User root\n  Port 38529        # 使用的端口号\n  IdentityFile ~\\.ssh\\id_rsa\n```\n\n# 快捷键\n\n| 快捷键 | 功能 | \n| :----: | :----: | \n| ctl + k + 0 | 快速收缩全部代码 | \n| ctl + k + j | 展开全部代码 | \n| ctl + shift + [ | 收缩当前代码 | \n| ctl + shift + ] | 展开当前代码 | \n| alt + left | 向后 | \n| alt + left | 向前 | \n| ctl + g | 跳到指定行 | \n| ctl + b | 关闭左侧栏 | \n| ctl + j | 关闭下面栏 | \n| ctl + K + T | 换主题颜色 | \n\n# 一些设置\nC++不报错\nC_Cpp.errorSquiggles\n\n\ncode runner在命令行中运行，可以接受输入\nCode-runner: Run In Terminal\n# 前端使用的插件\n\n快捷键\n开头按输入!,自动填充基础内容\n\n\n# Live Server\n保存以后会自动更新\nalt+KO可以打开新页面\n# 代码滚动时候进行附着\nsticky scroll\n打开以后会把函数名进行附着\n\n# 参考文献\n\n\n[在VScode中，代码提示左边的图标各自代表的含义]https://blog.csdn.net/qq_42838904/article/details/108222619\n[Sticky Scroll in vscode]https://dev.to/this-is-learning/sticky-scroll-in-vscode-44h2","content":"<h1 id=\"代码里的左侧颜色标识\"><a href=\"#代码里的左侧颜色标识\" class=\"headerlink\" title=\"代码里的左侧颜色标识:\"></a>代码里的左侧颜色标识:</h1><p>红色，未加入版本控制; (刚clone到本地)<br>绿色，已经加入版本控制暂未提交; (新增部分)<br>蓝色，加入版本控制，已提交，有改动； (修改部分)<br>白色，加入版本控制，已提交，无改动；<br>灰色：版本控制已忽略文件。</p>\n<p>git文件标识:<br>M: 文件的内容被修改了<br>U: 文件没有被合并(你需要完成合并才能进行提交)<br>D: 删除的一个文件</p>\n<p>A: 增加的文件.<br>C: 文件的一个新拷贝.<br>R: 文件名被修改了。<br>T: 文件的类型被修改了。<br>X: 未知状态</p>\n<h1 id=\"使用VSCode远程调试linux\"><a href=\"#使用VSCode远程调试linux\" class=\"headerlink\" title=\"使用VSCode远程调试linux\"></a>使用VSCode远程调试linux</h1><ol>\n<li>准备工作<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-<span class=\"built_in\">get</span> update</span><br><span class=\"line\">apt-<span class=\"built_in\">get</span> install sudo</span><br><span class=\"line\">apt-<span class=\"built_in\">get</span> install vim</span><br><span class=\"line\">passwd # 修改密码</span><br></pre></td></tr></table></figure></li>\n<li>安装openssh<br>apt-get install openssh-server<br>apt-get install openssh-client</li>\n<li>修改ssh配置文件<br>sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>PermitRootLogin yes<br>（默认为#PermitRootLogin prohibit-password）前面的#号要放开</li>\n<li>启动服务<br>&#x2F;etc&#x2F;init.d&#x2F;ssh restart</li>\n<li>连接测试<br>ssh user@[ip] -p [端口]<br>ssh <a href=\"mailto:&#117;&#115;&#x65;&#x72;&#x40;&#x31;&#57;&#50;&#46;&#49;&#x36;&#56;&#x2e;&#48;&#46;&#51;\">&#117;&#115;&#x65;&#x72;&#x40;&#x31;&#57;&#50;&#46;&#49;&#x36;&#56;&#x2e;&#48;&#46;&#51;</a> -p 22</li>\n<li>vscode配置<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host <span class=\"number\">192.168</span>.<span class=\"number\">0.3</span></span><br><span class=\"line\">  HostName <span class=\"number\">192.168</span>.<span class=\"number\">0.3</span></span><br><span class=\"line\">  <span class=\"keyword\">User</span> <span class=\"title\">username</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"使用VSCode远程调试linux中的容器\"><a href=\"#使用VSCode远程调试linux中的容器\" class=\"headerlink\" title=\"使用VSCode远程调试linux中的容器\"></a>使用VSCode远程调试linux中的容器</h1><ol>\n<li>需要把容器的端口映射出来</li>\n</ol>\n<p>容器内的ssh修改需要把root登录打开<br>sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>PermitRootLogin yes<br>重启，连接测试，可以连接</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host <span class=\"number\">15.1</span>.<span class=\"number\">0.89</span>      <span class=\"comment\"># 显示的名字</span></span><br><span class=\"line\">  HostName <span class=\"number\">15.1</span>.<span class=\"number\">0.89</span></span><br><span class=\"line\">  <span class=\"keyword\">User</span> <span class=\"title\">root</span></span><br><span class=\"line\">  Port <span class=\"number\">38529</span>        <span class=\"comment\"># 使用的端口号</span></span><br><span class=\"line\">  IdentityFile ~\\.ssh\\id_rsa</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h1><table>\n<thead>\n<tr>\n<th align=\"center\">快捷键</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ctl + k + 0</td>\n<td align=\"center\">快速收缩全部代码</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + k + j</td>\n<td align=\"center\">展开全部代码</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + shift + [</td>\n<td align=\"center\">收缩当前代码</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + shift + ]</td>\n<td align=\"center\">展开当前代码</td>\n</tr>\n<tr>\n<td align=\"center\">alt + left</td>\n<td align=\"center\">向后</td>\n</tr>\n<tr>\n<td align=\"center\">alt + left</td>\n<td align=\"center\">向前</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + g</td>\n<td align=\"center\">跳到指定行</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + b</td>\n<td align=\"center\">关闭左侧栏</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + j</td>\n<td align=\"center\">关闭下面栏</td>\n</tr>\n<tr>\n<td align=\"center\">ctl + K + T</td>\n<td align=\"center\">换主题颜色</td>\n</tr>\n</tbody></table>\n<h1 id=\"一些设置\"><a href=\"#一些设置\" class=\"headerlink\" title=\"一些设置\"></a>一些设置</h1><p>C++不报错<br>C_Cpp.errorSquiggles</p>\n<p>code runner在命令行中运行，可以接受输入<br>Code-runner: Run In Terminal</p>\n<h1 id=\"前端使用的插件\"><a href=\"#前端使用的插件\" class=\"headerlink\" title=\"前端使用的插件\"></a>前端使用的插件</h1><p>快捷键<br>开头按输入!,自动填充基础内容</p>\n<h1 id=\"Live-Server\"><a href=\"#Live-Server\" class=\"headerlink\" title=\"Live Server\"></a>Live Server</h1><p>保存以后会自动更新<br>alt+KO可以打开新页面</p>\n<h1 id=\"代码滚动时候进行附着\"><a href=\"#代码滚动时候进行附着\" class=\"headerlink\" title=\"代码滚动时候进行附着\"></a>代码滚动时候进行附着</h1><p>sticky scroll<br>打开以后会把函数名进行附着</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[在VScode中，代码提示左边的图标各自代表的含义]<a href=\"https://blog.csdn.net/qq_42838904/article/details/108222619\">https://blog.csdn.net/qq_42838904/article/details/108222619</a><br>[Sticky Scroll in vscode]<a href=\"https://dev.to/this-is-learning/sticky-scroll-in-vscode-44h2\">https://dev.to/this-is-learning/sticky-scroll-in-vscode-44h2</a></p>\n","slug":"Tutorial/VSCode_tutorial","updated":"02/01/2023","comments":true,"link":"","permalink":"http://example.com/2022/04/05/Tutorial/VSCode_tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"day07-项目","date":"03/04/2022","path":"2022/04/03/Linux-Network-Programming/Heima-Network-Programming/day07-Project/","text":"学习目标:1介绍一下项目的整体功能2介绍html语法3介绍http协议–请求协议和响应协议4介绍开发web服务器的整体流程5根据开发流程编写初级版本的web服务器 通过案例演示联想到的知识点:1开发网络服务器:多路IO复用技术:epoll select poll多进程或者多线程第三方库:libevent库2熟悉http协议请求协议应答协议3使用的协议有http协议+TCP协议TCP协议:建立连接的三次握手，连接建立完成后接着是数据传输web服务器:首先解析浏览器发来的请求数据，得到请求的文件名; 若文件存在 判断文件类型:若是普通文件，则发送文件内容给浏览器; 若是目录文件，则发送文件列表|若文件不存在，则发送一个错误页给浏览器;","raw":"---\ntitle: day07-项目\ndate: 2022-04-03 15:51:39\ntags:\n- Linux网络编程\n---\n\n学习目标:\n1介绍一下项目的整体功能\n2介绍html语法\n3介绍http协议--请求协议和响应协议\n4介绍开发web服务器的整体流程\n5根据开发流程编写初级版本的web服务器\n\n\n通过案例演示联想到的知识点:\n1开发网络服务器:\n多路IO复用技术:epoll select poll\n多进程或者多线程\n第三方库:libevent库\n2熟悉http协议\n请求协议\n应答协议\n3使用的协议有http协议+TCP协议\nTCP协议:建立连接的三次握手，连接建立完成后接着是数据传输\nweb服务器:首先解析浏览器发来的请求数据，得到请求的文件名;\n\n若文件存在\n    判断文件类型:若是普通文件，则发送文件内容给浏览器;\n                若是目录文件，则发送文件列表|\n若文件不存在，则发送一个错误页给浏览器;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>学习目标:<br>1介绍一下项目的整体功能<br>2介绍html语法<br>3介绍http协议–请求协议和响应协议<br>4介绍开发web服务器的整体流程<br>5根据开发流程编写初级版本的web服务器</p>\n<p>通过案例演示联想到的知识点:<br>1开发网络服务器:<br>多路IO复用技术:epoll select poll<br>多进程或者多线程<br>第三方库:libevent库<br>2熟悉http协议<br>请求协议<br>应答协议<br>3使用的协议有http协议+TCP协议<br>TCP协议:建立连接的三次握手，连接建立完成后接着是数据传输<br>web服务器:首先解析浏览器发来的请求数据，得到请求的文件名;</p>\n<p>若文件存在<br>    判断文件类型:若是普通文件，则发送文件内容给浏览器;<br>                若是目录文件，则发送文件列表|<br>若文件不存在，则发送一个错误页给浏览器;</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day07-Project","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/03/Linux-Network-Programming/Heima-Network-Programming/day07-Project/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day06-libevent","date":"03/04/2022","path":"2022/04/03/Linux-Network-Programming/Heima-Network-Programming/day06-libevent/","text":"描述什么是 libevent并掌握如何安装掌握event_base的作用和使用方法熟练掌握libevent库中的事件循环掌握event事件的使用方法掌握bufferevent的工作方式掌握使用libevent实现tcp服务器端流程掌握使用Libevent实现tcp客户端流程 libevent介绍1事件驱动，高性能，轻量级，专注于网络，只能用于网络服务端开发2源代码精炼，易读3跨平台4支持多种I&#x2F;o多路复用技术，如epoll select poll等5支持I&#x2F;O和信号等事件 登录官方网站: http://libevent.org，查看相关信息libevent源码下载主要分2个大版本: 1.4.x系列较为早期版本，适合源码学习 2.x系列，较新的版本，代码量比1.4 版本多很多，功能也更完善。 libevent的核心实现:在linux上，其实质就是epoll.反应堆.libevent,是事件驱动, epoll反应堆也是事件驱动，当要监测的事件发生的时候，就会调用事件对应的回调函数，执行相应操作．特别提醒:事件回调函数是由用户开发的，但是不是由用户显示去调用的，而是由libevent,去调用的.回调函数是自己写的","raw":"---\ntitle: day06-libevent\ndate: 2022-04-03 15:20:48\ntags:\n- Linux网络编程\n---\n\n\n\n\n\n\n\n\n\n\n\n\n描述什么是 libevent并掌握如何安装\n掌握event_base的作用和使用方法\n熟练掌握libevent库中的事件循环\n掌握event事件的使用方法\n掌握bufferevent的工作方式\n掌握使用libevent实现tcp服务器端流程\n掌握使用Libevent实现tcp客户端流程\n\n\n\n\nlibevent介绍\n1事件驱动，高性能，轻量级，专注于网络，只能用于网络服务端开发\n2源代码精炼，易读\n3跨平台\n4支持多种I/o多路复用技术，如epoll select poll等\n5支持I/O和信号等事件\n\n\n登录官方网站: http://libevent.org，查看相关信息\nlibevent源码下载主要分2个大版本:\n1. 1.4.x系列较为早期版本，适合源码学习\n2. 2.x系列，较新的版本，代码量比1.4 版本多很多，功能也更完善。\n\nlibevent的核心实现:\n在linux上，其实质就是epoll.反应堆.\nlibevent,是事件驱动, epoll反应堆也是事件驱动，当要监测的事件发生的时候，就会调用事件对应的回调函数，执行相应操作．特别提醒:事件回调函数是由用户开发的，但是不是由用户显示去调用的，而是由libevent,去调用的.\n回调函数是自己写的\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>描述什么是 libevent并掌握如何安装<br>掌握event_base的作用和使用方法<br>熟练掌握libevent库中的事件循环<br>掌握event事件的使用方法<br>掌握bufferevent的工作方式<br>掌握使用libevent实现tcp服务器端流程<br>掌握使用Libevent实现tcp客户端流程</p>\n<p>libevent介绍<br>1事件驱动，高性能，轻量级，专注于网络，只能用于网络服务端开发<br>2源代码精炼，易读<br>3跨平台<br>4支持多种I&#x2F;o多路复用技术，如epoll select poll等<br>5支持I&#x2F;O和信号等事件</p>\n<p>登录官方网站: <a href=\"http://libevent.org,查看相关信息/\">http://libevent.org，查看相关信息</a><br>libevent源码下载主要分2个大版本:</p>\n<ol>\n<li>1.4.x系列较为早期版本，适合源码学习</li>\n<li>2.x系列，较新的版本，代码量比1.4 版本多很多，功能也更完善。</li>\n</ol>\n<p>libevent的核心实现:<br>在linux上，其实质就是epoll.反应堆.<br>libevent,是事件驱动, epoll反应堆也是事件驱动，当要监测的事件发生的时候，就会调用事件对应的回调函数，执行相应操作．特别提醒:事件回调函数是由用户开发的，但是不是由用户显示去调用的，而是由libevent,去调用的.<br>回调函数是自己写的</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day06-libevent","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/03/Linux-Network-Programming/Heima-Network-Programming/day06-libevent/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day04-epoll函数","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day04-epoll/","text":"1了解poll函数2熟练使用epoll多路IO模型3了解epoll ET&#x2F;LT触发模式并实现4理解epoll,边缘非阻塞模式并实现5了解epoll反应堆模型设计思想6能看懂epoll反应堆模型的实现代码 pollpoll是介于select与epoll之间的模型，实际开发的过程中用的比较少和select相比没有本质的改变 linux下epollUNIX只能用select int poll(struct pollfd *fds, nfds_t nfds, int timeout);函数说明:跟select类似，委托内核监控可读，可写，异常事件函数参数: 1234567891011121314151617181920fds:一个struct pollfd结构体数组的首地址struct pollfd &#123; int fd; //要监控的文件描述符，如果fd为-1表示内核不再监控 short events; //输入参数，表示告诉内核要监控的事件，读事件，写事件,异常事件 short revents; ;//输出参数，表示内核告诉应用程序有哪些文件描述符有事件发生&#125;;events/revents: POLLIN:可读事件 POLLOUT:可写事件 POLLERR:异常事件nfds:告诉内核监控的范围，具体是:数组下标的最大值+1timedout: =0:不阻塞，立刻返回 -1:表示一直阻塞,直到有事件发生 &gt;0:表示阻塞时长，在时长范围内若有事件发生会立刻返回; 如果超过了时长也会立刻返回函数返回值: &gt;0:发生变化的文件描述符的个数 =0:没有文件描述符发生变化 -1:表示异常 说明:1 当poll函数返回的时候，结构体当中的fd,和events没有发生变化，究竞有没有事件发生由revents.来判断，所以poll是请求和返回分离.2 struct pollfd结构体中的fd成员若赋值为-1，则poll不会监控.3相对于select, poll没有本质上的改变;但是poll可以突破1024的限制.在&#x2F;proc&#x2F;svs&#x2F;fs&#x2F;file-max查看一个进程可以打开的socket描述符上限.如果需要可以修改配置文件:&#x2F;etc&#x2F;security&#x2F;limits.confs加入如下配置信息，然后重启终端即可生效. soft nofile 1024 hard nofile 10000osoft和 hard分别表示ulimit命令可以修改的最小限制和最大限制 多路I0-epoll将检测文件描述符的变化委托给内核去处理，然后内核将发生变化的文件描述符对应的事件返回给应用程序。linux下编程，肯定用这个了告诉有几个发生了变化，精准的告诉哪个有变化epoll底层实现用的红黑二叉树，也就是平衡二叉树 epoll_create()int epoll_create(int size); 函数说明:创建一棵epoll树,返回一个树根节点 函数参数:size:必须传一个大于0的数 返回值:返回个文件描述符,这个文件描述符就表示epoll树的树根节点. epoll_ctl()int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 函数说明:将fd上epoll树,从树上删除和修改 函数参数:epfd: epoll树的树根节点op: EPOLL_CTL_ADD:上树操作 EPOLL_CTL_MOD:修改 EPOLL_CTL_DEL:从树上删除节点 fd:要操作的文件描述符event: Event.exents: EPOLLIN:可读事件 EPOLLOUT:可写事件 EPOLLERR:异常事件 1234567891011typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;; 1234Struct epoll_exent ev;ex.events = EPOLLIN;ex.data.fd = fd;epoll_ctl(epfd, EPOLL_CTL_ADD, fd,&amp;ey); epoll_waitint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);有返回了，就说明一定有事件发生了 函数说明委托内核监控epoll树的事件节点 函数参数epfd: epoll树根节点events:传出参数,结构体数组maxevents: events数组大小timeout:-1:表示阻塞0:表示不阻塞 0:表示阻塞超时时长 函数返回值：只有在下面的情况下才会返回： 有至少一个事件发生 调用过程中被信号中断 超时。成功时，返回请求的I&#x2F;O准备就绪的文件描述符的数目发生错误时，返回-1并正确设置errno epoll_wait返回的数组中的事件节点的值不会修改,是当时上epoll树的时候设置的值. 进阶epollepoll有两种工作模式ET和LT 水平触发：高电平代表1 只要缓冲区中有数据，就一直通知 缓冲区是内核的读缓冲区边缘触发：电平有变化就代表1 缓冲区中有数据只会通知一次，之后再有数据才会通知 若是读数据的时候没有读完，则剩余的数据不会再通知，直到有新的数据到来边缘非阻塞模式:提高效率 LT模式（水平触发）ET模式（边沿触发） epoll的LT和ET模式: epoll默认情况下是LT模式，在这种模式下，若读数据一次性没有读完，缓冲区中还有可读数据，则epoll_wait还会再次通知 若将epoll设置为ET模式，若读数据的时候一次性没有读完，则epoll_wait不再通知，直到下次有新的数据发来 思考:1在ET模式下，如何在epoll_wait返回一次的情况下读完数据循环读数据,直到读完数据,但是读完数据之后会阻塞.2若能够一次性读完还需要设置什么?将通信文件描述符设置为非阻塞模式 epoll反应堆typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64;} epoll_data_t; struct epoll_event { uint32_t events; &#x2F;* Epoll events &#x2F; epoll_data_t data; &#x2F; User data variable *&#x2F;};触发了一个事件，产生了一连串的反应epoll反应堆实际上是应用了c++的封装思想,—个事件的产生会触发一系列连锁反应,事件产生之后最终调用的是回调函数.将数据和操作数据的方法封装到了一个类里面","raw":"---\ntitle: day04-epoll函数\ndate: 2022-04-02 19:39:01\ntags:\n- Linux网络编程\n---\n\n\n1了解poll函数\n2熟练使用epoll多路IO模型\n3了解epoll ET/LT触发模式并实现\n4理解epoll,边缘非阻塞模式并实现\n5了解epoll反应堆模型设计思想\n6能看懂epoll反应堆模型的实现代码\n\n\n# poll\npoll是介于select与epoll之间的模型，实际开发的过程中用的比较少\n和select相比没有本质的改变\n\nlinux下epoll\nUNIX只能用select\n\n\n int poll(struct pollfd *fds, nfds_t nfds, int timeout);\n函数说明:跟select类似，委托内核监控可读，可写，异常事件函数\n参数:\n```\n    fds:一个struct pollfd结构体数组的首地址\n    struct pollfd {\n        int   fd;         //要监控的文件描述符，如果fd为-1表示内核不再监控\n        short events;     //输入参数，表示告诉内核要监控的事件，读事件，写事件,异常事件\n        short revents;    ;//输出参数，表示内核告诉应用程序有哪些文件描述符有事件发生\n    };\n    events/revents:\n        POLLIN:可读事件\n        POLLOUT:可写事件\n        POLLERR:异常事件\n    nfds:告诉内核监控的范围，具体是:数组下标的最大值+1\n    timedout:\n        =0:不阻塞，立刻返回\n        -1:表示一直阻塞,直到有事件发生\n        >0:表示阻塞时长，在时长范围内若有事件发生会立刻返回;\n        如果超过了时长也会立刻返回\n    函数返回值:\n        >0:发生变化的文件描述符的个数\n        =0:没有文件描述符发生变化\n        -1:表示异常\n```\n说明:\n1 当poll函数返回的时候，结构体当中的fd,和events没有发生变化，究竞有没有事件发生由revents.来判断，所以poll是请求和返回分离.\n2 struct pollfd结构体中的fd成员若赋值为-1，则poll不会监控.\n3相对于select, poll没有本质上的改变;但是poll可以突破1024的限制.\n在/proc/svs/fs/file-max查看一个进程可以打开的socket描述符上限.\n如果需要可以修改配置文件:/etc/security/limits.conf\ns\n加入如下配置信息，然后重启终端即可生效.\n* soft nofile 1024\n* hard nofile 10000o\nsoft和 hard分别表示ulimit命令可以修改的最小限制和最大限制\n\n\n\n# 多路I0-epoll\n\n将检测文件描述符的变化委托给内核去处理，然后内核将发生变化的文件描述符对应的事件返回给应用程序。\nlinux下编程，肯定用这个了\n告诉有几个发生了变化，精准的告诉哪个有变化\nepoll底层实现用的红黑二叉树，也就是平衡二叉树\n\n## epoll_create()\nint epoll_create(int size);\n### 函数说明:\n创建一棵epoll树,返回一个树根节点\n### 函数参数:\nsize:必须传一个大于0的数\n### 返回值:\n返回个文件描述符,这个文件描述符就表示epoll树的树根节点.\n\n\n## epoll_ctl()\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n### 函数说明:\n将fd上epoll树,从树上删除和修改\n### 函数参数:\nepfd: epoll树的树根节点\nop:\n    EPOLL_CTL_ADD:上树操作\n    EPOLL_CTL_MOD:修改\n    EPOLL_CTL_DEL:从树上删除节点\n    fd:要操作的文件描述符\nevent:\n    Event.exents:\n    EPOLLIN:可读事件\n    EPOLLOUT:可写事件\n    EPOLLERR:异常事件\n```C++\ntypedef union epoll_data {\n    void        *ptr;\n    int          fd;\n    uint32_t     u32;\n    uint64_t     u64;\n} epoll_data_t;\n\nstruct epoll_event {\n    uint32_t     events;      /* Epoll events */\n    epoll_data_t data;        /* User data variable */\n};\n```\n```C++\nStruct epoll_exent ev;\nex.events = EPOLLIN;\nex.data.fd = fd;\nepoll_ctl(epfd, EPOLL_CTL_ADD, fd,&ey);\n```\n\n\n## epoll_wait\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n有返回了，就说明一定有事件发生了\n\n### 函数说明\n委托内核监控epoll树的事件节点\n### 函数参数\nepfd: epoll树根节点\nevents:传出参数,结构体数组\nmaxevents: events数组大小\ntimeout:\n-1:表示阻塞\n0:表示不阻塞\n>0:表示阻塞超时时长\n### 函数返回值：\n只有在下面的情况下才会返回：\n1. 有至少一个事件发生\n2. 调用过程中被信号中断\n3. 超时。\n成功时，返回请求的I/O准备就绪的文件描述符的数目\n发生错误时，返回-1并正确设置errno\n\n\nepoll_wait返回的数组中的事件节点的值不会修改,是当时上epoll树的时候设置的值.\n\n\n\n\n# 进阶epoll\nepoll有两种工作模式ET和LT\n\n水平触发：高电平代表1\n- 只要缓冲区中有数据，就一直通知\n- 缓冲区是内核的读缓冲区\n边缘触发：电平有变化就代表1\n- 缓冲区中有数据只会通知一次，之后再有数据才会通知\n- 若是读数据的时候没有读完，则剩余的数据不会再通知，直到有新的数据到来\n边缘非阻塞模式:提高效率\n\n\nLT模式（水平触发）\nET模式（边沿触发）\n\nepoll的LT和ET模式:\n1. epoll默认情况下是LT模式，在这种模式下，若读数据一次性没有读完，缓冲区中还有可读数据，则epoll_wait还会再次通知\n2. 若将epoll设置为ET模式，若读数据的时候一次性没有读完，则epoll_wait不再通知，直到下次有新的数据发来\n\n思考:\n1在ET模式下，如何在epoll_wait返回一次的情况下读完数据\n循环读数据,直到读完数据,但是读完数据之后会阻塞.\n2若能够一次性读完还需要设置什么?\n将通信文件描述符设置为非阻塞模式\n\n\n# epoll反应堆\n\ntypedef union epoll_data {\n    void        *ptr;\n    int          fd;\n    uint32_t     u32;\n    uint64_t     u64;\n} epoll_data_t;\n\nstruct epoll_event {\n    uint32_t     events;      /* Epoll events */\n    epoll_data_t data;        /* User data variable */\n};\n触发了一个事件，产生了一连串的反应\nepoll反应堆实际上是应用了c++的封装思想,—个事件的产生会触发一系列连锁反应,事件产生之后最终调用的是回调函数.\n将数据和操作数据的方法封装到了一个类里面\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>1了解poll函数<br>2熟练使用epoll多路IO模型<br>3了解epoll ET&#x2F;LT触发模式并实现<br>4理解epoll,边缘非阻塞模式并实现<br>5了解epoll反应堆模型设计思想<br>6能看懂epoll反应堆模型的实现代码</p>\n<h1 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h1><p>poll是介于select与epoll之间的模型，实际开发的过程中用的比较少<br>和select相比没有本质的改变</p>\n<p>linux下epoll<br>UNIX只能用select</p>\n<p> int poll(struct pollfd *fds, nfds_t nfds, int timeout);<br>函数说明:跟select类似，委托内核监控可读，可写，异常事件函数<br>参数:</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">fds:</span>一个struct pollfd结构体数组的首地址</span><br><span class=\"line\">struct <span class=\"title class_\">pollfd</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    int   <span class=\"attr\">fd</span><span class=\"punctuation\">;</span>         <span class=\"comment\">//要监控的文件描述符，如果fd为-1表示内核不再监控</span></span><br><span class=\"line\">    short <span class=\"attr\">events</span><span class=\"punctuation\">;</span>     <span class=\"comment\">//输入参数，表示告诉内核要监控的事件，读事件，写事件,异常事件</span></span><br><span class=\"line\">    short <span class=\"attr\">revents</span><span class=\"punctuation\">;</span>    <span class=\"punctuation\">;</span><span class=\"comment\">//输出参数，表示内核告诉应用程序有哪些文件描述符有事件发生</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;;</span></span><br><span class=\"line\">events/revents:</span><br><span class=\"line\"><span class=\"symbol\">    POLLIN:</span>可读事件</span><br><span class=\"line\"><span class=\"symbol\">    POLLOUT:</span>可写事件</span><br><span class=\"line\"><span class=\"symbol\">    POLLERR:</span>异常事件</span><br><span class=\"line\"><span class=\"symbol\">nfds:</span>告诉内核监控的范围，具体是:数组下标的最大值+<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"symbol\">timedout:</span></span><br><span class=\"line\">    =<span class=\"number\">0</span>:不阻塞，立刻返回</span><br><span class=\"line\">    <span class=\"number\">-1</span>:表示一直阻塞,直到有事件发生</span><br><span class=\"line\">    &gt;<span class=\"number\">0</span>:表示阻塞时长，在时长范围内若有事件发生会立刻返回<span class=\"punctuation\">;</span></span><br><span class=\"line\">    如果超过了时长也会立刻返回</span><br><span class=\"line\">函数返回值:</span><br><span class=\"line\">    &gt;<span class=\"number\">0</span>:发生变化的文件描述符的个数</span><br><span class=\"line\">    =<span class=\"number\">0</span>:没有文件描述符发生变化</span><br><span class=\"line\">    <span class=\"number\">-1</span>:表示异常</span><br></pre></td></tr></table></figure>\n<p>说明:<br>1 当poll函数返回的时候，结构体当中的fd,和events没有发生变化，究竞有没有事件发生由revents.来判断，所以poll是请求和返回分离.<br>2 struct pollfd结构体中的fd成员若赋值为-1，则poll不会监控.<br>3相对于select, poll没有本质上的改变;但是poll可以突破1024的限制.<br>在&#x2F;proc&#x2F;svs&#x2F;fs&#x2F;file-max查看一个进程可以打开的socket描述符上限.<br>如果需要可以修改配置文件:&#x2F;etc&#x2F;security&#x2F;limits.conf<br>s<br>加入如下配置信息，然后重启终端即可生效.</p>\n<ul>\n<li>soft nofile 1024</li>\n<li>hard nofile 10000o<br>soft和 hard分别表示ulimit命令可以修改的最小限制和最大限制</li>\n</ul>\n<h1 id=\"多路I0-epoll\"><a href=\"#多路I0-epoll\" class=\"headerlink\" title=\"多路I0-epoll\"></a>多路I0-epoll</h1><p>将检测文件描述符的变化委托给内核去处理，然后内核将发生变化的文件描述符对应的事件返回给应用程序。<br>linux下编程，肯定用这个了<br>告诉有几个发生了变化，精准的告诉哪个有变化<br>epoll底层实现用的红黑二叉树，也就是平衡二叉树</p>\n<h2 id=\"epoll-create\"><a href=\"#epoll-create\" class=\"headerlink\" title=\"epoll_create()\"></a>epoll_create()</h2><p>int epoll_create(int size);</p>\n<h3 id=\"函数说明\"><a href=\"#函数说明\" class=\"headerlink\" title=\"函数说明:\"></a>函数说明:</h3><p>创建一棵epoll树,返回一个树根节点</p>\n<h3 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数:\"></a>函数参数:</h3><p>size:必须传一个大于0的数</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值:\"></a>返回值:</h3><p>返回个文件描述符,这个文件描述符就表示epoll树的树根节点.</p>\n<h2 id=\"epoll-ctl\"><a href=\"#epoll-ctl\" class=\"headerlink\" title=\"epoll_ctl()\"></a>epoll_ctl()</h2><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>\n<h3 id=\"函数说明-1\"><a href=\"#函数说明-1\" class=\"headerlink\" title=\"函数说明:\"></a>函数说明:</h3><p>将fd上epoll树,从树上删除和修改</p>\n<h3 id=\"函数参数-1\"><a href=\"#函数参数-1\" class=\"headerlink\" title=\"函数参数:\"></a>函数参数:</h3><p>epfd: epoll树的树根节点<br>op:<br>    EPOLL_CTL_ADD:上树操作<br>    EPOLL_CTL_MOD:修改<br>    EPOLL_CTL_DEL:从树上删除节点<br>    fd:要操作的文件描述符<br>event:<br>    Event.exents:<br>    EPOLLIN:可读事件<br>    EPOLLOUT:可写事件<br>    EPOLLERR:异常事件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> <span class=\"title class_\">epoll_data</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">void</span>        *ptr;</span><br><span class=\"line\">    <span class=\"type\">int</span>          fd;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>     u32;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>     u64;</span><br><span class=\"line\">&#125; <span class=\"type\">epoll_data_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">epoll_event</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>     events;      <span class=\"comment\">/* Epoll events */</span></span><br><span class=\"line\">    <span class=\"type\">epoll_data_t</span> data;        <span class=\"comment\">/* User data variable */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Struct epoll_exent ev;</span><br><span class=\"line\">ex.events = EPOLLIN;</span><br><span class=\"line\">ex.data.fd = fd;</span><br><span class=\"line\"><span class=\"built_in\">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, fd,&amp;ey);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"epoll-wait\"><a href=\"#epoll-wait\" class=\"headerlink\" title=\"epoll_wait\"></a>epoll_wait</h2><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);<br>有返回了，就说明一定有事件发生了</p>\n<h3 id=\"函数说明-2\"><a href=\"#函数说明-2\" class=\"headerlink\" title=\"函数说明\"></a>函数说明</h3><p>委托内核监控epoll树的事件节点</p>\n<h3 id=\"函数参数-2\"><a href=\"#函数参数-2\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h3><p>epfd: epoll树根节点<br>events:传出参数,结构体数组<br>maxevents: events数组大小<br>timeout:<br>-1:表示阻塞<br>0:表示不阻塞</p>\n<blockquote>\n<p>0:表示阻塞超时时长</p>\n</blockquote>\n<h3 id=\"函数返回值：\"><a href=\"#函数返回值：\" class=\"headerlink\" title=\"函数返回值：\"></a>函数返回值：</h3><p>只有在下面的情况下才会返回：</p>\n<ol>\n<li>有至少一个事件发生</li>\n<li>调用过程中被信号中断</li>\n<li>超时。<br>成功时，返回请求的I&#x2F;O准备就绪的文件描述符的数目<br>发生错误时，返回-1并正确设置errno</li>\n</ol>\n<p>epoll_wait返回的数组中的事件节点的值不会修改,是当时上epoll树的时候设置的值.</p>\n<h1 id=\"进阶epoll\"><a href=\"#进阶epoll\" class=\"headerlink\" title=\"进阶epoll\"></a>进阶epoll</h1><p>epoll有两种工作模式ET和LT</p>\n<p>水平触发：高电平代表1</p>\n<ul>\n<li>只要缓冲区中有数据，就一直通知</li>\n<li>缓冲区是内核的读缓冲区<br>边缘触发：电平有变化就代表1</li>\n<li>缓冲区中有数据只会通知一次，之后再有数据才会通知</li>\n<li>若是读数据的时候没有读完，则剩余的数据不会再通知，直到有新的数据到来<br>边缘非阻塞模式:提高效率</li>\n</ul>\n<p>LT模式（水平触发）<br>ET模式（边沿触发）</p>\n<p>epoll的LT和ET模式:</p>\n<ol>\n<li>epoll默认情况下是LT模式，在这种模式下，若读数据一次性没有读完，缓冲区中还有可读数据，则epoll_wait还会再次通知</li>\n<li>若将epoll设置为ET模式，若读数据的时候一次性没有读完，则epoll_wait不再通知，直到下次有新的数据发来</li>\n</ol>\n<p>思考:<br>1在ET模式下，如何在epoll_wait返回一次的情况下读完数据<br>循环读数据,直到读完数据,但是读完数据之后会阻塞.<br>2若能够一次性读完还需要设置什么?<br>将通信文件描述符设置为非阻塞模式</p>\n<h1 id=\"epoll反应堆\"><a href=\"#epoll反应堆\" class=\"headerlink\" title=\"epoll反应堆\"></a>epoll反应堆</h1><p>typedef union epoll_data {<br>    void        *ptr;<br>    int          fd;<br>    uint32_t     u32;<br>    uint64_t     u64;<br>} epoll_data_t;</p>\n<p>struct epoll_event {<br>    uint32_t     events;      &#x2F;* Epoll events <em>&#x2F;<br>    epoll_data_t data;        &#x2F;</em> User data variable *&#x2F;<br>};<br>触发了一个事件，产生了一连串的反应<br>epoll反应堆实际上是应用了c++的封装思想,—个事件的产生会触发一系列连锁反应,事件产生之后最终调用的是回调函数.<br>将数据和操作数据的方法封装到了一个类里面</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day04-epoll","updated":"30/10/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day04-epoll/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day02-多进程多线程","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day02-multi-process-multi-thread/","text":"掌握三次握手建立连接过程掌握四次握手关闭连接的过程掌握滑动窗口的概念掌握错误处理函数封装实现多进程并发服务器实现多线程并发服务器 函数封装的思想-处理异常情况结合man-page和errno进行封装.在封装的时候起名可以把第一个函数名的字母大写，如 socket可以封装成Socket,这样可以按shif+K进行搜索, shift+k搜索函数说明的时候不区分大小写,使用man page也可以查看, man page对大小写不区分. 真正的程序，是看不到socket,bind,listen这种函数，一般都集成好了，一个函数能实现好几个功能 像accept,read这样的能够引起阻塞的函数，若被信号打断，由于信号的优先级较高，会优先处理信号，信号处理完成后，会使accept或者read 解除阻塞，然后返回,此时返回值为-1，设置 errno&#x3D;EINTR;errno&#x3D;ECONNABORTED表示连接被打断,异常. errno宏:在&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h 文件中包含了errno所有的宏和对应的错误描述信息. 通过man errno查看 高并发服务器如何支持多个客户端—支持多并发的服务器由于accept 和read函数都会阻塞，如当read的时候，不能调用accept接受新的连接，当accept阻塞等待的时候不能read读数据.第一种方案:使用多进程，可以让父进程接受新连接，让子进程处理与客户端通信思路:让父进程accept接受新连接，然后fork子进程，让子进程处理通信，子进程处理完成后退出，父进程使用SIGCHLD信号回收子进程. 代码实现:第二种方案:使用多线程，让主线程接受新连接，让子线程处理与客户端通信;使用多线程要将线程设置为分离属性，让线程在退出之后自己回收资源.","raw":"---\ntitle: day02-多进程多线程\ndate: 2022-04-02 17:05:42\ntags:\n- Linux网络编程\n---\n\n\n\n\n掌握三次握手建立连接过程\n掌握四次握手关闭连接的过程\n掌握滑动窗口的概念\n掌握错误处理函数封装\n实现多进程并发服务器\n实现多线程并发服务器\n\n\n\n函数封装的思想-处理异常情况\n结合man-page和errno进行封装.\n在封装的时候起名可以把第一个函数名的字母大写，如 socket可以封装成Socket,这样可以按shif+K进行搜索, shift+k搜索函数说明的时候不区分大小写,使用man page也可以查看, man page对大小写不区分.\n\n真正的程序，是看不到socket,bind,listen这种函数，一般都集成好了，一个函数能实现好几个功能\n\n\n像accept,read这样的能够引起阻塞的函数，若被信号打断，由于信号的优先级较高，会优先处理信号，信号处理完成后，会使accept或者read 解除阻塞，然后返回,此时返回值为-1，设置 errno=EINTR;\nerrno=ECONNABORTED表示连接被打断,异常.\n\nerrno宏:\n在/usr/include/asm-generic/errno.h 文件中包含了errno所有的宏和对应的错误描述信息.\n\n通过man errno查看\n\n\n\n# 高并发服务器\n如何支持多个客户端---支持多并发的服务器\n由于accept 和read函数都会阻塞，如当read的时候，不能调用accept接受新的连接，当accept阻塞等待的时候不能read读数据.\n第一种方案:使用多进程，可以让父进程接受新连接，让子进程处理与客户端通信\n思路:让父进程accept接受新连接，然后fork子进程，让子进程处理通信，子进程处理完成后退出，父进程使用SIGCHLD信号回收子进程.\n\n代码实现:\n第二种方案:使用多线程，让主线程接受新连接，让子线程处理与客户端通信;使用多线程要将线程设置为分离属性，让线程在退出之后自己回收资源.\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>掌握三次握手建立连接过程<br>掌握四次握手关闭连接的过程<br>掌握滑动窗口的概念<br>掌握错误处理函数封装<br>实现多进程并发服务器<br>实现多线程并发服务器</p>\n<p>函数封装的思想-处理异常情况<br>结合man-page和errno进行封装.<br>在封装的时候起名可以把第一个函数名的字母大写，如 socket可以封装成Socket,这样可以按shif+K进行搜索, shift+k搜索函数说明的时候不区分大小写,使用man page也可以查看, man page对大小写不区分.</p>\n<p>真正的程序，是看不到socket,bind,listen这种函数，一般都集成好了，一个函数能实现好几个功能</p>\n<p>像accept,read这样的能够引起阻塞的函数，若被信号打断，由于信号的优先级较高，会优先处理信号，信号处理完成后，会使accept或者read 解除阻塞，然后返回,此时返回值为-1，设置 errno&#x3D;EINTR;<br>errno&#x3D;ECONNABORTED表示连接被打断,异常.</p>\n<p>errno宏:<br>在&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h 文件中包含了errno所有的宏和对应的错误描述信息.</p>\n<p>通过man errno查看</p>\n<h1 id=\"高并发服务器\"><a href=\"#高并发服务器\" class=\"headerlink\" title=\"高并发服务器\"></a>高并发服务器</h1><p>如何支持多个客户端—支持多并发的服务器<br>由于accept 和read函数都会阻塞，如当read的时候，不能调用accept接受新的连接，当accept阻塞等待的时候不能read读数据.<br>第一种方案:使用多进程，可以让父进程接受新连接，让子进程处理与客户端通信<br>思路:让父进程accept接受新连接，然后fork子进程，让子进程处理通信，子进程处理完成后退出，父进程使用SIGCHLD信号回收子进程.</p>\n<p>代码实现:<br>第二种方案:使用多线程，让主线程接受新连接，让子线程处理与客户端通信;使用多线程要将线程设置为分离属性，让线程在退出之后自己回收资源.</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day02-multi-process-multi-thread","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day02-multi-process-multi-thread/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day01-一个服务器","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day01-first-sever/","text":"熟练掌握TCP状态转换图熟练掌握端口复用的方法了解半关闭的概念和实现方式了解多路I0转接模型熟练掌握select函数的使用熟练使用fd_set相关函数的使用能够编写select多路IO转接模型的代码","raw":"---\ntitle: day01-一个服务器\ndate: 2022-04-02 17:05:36\ntags:\n- Linux网络编程\n---\n\n\n\n\n熟练掌握TCP状态转换图\n熟练掌握端口复用的方法\n了解半关闭的概念和实现方式\n了解多路I0转接模型\n熟练掌握select函数的使用\n熟练使用fd_set相关函数的使用\n能够编写select多路IO转接模型的代码\n\n\n\n\n\n","content":"<p>熟练掌握TCP状态转换图<br>熟练掌握端口复用的方法<br>了解半关闭的概念和实现方式<br>了解多路I0转接模型<br>熟练掌握select函数的使用<br>熟练使用fd_set相关函数的使用<br>能够编写select多路IO转接模型的代码</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day01-first-sever","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day01-first-sever/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day03-select函数","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day03-select/","text":"熟练掌握TCP状态转换图熟练掌握端口复用的方法了解半关闭的概念和实现方式了解多路I0转接模型熟练掌握select函数的使用熟练使用fd_set相关函数的使用能够编写select多路IO转接模型的代码 端口复用解决端口复用的问题: bind error: Address already in use，发生这种情况是在服务端主动关闭连接以后，接着立刻启动就会报这种错误. int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); setsockopt(lfd, SOL_SOCKETPSO_REUSEADDR,&amp;opt, sizeof(int));setsockopt(lfd , SOL_SOCKET,SO_REUSEPORT,&amp;opt, sizeof(int)); UNIX高级环境编程这个函数写在socket之后，bind前 高并发服务器模型–select一个进程支持多个客户端 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);函数作用:委托内核监控可读,可写,异常事件 函数参数:nfds:，输入参数,告诉内核要监控文件描述符的范围,一般取值为最大文件描述符+1readfds:-输入参数:告诉内核要监控哪些文件描述符-输出参数:内核告诉应用程序哪些文件描述符有变化writefds:-输入参数:告诉内核要监控哪些文件描述符-输出参数:内核告诉应用程序哪些文件描述符有变化Exceptfds:输入输出参数,一般表示异常事件Timeout:超时时间:NULL:表示永久阻塞,直到有事件发生0:表示不阻塞,不管有没有事件发生,都会立刻返回 0:表示阻塞的时长,若没有超过时长,则一直阻塞;若在时长内,有事件发生,则立刻返回,若超过时长,则立刻返回返回值:成功返回发生变化的文件描述符个数. fd_set set;void FD_CLR(int fd, fd_set *set);说明:从set集合中清除fdint FD_ISSET(int fd, fd_set *set);说明:判断fd是否在set集合中void FD_SET(int fd, fd_set *set);说明:将fd添加到set集合中void FD_ZERO(fd_set *set);说明:清空文件描述符集 关于select的思考:问题:如果有效的文件描述符比较少，会使循环的次数太多.解决办法:可以将有效的文件描述符放到一个数组当中，这样遍历效率就高了. 代码优化方向:1将通信文件描述符保存到一个整形数组中，使用一个变量记录数组中最大元素的下标.2如果数组中有无效的文件描述符，直接跳过 select优点:1一个进程可以支持多个客户端2 select支持跨平台 select缺点:1代码编写困难2会涉及到用户区到内核区的来回拷贝3当客户端多个连接，但少数活跃的情况, select效率较低例如:作为极端的一种情况,3-1023文件描述符全部打开，但是只有1023有发送数据, select就显得效率低下4最大支持1024个客户端连接select最大支持1024个客户端连接不是有文件描述符表最多可以支持1024个文件描述符限制的，需是由FD_SETSIZE&#x3D;1024限制的. FD_SETSIZE&#x3D;1024 fd_set使用了该宏，当然可以修改内核，然后再重新编译内核，一般不建议这么做. 作业:编写代码，让 select监控标准输入，监控网络，如果标准输入有数据就写入网络，如果网络有数据就读出网络数据，然后打印到标准输出.注意: select不仅可以监控socket文件描述符，也可以监视标准输","raw":"---\ntitle: day03-select函数\ndate: 2022-04-02 17:02:00\ntags:\n- Linux网络编程\n---\n\n\n熟练掌握TCP状态转换图\n熟练掌握端口复用的方法\n了解半关闭的概念和实现方式\n了解多路I0转接模型\n熟练掌握select函数的使用\n熟练使用fd_set相关函数的使用\n能够编写select多路IO转接模型的代码\n\n\n\n# 端口复用\n解决端口复用的问题: bind error: Address already in use，发生这种情况是在服务端主动关闭连接以后，接着立刻启动就会报这种错误.\n int setsockopt(int sockfd, int level, int optname,\n                      const void *optval, socklen_t optlen);\n\nsetsockopt(lfd, SOL_SOCKETPSO_REUSEADDR,&opt, sizeof(int));\nsetsockopt(lfd , SOL_SOCKET,SO_REUSEPORT,&opt, sizeof(int));\n\nUNIX高级环境编程\n这个函数写在socket之后，bind前\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 高并发服务器模型--select\n\n一个进程支持多个客户端\n\n int select(int nfds, fd_set *readfds, fd_set *writefds,\n                  fd_set *exceptfds, struct timeval *timeout);\n函数作用:\n委托内核监控可读,可写,异常事件\n\n函数参数:\nnfds:，输入参数,告诉内核要监控文件描述符的范围,一般取值为最大文件描述符+1\nreadfds:\n-输入参数:告诉内核要监控哪些文件描述符\n-输出参数:内核告诉应用程序哪些文件描述符有变化\nwritefds:\n-输入参数:告诉内核要监控哪些文件描述符\n-输出参数:内核告诉应用程序哪些文件描述符有变化\nExceptfds:\n输入输出参数,一般表示异常事件\nTimeout:\n超时时间:\nNULL:表示永久阻塞,直到有事件发生\n0:表示不阻塞,不管有没有事件发生,都会立刻返回\n>0:表示阻塞的时长,若没有超过时长,则一直阻塞;\n若在时长内,有事件发生,则立刻返回,\n若超过时长,则立刻返回\n返回值:\n成功返回发生变化的文件描述符个数.\n\n\n\n\nfd_set set;\nvoid FD_CLR(int fd, fd_set *set);\n说明:从set集合中清除fd\nint FD_ISSET(int fd, fd_set *set);\n说明:判断fd是否在set集合中\nvoid FD_SET(int fd, fd_set *set);\n说明:将fd添加到set集合中\nvoid FD_ZERO(fd_set *set);\n说明:清空文件描述符集\n\n\n\n关于select的思考:\n问题:如果有效的文件描述符比较少，会使循环的次数太多.\n解决办法:可以将有效的文件描述符放到一个数组当中，这样遍历效率就高了.\n\n\n代码优化方向:\n1将通信文件描述符保存到一个整形数组中，使用一个变量记录数组中最大元素的下标.\n2如果数组中有无效的文件描述符，直接跳过\n\n\n\nselect优点:\n1一个进程可以支持多个客户端\n2 select支持跨平台\n\nselect缺点:\n1代码编写困难\n2会涉及到用户区到内核区的来回拷贝\n3当客户端多个连接，但少数活跃的情况, select效率较低\n例如:作为极端的一种情况,3-1023文件描述符全部打开，但是只有1023有发送数据, select就显得效率低下\n4最大支持1024个客户端连接\nselect最大支持1024个客户端连接不是有文件描述符表最多可以支持1024个文件描述符限制的，需是由FD_SETSIZE=1024限制的.\n\nFD_SETSIZE=1024 fd_set使用了该宏，当然可以修改内核，然后再重新编译内核，一般不建议这么做.\n\n作业:\n编写代码，让 select监控标准输入，监控网络，如果标准输入有数据就写入网络，如果网络有数据就读出网络数据，然后打印到标准输出.\n注意: select不仅可以监控socket文件描述符，也可以监视标准输\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>熟练掌握TCP状态转换图<br>熟练掌握端口复用的方法<br>了解半关闭的概念和实现方式<br>了解多路I0转接模型<br>熟练掌握select函数的使用<br>熟练使用fd_set相关函数的使用<br>能够编写select多路IO转接模型的代码</p>\n<h1 id=\"端口复用\"><a href=\"#端口复用\" class=\"headerlink\" title=\"端口复用\"></a>端口复用</h1><p>解决端口复用的问题: bind error: Address already in use，发生这种情况是在服务端主动关闭连接以后，接着立刻启动就会报这种错误.<br> int setsockopt(int sockfd, int level, int optname,<br>                      const void *optval, socklen_t optlen);</p>\n<p>setsockopt(lfd, SOL_SOCKETPSO_REUSEADDR,&amp;opt, sizeof(int));<br>setsockopt(lfd , SOL_SOCKET,SO_REUSEPORT,&amp;opt, sizeof(int));</p>\n<p>UNIX高级环境编程<br>这个函数写在socket之后，bind前</p>\n<h1 id=\"高并发服务器模型–select\"><a href=\"#高并发服务器模型–select\" class=\"headerlink\" title=\"高并发服务器模型–select\"></a>高并发服务器模型–select</h1><p>一个进程支持多个客户端</p>\n<p> int select(int nfds, fd_set *readfds, fd_set *writefds,<br>                  fd_set *exceptfds, struct timeval *timeout);<br>函数作用:<br>委托内核监控可读,可写,异常事件</p>\n<p>函数参数:<br>nfds:，输入参数,告诉内核要监控文件描述符的范围,一般取值为最大文件描述符+1<br>readfds:<br>-输入参数:告诉内核要监控哪些文件描述符<br>-输出参数:内核告诉应用程序哪些文件描述符有变化<br>writefds:<br>-输入参数:告诉内核要监控哪些文件描述符<br>-输出参数:内核告诉应用程序哪些文件描述符有变化<br>Exceptfds:<br>输入输出参数,一般表示异常事件<br>Timeout:<br>超时时间:<br>NULL:表示永久阻塞,直到有事件发生<br>0:表示不阻塞,不管有没有事件发生,都会立刻返回</p>\n<blockquote>\n<p>0:表示阻塞的时长,若没有超过时长,则一直阻塞;<br>若在时长内,有事件发生,则立刻返回,<br>若超过时长,则立刻返回<br>返回值:<br>成功返回发生变化的文件描述符个数.</p>\n</blockquote>\n<p>fd_set set;<br>void FD_CLR(int fd, fd_set *set);<br>说明:从set集合中清除fd<br>int FD_ISSET(int fd, fd_set *set);<br>说明:判断fd是否在set集合中<br>void FD_SET(int fd, fd_set *set);<br>说明:将fd添加到set集合中<br>void FD_ZERO(fd_set *set);<br>说明:清空文件描述符集</p>\n<p>关于select的思考:<br>问题:如果有效的文件描述符比较少，会使循环的次数太多.<br>解决办法:可以将有效的文件描述符放到一个数组当中，这样遍历效率就高了.</p>\n<p>代码优化方向:<br>1将通信文件描述符保存到一个整形数组中，使用一个变量记录数组中最大元素的下标.<br>2如果数组中有无效的文件描述符，直接跳过</p>\n<p>select优点:<br>1一个进程可以支持多个客户端<br>2 select支持跨平台</p>\n<p>select缺点:<br>1代码编写困难<br>2会涉及到用户区到内核区的来回拷贝<br>3当客户端多个连接，但少数活跃的情况, select效率较低<br>例如:作为极端的一种情况,3-1023文件描述符全部打开，但是只有1023有发送数据, select就显得效率低下<br>4最大支持1024个客户端连接<br>select最大支持1024个客户端连接不是有文件描述符表最多可以支持1024个文件描述符限制的，需是由FD_SETSIZE&#x3D;1024限制的.</p>\n<p>FD_SETSIZE&#x3D;1024 fd_set使用了该宏，当然可以修改内核，然后再重新编译内核，一般不建议这么做.</p>\n<p>作业:<br>编写代码，让 select监控标准输入，监控网络，如果标准输入有数据就写入网络，如果网络有数据就读出网络数据，然后打印到标准输出.<br>注意: select不仅可以监控socket文件描述符，也可以监视标准输</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day03-select","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day03-select/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"day05-线程池","date":"02/04/2022","path":"2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day05-Thread-Pool/","text":"什么是线程池? 是一个抽象的概念,若干个线程组合到一起,形成线程池. 为什么需要线程池?多线程版服务器一个客户端就需要创建一个线程!若客户端太多，显然不太合适. 什么时候需要创建线程池呢?简单的说，如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了。如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池了。实现的时候类似于生产者和消费者 线程池和任务池:任务池相当于共享资源，所以需要使用互斥锁，当任务池中没有任务的时候需要让线程阻塞，所以需要使用条件变量. 线程相关函数:1 pthread_create2 pthread_detachpthread_attr_t attr;pthread_attr_initpthread_attr_setdetachstate3 pthread_exit 涉及到共享资源:(主线程和各个子线程共享任务池)互斥锁相关函数:pthread_mutex_t mutex;pthread_mutex_initpthread_mutex_lock&#x2F;unlockpthread_mutex_destroy 能够是线程引起阻塞的函数:若任务池已满,主线程应该阻塞等待子线程处理任务,此时主线程需要阻塞等待若任务池空了，子线程应该阻塞等待,等待主线程往任务池中添加任务;pthread_cond_waitpthread_cond_signal 子线程负责从任务池冲获取任务,每一个任务有一个回调函数每王个回调函数执行下同操作.","raw":"---\ntitle: day05-线程池\ndate: 2022-04-02 17:01:50\ntags:\n- Linux网络编程\n---\n\n什么是线程池?\n    是一个抽象的概念,若干个线程组合到一起,形成线程池.\n\n为什么需要线程池?\n多线程版服务器一个客户端就需要创建一个线程!若客户端太多，显然不太合适.\n\n什么时候需要创建线程池呢?\n简单的说，如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了。如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池了。\n实现的时候类似于生产者和消费者\n\n\n线程池和任务池:\n任务池相当于共享资源，所以需要使用互斥锁，当任务池中没有任务的时候需要让线程阻塞，所以需要使用条件变量.\n\n\n线程相关函数:\n1 pthread_create\n2 pthread_detach\npthread_attr_t attr;\npthread_attr_init\npthread_attr_setdetachstate\n3 pthread_exit\n\n涉及到共享资源:(主线程和各个子线程共享任务池)\n互斥锁相关函数:\npthread_mutex_t mutex;\npthread_mutex_init\npthread_mutex_lock/unlock\npthread_mutex_destroy\n\n能够是线程引起阻塞的函数:\n若任务池已满,主线程应该阻塞等待子线程处理任务,此时主线程需要阻塞等待\n若任务池空了，子线程应该阻塞等待,等待主线程往任务池中添加任务;\npthread_cond_wait\npthread_cond_signal\n\n\n子线程负责从任务池冲获取任务,每一个任务有一个回调函数每王个回调函数执行下同操作.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>什么是线程池?<br>    是一个抽象的概念,若干个线程组合到一起,形成线程池.</p>\n<p>为什么需要线程池?<br>多线程版服务器一个客户端就需要创建一个线程!若客户端太多，显然不太合适.</p>\n<p>什么时候需要创建线程池呢?<br>简单的说，如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了。如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池了。<br>实现的时候类似于生产者和消费者</p>\n<p>线程池和任务池:<br>任务池相当于共享资源，所以需要使用互斥锁，当任务池中没有任务的时候需要让线程阻塞，所以需要使用条件变量.</p>\n<p>线程相关函数:<br>1 pthread_create<br>2 pthread_detach<br>pthread_attr_t attr;<br>pthread_attr_init<br>pthread_attr_setdetachstate<br>3 pthread_exit</p>\n<p>涉及到共享资源:(主线程和各个子线程共享任务池)<br>互斥锁相关函数:<br>pthread_mutex_t mutex;<br>pthread_mutex_init<br>pthread_mutex_lock&#x2F;unlock<br>pthread_mutex_destroy</p>\n<p>能够是线程引起阻塞的函数:<br>若任务池已满,主线程应该阻塞等待子线程处理任务,此时主线程需要阻塞等待<br>若任务池空了，子线程应该阻塞等待,等待主线程往任务池中添加任务;<br>pthread_cond_wait<br>pthread_cond_signal</p>\n<p>子线程负责从任务池冲获取任务,每一个任务有一个回调函数每王个回调函数执行下同操作.</p>\n","slug":"Linux-Network-Programming/Heima-Network-Programming/day05-Thread-Pool","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/04/02/Linux-Network-Programming/Heima-Network-Programming/day05-Thread-Pool/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"shell 教程","date":"26/03/2022","path":"2022/03/26/Tutorial/shell-tutorial/","text":"ans_yn.sh: 2: [: missing ]代码中的 ] 方括号内部必须要有个空格， [ “${yn}” &#x3D;&#x3D; “Y” -o “${yn}” &#x3D;&#x3D; “y”] 改成 [ “${yn}” &#x3D;&#x3D; “Y” -o “${yn}” &#x3D;&#x3D; “y” ] 即可ans_yn.sh: 2: [: y: unexpected operator 后来发现，因为ubuntu默认的sh是连接到dash的,又因为dash跟bash的不兼容所以出错了.执行时可以把sh换成bash文件名.sh来执行.成功.dash是什么东西,查了一下,应该也是一种shell,貌似用户对它的诟病颇多。修改sh默认连接到bash的一种方法： sudo dpkg-reconfigure dash选择no即可. [ -d DIR ] 如果 FILE 存在且是一个目录则为真。[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真； https://blog.csdn.net/liuqiyao_01/article/details/41551075","raw":"---\ntitle: shell 教程\ndate: 2022-03-26 14:21:04\ntags:\n- 教程\n---\n\nans_yn.sh: 2: [: missing ]\n代码中的 ] 方括号内部必须要有个空格， [ \"${yn}\" == \"Y\" -o \"${yn}\" == \"y\"] 改成  [ \"${yn}\" == \"Y\" -o \"${yn}\" == \"y\" ] 即可\nans_yn.sh: 2: [: y: unexpected operator\n\n\n后来发现，因为ubuntu默认的sh是连接到dash的,又因为dash跟bash的不兼容所以出错了.执行时可以把sh换成bash文件名.sh来执行.成功.dash是什么东西,查了一下,应该也是一种shell,貌似用户对它的诟病颇多。\n修改sh默认连接到bash的一种方法：\n\n\nsudo dpkg-reconfigure dash\n选择no即可.\n\n\n\n[ -d DIR ] 如果 FILE 存在且是一个目录则为真。\n[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；\n\n\n\n\nhttps://blog.csdn.net/liuqiyao_01/article/details/41551075","content":"<p>ans_yn.sh: 2: [: missing ]<br>代码中的 ] 方括号内部必须要有个空格， [ “${yn}” &#x3D;&#x3D; “Y” -o “${yn}” &#x3D;&#x3D; “y”] 改成  [ “${yn}” &#x3D;&#x3D; “Y” -o “${yn}” &#x3D;&#x3D; “y” ] 即可<br>ans_yn.sh: 2: [: y: unexpected operator</p>\n<p>后来发现，因为ubuntu默认的sh是连接到dash的,又因为dash跟bash的不兼容所以出错了.执行时可以把sh换成bash文件名.sh来执行.成功.dash是什么东西,查了一下,应该也是一种shell,貌似用户对它的诟病颇多。<br>修改sh默认连接到bash的一种方法：</p>\n<p>sudo dpkg-reconfigure dash<br>选择no即可.</p>\n<p>[ -d DIR ] 如果 FILE 存在且是一个目录则为真。<br>[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；</p>\n<p><a href=\"https://blog.csdn.net/liuqiyao_01/article/details/41551075\">https://blog.csdn.net/liuqiyao_01/article/details/41551075</a></p>\n","slug":"Tutorial/shell-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/26/Tutorial/shell-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"设计模式题目","date":"19/03/2022","path":"2022/03/19/Interview-Q&A/Design-Patterns-Q&A/","text":"传输对象模式 当我们要一次从客户端到服务器传递具有多个属性的数据时，使用此模式 传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。 业务对象（Business Object） - 为传输对象填充数据的业务服务。传输对象（Transfer Object） - 简单的 POJO，只有设置&#x2F;获取属性的方法。客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。 以下哪种模式使用简单对象并采用逐步方法来构建复杂对象？ 建造者模式A、 桥接模式 B、 建造者模式 C、 过滤器模式 D、 适配器模式 Adapter class&#x2F;object 适配器模式可以进行接口转化 意图：将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适用性：你想使用一个已经存在的类，而它的接口不符合你的需求。你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 类适配器和对象适配器 这里列举一个c++ STL中的适配器例子，这是只是简单模型，想要深入请看STL源码剖析这里target：Sequenceadaptee是：deque而被实现的适配器是queue和stack 解释器模式（Interpreter Pattern）解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 (1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 (2) 一些重复出现的问题可以用一种简单的语言来进行表达。 (3) 一个语言的文法较为简单。 (4) 执行效率不是关键问题。（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。 优点:(1) 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 (2) 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 (3) 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。 (4) 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。 缺点:(1) 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 (2) 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦 实现： 尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。实现方式基本同Composite模式。重构成本：高。 参考文献：https://blog.csdn.net/chenxun_2010/article/details/48383571https://blog.csdn.net/llg070401046/article/details/73323934","raw":"---\ntitle: 设计模式题目\ndate: 2022-03-19 15:28:21\ntags:\n- 面试\n---\n\n\n\n\n\n\n\n\n\n\n\n\n2. 传输对象模式\n\n当我们要一次从客户端到服务器传递具有多个属性的数据时，使用此模式\n\n传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。\n服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。\n对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。\n\n业务对象（Business Object） - 为传输对象填充数据的业务服务。\n传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法。\n客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。\n\n\n\n3. 以下哪种模式使用简单对象并采用逐步方法来构建复杂对象？  建造者模式\nA、\t桥接模式\t\nB、\t建造者模式\t\nC、\t过滤器模式\t\nD、\t适配器模式\n\n\n\n## Adapter class/object 适配器模式\n**可以进行接口转化**\n- 意图：\n将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n- 适用性：\n你想使用一个已经存在的类，而它的接口不符合你的需求。\n你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。\n（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。\n\n\n类适配器和对象适配器\n\n这里列举一个c++ STL中的适配器例子，这是只是简单模型，想要深入请看STL源码剖析\n这里target：Sequence\nadaptee是：deque\n而被实现的适配器是queue和stack\n\n\n# 解释器模式（Interpreter Pattern）\n\n解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。\n\n(1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。\n\n(2)  一些重复出现的问题可以用一种简单的语言来进行表达。\n\n(3) 一个语言的文法较为简单。\n\n(4) 执行效率不是关键问题。（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。\n\n### 优点:\n\n\n(1) 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。\n\n(2) 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。\n\n(3) 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。\n\n(4) 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。\n\n### 缺点:\n(1) 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。\n\n(2) 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦\n\n\n实现： 尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。实现方式基本同Composite模式。\n重构成本：高。\n\n\n\n# 参考文献：\n\nhttps://blog.csdn.net/chenxun_2010/article/details/48383571\nhttps://blog.csdn.net/llg070401046/article/details/73323934\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<ol start=\"2\">\n<li>传输对象模式</li>\n</ol>\n<p>当我们要一次从客户端到服务器传递具有多个属性的数据时，使用此模式</p>\n<p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。<br>服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。<br>对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。</p>\n<p>业务对象（Business Object） - 为传输对象填充数据的业务服务。<br>传输对象（Transfer Object） - 简单的 POJO，只有设置&#x2F;获取属性的方法。<br>客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。</p>\n<ol start=\"3\">\n<li>以下哪种模式使用简单对象并采用逐步方法来构建复杂对象？  建造者模式<br>A、\t桥接模式\t<br>B、\t建造者模式\t<br>C、\t过滤器模式\t<br>D、\t适配器模式</li>\n</ol>\n<h2 id=\"Adapter-class-x2F-object-适配器模式\"><a href=\"#Adapter-class-x2F-object-适配器模式\" class=\"headerlink\" title=\"Adapter class&#x2F;object 适配器模式\"></a>Adapter class&#x2F;object 适配器模式</h2><p><strong>可以进行接口转化</strong></p>\n<ul>\n<li>意图：<br>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>\n<li>适用性：<br>你想使用一个已经存在的类，而它的接口不符合你的需求。<br>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。<br>（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>\n</ul>\n<p>类适配器和对象适配器</p>\n<p>这里列举一个c++ STL中的适配器例子，这是只是简单模型，想要深入请看STL源码剖析<br>这里target：Sequence<br>adaptee是：deque<br>而被实现的适配器是queue和stack</p>\n<h1 id=\"解释器模式（Interpreter-Pattern）\"><a href=\"#解释器模式（Interpreter-Pattern）\" class=\"headerlink\" title=\"解释器模式（Interpreter Pattern）\"></a>解释器模式（Interpreter Pattern）</h1><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p>\n<p>(1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</p>\n<p>(2)  一些重复出现的问题可以用一种简单的语言来进行表达。</p>\n<p>(3) 一个语言的文法较为简单。</p>\n<p>(4) 执行效率不是关键问题。（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><p>(1) 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</p>\n<p>(2) 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p>\n<p>(3) 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。</p>\n<p>(4) 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h3><p>(1) 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。</p>\n<p>(2) 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦</p>\n<p>实现： 尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。实现方式基本同Composite模式。<br>重构成本：高。</p>\n<h1 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h1><p><a href=\"https://blog.csdn.net/chenxun_2010/article/details/48383571\">https://blog.csdn.net/chenxun_2010/article/details/48383571</a><br><a href=\"https://blog.csdn.net/llg070401046/article/details/73323934\">https://blog.csdn.net/llg070401046/article/details/73323934</a></p>\n","slug":"Interview-Q&A/Design-Patterns-Q&A","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/19/Interview-Q&A/Design-Patterns-Q&A/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"C++题目","date":"19/03/2022","path":"2022/03/19/Interview-Q&A/Cplusplus-Q&A/","text":"字节数目64位机器bool: sizeof(1)char: sizeof(1)int: sizeof(4)short: sizeof(2)short int: sizeof(2)long: sizeof(4)long int: sizeof(4)long long: sizeof(8)float: sizeof(4)double: sizeof(8) 1. 结构体的第一个成员永远放在结构体起始位置偏移量为0的地址处。 2. 第二个成员开始，总是放在偏移量为对齐数整数倍的地址处。 对齐数 == 编译器默认的对齐数 与 变量自身大小的较小值 (vs的默认值为8) 3. 结构体的总大小必须是各成员的对齐数中最大对齐数的整数倍。 将一个运算符重载为友元函数时，如果其参数表中只有一个参数，则说明该运算符是( )。 A、 后置一元运算符 B、 前置一元运算符 C、 其他选项都可能 D、 二元运算符 前置一元运算符 若用一个大小为8的数组来实现循环队列,且当前队尾Rear和队首Front的值分别为0和5,当从队列中删除一个元素,再加入三个元素后，Rear和Front的值分别为 出队时，front&#x3D;(front+1)%MAXSIZE,rear不变，所以front&#x3D;6入队时，rear&#x3D;(rear+1)%MAXSIZE,front不变，所以rear&#x3D;3; 3和6 KMP算法模式串”abababcbcabcadaba”的next数组为（ ） 关于解决NPC问题的方法有（ ） A、 启发式算法得到的解可以保证解的好坏 B、 乱数算法在某些特定的情况下能够给快速求解 C、 启发式算法在很很多时候能给产生理性的解 D、 近似算法可以快速发现一定差距内的解 ACD NPC问题及其解决方法（回溯法、动态规划、贪心法、深度优先遍历） NP问题(Non-deterministic Polynomial )：多项式复杂程度的非确定性问题，这些问题无法根据公式直接地计算出来。比如，找大质数的问题（有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的）；再比如，大的合数分解质因数的问题（有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式）。 NPC问题(Non-deterministic Polynomial complete)：NP完全问题，可以这么认为，这种问题只有把解域里面的所有可能都穷举了之后才能得出答案，这样的问题是NP里面最难，但是这样算法的复杂程度，是指数关系。一般说来，如果要证明一个问题是NPC问题的话，可以拿已经是NPC问题的一个问题经过多项式时间的变化变成所需要证明的问题，那么所要证明的问题就是一个NPC问题了。NPC问题是一个问题族，如果里面任意一个问题有了多项式的解，即找到一个算法，那么所有的问题都可以有多项式的解。 著名的NPC问题： 背包问题（Knapsack problem）：01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2……Wn，与之相对应的价值为V1,V2……Vn。求出获得最大价值的方案。 旅行商问题（Traveling Saleman Problem，TSP），该问题是在寻求单一旅行者由起点出发，通过所有给定的需求点之后，最后再回到原点的最小路径成本。 哈密顿路径问题（Hamiltonian path problem）与哈密顿环路问题（Hamiltonian cycle problem）为旅行推销员问题的特殊案例。哈密顿图：由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次。 欧拉回路（从图的某一个顶点出发，图中每条边走且仅走一次，最后回到出发点；如果这样的回路存在，则称之为欧拉回路。）与欧拉路径（从图的某一个顶点出发，图中每条边走且仅走一次，最后到达某一个点；如果这样的路径存在，则称之为欧拉路径。） 无向图欧拉回路存在条件：所有顶点的度数均为偶数。无向图欧拉路径存在条件：至多有两个顶点的度数为奇数，其他顶点的度数均为偶数。有向图欧拉回路存在条件：所有顶点的入度和出度相等。有向图欧拉路径存在条件：至多有两个顶点的入度和出度绝对值差1（若有两个这样的顶点，则必须其中一个出度大于入度，另一个入度大于出度）,其他顶点的入度与出度相等。 Peterson算法 Peterson算法是一个实现互斥锁的并发程序设计算法，可以控制两个进程访问一个共享的单用户资源而不发生访问冲突。Gary L. Peterson于1981年提出此算法[1] 参考文献：https://blog.51cto.com/danlove/2049403 360的抽奖 https://wtaufpziv.github.io/2020/03/24/360%E7%9A%84%E6%8A%BD%E5%A5%96/","raw":"---\ntitle: C++题目\ndate: 2022-03-19 14:46:04\ntags:\n- 面试\n---\n\n\n字节数目\n64位机器\nbool:\t\tsizeof(1)\nchar:\t\tsizeof(1)\nint:\t\tsizeof(4)\nshort:\t\tsizeof(2)\nshort int:\tsizeof(2)\nlong:\t\tsizeof(4)\nlong int:\tsizeof(4)\nlong long:\tsizeof(8)\nfloat:\t\tsizeof(4)\ndouble:\t\tsizeof(8)\n\n\t1. 结构体的第一个成员永远放在结构体起始位置偏移量为0的地址处。\n\t2. 第二个成员开始，总是放在偏移量为对齐数整数倍的地址处。\n\t对齐数 == 编译器默认的对齐数 与 变量自身大小的较小值 (vs的默认值为8)\n\t3. 结构体的总大小必须是各成员的对齐数中最大对齐数的整数倍。\n\n\t\n1. 将一个运算符重载为友元函数时，如果其参数表中只有一个参数，则说明该运算符是(    )。\n\nA、\t后置一元运算符\t\nB、\t前置一元运算符\t\nC、\t其他选项都可能\t\nD、\t二元运算符\n\n\t前置一元运算符\n\n\n\n3. 若用一个大小为8的数组来实现循环队列,且当前队尾Rear和队首Front的值分别为0和5,当从队列中删除一个元素,再加入三个元素后，Rear和Front的值分别为\n\n出队时，front=(front+1)%MAXSIZE,rear不变，所以front=6\n入队时，rear=(rear+1)%MAXSIZE,front不变，所以rear=3;\n\n3和6\n\n4. KMP算法模式串\"abababcbcabcadaba\"的next数组为（      ）\n\n\n5. 关于解决NPC问题的方法有（    ）\n\nA、\t启发式算法得到的解可以保证解的好坏\t\nB、\t乱数算法在某些特定的情况下能够给快速求解\t\nC、\t启发式算法在很很多时候能给产生理性的解\t\nD、\t近似算法可以快速发现一定差距内的解\n\nACD\n\nNPC问题及其解决方法（回溯法、动态规划、贪心法、深度优先遍历）\n\nNP问题(Non-deterministic Polynomial )：多项式复杂程度的非确定性问题，这些问题无法根据公式直接地计算出来。比如，找大质数的问题（有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的）；再比如，大的合数分解质因数的问题（有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式）。\n\nNPC问题(Non-deterministic Polynomial complete)：NP完全问题，可以这么认为，这种问题只有把解域里面的所有可能都穷举了之后才能得出答案，这样的问题是NP里面最难，但是这样算法的复杂程度，是指数关系。一般说来，如果要证明一个问题是NPC问题的话，可以拿已经是NPC问题的一个问题经过多项式时间的变化变成所需要证明的问题，那么所要证明的问题就是一个NPC问题了。NPC问题是一个问题族，如果里面任意一个问题有了多项式的解，即找到一个算法，那么所有的问题都可以有多项式的解。\n\n著名的NPC问题：\n\n背包问题（Knapsack problem）：01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2……Wn，与之相对应的价值为V1,V2……Vn。求出获得最大价值的方案。\n\n旅行商问题（Traveling Saleman Problem，TSP），该问题是在寻求单一旅行者由起点出发，通过所有给定的需求点之后，最后再回到原点的最小路径成本。\n\n哈密顿路径问题（Hamiltonian path problem）与哈密顿环路问题（Hamiltonian cycle problem）为旅行推销员问题的特殊案例。哈密顿图：由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次。\n\n欧拉回路（从图的某一个顶点出发，图中每条边走且仅走一次，最后回到出发点；如果这样的回路存在，则称之为欧拉回路。）与欧拉路径（从图的某一个顶点出发，图中每条边走且仅走一次，最后到达某一个点；如果这样的路径存在，则称之为欧拉路径。）\n\n无向图欧拉回路存在条件：所有顶点的度数均为偶数。\n无向图欧拉路径存在条件：至多有两个顶点的度数为奇数，其他顶点的度数均为偶数。\n有向图欧拉回路存在条件：所有顶点的入度和出度相等。\n有向图欧拉路径存在条件：至多有两个顶点的入度和出度绝对值差1（若有两个这样的顶点，则必须其中一个出度大于入度，另一个入度大于出度）,其他顶点的入度与出度相等。\n\n\n\n\n6. Peterson算法\n\nPeterson算法是一个实现互斥锁的并发程序设计算法，可以控制两个进程访问一个共享的单用户资源而不发生访问冲突。Gary L. Peterson于1981年提出此算法[1] \n\n\n\n\n\n\n\n\n\n# 参考文献：\n\nhttps://blog.51cto.com/danlove/2049403\n\n360的抽奖  https://wtaufpziv.github.io/2020/03/24/360%E7%9A%84%E6%8A%BD%E5%A5%96/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>字节数目<br>64位机器<br>bool:\t\tsizeof(1)<br>char:\t\tsizeof(1)<br>int:\t\tsizeof(4)<br>short:\t\tsizeof(2)<br>short int:\tsizeof(2)<br>long:\t\tsizeof(4)<br>long int:\tsizeof(4)<br>long long:\tsizeof(8)<br>float:\t\tsizeof(4)<br>double:\t\tsizeof(8)</p>\n<pre><code>1. 结构体的第一个成员永远放在结构体起始位置偏移量为0的地址处。\n2. 第二个成员开始，总是放在偏移量为对齐数整数倍的地址处。\n对齐数 == 编译器默认的对齐数 与 变量自身大小的较小值 (vs的默认值为8)\n3. 结构体的总大小必须是各成员的对齐数中最大对齐数的整数倍。\n</code></pre>\n<ol>\n<li>将一个运算符重载为友元函数时，如果其参数表中只有一个参数，则说明该运算符是(    )。</li>\n</ol>\n<p>A、\t后置一元运算符\t<br>B、\t前置一元运算符\t<br>C、\t其他选项都可能\t<br>D、\t二元运算符</p>\n<pre><code>前置一元运算符\n</code></pre>\n<ol start=\"3\">\n<li>若用一个大小为8的数组来实现循环队列,且当前队尾Rear和队首Front的值分别为0和5,当从队列中删除一个元素,再加入三个元素后，Rear和Front的值分别为</li>\n</ol>\n<p>出队时，front&#x3D;(front+1)%MAXSIZE,rear不变，所以front&#x3D;6<br>入队时，rear&#x3D;(rear+1)%MAXSIZE,front不变，所以rear&#x3D;3;</p>\n<p>3和6</p>\n<ol start=\"4\">\n<li><p>KMP算法模式串”abababcbcabcadaba”的next数组为（      ）</p>\n</li>\n<li><p>关于解决NPC问题的方法有（    ）</p>\n</li>\n</ol>\n<p>A、\t启发式算法得到的解可以保证解的好坏\t<br>B、\t乱数算法在某些特定的情况下能够给快速求解\t<br>C、\t启发式算法在很很多时候能给产生理性的解\t<br>D、\t近似算法可以快速发现一定差距内的解</p>\n<p>ACD</p>\n<p>NPC问题及其解决方法（回溯法、动态规划、贪心法、深度优先遍历）</p>\n<p>NP问题(Non-deterministic Polynomial )：多项式复杂程度的非确定性问题，这些问题无法根据公式直接地计算出来。比如，找大质数的问题（有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的）；再比如，大的合数分解质因数的问题（有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式）。</p>\n<p>NPC问题(Non-deterministic Polynomial complete)：NP完全问题，可以这么认为，这种问题只有把解域里面的所有可能都穷举了之后才能得出答案，这样的问题是NP里面最难，但是这样算法的复杂程度，是指数关系。一般说来，如果要证明一个问题是NPC问题的话，可以拿已经是NPC问题的一个问题经过多项式时间的变化变成所需要证明的问题，那么所要证明的问题就是一个NPC问题了。NPC问题是一个问题族，如果里面任意一个问题有了多项式的解，即找到一个算法，那么所有的问题都可以有多项式的解。</p>\n<p>著名的NPC问题：</p>\n<p>背包问题（Knapsack problem）：01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2……Wn，与之相对应的价值为V1,V2……Vn。求出获得最大价值的方案。</p>\n<p>旅行商问题（Traveling Saleman Problem，TSP），该问题是在寻求单一旅行者由起点出发，通过所有给定的需求点之后，最后再回到原点的最小路径成本。</p>\n<p>哈密顿路径问题（Hamiltonian path problem）与哈密顿环路问题（Hamiltonian cycle problem）为旅行推销员问题的特殊案例。哈密顿图：由指定的起点前往指定的终点，途中经过所有其他节点且只经过一次。</p>\n<p>欧拉回路（从图的某一个顶点出发，图中每条边走且仅走一次，最后回到出发点；如果这样的回路存在，则称之为欧拉回路。）与欧拉路径（从图的某一个顶点出发，图中每条边走且仅走一次，最后到达某一个点；如果这样的路径存在，则称之为欧拉路径。）</p>\n<p>无向图欧拉回路存在条件：所有顶点的度数均为偶数。<br>无向图欧拉路径存在条件：至多有两个顶点的度数为奇数，其他顶点的度数均为偶数。<br>有向图欧拉回路存在条件：所有顶点的入度和出度相等。<br>有向图欧拉路径存在条件：至多有两个顶点的入度和出度绝对值差1（若有两个这样的顶点，则必须其中一个出度大于入度，另一个入度大于出度）,其他顶点的入度与出度相等。</p>\n<ol start=\"6\">\n<li>Peterson算法</li>\n</ol>\n<p>Peterson算法是一个实现互斥锁的并发程序设计算法，可以控制两个进程访问一个共享的单用户资源而不发生访问冲突。Gary L. Peterson于1981年提出此算法[1] </p>\n<h1 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h1><p><a href=\"https://blog.51cto.com/danlove/2049403\">https://blog.51cto.com/danlove/2049403</a></p>\n<p>360的抽奖  <a href=\"https://wtaufpziv.github.io/2020/03/24/360%E7%9A%84%E6%8A%BD%E5%A5%96/\">https://wtaufpziv.github.io/2020/03/24/360%E7%9A%84%E6%8A%BD%E5%A5%96/</a></p>\n","slug":"Interview-Q&A/Cplusplus-Q&A","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/19/Interview-Q&A/Cplusplus-Q&A/","excerpt":"","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"git 教程","date":"16/03/2022","path":"2022/03/16/Tutorial/Git-tutorial/","text":"linux环境下下载 git clone [ssh地址]直接克隆代码 git clone -b [分支名字] [ssh地址]需要克隆这个代码的一个分支 linux环境下提交 git initgit初始化输出： 1Initialized empty Git repository in /home/yzx/network/.git/ git add .提交所有的内容输出：无 git status查看当前提交的状态 1234567891011On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: ch04/4-2-1-getpid.c new file: ch04/4-2-2-fork.c new file: ch04/4-2-3-system.c new file: ch04/4-2-4-ececve.c new file: ch04/4-4-1-pthread.c new file: ch04/a.out git commit -m &quot;ch04&quot;提交到远程仓库git commit 规范指南Commit message 的格式 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; type用于说明 commit 的类别，只允许使用下面7个标识。feat：新功能（feature）fix&#x2F;to：修补bug fix：产生 diff 并自动修复此问题。适合于一次提交直接修复问题 to：只产生 diff不 自动修复此问题。适合于多次提交。最终修复问题提交时使用 fixdocs：仅仅修改了文档（documentation）style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑refactor：代码重构，没有加新功能或者修复 bug（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：改变构建流程、或者增加依赖库、工具等revert：回滚到上一个版本merge：代码合并sync：同步主线或分支的Bug scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subjectsubject是 commit 目的的简短描述，不超过50个字符。 BodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 git remote add origin git@github.com:gtoo8888/linux-network.git正常输出：无 报错： fatal: remote origin already exists. 解决： git remote -v 查看远程的仓库有什么 输出： origin &#103;&#105;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;:gtoo8888&#x2F;linux-network.git (fetch) origin &#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;:gtoo8888&#x2F;linux-network.git (push) git remote rm origin 移除远程的仓库 输出：无 git remote add origin &#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;:gtoo8888&#x2F;linux-network.git 再次使用指令 git push origin master步骤5操作过一次以后，下一次就不需要了 输出： 123456789101112Enumerating objects: 9, done.Counting objects: 100% (9/9), done.Delta compression using up to 2 threadsCompressing objects: 100% (8/8), done.Writing objects: 100% (9/9), 3.65 KiB | 1.21 MiB/s, done.Total 9 (delta 0), reused 0 (delta 0)remote:remote: Create a pull request for &#x27;master&#x27; on GitHub by visiting:remote: https://github.com/gtoo8888/linux-network/pull/new/masterremote:To github.com:gtoo8888/linux-network.git * [new branch] master -&gt; master 报错：error: src refspec main does not match anyerror: failed to push some refs to ‘&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;:gtoo8888&#x2F;linux-network.git’报错原因：本地文件与github上的文件有冲突本地需要提交的文件中存在空文件本地的origin和remote origin&#x2F;master 没有建立关联解决方法：git push origin main发现仓库中主要分支叫做master修改后就好了 生成ssh秘钥git config –global user.name “XXX”git config –global user.email “XXX” 1.生成公钥：git命令：ssh-keygen -m [密钥格式] -t [密钥类型] -C[密钥注解] 1234ssh-keygen -m PEM -t ed25519 -C &quot;ujm456@126.com&quot;ssh-keygen -m PEM -t ed25519 -C &quot;your.email@example.com&quot; // 创建新的 SSH 私钥与公钥秘钥对，输入你的邮箱作为标签Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 推荐使用默认地址Enter passphrase (empty for no passphrase): // 此处直接回车即可；若设置密码，则每次使用 SSH 方式推送代码时都会要求输入密码 成功之后显示： 1234Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your.email@example.com 2.添加公钥windows地址为（C:\\Users\\you.ssh）linux地址为（&#x2F;home&#x2F;user&#x2F;.ssh&#x2F;id_ed25519）linux地址为（&#x2F;root&#x2F;.ssh&#x2F;id_ed25519）打开上文中生成的秘钥对的地址（默认地址通常为 ~&#x2F;.ssh&#x2F;）找到后缀为 pub 的公钥文件，使用 cat 命令输出所有内容并复制。 3.尝试使用ssh连接githubssh -T &#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;ssh -T &#103;&#105;&#116;&#x40;&#x65;&#x2e;&#99;&#x6f;&#x64;&#x69;&#x6e;&#x67;&#x2e;&#x6e;&#x65;&#x74; 一些git的命令git LFS技术可以用来存放大文件 git lfs pull –allgit lfs pull checkoutgit checkout – bin&#x2F;test_tool.sh 放弃工作区中全部的修改git checkout . 放弃工作区中某个文件的修改：git checkout – filename git submodule当我们的项目很大很复杂的时候，需要将各个模块文件进行抽离，以此来降低项目文件之间的耦合程度。（当然你项目不大不复杂也可以使用，看个人喜好啦！！！）这个时候就可以使用git submodule来对项目文件进行抽离，最终使抽离出来的文件可以单独成为一个git仓库。这样做的好处是整个主项目对抽离出来的子项目（子模块）有依赖关系，却又并不关心子项目（子模块）的内部开发流程细节。 1234git submodule init# 初始化子项目git submodule update# 对子项目获取远程项目中最新的状态 git rmgit rm –cached git rm –cached test直接写要删除的文件或者文件夹名字就可以删除之后把自己需要的文件加上git add .git commit -m “”git push git rm -r –cached ..gitignore不生效 git configgit config –list列出git的所有配置 git配置中的CRLF、LF、CRCRLF: Carriage-Return Line-Feed的缩写，意思是回车换行，即\\r\\n;LF: Line-Feed的缩写,意思是换行，即\\n;CR: Carriage-Return的缩写，回车，即\\r;进阶当我们敲击回车键(Enter)时，操作系统会插入不可见的字符表示换行，不同的操作系统插入不同Windows: 插入\\r\\n,回车换行；Linux\\Unix: 插入\\n,换行；MacOS: 插入\\r，回车； git config –global core.autocrlf input AutoCRLF提交时转换为LF，检出时转换为CRLFgit config –global core.autocrlf true提交时转换为LF，检出时不转换git config –global core.autocrlf input提交检出均不转换如果下windows下下载的文件，需要映射到linux中去，不用总是手动改变编码 git branch查看当前所在分支 git branch -r查看远程有哪些分支 git branch -v显示当前分支的详细信息 git branch -d feat-0728删除本地创建的分支 git resetgit reset HEAD 恢复已经add的提交git reset HEAD test.cpp指定文件恢复 git reset HEAD^ 回退所有内容到上一个版本git reset HEAD^ hello.php 回退 hello.php 文件的版本到上一个版本 git 高级技术git log1234567891011git log --pretty=format:&#x27;%h: %s&#x27;d27f636: test:15e54dd6f: test:rebase 12db794d8: test:11ee8c5a3: test:rebase5a30601: test:308089a1: test:24a82470: test:146480b8: feat:增加了链接7035791: feat:init2544c56: Initial commit 只显示一行，详细的git log –pretty&#x3D;oneline只显示一行git log –oneline显示图形界面git log –graph git rebase步骤一：git rebase -i [startPonit] [endPoint]一般不使用endPointgit rebase -i ee8c5a3(ee8c5a3,d27f636](test:rebase,test:15]步骤二：接下来进入图形界面p 选择s 放弃步骤二：图形界面2注释掉不想要提交的:wq退出 如果需要rebase已经push的commit需要在提交的时候直接git push -f强制交上去，就会刷新掉之前的提交 修改最后一次提交的注释git commit –amend git stsh 暂存暂存命令git stash save “暂存的备注”直接执行git stash也可以达到暂存的目的，但是连续多次暂存后容易让人混淆哪次暂存了哪些代码 查看暂存记录git stash list取回暂存代码git stash pop取消【取消暂存代码】 git reset –hard git gc在当前存储库中运行许多内务处理任务，例如压缩文件修订（以减少磁盘空间并提高性能）并移除可能由之前git add调用创建的不可达对象。 鼓励用户在每个存储库中定期运行此任务，以保持良好的磁盘空间利用率和良好的操作性能。 git-gc - 清理不必要的文件并优化本地存储库 Git是如何存储对象的 Git 中存在两种对象 - 松散对象(loose object) 和 打包对象(packed object) . git gc 为了定时的对文件进行打包松散对象存储的文件，一个很大的文件1G的文件，改动一行，那依然会有一个1G的副本保存下来所以需要将松散对象打包为打包对象用来节约存储空间 关闭自动打包的原理是：如果有大文件包含在文件夹中，并且需要经常改动，那么就需要打开gc机制但是正常情况下，提交的都是几KB的小文件，源代码之类的，空间占用的很好，关闭git gc机制，还可以更好的溯源文件变化情况 问题：git gc以后，会消失一些什么信息？ git reflog如果使用git reset –herd HEAD^回退了版本，会出现amend的未来提交可以使用reflog查看到，并且回退到未来的版本 参考文献[GIT在线练习平台]https://learngitbranching.js.org/?locale=zh_CNhttps://blog.csdn.net/ajianyingxiaoqinghan/article/details/70544159https://blog.csdn.net/u014361280/article/details/109703556[git submodule]https://blog.csdn.net/weixin_44901565/article/details/123086226[git配置中的CRLF、LF、CR]https://blog.csdn.net/u013037336/article/details/121541008[git commit -m约定式提交]https://www.conventionalcommits.org/zh-hans/v1.0.0/[白色箭头]https://blog.csdn.net/bowenlaw/article/details/124594664[git commit 规范指南]https://blog.csdn.net/qq_41662115/article/details/99759645[.gitignore基础规则]https://www.cnblogs.com/kevingrace/p/5690241.html[git rebase]https://blog.csdn.net/small_white_123/article/details/121563248[git reset HEAD 用法]https://blog.csdn.net/wangkai6666/article/details/120810363[英文git教程网站]https://www.atlassian.com/git[git commit –amend]https://blog.csdn.net/xiaoyulike/article/details/119176756[git - 执行 git clone 时 “Filtering content”是什么意思？]https://www.coder.work/article/1531074[为什么要管理git gc自动垃圾回收(英文)]https://donatstudios.com/yagni-git-gc[为什么要git gc]https://www.cnblogs.com/ayseeing/p/4226471.html[Git是如何存储对象的]https://blog.csdn.net/hudashi/article/details/7669477[10.4 Git 内部原理 - 包文件]https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%8C%85%E6%96%87%E4%BB%B6[Git是如何存储对象的- 7. 原理解析- [ Git Community Book 中文版 …]https://www.shouce.ren/api/view/a/9924[git 版本回退]https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192[【学了就忘】Git操作 — 51.git reflog命令]https://www.jianshu.com/p/7e4cef3863e7[Good First Issue]https://goodfirstissue.dev/language/cplusplus/","raw":"---\ntitle: git 教程\ndate: 2022-03-16 21:56:51\ntags:\n- 教程\n---\n\n# linux环境下下载\n1. ```git clone [ssh地址]```\n直接克隆代码\n\n2. ```git clone -b [分支名字] [ssh地址]```\n需要克隆这个代码的一个分支\n\n\n# linux环境下提交\n1. ```git init```\ngit初始化\n输出：\n```\nInitialized empty Git repository in /home/yzx/network/.git/\n```\n2. ```git add .```\n提交所有的内容\n输出：\n无\n3. ```git status```\n查看当前提交的状态\n```\nOn branch master\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n        new file:   ch04/4-2-1-getpid.c\n        new file:   ch04/4-2-2-fork.c\n        new file:   ch04/4-2-3-system.c\n        new file:   ch04/4-2-4-ececve.c\n        new file:   ch04/4-4-1-pthread.c\n        new file:   ch04/a.out\n```\n\n4. ```git commit -m \"ch04\"```\n提交到远程仓库\ngit commit 规范指南\nCommit message 的格式\n```\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n```\n### type\n用于说明 commit 的类别，只允许使用下面7个标识。\nfeat：新功能（feature）\nfix/to：修补bug\n  - fix：产生 diff 并自动修复此问题。适合于一次提交直接修复问题\n  - to：只产生 diff不 自动修复此问题。适合于多次提交。最终修复问题提交时使用 fix\ndocs：仅仅修改了文档（documentation）\nstyle： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑\nrefactor：代码重构，没有加新功能或者修复 bug（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：改变构建流程、或者增加依赖库、工具等\nrevert：回滚到上一个版本\nmerge：代码合并\nsync：同步主线或分支的Bug\n\n\n### scope\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n### subject\nsubject是 commit 目的的简短描述，不超过50个字符。\n### Body\nBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。\n\n\n5. ```git remote add origin git@github.com:gtoo8888/linux-network.git```\n正常输出：\n无</br>\n\n- 报错：\n- fatal: remote origin already exists.\n- - 解决：\n- 1. git remote -v 查看远程的仓库有什么\n- - 输出：\n- - origin  git@github.com:gtoo8888/linux-network.git (fetch)\n- - origin  git@github.com:gtoo8888/linux-network.git (push)\n- 2. git remote rm origin 移除远程的仓库\n- - 输出：无\n- 3. git remote add origin git@github.com:gtoo8888/linux-network.git 再次使用指令\n\n6. ```git push origin master```\n步骤5操作过一次以后，下一次就不需要了\n\n输出：\n```\nEnumerating objects: 9, done.\nCounting objects: 100% (9/9), done.\nDelta compression using up to 2 threads\nCompressing objects: 100% (8/8), done.\nWriting objects: 100% (9/9), 3.65 KiB | 1.21 MiB/s, done.\nTotal 9 (delta 0), reused 0 (delta 0)\nremote:\nremote: Create a pull request for 'master' on GitHub by visiting:\nremote:      https://github.com/gtoo8888/linux-network/pull/new/master\nremote:\nTo github.com:gtoo8888/linux-network.git\n * [new branch]      master -> master\n```\n报错：\nerror: src refspec main does not match any\nerror: failed to push some refs to 'git@github.com:gtoo8888/linux-network.git'\n报错原因：\n本地文件与github上的文件有冲突\n本地需要提交的文件中存在空文件\n本地的origin和remote origin/master 没有建立关联\n解决方法：\ngit push origin main\n发现仓库中主要分支叫做master修改后就好了\n\n# 生成ssh秘钥\ngit config --global user.name \"XXX\"\ngit config --global user.email \"XXX\"\n## 1.生成公钥：\ngit命令：ssh-keygen  -m [密钥格式]  -t [密钥类型]  -C[密钥注解] \n```\nssh-keygen -m PEM -t ed25519 -C \"ujm456@126.com\"\nssh-keygen -m PEM -t ed25519 -C \"your.email@example.com\" // 创建新的 SSH 私钥与公钥秘钥对，输入你的邮箱作为标签\nEnter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 推荐使用默认地址\nEnter passphrase (empty for no passphrase): // 此处直接回车即可；若设置密码，则每次使用 SSH 方式推送代码时都会要求输入密码\n```\n成功之后显示：\n```\nYour identification has been saved in /Users/you/.ssh/id_rsa.\n# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.\n# The key fingerprint is:\n# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your.email@example.com\n```\n## 2.添加公钥\nwindows地址为（C:\\Users\\you\\.ssh）\nlinux地址为（/home/user/.ssh/id_ed25519）\nlinux地址为（/root/.ssh/id_ed25519）\n打开上文中生成的秘钥对的地址（默认地址通常为 ~/.ssh/）找到后缀为 pub 的公钥文件，使用 cat 命令输出所有内容并复制。\n\n## 3.尝试使用ssh连接github\nssh -T git@github.com\nssh -T git@e.coding.net\n\n# 一些git的命令\n\n## git LFS技术\n可以用来存放大文件\n\ngit lfs pull --all\ngit lfs pull\n\n\n## checkout\ngit checkout -- bin/test_tool.sh\n\n放弃工作区中全部的修改\ngit checkout .\n\n放弃工作区中某个文件的修改：\ngit checkout -- filename\n\n\n## git submodule\n当我们的项目很大很复杂的时候，需要将各个模块文件进行抽离，以此来降低项目文件之间的耦合程度。（当然你项目不大不复杂也可以使用，看个人喜好啦！！！）这个时候就可以使用git submodule来对项目文件进行抽离，最终使抽离出来的文件可以单独成为一个git仓库。这样做的好处是整个主项目对抽离出来的子项目（子模块）有依赖关系，却又并不关心子项目（子模块）的内部开发流程细节。\n\n```\ngit submodule init\n# 初始化子项目\ngit submodule update\n# 对子项目获取远程项目中最新的状态\n```\n# git rm \ngit rm --cached <File Name>\ngit rm --cached test\n<File Name>直接写要删除的文件或者文件夹名字就可以\n删除之后把自己需要的文件加上\ngit add .\ngit commit -m \"\"\ngit push \n\n\ngit rm -r --cached .\n.gitignore不生效\n\n\n# git config\ngit config --list\n列出git的所有配置\n\ngit配置中的CRLF、LF、CR\nCRLF: Carriage-Return Line-Feed的缩写，意思是回车换行，即\\r\\n;\nLF: Line-Feed的缩写,意思是换行，即\\n;\nCR: Carriage-Return的缩写，回车，即\\r;\n进阶\n当我们敲击回车键(Enter)时，操作系统会插入不可见的字符表示换行，不同的操作系统插入不同\nWindows: 插入\\r\\n,回车换行；\nLinux\\Unix: 插入\\n,换行；\nMacOS: 插入\\r，回车；\n\n\ngit config --global core.autocrlf input\n\nAutoCRLF\n提交时转换为LF，检出时转换为CRLF\ngit config --global core.autocrlf true\n提交时转换为LF，检出时不转换\ngit config --global core.autocrlf input\n提交检出均不转换\n如果下windows下下载的文件，需要映射到linux中去，不用总是手动改变编码\n\n\n# git branch\n查看当前所在分支 \n\n```git branch -r```\n查看远程有哪些分支\n\n```git branch -v```\n显示当前分支的详细信息\n\n```git branch -d feat-0728```\n删除本地创建的分支\n\n# git reset\n```git reset HEAD ```\n恢复已经add的提交\n```git reset HEAD test.cpp```\n指定文件恢复\n\n\n```git reset HEAD^ ```           \n回退所有内容到上一个版本  \n```git reset HEAD^ hello.php  ```    \n回退 hello.php 文件的版本到上一个版本  \n\n\n\n# git 高级技术\n\n## git log\n\n```\ngit log --pretty=format:'%h: %s'\nd27f636: test:15\ne54dd6f: test:rebase 12\ndb794d8: test:11\nee8c5a3: test:rebase\n5a30601: test:3\n08089a1: test:2\n4a82470: test:1\n46480b8: feat:增加了链接\n7035791: feat:init\n2544c56: Initial commit\n```\n\n只显示一行，详细的\ngit log --pretty=oneline\n只显示一行\ngit log --oneline\n显示图形界面\ngit log --graph\n## git rebase\n\n步骤一：\ngit rebase -i [startPonit] [endPoint]\n一般不使用endPoint\ngit rebase -i ee8c5a3\n(ee8c5a3,d27f636]\n(test:rebase,test:15]\n步骤二：\n接下来进入图形界面\np 选择\ns 放弃\n步骤二：\n图形界面2\n注释掉不想要提交的\n:wq退出\n\n\n如果需要rebase已经push的commit\n需要在提交的时候直接git push -f强制交上去，就会刷新掉之前的提交\n\n# 修改最后一次提交的注释\n\ngit commit --amend \n\n# git stsh 暂存\n暂存命令\ngit stash save \"暂存的备注\"\n直接执行git stash也可以达到暂存的目的，但是连续多次暂存后容易让人混淆哪次暂存了哪些代码\n\n查看暂存记录\ngit stash list\n取回暂存代码\ngit stash pop\n取消【取消暂存代码】\n\ngit reset --hard\n\n# git gc\n\n在当前存储库中运行许多内务处理任务，例如压缩文件修订（以减少磁盘空间并提高性能）\n并移除可能由之前git add调用创建的不可达对象。\n\n鼓励用户在每个存储库中定期运行此任务，以保持良好的磁盘空间利用率和良好的操作性能。\n\ngit-gc  - 清理不必要的文件并优化本地存储库\n\nGit是如何存储对象的\n\nGit 中存在两种对象 -  松散对象(loose object) 和 打包对象(packed object) .\n\ngit gc 为了定时的对文件进行打包\n松散对象存储的文件，一个很大的文件1G的文件，改动一行，那依然会有一个1G的副本保存下来\n所以需要将松散对象打包为打包对象用来节约存储空间\n\n关闭自动打包的原理是：\n如果有大文件包含在文件夹中，并且需要经常改动，那么就需要打开gc机制\n但是正常情况下，提交的都是几KB的小文件，源代码之类的，空间占用的很好，关闭git gc机制，还可以更好的溯源文件变化情况\n\n问题：\ngit gc以后，会消失一些什么信息？\n\n# git reflog\n\n如果使用git reset --herd HEAD^回退了版本，会出现amend的未来提交\n可以使用reflog查看到，并且回退到未来的版本\n\n# 参考文献\n[GIT在线练习平台]https://learngitbranching.js.org/?locale=zh_CN\nhttps://blog.csdn.net/ajianyingxiaoqinghan/article/details/70544159\nhttps://blog.csdn.net/u014361280/article/details/109703556\n[git submodule]https://blog.csdn.net/weixin_44901565/article/details/123086226\n[git配置中的CRLF、LF、CR]https://blog.csdn.net/u013037336/article/details/121541008\n[git commit -m约定式提交]https://www.conventionalcommits.org/zh-hans/v1.0.0/\n[白色箭头]https://blog.csdn.net/bowenlaw/article/details/124594664\n[git commit 规范指南]https://blog.csdn.net/qq_41662115/article/details/99759645\n[.gitignore基础规则]https://www.cnblogs.com/kevingrace/p/5690241.html\n[git rebase]https://blog.csdn.net/small_white_123/article/details/121563248\n[git reset HEAD 用法]https://blog.csdn.net/wangkai6666/article/details/120810363\n[英文git教程网站]https://www.atlassian.com/git\n[git commit --amend]https://blog.csdn.net/xiaoyulike/article/details/119176756\n[git - 执行 git clone 时 \"Filtering content\"是什么意思？]https://www.coder.work/article/1531074\n[为什么要管理git gc自动垃圾回收(英文)]https://donatstudios.com/yagni-git-gc\n[为什么要git gc]https://www.cnblogs.com/ayseeing/p/4226471.html\n[Git是如何存储对象的]https://blog.csdn.net/hudashi/article/details/7669477\n[10.4 Git 内部原理 - 包文件]https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%8C%85%E6%96%87%E4%BB%B6\n[Git是如何存储对象的- 7. 原理解析- [ Git Community Book 中文版 ...]https://www.shouce.ren/api/view/a/9924\n[git 版本回退]https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192\n[【学了就忘】Git操作 — 51.git reflog命令]https://www.jianshu.com/p/7e4cef3863e7\n[Good First Issue]https://goodfirstissue.dev/language/cplusplus/","content":"<h1 id=\"linux环境下下载\"><a href=\"#linux环境下下载\" class=\"headerlink\" title=\"linux环境下下载\"></a>linux环境下下载</h1><ol>\n<li><p><code>git clone [ssh地址]</code><br>直接克隆代码</p>\n</li>\n<li><p><code>git clone -b [分支名字] [ssh地址]</code><br>需要克隆这个代码的一个分支</p>\n</li>\n</ol>\n<h1 id=\"linux环境下提交\"><a href=\"#linux环境下提交\" class=\"headerlink\" title=\"linux环境下提交\"></a>linux环境下提交</h1><ol>\n<li><p><code>git init</code><br>git初始化<br>输出：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Initialized empty Git repository <span class=\"keyword\">in</span> <span class=\"regexp\">/home/y</span>zx<span class=\"regexp\">/network/</span>.git/</span><br></pre></td></tr></table></figure></li>\n<li><p><code>git add .</code><br>提交所有的内容<br>输出：<br>无</p>\n</li>\n<li><p><code>git status</code><br>查看当前提交的状态</p>\n<figure class=\"highlight vhdl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">On</span> branch master</span><br><span class=\"line\">No commits yet</span><br><span class=\"line\"></span><br><span class=\"line\">Changes <span class=\"keyword\">to</span> be committed:</span><br><span class=\"line\">  (<span class=\"keyword\">use</span> <span class=\"string\">&quot;git rm --cached &lt;file&gt;...&quot;</span> <span class=\"keyword\">to</span> unstage)</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">2</span>-<span class=\"number\">1</span>-getpid.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">2</span>-<span class=\"number\">2</span>-fork.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">2</span>-<span class=\"number\">3</span>-system.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">2</span>-<span class=\"number\">4</span>-ececve.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/<span class=\"number\">4</span>-<span class=\"number\">4</span>-<span class=\"number\">1</span>-pthread.c</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"keyword\">file</span>:   ch04/a.<span class=\"keyword\">out</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>git commit -m &quot;ch04&quot;</code><br>提交到远程仓库<br>git commit 规范指南<br>Commit message 的格式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>(<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>): <span class=\"tag\">&lt;<span class=\"name\">subject</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">BLANK</span> <span class=\"attr\">LINE</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">BLANK</span> <span class=\"attr\">LINE</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h3><p>用于说明 commit 的类别，只允许使用下面7个标识。<br>feat：新功能（feature）<br>fix&#x2F;to：修补bug</p>\n<ul>\n<li>fix：产生 diff 并自动修复此问题。适合于一次提交直接修复问题</li>\n<li>to：只产生 diff不 自动修复此问题。适合于多次提交。最终修复问题提交时使用 fix<br>docs：仅仅修改了文档（documentation）<br>style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑<br>refactor：代码重构，没有加新功能或者修复 bug（即不是新增功能，也不是修改bug的代码变动）<br>test：增加测试<br>chore：改变构建流程、或者增加依赖库、工具等<br>revert：回滚到上一个版本<br>merge：代码合并<br>sync：同步主线或分支的Bug</li>\n</ul>\n<h3 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"scope\"></a>scope</h3><p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>\n<h3 id=\"subject\"><a href=\"#subject\" class=\"headerlink\" title=\"subject\"></a>subject</h3><p>subject是 commit 目的的简短描述，不超过50个字符。</p>\n<h3 id=\"Body\"><a href=\"#Body\" class=\"headerlink\" title=\"Body\"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p>\n<ol start=\"5\">\n<li><code>git remote add origin git@github.com:gtoo8888/linux-network.git</code><br>正常输出：<br>无</br></li>\n</ol>\n<ul>\n<li>报错：</li>\n<li>fatal: remote origin already exists.</li>\n<li><ul>\n<li>解决：</li>\n</ul>\n</li>\n<li><ol>\n<li>git remote -v 查看远程的仓库有什么</li>\n</ol>\n</li>\n<li><ul>\n<li>输出：</li>\n</ul>\n</li>\n<li><ul>\n<li>origin  <a href=\"mailto:&#103;&#105;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;\">&#103;&#105;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a>:gtoo8888&#x2F;linux-network.git (fetch)</li>\n</ul>\n</li>\n<li><ul>\n<li>origin  <a href=\"mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;\">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;</a>:gtoo8888&#x2F;linux-network.git (push)</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>git remote rm origin 移除远程的仓库</li>\n</ol>\n</li>\n<li><ul>\n<li>输出：无</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>git remote add origin <a href=\"mailto:&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;\">&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>:gtoo8888&#x2F;linux-network.git 再次使用指令</li>\n</ol>\n</li>\n</ul>\n<ol start=\"6\">\n<li><code>git push origin master</code><br>步骤5操作过一次以后，下一次就不需要了</li>\n</ol>\n<p>输出：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enumerating objects: <span class=\"number\">9</span>, done.</span><br><span class=\"line\">Counting objects: <span class=\"number\">100</span>% (<span class=\"number\">9</span>/<span class=\"number\">9</span>), done.</span><br><span class=\"line\">Delta compression using up to <span class=\"number\">2</span> threads</span><br><span class=\"line\">Compressing objects: <span class=\"number\">100</span>% (<span class=\"number\">8</span>/<span class=\"number\">8</span>), done.</span><br><span class=\"line\">Writing objects: <span class=\"number\">100</span>% (<span class=\"number\">9</span><span class=\"regexp\">/9), 3.65 KiB | 1.21 MiB/</span>s, done.</span><br><span class=\"line\">Total <span class=\"number\">9</span> (delta <span class=\"number\">0</span>), reused <span class=\"number\">0</span> (delta <span class=\"number\">0</span>)</span><br><span class=\"line\">remote:</span><br><span class=\"line\">remote: Create a pull request <span class=\"keyword\">for</span> <span class=\"string\">&#x27;master&#x27;</span> on GitHub by visiting:</span><br><span class=\"line\">remote:      https:<span class=\"regexp\">//gi</span>thub.com<span class=\"regexp\">/gtoo8888/</span>linux-network<span class=\"regexp\">/pull/</span>new/master</span><br><span class=\"line\">remote:</span><br><span class=\"line\">To github.com:gtoo8888/linux-network.git</span><br><span class=\"line\"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure>\n<p>报错：<br>error: src refspec main does not match any<br>error: failed to push some refs to ‘<a href=\"mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;\">&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:gtoo8888&#x2F;linux-network.git’<br>报错原因：<br>本地文件与github上的文件有冲突<br>本地需要提交的文件中存在空文件<br>本地的origin和remote origin&#x2F;master 没有建立关联<br>解决方法：<br>git push origin main<br>发现仓库中主要分支叫做master修改后就好了</p>\n<h1 id=\"生成ssh秘钥\"><a href=\"#生成ssh秘钥\" class=\"headerlink\" title=\"生成ssh秘钥\"></a>生成ssh秘钥</h1><p>git config –global user.name “XXX”<br>git config –global user.email “XXX”</p>\n<h2 id=\"1-生成公钥：\"><a href=\"#1-生成公钥：\" class=\"headerlink\" title=\"1.生成公钥：\"></a>1.生成公钥：</h2><p>git命令：ssh-keygen  -m [密钥格式]  -t [密钥类型]  -C[密钥注解] </p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -m PEM -t ed25519 -C <span class=\"string\">&quot;ujm456@126.com&quot;</span></span><br><span class=\"line\">ssh-keygen -m PEM -t ed25519 -C <span class=\"string\">&quot;your.email@example.com&quot;</span> <span class=\"regexp\">//</span> 创建新的 SSH 私钥与公钥秘钥对，输入你的邮箱作为标签</span><br><span class=\"line\">Enter file <span class=\"keyword\">in</span> which to save the key (<span class=\"regexp\">/Users/y</span>ou<span class=\"regexp\">/.ssh/i</span>d_rsa): [Press enter] <span class=\"regexp\">//</span> 推荐使用默认地址</span><br><span class=\"line\">Enter passphrase (empty <span class=\"keyword\">for</span> no passphrase): <span class=\"regexp\">//</span> 此处直接回车即可；若设置密码，则每次使用 SSH 方式推送代码时都会要求输入密码</span><br></pre></td></tr></table></figure>\n<p>成功之后显示：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your identification has been saved <span class=\"keyword\">in</span> <span class=\"regexp\">/Users/y</span>ou<span class=\"regexp\">/.ssh/i</span>d_rsa.</span><br><span class=\"line\"><span class=\"comment\"># Your public key has been saved in /Users/you/.ssh/id_rsa.pub.</span></span><br><span class=\"line\"><span class=\"comment\"># The key fingerprint is:</span></span><br><span class=\"line\"><span class=\"comment\"># 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your.email@example.com</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-添加公钥\"><a href=\"#2-添加公钥\" class=\"headerlink\" title=\"2.添加公钥\"></a>2.添加公钥</h2><p>windows地址为（C:\\Users\\you.ssh）<br>linux地址为（&#x2F;home&#x2F;user&#x2F;.ssh&#x2F;id_ed25519）<br>linux地址为（&#x2F;root&#x2F;.ssh&#x2F;id_ed25519）<br>打开上文中生成的秘钥对的地址（默认地址通常为 ~&#x2F;.ssh&#x2F;）找到后缀为 pub 的公钥文件，使用 cat 命令输出所有内容并复制。</p>\n<h2 id=\"3-尝试使用ssh连接github\"><a href=\"#3-尝试使用ssh连接github\" class=\"headerlink\" title=\"3.尝试使用ssh连接github\"></a>3.尝试使用ssh连接github</h2><p>ssh -T <a href=\"mailto:&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;\">&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;</a><br>ssh -T <a href=\"mailto:&#103;&#105;&#116;&#x40;&#x65;&#x2e;&#99;&#x6f;&#x64;&#x69;&#x6e;&#x67;&#x2e;&#x6e;&#x65;&#x74;\">&#103;&#105;&#116;&#x40;&#x65;&#x2e;&#99;&#x6f;&#x64;&#x69;&#x6e;&#x67;&#x2e;&#x6e;&#x65;&#x74;</a></p>\n<h1 id=\"一些git的命令\"><a href=\"#一些git的命令\" class=\"headerlink\" title=\"一些git的命令\"></a>一些git的命令</h1><h2 id=\"git-LFS技术\"><a href=\"#git-LFS技术\" class=\"headerlink\" title=\"git LFS技术\"></a>git LFS技术</h2><p>可以用来存放大文件</p>\n<p>git lfs pull –all<br>git lfs pull</p>\n<h2 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h2><p>git checkout – bin&#x2F;test_tool.sh</p>\n<p>放弃工作区中全部的修改<br>git checkout .</p>\n<p>放弃工作区中某个文件的修改：<br>git checkout – filename</p>\n<h2 id=\"git-submodule\"><a href=\"#git-submodule\" class=\"headerlink\" title=\"git submodule\"></a>git submodule</h2><p>当我们的项目很大很复杂的时候，需要将各个模块文件进行抽离，以此来降低项目文件之间的耦合程度。（当然你项目不大不复杂也可以使用，看个人喜好啦！！！）这个时候就可以使用git submodule来对项目文件进行抽离，最终使抽离出来的文件可以单独成为一个git仓库。这样做的好处是整个主项目对抽离出来的子项目（子模块）有依赖关系，却又并不关心子项目（子模块）的内部开发流程细节。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">submodule </span>init</span><br><span class=\"line\"><span class=\"comment\"># 初始化子项目</span></span><br><span class=\"line\">git <span class=\"keyword\">submodule </span>update</span><br><span class=\"line\"><span class=\"comment\"># 对子项目获取远程项目中最新的状态</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h1><p>git rm –cached <File Name><br>git rm –cached test<br><File Name>直接写要删除的文件或者文件夹名字就可以<br>删除之后把自己需要的文件加上<br>git add .<br>git commit -m “”<br>git push </p>\n<p>git rm -r –cached .<br>.gitignore不生效</p>\n<h1 id=\"git-config\"><a href=\"#git-config\" class=\"headerlink\" title=\"git config\"></a>git config</h1><p>git config –list<br>列出git的所有配置</p>\n<p>git配置中的CRLF、LF、CR<br>CRLF: Carriage-Return Line-Feed的缩写，意思是回车换行，即\\r\\n;<br>LF: Line-Feed的缩写,意思是换行，即\\n;<br>CR: Carriage-Return的缩写，回车，即\\r;<br>进阶<br>当我们敲击回车键(Enter)时，操作系统会插入不可见的字符表示换行，不同的操作系统插入不同<br>Windows: 插入\\r\\n,回车换行；<br>Linux\\Unix: 插入\\n,换行；<br>MacOS: 插入\\r，回车；</p>\n<p>git config –global core.autocrlf input</p>\n<p>AutoCRLF<br>提交时转换为LF，检出时转换为CRLF<br>git config –global core.autocrlf true<br>提交时转换为LF，检出时不转换<br>git config –global core.autocrlf input<br>提交检出均不转换<br>如果下windows下下载的文件，需要映射到linux中去，不用总是手动改变编码</p>\n<h1 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h1><p>查看当前所在分支 </p>\n<p><code>git branch -r</code><br>查看远程有哪些分支</p>\n<p><code>git branch -v</code><br>显示当前分支的详细信息</p>\n<p><code>git branch -d feat-0728</code><br>删除本地创建的分支</p>\n<h1 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h1><p><code>git reset HEAD </code><br>恢复已经add的提交<br><code>git reset HEAD test.cpp</code><br>指定文件恢复</p>\n<p><code>git reset HEAD^ </code><br>回退所有内容到上一个版本<br><code>git reset HEAD^ hello.php  </code><br>回退 hello.php 文件的版本到上一个版本  </p>\n<h1 id=\"git-高级技术\"><a href=\"#git-高级技术\" class=\"headerlink\" title=\"git 高级技术\"></a>git 高级技术</h1><h2 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h2><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --pretty=format:&#x27;%h: <span class=\"built_in\">%s</span>&#x27;</span><br><span class=\"line\">d27f636: test:<span class=\"number\">15</span></span><br><span class=\"line\">e54dd6f: test:rebase <span class=\"number\">12</span></span><br><span class=\"line\">db794d8: test:<span class=\"number\">11</span></span><br><span class=\"line\">ee8c5a3: test:rebase</span><br><span class=\"line\">5a30601: test:<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">08089a1</span>: test:<span class=\"number\">2</span></span><br><span class=\"line\">4a82470: test:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">46480b8</span>: feat:增加了链接</span><br><span class=\"line\"><span class=\"number\">7035791</span>: feat:init</span><br><span class=\"line\">2544c56: Initial commit</span><br></pre></td></tr></table></figure>\n\n<p>只显示一行，详细的<br>git log –pretty&#x3D;oneline<br>只显示一行<br>git log –oneline<br>显示图形界面<br>git log –graph</p>\n<h2 id=\"git-rebase\"><a href=\"#git-rebase\" class=\"headerlink\" title=\"git rebase\"></a>git rebase</h2><p>步骤一：<br>git rebase -i [startPonit] [endPoint]<br>一般不使用endPoint<br>git rebase -i ee8c5a3<br>(ee8c5a3,d27f636]<br>(test:rebase,test:15]<br>步骤二：<br>接下来进入图形界面<br>p 选择<br>s 放弃<br>步骤二：<br>图形界面2<br>注释掉不想要提交的<br>:wq退出</p>\n<p>如果需要rebase已经push的commit<br>需要在提交的时候直接git push -f强制交上去，就会刷新掉之前的提交</p>\n<h1 id=\"修改最后一次提交的注释\"><a href=\"#修改最后一次提交的注释\" class=\"headerlink\" title=\"修改最后一次提交的注释\"></a>修改最后一次提交的注释</h1><p>git commit –amend </p>\n<h1 id=\"git-stsh-暂存\"><a href=\"#git-stsh-暂存\" class=\"headerlink\" title=\"git stsh 暂存\"></a>git stsh 暂存</h1><p>暂存命令<br>git stash save “暂存的备注”<br>直接执行git stash也可以达到暂存的目的，但是连续多次暂存后容易让人混淆哪次暂存了哪些代码</p>\n<p>查看暂存记录<br>git stash list<br>取回暂存代码<br>git stash pop<br>取消【取消暂存代码】</p>\n<p>git reset –hard</p>\n<h1 id=\"git-gc\"><a href=\"#git-gc\" class=\"headerlink\" title=\"git gc\"></a>git gc</h1><p>在当前存储库中运行许多内务处理任务，例如压缩文件修订（以减少磁盘空间并提高性能）<br>并移除可能由之前git add调用创建的不可达对象。</p>\n<p>鼓励用户在每个存储库中定期运行此任务，以保持良好的磁盘空间利用率和良好的操作性能。</p>\n<p>git-gc  - 清理不必要的文件并优化本地存储库</p>\n<p>Git是如何存储对象的</p>\n<p>Git 中存在两种对象 -  松散对象(loose object) 和 打包对象(packed object) .</p>\n<p>git gc 为了定时的对文件进行打包<br>松散对象存储的文件，一个很大的文件1G的文件，改动一行，那依然会有一个1G的副本保存下来<br>所以需要将松散对象打包为打包对象用来节约存储空间</p>\n<p>关闭自动打包的原理是：<br>如果有大文件包含在文件夹中，并且需要经常改动，那么就需要打开gc机制<br>但是正常情况下，提交的都是几KB的小文件，源代码之类的，空间占用的很好，关闭git gc机制，还可以更好的溯源文件变化情况</p>\n<p>问题：<br>git gc以后，会消失一些什么信息？</p>\n<h1 id=\"git-reflog\"><a href=\"#git-reflog\" class=\"headerlink\" title=\"git reflog\"></a>git reflog</h1><p>如果使用git reset –herd HEAD^回退了版本，会出现amend的未来提交<br>可以使用reflog查看到，并且回退到未来的版本</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[GIT在线练习平台]<a href=\"https://learngitbranching.js.org/?locale=zh_CN\">https://learngitbranching.js.org/?locale=zh_CN</a><br><a href=\"https://blog.csdn.net/ajianyingxiaoqinghan/article/details/70544159\">https://blog.csdn.net/ajianyingxiaoqinghan/article/details/70544159</a><br><a href=\"https://blog.csdn.net/u014361280/article/details/109703556\">https://blog.csdn.net/u014361280/article/details/109703556</a><br>[git submodule]<a href=\"https://blog.csdn.net/weixin_44901565/article/details/123086226\">https://blog.csdn.net/weixin_44901565/article/details/123086226</a><br>[git配置中的CRLF、LF、CR]<a href=\"https://blog.csdn.net/u013037336/article/details/121541008\">https://blog.csdn.net/u013037336/article/details/121541008</a><br>[git commit -m约定式提交]<a href=\"https://www.conventionalcommits.org/zh-hans/v1.0.0/\">https://www.conventionalcommits.org/zh-hans/v1.0.0/</a><br>[白色箭头]<a href=\"https://blog.csdn.net/bowenlaw/article/details/124594664\">https://blog.csdn.net/bowenlaw/article/details/124594664</a><br>[git commit 规范指南]<a href=\"https://blog.csdn.net/qq_41662115/article/details/99759645\">https://blog.csdn.net/qq_41662115/article/details/99759645</a><br>[.gitignore基础规则]<a href=\"https://www.cnblogs.com/kevingrace/p/5690241.html\">https://www.cnblogs.com/kevingrace/p/5690241.html</a><br>[git rebase]<a href=\"https://blog.csdn.net/small_white_123/article/details/121563248\">https://blog.csdn.net/small_white_123/article/details/121563248</a><br>[git reset HEAD 用法]<a href=\"https://blog.csdn.net/wangkai6666/article/details/120810363\">https://blog.csdn.net/wangkai6666/article/details/120810363</a><br>[英文git教程网站]<a href=\"https://www.atlassian.com/git\">https://www.atlassian.com/git</a><br>[git commit –amend]<a href=\"https://blog.csdn.net/xiaoyulike/article/details/119176756\">https://blog.csdn.net/xiaoyulike/article/details/119176756</a><br>[git - 执行 git clone 时 “Filtering content”是什么意思？]<a href=\"https://www.coder.work/article/1531074\">https://www.coder.work/article/1531074</a><br>[为什么要管理git gc自动垃圾回收(英文)]<a href=\"https://donatstudios.com/yagni-git-gc\">https://donatstudios.com/yagni-git-gc</a><br>[为什么要git gc]<a href=\"https://www.cnblogs.com/ayseeing/p/4226471.html\">https://www.cnblogs.com/ayseeing/p/4226471.html</a><br>[Git是如何存储对象的]<a href=\"https://blog.csdn.net/hudashi/article/details/7669477\">https://blog.csdn.net/hudashi/article/details/7669477</a><br>[10.4 Git 内部原理 - 包文件]<a href=\"https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%8C%85%E6%96%87%E4%BB%B6\">https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%8C%85%E6%96%87%E4%BB%B6</a><br>[Git是如何存储对象的- 7. 原理解析- [ Git Community Book 中文版 …]<a href=\"https://www.shouce.ren/api/view/a/9924\">https://www.shouce.ren/api/view/a/9924</a><br>[git 版本回退]<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192\">https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192</a><br>[【学了就忘】Git操作 — 51.git reflog命令]<a href=\"https://www.jianshu.com/p/7e4cef3863e7\">https://www.jianshu.com/p/7e4cef3863e7</a><br>[Good First Issue]<a href=\"https://goodfirstissue.dev/language/cplusplus/\">https://goodfirstissue.dev/language/cplusplus/</a></p>\n","slug":"Tutorial/Git-tutorial","updated":"25/09/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/16/Tutorial/Git-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"linux网络编程","date":"16/03/2022","path":"2022/03/16/Linux-Network-Programming/Linux-Network-Programming/","text":"用man pthread没有相应的解释sudo apt-get install glibc-doc sudo apt-get install manpages-posix-dev man -k pthread sudo apt-get install mysql-server service mysql start启动mysql &#x2F;&#x2F; 建立yourdb库create database yourdb; &#x2F;&#x2F;创建user表USE yourdb;CREATE TABLE user( username char(50) NULL, passwd char(50) NULL)ENGINE&#x3D;InnoDB; &#x2F;&#x2F; 添加数据INSERT INTO user(username, passwd) VALUES(‘name’, ‘passwd’); show databases;显示数据库 use demo_test;连接数据库 查看当前使用的数据库：mysql&gt; select database(); 查看表show tables; 获取表结构desc user; 查询表中的数据mysql&gt; select * from user;","raw":"---\ntitle: linux网络编程\ndate: 2022-03-16 21:45:13\ntags:\n- Linux网络编程\n---\n\n用man pthread没有相应的解释\nsudo apt-get install glibc-doc\n\nsudo apt-get install manpages-posix-dev\n\nman -k pthread \n\n\n\nsudo apt-get install mysql-server\n\n\n\nservice mysql start启动mysql\n\n\n// 建立yourdb库\ncreate database yourdb;\n\n//创建user表\nUSE yourdb;\nCREATE TABLE user(\n    username char(50) NULL,\n    passwd char(50) NULL\n)ENGINE=InnoDB;\n\n// 添加数据\nINSERT INTO user(username, passwd) VALUES('name', 'passwd');\n\n\nshow databases;\n显示数据库\n\nuse demo_test;\n连接数据库\n\n查看当前使用的数据库：\nmysql> select database();\n\n查看表\nshow tables;\n\n获取表结构\ndesc user;\n\n查询表中的数据\nmysql> select * from user;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","content":"<p>用man pthread没有相应的解释<br>sudo apt-get install glibc-doc</p>\n<p>sudo apt-get install manpages-posix-dev</p>\n<p>man -k pthread </p>\n<p>sudo apt-get install mysql-server</p>\n<p>service mysql start启动mysql</p>\n<p>&#x2F;&#x2F; 建立yourdb库<br>create database yourdb;</p>\n<p>&#x2F;&#x2F;创建user表<br>USE yourdb;<br>CREATE TABLE user(<br>    username char(50) NULL,<br>    passwd char(50) NULL<br>)ENGINE&#x3D;InnoDB;</p>\n<p>&#x2F;&#x2F; 添加数据<br>INSERT INTO user(username, passwd) VALUES(‘name’, ‘passwd’);</p>\n<p>show databases;<br>显示数据库</p>\n<p>use demo_test;<br>连接数据库</p>\n<p>查看当前使用的数据库：<br>mysql&gt; select database();</p>\n<p>查看表<br>show tables;</p>\n<p>获取表结构<br>desc user;</p>\n<p>查询表中的数据<br>mysql&gt; select * from user;</p>\n","slug":"Linux-Network-Programming/Linux-Network-Programming","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/16/Linux-Network-Programming/Linux-Network-Programming/","excerpt":"","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"gcc 教程","date":"11/03/2022","path":"2022/03/11/Tutorial/linux-dev-env/GCC-tutorial/","text":"GCC介绍 GCC 原名为 GNU C语言编译器（GNU C Compiler） GCC（GNU Compiler Collection， GNU编译器套件）是由 GNU 开发的编程语言译器。 GNU 编译器套件包括 C、 C++、 Objective-C、 Java、 Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++， libgcj等） GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数-std=c99 启动 GCC 时，编译器支持 C99 标准。 安装命令 sudo apt install gcc g++ （版本 &gt; 4.8.5） 查看版本 gcc&#x2F;g++ -v&#x2F;–version 语言流程高级语言编译汇编语言汇编机器语言运行计算机 GCC工作流程源代码(预处理)-&gt;预处理后源代码(编译器)-&gt;汇编代码(汇编器)-&gt;目标代码(链接器)-&gt;可执行程序.h.c.cpp.i.s.exe.out gcc 和 g++ 的区别gcc 和 g++都是GNU(组织)的一个编译器 误区一： gcc 只能编译 c 代码， g++ 只能编译 c++ 代码。两者都可以，请注意： 误区二： gcc 不会定义 __cplusplus 宏，而 g++ 会 误区三：编译只能用 gcc，链接只能用 g++ GCC常用参数选项 输出 说明 汇编 编译 链接 文件名 没有指令 a.out -E 预处理指定的源文件 × × × 屏幕输出 -S 编译到汇编语言 √ × × 原文件名.s -c 编译、汇编 √ √ × 原文件名.o -o [file1] 生成指定文件名file1 √ √ √ file1 |-o [file1][file2] [file2] | 将文件 file2 编译成可执行文件 file1|| gcc -o testgcc -c -o test将main.c和string.c编译成一个执行文件gcc -o test mian.c string.c 指令 说明 -I directory 指定 include 包含文件的搜索目录 — — -g 在编译的时候，生成调试信息，该程序可以被调试器调试 -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -O n n的取值范围： 0~3,编译器的优化选项的4个级别 -O 0表示没有优化， -O 1为缺省值， -O 3优化级别最高 -l 在程序编译的时候，指定使用的库 -L 指定编译的时候，搜索的库的路径。 -fPIC&#x2F;fpic 生成与位置无关的代码 -shared 生成共享目标文件，通常用在建立共享库时 -std 指定C方言，如:-std&#x3D;c++11， gcc默认的方言是GNU C 库文件 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。 库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。 库的好处： 1.代码保密 2.方便部署和分发 静态库的制作 命名规则： Linux : libxxx.a lib : 前缀（固定） xxx : 库的名字，自己起 .a : 后缀（固定） Windows : libxxx.lib 静态库的制作： gcc 获得 .o 文件 将 .o 文件打包，使用 ar 工具（archive） ar rcs libxxx.a xxx.o xxx.o r – 将文件插入备存文件中 c – 建立备存文件 s – 索引 参考资料：https://www.nowcoder.com/courses/cover/live/504[100个gdb小技巧]https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html","raw":"---\ntitle: gcc 教程\ndate: 2022-03-11 14:11:23\ntags:\n- 教程\n---\n\n# GCC介绍\n\n- GCC 原名为 GNU C语言编译器（GNU C Compiler）\n- GCC（GNU Compiler Collection， GNU编译器套件）是由 GNU 开发的编程语言\n译器。 GNU 编译器套件包括 C、 C++、 Objective-C、 Java、 Ada 和 Go 语言前\n端，也包括了这些语言的库（如 libstdc++， libgcj等）\n- GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行\n选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数\n`-std=c99` 启动 GCC 时，编译器支持 C99 标准。\n- 安装命令 sudo apt install gcc g++ （版本 > 4.8.5）\n- 查看版本 gcc/g++ -v/--version\n\n# 语言流程\n\n高级语言\n编译\n汇编语言\n汇编\n机器语言\n运行\n计算机\n\n# GCC工作流程\n\n源代码(预处理)->预处理后源代码(编译器)->汇编代码(汇编器)->目标代码(链接器)->可执行程序\n.h.c.cpp\n.i\n.s\n.exe.out\n\n# gcc 和 g++ 的区别\ngcc 和 g++都是GNU(组织)的一个编译器\n- 误区一： gcc 只能编译 c 代码， g++ 只能编译 c++ 代码。两者都可以，请注意：\n- 误区二： gcc 不会定义 __cplusplus 宏，而 g++ 会\n- 误区三：编译只能用 gcc，链接只能用 g++\n\n\n# GCC常用参数选项\n\n| 输出       | 说明                | 汇编 | 编译 | 链接 | 文件名     |\n| ---------- | ------------------- | ---- | ---- | ---- | ---------- |\n|            | 没有指令            |      |      |      | a.out      |\n| -E         | 预处理指定的源文件  | ×    | ×    | ×    | 屏幕输出   |\n| -S         | 编译到汇编语言      | √    | ×    | ×    | 原文件名.s |\n| -c         | 编译、汇编          | √    | √    | ×    | 原文件名.o |\n| -o [file1] | 生成指定文件名file1 | √    | √    | √    | file1      |\n\n|-o [file1][file2] [file2] | 将文件 file2 编译成可执行文件 file1||\n\ngcc -o test\ngcc -c -o test\n将main.c和string.c编译成一个执行文件\ngcc -o test mian.c string.c\n\n|指令| 说明|\n|---|---|\n|-I |directory 指定 include 包含文件的搜索目录|\n|---|---|\n|-g |在编译的时候，生成调试信息，该程序可以被调试器调试|\n|-D |在程序编译的时候，指定一个宏|\n|-w |不生成任何警告信息|\n|-Wall| 生成所有警告信息|\n|-O n|n的取值范围： 0~3,编译器的优化选项的4个级别</br> -O 0表示没有优化， -O 1为缺省值， -O 3优化级别最高|\n|-l |在程序编译的时候，指定使用的库|\n|-L |指定编译的时候，搜索的库的路径。|\n|-fPIC/fpic |生成与位置无关的代码|\n|-shared |生成共享目标文件，通常用在建立共享库时|\n|-std |指定C方言，如:-std=c++11， gcc默认的方言是GNU C|\n\n\n# 库文件\n\n- 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。\n- 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。\n- 库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。\n- 库的好处： 1.代码保密 2.方便部署和分发\n\n# 静态库的制作\n\n- 命名规则：\n    - Linux : libxxx.a\n    - lib : 前缀（固定）\n    - xxx : 库的名字，自己起\n    - .a : 后缀（固定）\n- Windows : libxxx.lib\n\n- 静态库的制作：\n- gcc 获得 .o 文件\n- 将 .o 文件打包，使用 ar 工具（archive）\n    - ar rcs libxxx.a xxx.o xxx.o\n        - r – 将文件插入备存文件中\n        - c – 建立备存文件\n        - s – 索引\n\n\n\n\n\n\n\n# 参考资料：\nhttps://www.nowcoder.com/courses/cover/live/504\n[100个gdb小技巧]https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html\n","content":"<h1 id=\"GCC介绍\"><a href=\"#GCC介绍\" class=\"headerlink\" title=\"GCC介绍\"></a>GCC介绍</h1><ul>\n<li>GCC 原名为 GNU C语言编译器（GNU C Compiler）</li>\n<li>GCC（GNU Compiler Collection， GNU编译器套件）是由 GNU 开发的编程语言<br>译器。 GNU 编译器套件包括 C、 C++、 Objective-C、 Java、 Ada 和 Go 语言前<br>端，也包括了这些语言的库（如 libstdc++， libgcj等）</li>\n<li>GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行<br>选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数<br><code>-std=c99</code> 启动 GCC 时，编译器支持 C99 标准。</li>\n<li>安装命令 sudo apt install gcc g++ （版本 &gt; 4.8.5）</li>\n<li>查看版本 gcc&#x2F;g++ -v&#x2F;–version</li>\n</ul>\n<h1 id=\"语言流程\"><a href=\"#语言流程\" class=\"headerlink\" title=\"语言流程\"></a>语言流程</h1><p>高级语言<br>编译<br>汇编语言<br>汇编<br>机器语言<br>运行<br>计算机</p>\n<h1 id=\"GCC工作流程\"><a href=\"#GCC工作流程\" class=\"headerlink\" title=\"GCC工作流程\"></a>GCC工作流程</h1><p>源代码(预处理)-&gt;预处理后源代码(编译器)-&gt;汇编代码(汇编器)-&gt;目标代码(链接器)-&gt;可执行程序<br>.h.c.cpp<br>.i<br>.s<br>.exe.out</p>\n<h1 id=\"gcc-和-g-的区别\"><a href=\"#gcc-和-g-的区别\" class=\"headerlink\" title=\"gcc 和 g++ 的区别\"></a>gcc 和 g++ 的区别</h1><p>gcc 和 g++都是GNU(组织)的一个编译器</p>\n<ul>\n<li>误区一： gcc 只能编译 c 代码， g++ 只能编译 c++ 代码。两者都可以，请注意：</li>\n<li>误区二： gcc 不会定义 __cplusplus 宏，而 g++ 会</li>\n<li>误区三：编译只能用 gcc，链接只能用 g++</li>\n</ul>\n<h1 id=\"GCC常用参数选项\"><a href=\"#GCC常用参数选项\" class=\"headerlink\" title=\"GCC常用参数选项\"></a>GCC常用参数选项</h1><table>\n<thead>\n<tr>\n<th>输出</th>\n<th>说明</th>\n<th>汇编</th>\n<th>编译</th>\n<th>链接</th>\n<th>文件名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>没有指令</td>\n<td></td>\n<td></td>\n<td></td>\n<td>a.out</td>\n</tr>\n<tr>\n<td>-E</td>\n<td>预处理指定的源文件</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n<td>屏幕输出</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>编译到汇编语言</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n<td>原文件名.s</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>编译、汇编</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n<td>原文件名.o</td>\n</tr>\n<tr>\n<td>-o [file1]</td>\n<td>生成指定文件名file1</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>file1</td>\n</tr>\n</tbody></table>\n<p>|-o [file1][file2] [file2] | 将文件 file2 编译成可执行文件 file1||</p>\n<p>gcc -o test<br>gcc -c -o test<br>将main.c和string.c编译成一个执行文件<br>gcc -o test mian.c string.c</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-I</td>\n<td>directory 指定 include 包含文件的搜索目录</td>\n</tr>\n<tr>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td>-g</td>\n<td>在编译的时候，生成调试信息，该程序可以被调试器调试</td>\n</tr>\n<tr>\n<td>-D</td>\n<td>在程序编译的时候，指定一个宏</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>不生成任何警告信息</td>\n</tr>\n<tr>\n<td>-Wall</td>\n<td>生成所有警告信息</td>\n</tr>\n<tr>\n<td>-O n</td>\n<td>n的取值范围： 0~3,编译器的优化选项的4个级别</br> -O 0表示没有优化， -O 1为缺省值， -O 3优化级别最高</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>在程序编译的时候，指定使用的库</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>指定编译的时候，搜索的库的路径。</td>\n</tr>\n<tr>\n<td>-fPIC&#x2F;fpic</td>\n<td>生成与位置无关的代码</td>\n</tr>\n<tr>\n<td>-shared</td>\n<td>生成共享目标文件，通常用在建立共享库时</td>\n</tr>\n<tr>\n<td>-std</td>\n<td>指定C方言，如:-std&#x3D;c++11， gcc默认的方言是GNU C</td>\n</tr>\n</tbody></table>\n<h1 id=\"库文件\"><a href=\"#库文件\" class=\"headerlink\" title=\"库文件\"></a>库文件</h1><ul>\n<li>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。</li>\n<li>库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。</li>\n<li>库文件有两种，静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</li>\n<li>库的好处： 1.代码保密 2.方便部署和分发</li>\n</ul>\n<h1 id=\"静态库的制作\"><a href=\"#静态库的制作\" class=\"headerlink\" title=\"静态库的制作\"></a>静态库的制作</h1><ul>\n<li><p>命名规则：</p>\n<ul>\n<li>Linux : libxxx.a</li>\n<li>lib : 前缀（固定）</li>\n<li>xxx : 库的名字，自己起</li>\n<li>.a : 后缀（固定）</li>\n</ul>\n</li>\n<li><p>Windows : libxxx.lib</p>\n</li>\n<li><p>静态库的制作：</p>\n</li>\n<li><p>gcc 获得 .o 文件</p>\n</li>\n<li><p>将 .o 文件打包，使用 ar 工具（archive）</p>\n<ul>\n<li>ar rcs libxxx.a xxx.o xxx.o<ul>\n<li>r – 将文件插入备存文件中</li>\n<li>c – 建立备存文件</li>\n<li>s – 索引</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><p><a href=\"https://www.nowcoder.com/courses/cover/live/504\">https://www.nowcoder.com/courses/cover/live/504</a><br>[100个gdb小技巧]<a href=\"https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html\">https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html</a></p>\n","slug":"Tutorial/linux-dev-env/GCC-tutorial","updated":"02/11/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/11/Tutorial/linux-dev-env/GCC-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Cpluspulus 语法","date":"08/03/2022","path":"2022/03/08/Grammar/Cpluspulus-Grammar/","text":"不会的知识点的罗列C++11std::threadC++11中加入了&lt;thread&gt;头文件，此头文件主要声明了std::thread线程类 std::mutexC++11中新增了&lt;mutex&gt;，它是C++标准程序库中的一个头文件，定义了C++11标准中的一些互斥访问的类与方法等 explicitexplicit构造函数是用来防止隐式转换的 noexcept从C++11开始，我们能看到很多代码当中都有关键字noexcept。比如下面就是std::initializer_list的默认构造函数，其中使用了noexcept。 constexpr initializer_list() noexcept : _M_array(0), _M_len(0) &#123; &#125; 该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。 Snowflake 雪花算法分布式系统中ID生成方案，比较简单的是UUID（Universally Unique Identifier，通用唯一识别码），但是其存在两个明显的弊端：一、UUID是128位的，长度过长；二、UUID是完全随机的，无法生成递增有序的UUID。而现在流行的基于 Snowflake 雪花算法的ID生成方案就可以很好的解决了UUID存在的这两个问题 numeric_limitsnumeric_limits::max ()是函数，返回编译器允许的 double 型数 最大值。类似的 numeric_limits::max () 返回 编译器允许的 int 型数 最大值。需包含头文件 #include imits是STL提供的头文件（包含numeric_limits模板类），limit.h是C语言提供的头文件（包含一些宏定义） std::lock_guardlock_guard锁守卫是一个管理mutex对象的对象，使其始终处于锁定状态。在构造时，mutex对象被调用线程锁定，在销毁时，mutex被解锁。这是最简单的锁，作为一个自动持续时间的对象，它的作用特别大，可以持续到上下文结束。通过这种方式，它可以保证mutex对象在发生异常时被正确解锁。但请注意，lock_guard对象并不以任何方式管理mutex对象的寿命：mutex对象的持续时间至少应延长到锁定它的lock_guard被破坏为止。程序在std::lock_guard生命周期内加锁和解锁，其中加锁和解锁分别在构造函数和析构函数中完成，具体如何我们看下std::lock_guard的构造函数和析构函数。 cv::gpu::GpuMatstd::movestd::enable_shared_from_this在类的内部获取自己的 shared_ptr 这件事情而存在的。 std::chrono::durationstd::chrono::duration(下文简称duration)是标准库中用来代表时间段的一个类模板 std::unique_lock功能比std::unique_group更多 std::condition_variable condition_variable是一个类，搭配互斥量mutex来用， C++171.语法糖结构化绑定模板参数推导constexpr if在编译时期就可以判断是否要用这个分支，根据输入的类型来判断分支的走向 if初始化语句可以像for一样，将一些变量的生命周期控制在if里面 2.性能提升shared_mutexstring_view在调用一些strcpy函数的时候，不会进行值传递，而是会复制引用 try_emplace在插入map之类的数组的时候，会先检查是否已经有元素存在了 3.类型系统any代替了空类型void*，变得类型安全了 optinalvariant4.其他applymake_from_tuple[[nodiscard]]捕获*this结构化绑定auto [cur, pos] &#x3D; qu.front();https://blog.csdn.net/yaoshenjie/article/details/99288495 第三方库httplib库简介httplib库简介httplib库是一个以C++11特性编写的库，所以编译器也需要能支持C++11的。库在使用时只需包含一个头文件即可，非常方便。 下载地址 注意：此库为线程阻塞，使用时还请注意 jsoncpp库#include &lt;json&#x2F;json.h&gt; 注释规范@brief @param @return @author @date @version是代码书写的一种规范@brief ：简介，简单介绍函数作用@param ：介绍函数参数@return：函数返回类型说明@exception NSException 可能抛出的异常.@author zhangsan： 作者@date 2011-07-27 22:30:00 ：时间@version 1.0 ：版本@property ：属性介绍 std::recursive_mutexrecursive_mutex 精确到ns的计时方法std::chrono 参考文献：[C++ explicit 关键字]https://zhuanlan.zhihu.com/p/52152355[解决 VSCode 编写 C++11 代码报红问题]https://blog.csdn.net/weixin_42292229/article/details/113767569[C++11 带来的新特性 （3）—— 关键字noexcept]https://www.cnblogs.com/sword03/p/10020344.html[C++ limits头文件的用法numeric_limits]https://blog.csdn.net/CHYabc123456hh/article/details/117260306[C++中lock_guard的学习]https://blog.csdn.net/CHYabc123456hh/article/details/111317404[C++ std::lock_guard详解]https://jishuin.proginn.com/p/763bfbd6f671[一文详解OpenCV中的CUDA模块]https://zhuanlan.zhihu.com/p/358648337[「直播回放」腾讯工程师：C++17在业务代码中最好用的十个特性]https://www.zhihu.com/zvideo/1523417372937027584[Qt开源作品21-日志重定向输出类]https://www.cnblogs.com/feiyangqingyun/p/12970350.html[C++多线程之semaphore]https://blog.csdn.net/qq_41949047/article/details/108324225[C++11中enable_shared_from_this的用法解析]https://blog.csdn.net/breadheart/article/details/112451022[std::chrono::duration详解]https://blog.csdn.net/t114211200/article/details/78029553[C++ 11 多线程下std::unique_lock与std::lock_guard的区别和用法]http://t.zoukankan.com/moodlxs-p-10111843.html[C++ 条件变量(condition_variable)]https://cloud.tencent.com/developer/article/1584067[httplib库的使用(支持http&#x2F;https)（一）]https://blog.csdn.net/harry49/article/details/115763383[注释规范：详细]https://www.cnblogs.com/lyggqm/p/4629711.html[注释规范]https://blog.csdn.net/lxj362343/article/details/105711524/[C++11 新的计时方法——std::chrono 大法好]https://blog.csdn.net/u013390476/article/details/50209603[C++模板全特化、偏特化]https://blog.csdn.net/m_buddy/article/details/72973207","raw":"---\ntitle: Cpluspulus 语法\ndate: 2022-03-08 20:34:13\ntags:\n- 语法\n---\n\n# 不会的知识点的罗列\n\n\n# C++11\n\n# std::thread\nC++11中加入了\\<thread>头文件，此头文件主要声明了std::thread线程类\n\n\n\n# std::mutex\nC++11中新增了\\<mutex>，它是C++标准程序库中的一个头文件，定义了C++11标准中的一些互斥访问的类与方法等\n\n\n# explicit\nexplicit构造函数是用来防止隐式转换的\n\n\n\n# noexcept\n从C++11开始，我们能看到很多代码当中都有关键字noexcept。比如下面就是std::initializer_list的默认构造函数，其中使用了noexcept。\n\n      constexpr initializer_list() noexcept\n      : _M_array(0), _M_len(0) { }\n该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。\n如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。\n\n\n\n## Snowflake 雪花算法\n分布式系统中ID生成方案，比较简单的是UUID（Universally Unique Identifier，通用唯一识别码），但是其存在两个明显的弊端：一、UUID是128位的，长度过长；二、UUID是完全随机的，无法生成递增有序的UUID。而现在流行的基于 Snowflake 雪花算法的ID生成方案就可以很好的解决了UUID存在的这两个问题\n\n\n## numeric_limits\nnumeric_limits<double>::max ()是函数，返回编译器允许的 double 型数 最大值。\n类似的 numeric_limits<int>::max () 返回 编译器允许的 int 型数 最大值。\n需包含头文件 #include <limits>  imits是STL提供的头文件（包含numeric_limits模板类），limit.h是C语言提供的头文件（包含一些宏定义）\n\n\n## std::lock_guard\nlock_guard\n锁守卫是一个管理mutex对象的对象，使其始终处于锁定状态。\n在构造时，mutex对象被调用线程锁定，在销毁时，mutex被解锁。这是最简单的锁，作为一个自动持续时间的对象，它的作用特别大，可以持续到上下文结束。通过这种方式，它可以保证mutex对象在发生异常时被正确解锁。\n但请注意，lock_guard对象并不以任何方式管理mutex对象的寿命：mutex对象的持续时间至少应延长到锁定它的lock_guard被破坏为止。\n程序在std::lock_guard生命周期内加锁和解锁，其中加锁和解锁分别在构造函数和析构函数中完成，具体如何我们看下std::lock_guard的构造函数和析构函数。\n\n\n## cv::gpu::GpuMat\n\n\n## std::move\n\n\n\n## std::enable_shared_from_this\n在类的内部获取自己的 shared_ptr 这件事情而存在的。\n\n\n## std::chrono::duration\nstd::chrono::duration(下文简称duration)是标准库中用来代表时间段的一个类模板\n\n\n\n## std::unique_lock\n功能比std::unique_group更多\n\n\n## std::condition_variable\n condition_variable是一个类，搭配互斥量mutex来用，\n\n\n# C++17\n\n## 1.语法糖\n### 结构化绑定\n### 模板参数推导\n### constexpr if\n在编译时期就可以判断是否要用这个分支，根据输入的类型来判断分支的走向\n\n### if初始化语句\n可以像for一样，将一些变量的生命周期控制在if里面\n\n## 2.性能提升\n### shared_mutex\n\n### string_view\n在调用一些strcpy函数的时候，不会进行值传递，而是会复制引用\n\n\n### try_emplace\n在插入map之类的数组的时候，会先检查是否已经有元素存在了\n\n\n## 3.类型系统\n### any\n代替了空类型void*，变得类型安全了\n\n### optinal\n\n### variant\n\n## 4.其他\n\n### apply\n\n### make_from_tuple\n\n### [[nodiscard]]\n\n### 捕获*this\n\n## 结构化绑定\nauto [cur, pos] = qu.front();\nhttps://blog.csdn.net/yaoshenjie/article/details/99288495\n\n\n# 第三方库\n\n## httplib库简介\nhttplib库简介\nhttplib库是一个以C++11特性编写的库，所以编译器也需要能支持C++11的。库在使用时只需包含一个头文件即可，非常方便。\n\n下载地址\n\n注意：此库为线程阻塞，使用时还请注意\n\n##  jsoncpp库\n#include <json/json.h>\n\n\n# 注释规范\n\n@brief  @param  @return @author @date @version是代码书写的一种规范\n@brief  ：简介，简单介绍函数作用\n@param  ：介绍函数参数\n@return：函数返回类型说明\n@exception NSException 可能抛出的异常.\n@author zhangsan：  作者\n@date 2011-07-27 22:30:00 ：时间\n@version 1.0 ：版本  \n@property ：属性介绍\n\n\n\n# std::recursive_mutex\nrecursive_mutex\n\n\n\n# 精确到ns的计时方法\nstd::chrono\n\n# 参考文献：\n[C++ explicit 关键字]https://zhuanlan.zhihu.com/p/52152355\n[解决 VSCode 编写 C++11 代码报红问题]https://blog.csdn.net/weixin_42292229/article/details/113767569\n[C++11 带来的新特性 （3）—— 关键字noexcept]https://www.cnblogs.com/sword03/p/10020344.html\n[C++ limits头文件的用法numeric_limits]https://blog.csdn.net/CHYabc123456hh/article/details/117260306\n[C++中lock_guard的学习]https://blog.csdn.net/CHYabc123456hh/article/details/111317404\n[C++ std::lock_guard详解]https://jishuin.proginn.com/p/763bfbd6f671\n[一文详解OpenCV中的CUDA模块]https://zhuanlan.zhihu.com/p/358648337\n[「直播回放」腾讯工程师：C++17在业务代码中最好用的十个特性]https://www.zhihu.com/zvideo/1523417372937027584\n[Qt开源作品21-日志重定向输出类]https://www.cnblogs.com/feiyangqingyun/p/12970350.html\n[C++多线程之semaphore]https://blog.csdn.net/qq_41949047/article/details/108324225\n[C++11中enable_shared_from_this的用法解析]https://blog.csdn.net/breadheart/article/details/112451022\n[std::chrono::duration详解]https://blog.csdn.net/t114211200/article/details/78029553\n[C++ 11 多线程下std::unique_lock与std::lock_guard的区别和用法]http://t.zoukankan.com/moodlxs-p-10111843.html\n[C++ 条件变量(condition_variable)]https://cloud.tencent.com/developer/article/1584067\n[httplib库的使用(支持http/https)（一）]https://blog.csdn.net/harry49/article/details/115763383\n[注释规范：详细]https://www.cnblogs.com/lyggqm/p/4629711.html\n[注释规范]https://blog.csdn.net/lxj362343/article/details/105711524/\n[C++11 新的计时方法——std::chrono 大法好]https://blog.csdn.net/u013390476/article/details/50209603\n[C++模板全特化、偏特化]https://blog.csdn.net/m_buddy/article/details/72973207\n\n\n","content":"<h1 id=\"不会的知识点的罗列\"><a href=\"#不会的知识点的罗列\" class=\"headerlink\" title=\"不会的知识点的罗列\"></a>不会的知识点的罗列</h1><h1 id=\"C-11\"><a href=\"#C-11\" class=\"headerlink\" title=\"C++11\"></a>C++11</h1><h1 id=\"std-thread\"><a href=\"#std-thread\" class=\"headerlink\" title=\"std::thread\"></a>std::thread</h1><p>C++11中加入了&lt;thread&gt;头文件，此头文件主要声明了std::thread线程类</p>\n<h1 id=\"std-mutex\"><a href=\"#std-mutex\" class=\"headerlink\" title=\"std::mutex\"></a>std::mutex</h1><p>C++11中新增了&lt;mutex&gt;，它是C++标准程序库中的一个头文件，定义了C++11标准中的一些互斥访问的类与方法等</p>\n<h1 id=\"explicit\"><a href=\"#explicit\" class=\"headerlink\" title=\"explicit\"></a>explicit</h1><p>explicit构造函数是用来防止隐式转换的</p>\n<h1 id=\"noexcept\"><a href=\"#noexcept\" class=\"headerlink\" title=\"noexcept\"></a>noexcept</h1><p>从C++11开始，我们能看到很多代码当中都有关键字noexcept。比如下面就是std::initializer_list的默认构造函数，其中使用了noexcept。</p>\n<pre><code>  constexpr initializer_list() noexcept\n  : _M_array(0), _M_len(0) &#123; &#125;\n</code></pre>\n<p>该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。<br>如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。</p>\n<h2 id=\"Snowflake-雪花算法\"><a href=\"#Snowflake-雪花算法\" class=\"headerlink\" title=\"Snowflake 雪花算法\"></a>Snowflake 雪花算法</h2><p>分布式系统中ID生成方案，比较简单的是UUID（Universally Unique Identifier，通用唯一识别码），但是其存在两个明显的弊端：一、UUID是128位的，长度过长；二、UUID是完全随机的，无法生成递增有序的UUID。而现在流行的基于 Snowflake 雪花算法的ID生成方案就可以很好的解决了UUID存在的这两个问题</p>\n<h2 id=\"numeric-limits\"><a href=\"#numeric-limits\" class=\"headerlink\" title=\"numeric_limits\"></a>numeric_limits</h2><p>numeric_limits<double>::max ()是函数，返回编译器允许的 double 型数 最大值。<br>类似的 numeric_limits<int>::max () 返回 编译器允许的 int 型数 最大值。<br>需包含头文件 #include <limits>  imits是STL提供的头文件（包含numeric_limits模板类），limit.h是C语言提供的头文件（包含一些宏定义）</p>\n<h2 id=\"std-lock-guard\"><a href=\"#std-lock-guard\" class=\"headerlink\" title=\"std::lock_guard\"></a>std::lock_guard</h2><p>lock_guard<br>锁守卫是一个管理mutex对象的对象，使其始终处于锁定状态。<br>在构造时，mutex对象被调用线程锁定，在销毁时，mutex被解锁。这是最简单的锁，作为一个自动持续时间的对象，它的作用特别大，可以持续到上下文结束。通过这种方式，它可以保证mutex对象在发生异常时被正确解锁。<br>但请注意，lock_guard对象并不以任何方式管理mutex对象的寿命：mutex对象的持续时间至少应延长到锁定它的lock_guard被破坏为止。<br>程序在std::lock_guard生命周期内加锁和解锁，其中加锁和解锁分别在构造函数和析构函数中完成，具体如何我们看下std::lock_guard的构造函数和析构函数。</p>\n<h2 id=\"cv-gpu-GpuMat\"><a href=\"#cv-gpu-GpuMat\" class=\"headerlink\" title=\"cv::gpu::GpuMat\"></a>cv::gpu::GpuMat</h2><h2 id=\"std-move\"><a href=\"#std-move\" class=\"headerlink\" title=\"std::move\"></a>std::move</h2><h2 id=\"std-enable-shared-from-this\"><a href=\"#std-enable-shared-from-this\" class=\"headerlink\" title=\"std::enable_shared_from_this\"></a>std::enable_shared_from_this</h2><p>在类的内部获取自己的 shared_ptr 这件事情而存在的。</p>\n<h2 id=\"std-chrono-duration\"><a href=\"#std-chrono-duration\" class=\"headerlink\" title=\"std::chrono::duration\"></a>std::chrono::duration</h2><p>std::chrono::duration(下文简称duration)是标准库中用来代表时间段的一个类模板</p>\n<h2 id=\"std-unique-lock\"><a href=\"#std-unique-lock\" class=\"headerlink\" title=\"std::unique_lock\"></a>std::unique_lock</h2><p>功能比std::unique_group更多</p>\n<h2 id=\"std-condition-variable\"><a href=\"#std-condition-variable\" class=\"headerlink\" title=\"std::condition_variable\"></a>std::condition_variable</h2><p> condition_variable是一个类，搭配互斥量mutex来用，</p>\n<h1 id=\"C-17\"><a href=\"#C-17\" class=\"headerlink\" title=\"C++17\"></a>C++17</h1><h2 id=\"1-语法糖\"><a href=\"#1-语法糖\" class=\"headerlink\" title=\"1.语法糖\"></a>1.语法糖</h2><h3 id=\"结构化绑定\"><a href=\"#结构化绑定\" class=\"headerlink\" title=\"结构化绑定\"></a>结构化绑定</h3><h3 id=\"模板参数推导\"><a href=\"#模板参数推导\" class=\"headerlink\" title=\"模板参数推导\"></a>模板参数推导</h3><h3 id=\"constexpr-if\"><a href=\"#constexpr-if\" class=\"headerlink\" title=\"constexpr if\"></a>constexpr if</h3><p>在编译时期就可以判断是否要用这个分支，根据输入的类型来判断分支的走向</p>\n<h3 id=\"if初始化语句\"><a href=\"#if初始化语句\" class=\"headerlink\" title=\"if初始化语句\"></a>if初始化语句</h3><p>可以像for一样，将一些变量的生命周期控制在if里面</p>\n<h2 id=\"2-性能提升\"><a href=\"#2-性能提升\" class=\"headerlink\" title=\"2.性能提升\"></a>2.性能提升</h2><h3 id=\"shared-mutex\"><a href=\"#shared-mutex\" class=\"headerlink\" title=\"shared_mutex\"></a>shared_mutex</h3><h3 id=\"string-view\"><a href=\"#string-view\" class=\"headerlink\" title=\"string_view\"></a>string_view</h3><p>在调用一些strcpy函数的时候，不会进行值传递，而是会复制引用</p>\n<h3 id=\"try-emplace\"><a href=\"#try-emplace\" class=\"headerlink\" title=\"try_emplace\"></a>try_emplace</h3><p>在插入map之类的数组的时候，会先检查是否已经有元素存在了</p>\n<h2 id=\"3-类型系统\"><a href=\"#3-类型系统\" class=\"headerlink\" title=\"3.类型系统\"></a>3.类型系统</h2><h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><p>代替了空类型void*，变得类型安全了</p>\n<h3 id=\"optinal\"><a href=\"#optinal\" class=\"headerlink\" title=\"optinal\"></a>optinal</h3><h3 id=\"variant\"><a href=\"#variant\" class=\"headerlink\" title=\"variant\"></a>variant</h3><h2 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4.其他\"></a>4.其他</h2><h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><h3 id=\"make-from-tuple\"><a href=\"#make-from-tuple\" class=\"headerlink\" title=\"make_from_tuple\"></a>make_from_tuple</h3><h3 id=\"nodiscard\"><a href=\"#nodiscard\" class=\"headerlink\" title=\"[[nodiscard]]\"></a>[[nodiscard]]</h3><h3 id=\"捕获-this\"><a href=\"#捕获-this\" class=\"headerlink\" title=\"捕获*this\"></a>捕获*this</h3><h2 id=\"结构化绑定-1\"><a href=\"#结构化绑定-1\" class=\"headerlink\" title=\"结构化绑定\"></a>结构化绑定</h2><p>auto [cur, pos] &#x3D; qu.front();<br><a href=\"https://blog.csdn.net/yaoshenjie/article/details/99288495\">https://blog.csdn.net/yaoshenjie/article/details/99288495</a></p>\n<h1 id=\"第三方库\"><a href=\"#第三方库\" class=\"headerlink\" title=\"第三方库\"></a>第三方库</h1><h2 id=\"httplib库简介\"><a href=\"#httplib库简介\" class=\"headerlink\" title=\"httplib库简介\"></a>httplib库简介</h2><p>httplib库简介<br>httplib库是一个以C++11特性编写的库，所以编译器也需要能支持C++11的。库在使用时只需包含一个头文件即可，非常方便。</p>\n<p>下载地址</p>\n<p>注意：此库为线程阻塞，使用时还请注意</p>\n<h2 id=\"jsoncpp库\"><a href=\"#jsoncpp库\" class=\"headerlink\" title=\"jsoncpp库\"></a>jsoncpp库</h2><p>#include &lt;json&#x2F;json.h&gt;</p>\n<h1 id=\"注释规范\"><a href=\"#注释规范\" class=\"headerlink\" title=\"注释规范\"></a>注释规范</h1><p>@brief  @param  @return @author @date @version是代码书写的一种规范<br>@brief  ：简介，简单介绍函数作用<br>@param  ：介绍函数参数<br>@return：函数返回类型说明<br>@exception NSException 可能抛出的异常.<br>@author zhangsan：  作者<br>@date 2011-07-27 22:30:00 ：时间<br>@version 1.0 ：版本<br>@property ：属性介绍</p>\n<h1 id=\"std-recursive-mutex\"><a href=\"#std-recursive-mutex\" class=\"headerlink\" title=\"std::recursive_mutex\"></a>std::recursive_mutex</h1><p>recursive_mutex</p>\n<h1 id=\"精确到ns的计时方法\"><a href=\"#精确到ns的计时方法\" class=\"headerlink\" title=\"精确到ns的计时方法\"></a>精确到ns的计时方法</h1><p>std::chrono</p>\n<h1 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h1><p>[C++ explicit 关键字]<a href=\"https://zhuanlan.zhihu.com/p/52152355\">https://zhuanlan.zhihu.com/p/52152355</a><br>[解决 VSCode 编写 C++11 代码报红问题]<a href=\"https://blog.csdn.net/weixin_42292229/article/details/113767569\">https://blog.csdn.net/weixin_42292229/article/details/113767569</a><br>[C++11 带来的新特性 （3）—— 关键字noexcept]<a href=\"https://www.cnblogs.com/sword03/p/10020344.html\">https://www.cnblogs.com/sword03/p/10020344.html</a><br>[C++ limits头文件的用法numeric_limits]<a href=\"https://blog.csdn.net/CHYabc123456hh/article/details/117260306\">https://blog.csdn.net/CHYabc123456hh/article/details/117260306</a><br>[C++中lock_guard的学习]<a href=\"https://blog.csdn.net/CHYabc123456hh/article/details/111317404\">https://blog.csdn.net/CHYabc123456hh/article/details/111317404</a><br>[C++ std::lock_guard详解]<a href=\"https://jishuin.proginn.com/p/763bfbd6f671\">https://jishuin.proginn.com/p/763bfbd6f671</a><br>[一文详解OpenCV中的CUDA模块]<a href=\"https://zhuanlan.zhihu.com/p/358648337\">https://zhuanlan.zhihu.com/p/358648337</a><br>[「直播回放」腾讯工程师：C++17在业务代码中最好用的十个特性]<a href=\"https://www.zhihu.com/zvideo/1523417372937027584\">https://www.zhihu.com/zvideo/1523417372937027584</a><br>[Qt开源作品21-日志重定向输出类]<a href=\"https://www.cnblogs.com/feiyangqingyun/p/12970350.html\">https://www.cnblogs.com/feiyangqingyun/p/12970350.html</a><br>[C++多线程之semaphore]<a href=\"https://blog.csdn.net/qq_41949047/article/details/108324225\">https://blog.csdn.net/qq_41949047/article/details/108324225</a><br>[C++11中enable_shared_from_this的用法解析]<a href=\"https://blog.csdn.net/breadheart/article/details/112451022\">https://blog.csdn.net/breadheart/article/details/112451022</a><br>[std::chrono::duration详解]<a href=\"https://blog.csdn.net/t114211200/article/details/78029553\">https://blog.csdn.net/t114211200/article/details/78029553</a><br>[C++ 11 多线程下std::unique_lock与std::lock_guard的区别和用法]<a href=\"http://t.zoukankan.com/moodlxs-p-10111843.html\">http://t.zoukankan.com/moodlxs-p-10111843.html</a><br>[C++ 条件变量(condition_variable)]<a href=\"https://cloud.tencent.com/developer/article/1584067\">https://cloud.tencent.com/developer/article/1584067</a><br>[httplib库的使用(支持http&#x2F;https)（一）]<a href=\"https://blog.csdn.net/harry49/article/details/115763383\">https://blog.csdn.net/harry49/article/details/115763383</a><br>[注释规范：详细]<a href=\"https://www.cnblogs.com/lyggqm/p/4629711.html\">https://www.cnblogs.com/lyggqm/p/4629711.html</a><br>[注释规范]<a href=\"https://blog.csdn.net/lxj362343/article/details/105711524/\">https://blog.csdn.net/lxj362343/article/details/105711524/</a><br>[C++11 新的计时方法——std::chrono 大法好]<a href=\"https://blog.csdn.net/u013390476/article/details/50209603\">https://blog.csdn.net/u013390476/article/details/50209603</a><br>[C++模板全特化、偏特化]<a href=\"https://blog.csdn.net/m_buddy/article/details/72973207\">https://blog.csdn.net/m_buddy/article/details/72973207</a></p>\n","slug":"Grammar/Cpluspulus-Grammar","updated":"04/10/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/08/Grammar/Cpluspulus-Grammar/","excerpt":"","categories":[],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"vim 教程","date":"04/03/2022","path":"2022/03/04/Tutorial/vim-tutorial/","text":"第一部分：一般模式移动光标的方法 命令 解释 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 0 或功能键[Home] 移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 gg 移动到这个档案的第一行，相当于 1G (常用) n n 为数字。光标向下移动 n 行 搜索替换 命令 解释 &#x2F;word 向光标之下寻找一个名称为 word 的字符串 ?word 向光标之上寻找一个字符串名称为 word 的字符串 n 这个 n 是英文按键。代表重复前一个搜寻的动作 N 反向进行前一个搜寻动作 删除、复制与粘贴 命令 解释 dd 剪切游标所在的那一整行(常用) yy 复制游标所在的那一行(常用) p p 为将已复制的数据在光标下一行贴上 P P 则为贴在游标上一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 第二部分：一般模式切换到编辑模式 第三部分：一般模式切换到指令行模式 vim 环境的变更 命令 解释 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号 :set ff&#x3D;unix 改变vim文件中换行符的编码格式 复制粘贴全选（高亮显示）：按esc后，然后ggvG或者ggVG 全部复制：按esc后，然后ggyG 全部删除：按esc后，然后dG 解析： gg：是让光标移到首行，在vim才有效，vi中无效 v ： 是进入Visual(可视）模式 G ：光标移到最后一行 选中内容以后就可以其他的操作了，比如： d 删除选中内容 y 复制选中内容到0号寄存器 “+y 复制选中内容到＋寄存器，也就是系统的剪贴板，供其他程序用 全选（高亮显示）：按esc后，然后ggvG或者ggVG 全部复制：按esc后，然后ggyG 全部删除：按esc后，然后dGvim全选，全部复制，全部删除 https://blog.51cto.com/u_15127698/3564626https://www.runoob.com/linux/linux-vim.html","raw":"---\ntitle: vim 教程\ndate: 2022-03-04 15:01:03\ntags:\n- 教程\n---\n![VIM](https://s1.ax1x.com/2022/04/05/qXil1P.png)\n\n# 第一部分：一般模式\n## 移动光标的方法\n| 命令  | 解释 |\n| ------ | ------ |\n|[Ctrl] + [f]\t|屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)|\n|[Ctrl] + [b]\t|屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)|\n|[Ctrl] + [d]\t|屏幕『向下』移动半页|\n|[Ctrl] + [u]\t|屏幕『向上』移动半页|\n|h 或 向左箭头键(←) |\t光标向左移动一个字符|\n|j 或 向下箭头键(↓)\t|光标向下移动一个字符|\n|k 或 向上箭头键(↑)\t|光标向上移动一个字符|\n|l 或 向右箭头键(→)\t|光标向右移动一个字符|\n|0 或功能键[Home]\t|移动到这一行的最前面字符处 (常用)|\n|$ 或功能键[End]\t|移动到这一行的最后面字符处(常用)|\n|G\t|移动到这个档案的最后一行(常用)|\n|nG\tn |为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 |\n|gg|移动到这个档案的第一行，相当于 1G  (常用)|\n|n<Enter>\t|n 为数字。光标向下移动 n 行 |\n\n\n##  搜索替换\n| 命令 | 解释 |\n| ------ | ------ |\n|/word|\t向光标之下寻找一个名称为 word 的字符串|\n|?word\t|向光标之上寻找一个字符串名称为 word 的字符串|\n|n\t|这个 n 是英文按键。代表重复前一个搜寻的动作|\n|N\t|反向进行前一个搜寻动作|\n\n\n\n## 删除、复制与粘贴\n\n| 命令 | 解释 |\n| ------ | ------ |\n|dd\t|剪切游标所在的那一整行(常用)|\n|yy\t|复制游标所在的那一行(常用)|\n|p\t|p 为将已复制的数据在光标下一行贴上|\n|P      | P 则为贴在游标上一行|\n|c|\t重复删除多个数据，例如向下删除 10 行，[ 10cj ]|\n|u\t|复原前一个动作。(常用)|\n|[Ctrl]+r\t|重做上一个动作。(常用)|\n\n\n\n---\n# 第二部分：一般模式切换到编辑模式\n\n\n\n\n\n---\n# 第三部分：一般模式切换到指令行模式\n\n\n\n---\n\n# vim 环境的变更\n\n| 命令 | 解释 |\n| ------ | ------ |\n| :set nu| \t显示行号，设定之后，会在每一行的前缀显示该行的行号| \n| :set nonu\t| 与 set nu 相反，为取消行号| \n| :set ff=unix|改变vim文件中换行符的编码格式|\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---\n\n# 复制粘贴\n全选（高亮显示）：按esc后，然后ggvG或者ggVG\n\n全部复制：按esc后，然后ggyG\n\n全部删除：按esc后，然后dG\n\n\n解析：\n\ngg：是让光标移到首行，在vim才有效，vi中无效 \n\nv ： 是进入Visual(可视）模式 \n\nG ：光标移到最后一行 \n\n选中内容以后就可以其他的操作了，比如： \nd  删除选中内容 \ny  复制选中内容到0号寄存器 \n\"+y  复制选中内容到＋寄存器，也就是系统的剪贴板，供其他程序用 \n\n \n\n全选（高亮显示）：按esc后，然后ggvG或者ggVG\n\n全部复制：按esc后，然后ggyG\n\n全部删除：按esc后，然后dG\n-----------------------------------\nvim全选，全部复制，全部删除\n\n\n\n\n\n\nhttps://blog.51cto.com/u_15127698/3564626\nhttps://www.runoob.com/linux/linux-vim.html\n","content":"<p><img src=\"https://s1.ax1x.com/2022/04/05/qXil1P.png\" alt=\"VIM\"></p>\n<h1 id=\"第一部分：一般模式\"><a href=\"#第一部分：一般模式\" class=\"headerlink\" title=\"第一部分：一般模式\"></a>第一部分：一般模式</h1><h2 id=\"移动光标的方法\"><a href=\"#移动光标的方法\" class=\"headerlink\" title=\"移动光标的方法\"></a>移动光标的方法</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[Ctrl] + [f]</td>\n<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>\n</tr>\n<tr>\n<td>[Ctrl] + [b]</td>\n<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>\n</tr>\n<tr>\n<td>[Ctrl] + [d]</td>\n<td>屏幕『向下』移动半页</td>\n</tr>\n<tr>\n<td>[Ctrl] + [u]</td>\n<td>屏幕『向上』移动半页</td>\n</tr>\n<tr>\n<td>h 或 向左箭头键(←)</td>\n<td>光标向左移动一个字符</td>\n</tr>\n<tr>\n<td>j 或 向下箭头键(↓)</td>\n<td>光标向下移动一个字符</td>\n</tr>\n<tr>\n<td>k 或 向上箭头键(↑)</td>\n<td>光标向上移动一个字符</td>\n</tr>\n<tr>\n<td>l 或 向右箭头键(→)</td>\n<td>光标向右移动一个字符</td>\n</tr>\n<tr>\n<td>0 或功能键[Home]</td>\n<td>移动到这一行的最前面字符处 (常用)</td>\n</tr>\n<tr>\n<td>$ 或功能键[End]</td>\n<td>移动到这一行的最后面字符处(常用)</td>\n</tr>\n<tr>\n<td>G</td>\n<td>移动到这个档案的最后一行(常用)</td>\n</tr>\n<tr>\n<td>nG\tn</td>\n<td>为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20</td>\n</tr>\n<tr>\n<td>gg</td>\n<td>移动到这个档案的第一行，相当于 1G  (常用)</td>\n</tr>\n<tr>\n<td>n<Enter></td>\n<td>n 为数字。光标向下移动 n 行</td>\n</tr>\n</tbody></table>\n<h2 id=\"搜索替换\"><a href=\"#搜索替换\" class=\"headerlink\" title=\"搜索替换\"></a>搜索替换</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x2F;word</td>\n<td>向光标之下寻找一个名称为 word 的字符串</td>\n</tr>\n<tr>\n<td>?word</td>\n<td>向光标之上寻找一个字符串名称为 word 的字符串</td>\n</tr>\n<tr>\n<td>n</td>\n<td>这个 n 是英文按键。代表重复前一个搜寻的动作</td>\n</tr>\n<tr>\n<td>N</td>\n<td>反向进行前一个搜寻动作</td>\n</tr>\n</tbody></table>\n<h2 id=\"删除、复制与粘贴\"><a href=\"#删除、复制与粘贴\" class=\"headerlink\" title=\"删除、复制与粘贴\"></a>删除、复制与粘贴</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dd</td>\n<td>剪切游标所在的那一整行(常用)</td>\n</tr>\n<tr>\n<td>yy</td>\n<td>复制游标所在的那一行(常用)</td>\n</tr>\n<tr>\n<td>p</td>\n<td>p 为将已复制的数据在光标下一行贴上</td>\n</tr>\n<tr>\n<td>P</td>\n<td>P 则为贴在游标上一行</td>\n</tr>\n<tr>\n<td>c</td>\n<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>\n</tr>\n<tr>\n<td>u</td>\n<td>复原前一个动作。(常用)</td>\n</tr>\n<tr>\n<td>[Ctrl]+r</td>\n<td>重做上一个动作。(常用)</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"第二部分：一般模式切换到编辑模式\"><a href=\"#第二部分：一般模式切换到编辑模式\" class=\"headerlink\" title=\"第二部分：一般模式切换到编辑模式\"></a>第二部分：一般模式切换到编辑模式</h1><hr>\n<h1 id=\"第三部分：一般模式切换到指令行模式\"><a href=\"#第三部分：一般模式切换到指令行模式\" class=\"headerlink\" title=\"第三部分：一般模式切换到指令行模式\"></a>第三部分：一般模式切换到指令行模式</h1><hr>\n<h1 id=\"vim-环境的变更\"><a href=\"#vim-环境的变更\" class=\"headerlink\" title=\"vim 环境的变更\"></a>vim 环境的变更</h1><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>:set nu</td>\n<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>\n</tr>\n<tr>\n<td>:set nonu</td>\n<td>与 set nu 相反，为取消行号</td>\n</tr>\n<tr>\n<td>:set ff&#x3D;unix</td>\n<td>改变vim文件中换行符的编码格式</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"复制粘贴\"><a href=\"#复制粘贴\" class=\"headerlink\" title=\"复制粘贴\"></a>复制粘贴</h1><p>全选（高亮显示）：按esc后，然后ggvG或者ggVG</p>\n<p>全部复制：按esc后，然后ggyG</p>\n<p>全部删除：按esc后，然后dG</p>\n<p>解析：</p>\n<p>gg：是让光标移到首行，在vim才有效，vi中无效 </p>\n<p>v ： 是进入Visual(可视）模式 </p>\n<p>G ：光标移到最后一行 </p>\n<p>选中内容以后就可以其他的操作了，比如： <br>d  删除选中内容 <br>y  复制选中内容到0号寄存器 <br>“+y  复制选中内容到＋寄存器，也就是系统的剪贴板，供其他程序用 </p>\n<p> </p>\n<p>全选（高亮显示）：按esc后，然后ggvG或者ggVG</p>\n<p>全部复制：按esc后，然后ggyG</p>\n<h2 id=\"全部删除：按esc后，然后dG\"><a href=\"#全部删除：按esc后，然后dG\" class=\"headerlink\" title=\"全部删除：按esc后，然后dG\"></a>全部删除：按esc后，然后dG</h2><p>vim全选，全部复制，全部删除</p>\n<p><a href=\"https://blog.51cto.com/u_15127698/3564626\">https://blog.51cto.com/u_15127698/3564626</a><br><a href=\"https://www.runoob.com/linux/linux-vim.html\">https://www.runoob.com/linux/linux-vim.html</a></p>\n","slug":"Tutorial/vim-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/03/04/Tutorial/vim-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"如何阅读源码","date":"25/02/2022","path":"2022/02/25/Others/How-to-read-the-source-code/","text":"0.确定阅读源码的目的1.通过编译，能跑起来。有的时候环境比较复杂，搭建调试环境的时候就需要花很多时间。先通过搜索把调试环境搭建起来，这一步就能积累很多经验。 2.精简调试环境，减少干扰信息python用pycharmC\\C++类的代码，使用Vim+Ctags+Cscope来 3.调试手段 加调试语句。为了做到这一点，你需要先了解项目如何加调试日志，可能需要修改项目的日志级别支持输出一些在调试级别的日志，等等。 断点调试。并不是所有项目代码，跑起来之后都自带调试信息能够断点调试的。所以在自己的调试环境里需要先确定这一点。 利用好测试用例好的项目都会自带不少用例，这类型的例子有：etcd、google出品的几个开源项目。 如果测试用例写的很仔细，那么很值得好好去研究一下。原因在于：测试用例往往是针对某个单一的场景，独自构造出一些数据来对程序的流程进行验证。所以，其实跟前面的“情景分析”一样，都是让你从大的项目转而关注具体某个场景的手段之一。 厘清核心数据结构之间的关系虽然说“程序设计&#x3D;算法+数据结构”，然后我实际中的体会，数据结构更加重要。 因为结构定义了一个程序的架构，结构定下来了才有具体的实现。 Linus说： “烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。” 因此，在阅读一份代码时，厘清核心的数据结构之间的关系尤其重要。这个时候，需要使用一些工具来画一下这些结构之间的关系，我的源码分析类博客中有很多这样的例子，比如《Leveldb代码阅读笔记》、《Etcd存储的实现》等等。 需要说明的是，情景分析、厘清核心数据结构这两步并没有严格的顺序关系，不见得是先做某事再做某事，而是交互进行的。 比如，你如果现在刚接手某个项目，需要简单的了解一下项目，可以先阅读代码了解都有哪些核心数据结构。理解了之后，如果不清楚某些情景下的流程，可以使用情景分析法。总而言之，交替进行直到解答你的疑问为止。 3整体和细节阅读代码的过程中，需要在整体和细节之间做权衡。 比如，有时候你需要大体了解一个整体的框架、轮廓、流程之后，才能再针对具体的细节深入进去。这个时候，不宜针对具体的函数实现、算法等深入分析。而细节的分析，又不能缺少，否则一些东西的理解又流于表面。 所以，如何把握整体和细节是一个需要累积阅读代码经验才能把握好的。我的建议是：过程中还是以整体为首，在不理解整体的前提之前，不要太过深入某个细节。把某个函数、数据结构当成一个黑盒，知道它们的输入、输出就好，只要不影响整体的理解就暂且放下接着往前看。 3多问自己几个问题学习的过程中离不开交互。 如果阅读代码只是输入（Input），那么还需要有输出（Output）。只有简单的输入好比喂东西给你吃，而只有更好的消化才能变为自己的营养，而输出就是更好消化知识的重要手段。 其实这个思想很常见，比如学生上课（Input）了需要做练习作业（Output），比如学了算法（Input）需要自己编码练习（Output），等等。简而言之，输出是学习过程中的一种及时反馈，质量越高学习效率越高。 输出的手段有很多，在阅读代码时，比较建议的是自己能够多问自己一些问题，比如： 为什么选择这个数据结构来描述这个问题？类似的场景下，其他项目是怎么设计的？都有哪些数据结构做这样的事情？如果由我来设计这样的项目，我会怎么做？等等等等。越是主动积极的思考，就越有更好的输出，输出质量与学习质量成正比关系。 4.写自己的代码阅读笔记我从开始写博客，就是写不少各种项目的代码解读类文章，网名“codedump”也源于想把“code内部的实现原理dump出来”之意。 前面提到学习质量与输出质量成正比关系，这是我自己的深刻体会。也因为如此，所以才要坚持阅读源码之后写自己的分析类笔记。 写这类笔记，有以下几个需要注意的地方。 虽然是笔记，但是要想象着在向一个不太熟悉这个项目的人讲解原理，或者想象一下是几个月甚至几年后的自己回头来看这个文章。在这种情况下，会尽量的把语言组织好，循循善诱的解释。 尽量避免大段的贴代码。我认为在这类文章中，大段贴上代码有点自欺欺人：就是看上去自己懂了，其实并不见得。如果真要解释某段代码，可以使用伪代码或者缩减代码的方式。记住：不要自欺欺人，要真的懂了。如果真的想在代码上加上自己的注释，我有一个建议是fork出来一份该项目某个版本的代码，提交到自己的github上，上面随时可以加上自己的注释并且保存提交。比如我自己注释的etcd 3.1.10代码：etcd-3.1.10-codedump，类似的我阅读的其他项目都会在github上fork出一个带上codedump后缀的项目。 多画图，一图胜千言，使用图形展示代码流程、数据结构之间的关系。我最近才发现画图能力也是很重要的能力，自己在从头学习如何使用图像来表达自己的想法。 写作是很重要的基础能力，我一个朋友最近教育我，大体的意思是说：如果你在某方面的能力很强，如果再加上写作好、英语好，那么将极大放大你在这方面的能力。而类似写作、英语这样的底层基础能力，不是一撮而就的，需要长时间保持练习才可以。而写博客，对于技术人员而言，就是一种很好的锻炼写作的手段。 必须找好切入点。你要解决什么问题。是要fix bug；还是要把这个系统和其它模块集成；还是要增加新功能。物理学家没有上来就研究整个宇宙的，必须选好分支。如果你有一个猜想，但是又和你的目标关联不太大，那就坚持这个猜想，直到出现明显反例。物理学有很多这样的例子，和数学不同，为了旁支猜想投入过多研究是不明智的。如果有明显证据证明你的某个旁支猜想大错特错，你就要放弃主要目标，暂时把解决旁支猜想作为主要目标。比如，你本来以为某个结构是LRU的cache，结果发现怎么做都不对，那就先放弃原来的目标，专门研究这个结构的用途。对于旁支猜想的不断切换，要做好自己的task stack保留。在旁支猜想解决之后，要根据结论尽快回到上次中断的任务。 很简单的第一，找准入口出口，不要直接跳进去看，任何代码都有触发点，无论是http request，还是服务器自动启动，还是main函数，还是其他的，先从入口开始。第二，手边一支笔一张纸，除非你是Jeff，否则你不会记得那么多跳转的。一个跳转就写下来函数&#x2F;方法名和参数，读完一遍，就有了一个sequence diagram雏形第三，私有方法掠过，只要记住输入输出即可，无需看具体实现 常见的困难在阅读源代码的过程中，会遇到不少的困难，常见的有： 成熟的开源项目往往自身的代码量很大，盲目地从入口文件开始阅读，会陷入到各种代码分支上，耗费大量时间不说，收获也甚微。代码难以看懂，不清楚来龙去脉。本人在阅读源代码的时候，走了不少的弯路，结合自己的实践谈谈自己是如何克服上述的困难。 阅读的目的首先，做一件事件，要先明确目的。目的可以起到指引的作用，同时也可以检验自己是否已经完成。 阅读源代码也不例外。阅读源代码的目的可能是： 了解源代码的目录结构，学习开源项目是如何组织代码开源项目有某些强大的功能，阅读源代码了解实现细节，以便更加全面的掌握。在使用开源项目时，遇到一些问题，边阅读源码，边debug其他漫无目的的看源代码一般难以有收获。 事先准备如果目的是通过阅读源代码，加深对技术细节的理解，做好以下几步，可以降低阅读源码的难度。 了解这门技术的历史，搞清楚这门技术是为了解决什么样的问题而发展起来的。了解技术的架构，概念。优秀的开源项目源码实现和技术架构，概念都有清晰的联系。如果没有在实际运用中使用过该技术，建议还是仔细阅读官网上的start指引，编写运行几个小的demo。准备问题，试着在阅读官网文档或者编写demo的过程中提出几个问题，当然也可以参考别人提出的问题（常见的面试题也是不错的）。在github上clone该项目到本地，保留项目完整的commit和tag。 硬核课堂，源码阅读方法来自B站的硬核课堂 第一步：环境搭建1. 源码运行环境克隆源码下来之后，必须要保证源码正常编译运行 2. 源码阅读工具如需要支持函数之间的跳转，如vim&#x2F;vscode&#x2F;code-server&#x2F;source insight等，适合自己的就行；gdb调试工具等 第二步：阅读项目文档，熟悉项目阅读项目文档，主要是对项目有个整体的认知，不要一开始拘泥细节，包括： 项目简介 背景知识：这部分不清楚的，可以先去补充一下，比如leveldb涉及到的lsm树，不熟悉的，可以先去看看lsm相关知识 整体架构 第三步：编译并运行源码将源码以debug的方式(Leveldb源码解读(一) )编译&#x2F;运行起来，以debug的方式，目的方便我们调试 第四步：更深入进行阅读 gdb跟踪我们的单元测试(常见的命令如，bt&#x2F;b&#x2F;p&#x2F;n&#x2F;s,layout src等) 自己编写测试用例 如果此时还是摸不着头脑，要学会站在“巨人”的肩膀上，借助网络的力量，去看看前人写的文章，去问问别人，来打开思路，慢慢形成自己的方法 多使用日志大法，多线程等场景可能使用gdb不太方便，我们完全可以在源码中添加自己的日志 涉及到网络相关的项目如redis，我在阅读源码时，也会借助tcpdump工具来抓包验证是否自己的理解正确 第五步：重复和总结 我们没有过目不忘和无所不知的本领，因此源码阅读应该是一个心平气和和重复循环的过程(多看几遍总是有好处的) 要有沉淀，可以记笔记&#x2F;录制视频，能把别人讲清楚，那你自己肯定清楚了 可以想想如何将源码中知识点应用到我们自己的项目中来 我自己阅读了leveldb之后，将sst中的差值压缩思想应用项目中，存储压缩比大约30%+ 命名更人性化 参考链接https://www.codedump.info/post/20190324-how-to-read-code/https://www.zhihu.com/question/19625320/answer/12429108https://www.zhihu.com/question/19625320/answer/307133854https://github.com/zhangguixu/myblogs/issues/4[英文能力与独立思考]https://www.raychase.net/6902[分享个人阅读源码的方法]https://www.bilibili.com/video/BV1w34y1p7V7/?spm_id_from=333.999.0.0&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca[LevelDB 源码分析]https://hardcore.feishu.cn/mindnotes/bmncnzpUmXNQruVGOwRwisHyxoh","raw":"---\ntitle: 如何阅读源码\ndate: 2022-02-25 12:44:36\ntags:\n- 其他\n---\n\n# 0.确定阅读源码的目的\n\n1.通过编译，能跑起来。\n有的时候环境比较复杂，搭建调试环境的时候就需要花很多时间。\n先通过搜索把调试环境搭建起来，这一步就能积累很多经验。\n\n\n\n2.精简调试环境，减少干扰信息\npython用pycharm\nC\\C++类的代码，使用Vim+Ctags+Cscope来\n\n3.调试手段\n\n- 加调试语句。为了做到这一点，你需要先了解项目如何加调试日志，可能需要修改项目的日志级别支持输出一些在调试级别的日志，等等。\n\n- 断点调试。并不是所有项目代码，跑起来之后都自带调试信息能够断点调试的。所以在自己的调试环境里需要先确定这一点。\n\n# 利用好测试用例\n好的项目都会自带不少用例，这类型的例子有：etcd、google出品的几个开源项目。\n\n如果测试用例写的很仔细，那么很值得好好去研究一下。原因在于：测试用例往往是针对某个单一的场景，独自构造出一些数据来对程序的流程进行验证。所以，其实跟前面的“情景分析”一样，都是让你从大的项目转而关注具体某个场景的手段之一。\n\n# 厘清核心数据结构之间的关系\n虽然说“程序设计=算法+数据结构”，然后我实际中的体会，数据结构更加重要。\n\n因为结构定义了一个程序的架构，结构定下来了才有具体的实现。\n\nLinus说： “烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。”\n\n因此，在阅读一份代码时，厘清核心的数据结构之间的关系尤其重要。这个时候，需要使用一些工具来画一下这些结构之间的关系，我的源码分析类博客中有很多这样的例子，比如《Leveldb代码阅读笔记》、《Etcd存储的实现》等等。\n\n需要说明的是，情景分析、厘清核心数据结构这两步并没有严格的顺序关系，不见得是先做某事再做某事，而是交互进行的。\n\n比如，你如果现在刚接手某个项目，需要简单的了解一下项目，可以先阅读代码了解都有哪些核心数据结构。理解了之后，如果不清楚某些情景下的流程，可以使用情景分析法。总而言之，交替进行直到解答你的疑问为止。\n\n\n# 3整体和细节\n阅读代码的过程中，需要在整体和细节之间做权衡。\n\n比如，有时候你需要大体了解一个整体的框架、轮廓、流程之后，才能再针对具体的细节深入进去。这个时候，不宜针对具体的函数实现、算法等深入分析。而细节的分析，又不能缺少，否则一些东西的理解又流于表面。\n\n所以，如何把握整体和细节是一个需要累积阅读代码经验才能把握好的。我的建议是：过程中还是以整体为首，在不理解整体的前提之前，不要太过深入某个细节。把某个函数、数据结构当成一个黑盒，知道它们的输入、输出就好，只要不影响整体的理解就暂且放下接着往前看。\n\n# 3多问自己几个问题\n学习的过程中离不开交互。\n\n如果阅读代码只是输入（Input），那么还需要有输出（Output）。只有简单的输入好比喂东西给你吃，而只有更好的消化才能变为自己的营养，而输出就是更好消化知识的重要手段。\n\n其实这个思想很常见，比如学生上课（Input）了需要做练习作业（Output），比如学了算法（Input）需要自己编码练习（Output），等等。简而言之，输出是学习过程中的一种及时反馈，质量越高学习效率越高。\n\n输出的手段有很多，在阅读代码时，比较建议的是自己能够多问自己一些问题，比如：\n\n为什么选择这个数据结构来描述这个问题？类似的场景下，其他项目是怎么设计的？都有哪些数据结构做这样的事情？\n如果由我来设计这样的项目，我会怎么做？\n等等等等。越是主动积极的思考，就越有更好的输出，输出质量与学习质量成正比关系。\n\n\n4.写自己的代码阅读笔记\n我从开始写博客，就是写不少各种项目的代码解读类文章，网名“codedump”也源于想把“code内部的实现原理dump出来”之意。\n\n前面提到学习质量与输出质量成正比关系，这是我自己的深刻体会。也因为如此，所以才要坚持阅读源码之后写自己的分析类笔记。\n\n写这类笔记，有以下几个需要注意的地方。\n\n虽然是笔记，但是要想象着在向一个不太熟悉这个项目的人讲解原理，或者想象一下是几个月甚至几年后的自己回头来看这个文章。在这种情况下，会尽量的把语言组织好，循循善诱的解释。\n\n尽量避免大段的贴代码。我认为在这类文章中，大段贴上代码有点自欺欺人：就是看上去自己懂了，其实并不见得。如果真要解释某段代码，可以使用伪代码或者缩减代码的方式。记住：不要自欺欺人，要真的懂了。如果真的想在代码上加上自己的注释，我有一个建议是fork出来一份该项目某个版本的代码，提交到自己的github上，上面随时可以加上自己的注释并且保存提交。比如我自己注释的etcd 3.1.10代码：etcd-3.1.10-codedump，类似的我阅读的其他项目都会在github上fork出一个带上codedump后缀的项目。\n\n多画图，一图胜千言，使用图形展示代码流程、数据结构之间的关系。我最近才发现画图能力也是很重要的能力，自己在从头学习如何使用图像来表达自己的想法。\n\n写作是很重要的基础能力，我一个朋友最近教育我，大体的意思是说：如果你在某方面的能力很强，如果再加上写作好、英语好，那么将极大放大你在这方面的能力。而类似写作、英语这样的底层基础能力，不是一撮而就的，需要长时间保持练习才可以。而写博客，对于技术人员而言，就是一种很好的锻炼写作的手段。\n\n\n必须找好切入点。你要解决什么问题。是要fix bug；还是要把这个系统和其它模块集成；还是要增加新功能。物理学家没有上来就研究整个宇宙的，必须选好分支。如果你有一个猜想，但是又和你的目标关联不太大，那就坚持这个猜想，直到出现明显反例。物理学有很多这样的例子，和数学不同，为了旁支猜想投入过多研究是不明智的。如果有明显证据证明你的某个旁支猜想大错特错，你就要放弃主要目标，暂时把解决旁支猜想作为主要目标。比如，你本来以为某个结构是LRU的cache，结果发现怎么做都不对，那就先放弃原来的目标，专门研究这个结构的用途。对于旁支猜想的不断切换，要做好自己的task stack保留。在旁支猜想解决之后，要根据结论尽快回到上次中断的任务。\n\n\n很简单的第一，找准入口出口，不要直接跳进去看，任何代码都有触发点，无论是http request，还是服务器自动启动，还是main函数，还是其他的，先从入口开始。第二，手边一支笔一张纸，除非你是Jeff，否则你不会记得那么多跳转的。一个跳转就写下来函数/方法名和参数，读完一遍，就有了一个sequence diagram雏形第三，私有方法掠过，只要记住输入输出即可，无需看具体实现\n\n\n常见的困难\n在阅读源代码的过程中，会遇到不少的困难，常见的有：\n\n成熟的开源项目往往自身的代码量很大，盲目地从入口文件开始阅读，会陷入到各种代码分支上，耗费大量时间不说，收获也甚微。\n代码难以看懂，不清楚来龙去脉。\n本人在阅读源代码的时候，走了不少的弯路，结合自己的实践谈谈自己是如何克服上述的困难。\n\n阅读的目的\n首先，做一件事件，要先明确目的。目的可以起到指引的作用，同时也可以检验自己是否已经完成。\n\n阅读源代码也不例外。阅读源代码的目的可能是：\n\n了解源代码的目录结构，学习开源项目是如何组织代码\n开源项目有某些强大的功能，阅读源代码了解实现细节，以便更加全面的掌握。\n在使用开源项目时，遇到一些问题，边阅读源码，边debug\n其他\n漫无目的的看源代码一般难以有收获。\n\n事先准备\n如果目的是通过阅读源代码，加深对技术细节的理解，做好以下几步，可以降低阅读源码的难度。\n\n了解这门技术的历史，搞清楚这门技术是为了解决什么样的问题而发展起来的。\n了解技术的架构，概念。优秀的开源项目源码实现和技术架构，概念都有清晰的联系。\n如果没有在实际运用中使用过该技术，建议还是仔细阅读官网上的start指引，编写运行几个小的demo。\n准备问题，试着在阅读官网文档或者编写demo的过程中提出几个问题，当然也可以参考别人提出的问题（常见的面试题也是不错的）。\n在github上clone该项目到本地，保留项目完整的commit和tag。\n\n\n\n\n# 硬核课堂，源码阅读方法\n来自B站的硬核课堂\n## 第一步：环境搭建\n### 1. 源码运行环境\n克隆源码下来之后，必须要保证源码正常编译运行\n### 2. 源码阅读工具\n如需要支持函数之间的跳转，如vim/vscode/code-server/source insight等，适合自己的就行；\ngdb调试工具等\n## 第二步：阅读项目文档，熟悉项目\n阅读项目文档，主要是对项目有个整体的认知，不要一开始拘泥细节，包括：\n- 项目简介\n- 背景知识：这部分不清楚的，可以先去补充一下，比如leveldb涉及到的lsm树，不熟悉的，可以先去看看lsm相关知识\n- 整体架构\n## 第三步：编译并运行源码\n将源码以debug的方式(Leveldb源码解读(一) )编译/运行起来，以debug的方式，目的方便我们调试\n## 第四步：更深入进行阅读\n1. gdb跟踪我们的单元测试(常见的命令如，bt/b/p/n/s,layout src等)\n2. 自己编写测试用例\n3. 如果此时还是摸不着头脑，要学会站在“巨人”的肩膀上，借助网络的力量，去看看前人写的文章，去问问别人，来打开思路，慢慢形成自己的方法\n4. 多使用日志大法，多线程等场景可能使用gdb不太方便，我们完全可以在源码中添加自己的日志\n5. 涉及到网络相关的项目如redis，我在阅读源码时，也会借助tcpdump工具来抓包验证是否自己的理解正确\n## 第五步：重复和总结\n1. 我们没有过目不忘和无所不知的本领，因此源码阅读应该是一个心平气和和重复循环的过程(多看几遍总是有好处的)\n2. 要有沉淀，可以记笔记/录制视频，能把别人讲清楚，那你自己肯定清楚了\n3. 可以想想如何将源码中知识点应用到我们自己的项目中来\n  1. 我自己阅读了leveldb之后，将sst中的差值压缩思想应用项目中，存储压缩比大约30%+\n  2. 命名更人性化\n\n## 参考链接\nhttps://www.codedump.info/post/20190324-how-to-read-code/\nhttps://www.zhihu.com/question/19625320/answer/12429108\nhttps://www.zhihu.com/question/19625320/answer/307133854\nhttps://github.com/zhangguixu/myblogs/issues/4\n[英文能力与独立思考]https://www.raychase.net/6902\n[分享个人阅读源码的方法]https://www.bilibili.com/video/BV1w34y1p7V7/?spm_id_from=333.999.0.0&vd_source=76dff3ae3b42b00d067c0921bf6859ca     \n[LevelDB 源码分析]https://hardcore.feishu.cn/mindnotes/bmncnzpUmXNQruVGOwRwisHyxoh","content":"<h1 id=\"0-确定阅读源码的目的\"><a href=\"#0-确定阅读源码的目的\" class=\"headerlink\" title=\"0.确定阅读源码的目的\"></a>0.确定阅读源码的目的</h1><p>1.通过编译，能跑起来。<br>有的时候环境比较复杂，搭建调试环境的时候就需要花很多时间。<br>先通过搜索把调试环境搭建起来，这一步就能积累很多经验。</p>\n<p>2.精简调试环境，减少干扰信息<br>python用pycharm<br>C\\C++类的代码，使用Vim+Ctags+Cscope来</p>\n<p>3.调试手段</p>\n<ul>\n<li><p>加调试语句。为了做到这一点，你需要先了解项目如何加调试日志，可能需要修改项目的日志级别支持输出一些在调试级别的日志，等等。</p>\n</li>\n<li><p>断点调试。并不是所有项目代码，跑起来之后都自带调试信息能够断点调试的。所以在自己的调试环境里需要先确定这一点。</p>\n</li>\n</ul>\n<h1 id=\"利用好测试用例\"><a href=\"#利用好测试用例\" class=\"headerlink\" title=\"利用好测试用例\"></a>利用好测试用例</h1><p>好的项目都会自带不少用例，这类型的例子有：etcd、google出品的几个开源项目。</p>\n<p>如果测试用例写的很仔细，那么很值得好好去研究一下。原因在于：测试用例往往是针对某个单一的场景，独自构造出一些数据来对程序的流程进行验证。所以，其实跟前面的“情景分析”一样，都是让你从大的项目转而关注具体某个场景的手段之一。</p>\n<h1 id=\"厘清核心数据结构之间的关系\"><a href=\"#厘清核心数据结构之间的关系\" class=\"headerlink\" title=\"厘清核心数据结构之间的关系\"></a>厘清核心数据结构之间的关系</h1><p>虽然说“程序设计&#x3D;算法+数据结构”，然后我实际中的体会，数据结构更加重要。</p>\n<p>因为结构定义了一个程序的架构，结构定下来了才有具体的实现。</p>\n<p>Linus说： “烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。”</p>\n<p>因此，在阅读一份代码时，厘清核心的数据结构之间的关系尤其重要。这个时候，需要使用一些工具来画一下这些结构之间的关系，我的源码分析类博客中有很多这样的例子，比如《Leveldb代码阅读笔记》、《Etcd存储的实现》等等。</p>\n<p>需要说明的是，情景分析、厘清核心数据结构这两步并没有严格的顺序关系，不见得是先做某事再做某事，而是交互进行的。</p>\n<p>比如，你如果现在刚接手某个项目，需要简单的了解一下项目，可以先阅读代码了解都有哪些核心数据结构。理解了之后，如果不清楚某些情景下的流程，可以使用情景分析法。总而言之，交替进行直到解答你的疑问为止。</p>\n<h1 id=\"3整体和细节\"><a href=\"#3整体和细节\" class=\"headerlink\" title=\"3整体和细节\"></a>3整体和细节</h1><p>阅读代码的过程中，需要在整体和细节之间做权衡。</p>\n<p>比如，有时候你需要大体了解一个整体的框架、轮廓、流程之后，才能再针对具体的细节深入进去。这个时候，不宜针对具体的函数实现、算法等深入分析。而细节的分析，又不能缺少，否则一些东西的理解又流于表面。</p>\n<p>所以，如何把握整体和细节是一个需要累积阅读代码经验才能把握好的。我的建议是：过程中还是以整体为首，在不理解整体的前提之前，不要太过深入某个细节。把某个函数、数据结构当成一个黑盒，知道它们的输入、输出就好，只要不影响整体的理解就暂且放下接着往前看。</p>\n<h1 id=\"3多问自己几个问题\"><a href=\"#3多问自己几个问题\" class=\"headerlink\" title=\"3多问自己几个问题\"></a>3多问自己几个问题</h1><p>学习的过程中离不开交互。</p>\n<p>如果阅读代码只是输入（Input），那么还需要有输出（Output）。只有简单的输入好比喂东西给你吃，而只有更好的消化才能变为自己的营养，而输出就是更好消化知识的重要手段。</p>\n<p>其实这个思想很常见，比如学生上课（Input）了需要做练习作业（Output），比如学了算法（Input）需要自己编码练习（Output），等等。简而言之，输出是学习过程中的一种及时反馈，质量越高学习效率越高。</p>\n<p>输出的手段有很多，在阅读代码时，比较建议的是自己能够多问自己一些问题，比如：</p>\n<p>为什么选择这个数据结构来描述这个问题？类似的场景下，其他项目是怎么设计的？都有哪些数据结构做这样的事情？<br>如果由我来设计这样的项目，我会怎么做？<br>等等等等。越是主动积极的思考，就越有更好的输出，输出质量与学习质量成正比关系。</p>\n<p>4.写自己的代码阅读笔记<br>我从开始写博客，就是写不少各种项目的代码解读类文章，网名“codedump”也源于想把“code内部的实现原理dump出来”之意。</p>\n<p>前面提到学习质量与输出质量成正比关系，这是我自己的深刻体会。也因为如此，所以才要坚持阅读源码之后写自己的分析类笔记。</p>\n<p>写这类笔记，有以下几个需要注意的地方。</p>\n<p>虽然是笔记，但是要想象着在向一个不太熟悉这个项目的人讲解原理，或者想象一下是几个月甚至几年后的自己回头来看这个文章。在这种情况下，会尽量的把语言组织好，循循善诱的解释。</p>\n<p>尽量避免大段的贴代码。我认为在这类文章中，大段贴上代码有点自欺欺人：就是看上去自己懂了，其实并不见得。如果真要解释某段代码，可以使用伪代码或者缩减代码的方式。记住：不要自欺欺人，要真的懂了。如果真的想在代码上加上自己的注释，我有一个建议是fork出来一份该项目某个版本的代码，提交到自己的github上，上面随时可以加上自己的注释并且保存提交。比如我自己注释的etcd 3.1.10代码：etcd-3.1.10-codedump，类似的我阅读的其他项目都会在github上fork出一个带上codedump后缀的项目。</p>\n<p>多画图，一图胜千言，使用图形展示代码流程、数据结构之间的关系。我最近才发现画图能力也是很重要的能力，自己在从头学习如何使用图像来表达自己的想法。</p>\n<p>写作是很重要的基础能力，我一个朋友最近教育我，大体的意思是说：如果你在某方面的能力很强，如果再加上写作好、英语好，那么将极大放大你在这方面的能力。而类似写作、英语这样的底层基础能力，不是一撮而就的，需要长时间保持练习才可以。而写博客，对于技术人员而言，就是一种很好的锻炼写作的手段。</p>\n<p>必须找好切入点。你要解决什么问题。是要fix bug；还是要把这个系统和其它模块集成；还是要增加新功能。物理学家没有上来就研究整个宇宙的，必须选好分支。如果你有一个猜想，但是又和你的目标关联不太大，那就坚持这个猜想，直到出现明显反例。物理学有很多这样的例子，和数学不同，为了旁支猜想投入过多研究是不明智的。如果有明显证据证明你的某个旁支猜想大错特错，你就要放弃主要目标，暂时把解决旁支猜想作为主要目标。比如，你本来以为某个结构是LRU的cache，结果发现怎么做都不对，那就先放弃原来的目标，专门研究这个结构的用途。对于旁支猜想的不断切换，要做好自己的task stack保留。在旁支猜想解决之后，要根据结论尽快回到上次中断的任务。</p>\n<p>很简单的第一，找准入口出口，不要直接跳进去看，任何代码都有触发点，无论是http request，还是服务器自动启动，还是main函数，还是其他的，先从入口开始。第二，手边一支笔一张纸，除非你是Jeff，否则你不会记得那么多跳转的。一个跳转就写下来函数&#x2F;方法名和参数，读完一遍，就有了一个sequence diagram雏形第三，私有方法掠过，只要记住输入输出即可，无需看具体实现</p>\n<p>常见的困难<br>在阅读源代码的过程中，会遇到不少的困难，常见的有：</p>\n<p>成熟的开源项目往往自身的代码量很大，盲目地从入口文件开始阅读，会陷入到各种代码分支上，耗费大量时间不说，收获也甚微。<br>代码难以看懂，不清楚来龙去脉。<br>本人在阅读源代码的时候，走了不少的弯路，结合自己的实践谈谈自己是如何克服上述的困难。</p>\n<p>阅读的目的<br>首先，做一件事件，要先明确目的。目的可以起到指引的作用，同时也可以检验自己是否已经完成。</p>\n<p>阅读源代码也不例外。阅读源代码的目的可能是：</p>\n<p>了解源代码的目录结构，学习开源项目是如何组织代码<br>开源项目有某些强大的功能，阅读源代码了解实现细节，以便更加全面的掌握。<br>在使用开源项目时，遇到一些问题，边阅读源码，边debug<br>其他<br>漫无目的的看源代码一般难以有收获。</p>\n<p>事先准备<br>如果目的是通过阅读源代码，加深对技术细节的理解，做好以下几步，可以降低阅读源码的难度。</p>\n<p>了解这门技术的历史，搞清楚这门技术是为了解决什么样的问题而发展起来的。<br>了解技术的架构，概念。优秀的开源项目源码实现和技术架构，概念都有清晰的联系。<br>如果没有在实际运用中使用过该技术，建议还是仔细阅读官网上的start指引，编写运行几个小的demo。<br>准备问题，试着在阅读官网文档或者编写demo的过程中提出几个问题，当然也可以参考别人提出的问题（常见的面试题也是不错的）。<br>在github上clone该项目到本地，保留项目完整的commit和tag。</p>\n<h1 id=\"硬核课堂，源码阅读方法\"><a href=\"#硬核课堂，源码阅读方法\" class=\"headerlink\" title=\"硬核课堂，源码阅读方法\"></a>硬核课堂，源码阅读方法</h1><p>来自B站的硬核课堂</p>\n<h2 id=\"第一步：环境搭建\"><a href=\"#第一步：环境搭建\" class=\"headerlink\" title=\"第一步：环境搭建\"></a>第一步：环境搭建</h2><h3 id=\"1-源码运行环境\"><a href=\"#1-源码运行环境\" class=\"headerlink\" title=\"1. 源码运行环境\"></a>1. 源码运行环境</h3><p>克隆源码下来之后，必须要保证源码正常编译运行</p>\n<h3 id=\"2-源码阅读工具\"><a href=\"#2-源码阅读工具\" class=\"headerlink\" title=\"2. 源码阅读工具\"></a>2. 源码阅读工具</h3><p>如需要支持函数之间的跳转，如vim&#x2F;vscode&#x2F;code-server&#x2F;source insight等，适合自己的就行；<br>gdb调试工具等</p>\n<h2 id=\"第二步：阅读项目文档，熟悉项目\"><a href=\"#第二步：阅读项目文档，熟悉项目\" class=\"headerlink\" title=\"第二步：阅读项目文档，熟悉项目\"></a>第二步：阅读项目文档，熟悉项目</h2><p>阅读项目文档，主要是对项目有个整体的认知，不要一开始拘泥细节，包括：</p>\n<ul>\n<li>项目简介</li>\n<li>背景知识：这部分不清楚的，可以先去补充一下，比如leveldb涉及到的lsm树，不熟悉的，可以先去看看lsm相关知识</li>\n<li>整体架构</li>\n</ul>\n<h2 id=\"第三步：编译并运行源码\"><a href=\"#第三步：编译并运行源码\" class=\"headerlink\" title=\"第三步：编译并运行源码\"></a>第三步：编译并运行源码</h2><p>将源码以debug的方式(Leveldb源码解读(一) )编译&#x2F;运行起来，以debug的方式，目的方便我们调试</p>\n<h2 id=\"第四步：更深入进行阅读\"><a href=\"#第四步：更深入进行阅读\" class=\"headerlink\" title=\"第四步：更深入进行阅读\"></a>第四步：更深入进行阅读</h2><ol>\n<li>gdb跟踪我们的单元测试(常见的命令如，bt&#x2F;b&#x2F;p&#x2F;n&#x2F;s,layout src等)</li>\n<li>自己编写测试用例</li>\n<li>如果此时还是摸不着头脑，要学会站在“巨人”的肩膀上，借助网络的力量，去看看前人写的文章，去问问别人，来打开思路，慢慢形成自己的方法</li>\n<li>多使用日志大法，多线程等场景可能使用gdb不太方便，我们完全可以在源码中添加自己的日志</li>\n<li>涉及到网络相关的项目如redis，我在阅读源码时，也会借助tcpdump工具来抓包验证是否自己的理解正确</li>\n</ol>\n<h2 id=\"第五步：重复和总结\"><a href=\"#第五步：重复和总结\" class=\"headerlink\" title=\"第五步：重复和总结\"></a>第五步：重复和总结</h2><ol>\n<li>我们没有过目不忘和无所不知的本领，因此源码阅读应该是一个心平气和和重复循环的过程(多看几遍总是有好处的)</li>\n<li>要有沉淀，可以记笔记&#x2F;录制视频，能把别人讲清楚，那你自己肯定清楚了</li>\n<li>可以想想如何将源码中知识点应用到我们自己的项目中来</li>\n<li>我自己阅读了leveldb之后，将sst中的差值压缩思想应用项目中，存储压缩比大约30%+</li>\n<li>命名更人性化</li>\n</ol>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.codedump.info/post/20190324-how-to-read-code/\">https://www.codedump.info/post/20190324-how-to-read-code/</a><br><a href=\"https://www.zhihu.com/question/19625320/answer/12429108\">https://www.zhihu.com/question/19625320/answer/12429108</a><br><a href=\"https://www.zhihu.com/question/19625320/answer/307133854\">https://www.zhihu.com/question/19625320/answer/307133854</a><br><a href=\"https://github.com/zhangguixu/myblogs/issues/4\">https://github.com/zhangguixu/myblogs/issues/4</a><br>[英文能力与独立思考]<a href=\"https://www.raychase.net/6902\">https://www.raychase.net/6902</a><br>[分享个人阅读源码的方法]<a href=\"https://www.bilibili.com/video/BV1w34y1p7V7/?spm_id_from=333.999.0.0&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca\">https://www.bilibili.com/video/BV1w34y1p7V7/?spm_id_from=333.999.0.0&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca</a><br>[LevelDB 源码分析]<a href=\"https://hardcore.feishu.cn/mindnotes/bmncnzpUmXNQruVGOwRwisHyxoh\">https://hardcore.feishu.cn/mindnotes/bmncnzpUmXNQruVGOwRwisHyxoh</a></p>\n","slug":"Others/How-to-read-the-source-code","updated":"26/10/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/25/Others/How-to-read-the-source-code/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"python 语法","date":"24/02/2022","path":"2022/02/24/Grammar/python-Grammar/","text":"语言规范 变量名小写，下划线连接 train_txt_file 函数名一般小写，下划线连接 def txt_save(self): 类名称一般大驼峰 class BatchRename(): 基础infPython中可以用如下方式表示正负无穷 12float(&quot;inf&quot;) # 正无穷float(&quot;-inf&quot;) # 负无穷 INF做加法、乘法等算数运算仍然会的到inf： 除了 INF 外的其他数除以 INF ，会得到0： 任何其他的数值除以 INF 都会得到 INF， 因为INF表示正无穷 如果 INF 涉及到 &lt; 和 &gt; 不等式的问题，所有数都比 -inf 大，所有数都比 +inf 小就可以了。 Numpynp.mean()np.mean()函数功能：求取均值经常操作的参数为axis，以m * n矩阵举例：axis 不设置值，对 mn 个数求均值，返回一个实数axis &#x3D; 0：压缩行，对各列求均值，返回 1 n 矩阵axis &#x3D;1 ：压缩列，对各行求均值，返回 m *1 矩阵 12345678910111213np.mean(num1,0)num1 = np.array([[1,2,3],[2,3,4],[3,4,5],[4,5,6]])num2 = np.mat(num1)ans = np.mean(num1,0)3.5ans = np.mean(num1,0) # 压缩行，对各列求均值matrix([[ 2.5, 3.5, 4.5]])ans = np.mean(num1,1) # 压缩列，对各行求均值matrix([[ 2.], [ 3.], [ 4.], [ 5.]]) np.fliplr()将数组在左右方向上翻转 123456789arr = np.array([[[0,1],[2,3]],[[4,5],[6,7]]], dtype=float)print(arr)print(np.fliplr(arr))[[[0,1], [2, 3]] [[4,5], [6, 7]]][[[2, 3], [0, 1]] [[6, 7], [4, 5]] ] px, py = np.transpose(np.flipud(np.fliplr(path))) np.flipud()翻转列表，将矩阵进行上下翻转 123456789101112arr=np.diag([1,2,3,4]) #diag用于声明对角矩阵print(arr)print(np.flipud(arr))[[1 0 0 0] [0 2 0 0] [0 0 3 0] [0 0 0 4]][[0, 0, 0, 4], [0, 0, 3, 0], [0, 2, 0, 0], [1, 0, 0, 0]] np.transpose()transpose在不指定参数是默认是矩阵转置 123456arr = np.arange(4).reshape((2,2))[[0, 1],[2, 3]][[0, 2],[1, 3]] 求维数，求长宽data &#x3D; np.array([ [1,2,3], [4,5,6], [7,8,9], [0,0,0] ]) print(data)print(data.ndim)print(data.shape) 2(4, 3) Mathmath.ceil()ceil() 向上取整 12ans = math.ceil(-45.17) : -45.0ans = math.ceil(100.12) : 101.0 anaconda 打开anaconda,初始化自己的环境 12345# 装python3.6版本，环境所用的python版本需要在后面指定，如果不指定默认Anaconda自带python版本# doccano 是环境名称，可根据自己命名区分不同自己的环境conda create -n labeme python=3.10# 激活自己的环境conda activate ant 在pycharm中配置file-&gt;setting-&gt;Project: Complete Coverage Pat…-&gt;Python Interpreter 安装过程增加环境变量E:\\AnacondaE:\\Anaconda\\ScriptsE:\\Anaconda\\Library\\mingw-w64\\binE:\\Anaconda\\Library\\usr\\binE:\\Anaconda\\Library\\bin conda update -n base conda conda install –yes –file requirements.txt conda config –remove-key channelsconda config –show # 查看conda的配置，确认channelsconda config –show-sources # 仅查看所有镜像 查看已经添加的channels conda config –get channelsconda config –show channels 修改文件在C:\\Users{username} 文件夹下面修改.condarcchannels: defaultsshow_channel_urls: truedefault_channels: https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud channel_priority: flexible conda list pip3 install torch torchvision -i https://pypi.mirrors.ustc.edu.cn/simple/ import torch print(torch.version)print(torch.cuda.is_available()) argparsepycharm python的编译过程 没有二进制文件，直接编译成字节码了 pip3 install paddlepaddle -i https://mirror.baidu.com/pypi/simple/ pip3 install eiseg -i https://mirror.baidu.com/pypi/simple/ anaconda导出环境conda env export &gt; environment.yaml 导入环境conda env create -f environment.yaml 安装anaconda环境pip3pip3 安装在&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packagespip3 freeze # 查看安装了什么包pip3 show pip3 list -v # 列出所有已安装包的位置pip3 –version 查看 pip3 的默认安装位置 Linux下安装Django使用在线安装sudo pip3 install django&#x3D;&#x3D;2.2.28 使用离线安装包安装 123456apt-get install python3-setuptools -y # setup.py中的依赖项apt-get install python3-pip -ytar -xvf Django-2.2.28.tar.gz cd Django-2.2.28/python3 setup.py installpip3 freeze |grep Django # 查看是否安装成功 vscode调试python单个文件只需要直接F5，自动生成的就可以了 常用命令python3 manage.py runserver # 启动服务python3 manage.py startapp # 创建应用python3 manage.py migrate # 数据库迁移python3 manage.py # 列出所有Django子命令 项目结构_init : Python包的初始化文件wsgi.py : WEB服务网关的配置文件– Django正式启动时，需要用到urls.py :项目的主路由配置- HTTP请求进入Django时，优先调用该文件settings.py:项目的配置文件–包含项目启动时需要的配置 搭建第一个Django程序 安装环境 django-admin startproject mysite1 需要在setting中改为，ALLOWED_HOSTS &#x3D; [“192.168.1.19”] python3 manage.py runserver 0.0.0.0:8000 # 将所有IP的请求都接入进来 成功连接 常见修改LANGUAGE_CODE &#x3D; ‘zh-Hans’ TIME_ZONE &#x3D; ‘Asia&#x2F;Shanghai’ 参考资料[anaconda启动非常慢，一直卡在Initializing(看起来没什么用，FQ马上打开了)]https://blog.csdn.net/qq_40051406/article/details/121365478[Anaconda超详细安装教程（Windows环境下）]https://blog.csdn.net/fan18317517352/article/details/123035625[新手教程一：Anaconda新建开发环境]https://blog.csdn.net/qq_42573052/article/details/113770662anaconda 换清华镜像源 windows[Python命名规范-大小写]https://blog.csdn.net/quietbxj/article/details/107188786[Solving environment: failed with initial frozen solve. Retrying with flexible solve的解决]https://blog.csdn.net/Brookekitty/article/details/106226285[Python使用conda安装requirement.txt的扩展包]https://blog.csdn.net/weixin_45092662/article/details/106906719[安装PyTorch详细过程]https://blog.csdn.net/MCYZSF/article/details/116525159[清华大学开源软件镜像站]https://mirrors.tuna.tsinghua.edu.cn/[Pytorch教程（一）：Pytorch安装教程-使用pip在conda里面装上了]https://zhuanlan.zhihu.com/p/88903659[基于pytorch的yolov5运行报错warnings.warn(‘User provided device_type of ‘cuda‘, but CUDA is not available)]https://blog.csdn.net/weixin_50813961/article/details/122587255[CUDA 11.7无法安装pytorch的GPU版本]https://blog.csdn.net/qq_46037444/article/details/125991109[pytorch官网]https://pytorch.org/get-started/locally/[__pycache__文件夹是什么东西？]https://zhuanlan.zhihu.com/p/476772186Anaconda之导出&#x2F;导出配置好的虚拟环境[EISeg工具对应博文]https://blog.csdn.net/qq_37541097/article/details/120154543","raw":"---\ntitle: python 语法\ndate: 2022-02-24 20:47:46\ntags:\n- 语法\n---\n\n# 语言规范\n\n\n1. 变量名小写，下划线连接\n   1. train_txt_file\n2. 函数名一般小写，下划线连接\n   1. def txt_save(self):\n3. 类名称一般大驼峰\n   1. class BatchRename():\n\n# 基础\n\n## inf\nPython中可以用如下方式表示正负无穷\n```\nfloat(\"inf\")  # 正无穷\nfloat(\"-inf\")  # 负无穷\n```\n 1. INF做加法、乘法等算数运算仍然会的到inf：\n 2. 除了 INF 外的其他数除以 INF ，会得到0：\n 3. 任何其他的数值除以 INF 都会得到 INF， 因为INF表示正无穷\n 4. 如果 INF 涉及到 < 和 > 不等式的问题，所有数都比 -inf 大，所有数都比 +inf 小就可以了。\n\n# Numpy\n\n## np.mean()\nnp.mean()函数功能：求取均值\n经常操作的参数为axis，以m * n矩阵举例：\naxis 不设置值，对 m*n 个数求均值，返回一个实数\naxis = 0：压缩行，对各列求均值，返回 1* n 矩阵\naxis =1 ：压缩列，对各行求均值，返回 m *1 矩阵\n\n```\nnp.mean(num1,0)\nnum1 = np.array([[1,2,3],[2,3,4],[3,4,5],[4,5,6]])\nnum2 = np.mat(num1)\n\nans = np.mean(num1,0)\n3.5\nans = np.mean(num1,0) # 压缩行，对各列求均值\nmatrix([[ 2.5,  3.5,  4.5]])\nans = np.mean(num1,1) # 压缩列，对各行求均值\nmatrix([[ 2.],\n        [ 3.],\n        [ 4.],\n        [ 5.]])\n```\n\n## np.fliplr()\n将数组在左右方向上翻转\n```\narr = np.array([[[0,1],[2,3]],[[4,5],[6,7]]], dtype=float)\nprint(arr)\nprint(np.fliplr(arr))\n\n[[[0,1], [2, 3]]\n [[4,5], [6, 7]]]\n\n[[[2, 3], [0, 1]]\n [[6, 7], [4, 5]] ]\n```\n    px, py = np.transpose(np.flipud(np.fliplr(path)))\n\n## np.flipud()\n翻转列表，将矩阵进行上下翻转\n```\narr=np.diag([1,2,3,4]) #diag用于声明对角矩阵\nprint(arr)\nprint(np.flipud(arr))\n[[1 0 0 0]\n [0 2 0 0]\n [0 0 3 0]\n [0 0 0 4]]\n\n[[0, 0, 0, 4],\n [0, 0, 3, 0],\n [0, 2, 0, 0],\n [1, 0, 0, 0]]\n```\n\n\n## np.transpose()\ntranspose在不指定参数是默认是矩阵转置\n```\narr = np.arange(4).reshape((2,2))\n[[0, 1],\n[2, 3]]\n\n[[0, 2],\n[1, 3]]\n```\n\n\n\n\n# 求维数，求长宽\n\ndata = np.array([\n\t\t[1,2,3],\n\t\t[4,5,6],\n\t\t[7,8,9],\n\t\t[0,0,0]\n\t])\n\n\nprint(data)\nprint(data.ndim)\nprint(data.shape) \n\n2\n(4, 3)\n\n# Math\n\n## math.ceil()\nceil() 向上取整\n```\nans = math.ceil(-45.17) : -45.0\nans = math.ceil(100.12) :  101.0\n```\n\n# anaconda\n\n1. 打开anaconda,初始化自己的环境\n\n```python\n# 装python3.6版本，环境所用的python版本需要在后面指定，如果不指定默认Anaconda自带python版本\n# doccano 是环境名称，可根据自己命名区分不同自己的环境\nconda create -n labeme python=3.10\n# 激活自己的环境\nconda activate ant\n```\n\n2. 在pycharm中配置\nfile->setting->Project: Complete Coverage Pat...->Python Interpreter\n\n\n安装过程增加环境变量\nE:\\Anaconda \nE:\\Anaconda\\Scripts \nE:\\Anaconda\\Library\\mingw-w64\\bin\nE:\\Anaconda\\Library\\usr\\bin \nE:\\Anaconda\\Library\\bin\n\n\nconda update -n base conda\n\n\nconda install --yes --file requirements.txt\n\n\nconda config --remove-key channels\nconda config --show # 查看conda的配置，确认channels\nconda config --show-sources # 仅查看所有镜像\n\n\n查看已经添加的channels\n\nconda config --get channels\nconda config --show channels\n\n## 修改文件\n在C:\\Users\\{username} 文件夹下面修改.condarc\nchannels:\n  - defaults\nshow_channel_urls: true\ndefault_channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n\nchannel_priority: flexible\n\nconda list\n\npip3 install torch torchvision -i https://pypi.mirrors.ustc.edu.cn/simple/\n\n\n\nimport torch\n\nprint(torch.__version__)\nprint(torch.cuda.is_available())\n\n\n# argparse\n\n# pycharm\n1. python的编译过程\n\n没有二进制文件，直接编译成字节码了\n\n\npip3 install paddlepaddle -i https://mirror.baidu.com/pypi/simple/\n\npip3 install eiseg -i https://mirror.baidu.com/pypi/simple/\n\n# anaconda导出环境\nconda env export > environment.yaml\n\n导入环境\nconda env create -f environment.yaml\n\n\n# 安装anaconda环境\n\n\n# pip3\npip3 安装在/usr/lib/python3/dist-packages\npip3 freeze # 查看安装了什么包\npip3 show <package_name>\npip3 list -v # 列出所有已安装包的位置\npip3 --version 查看 pip3 的默认安装位置\n\n\n\n# Linux下安装Django\n使用在线安装\nsudo pip3 install django==2.2.28\n\n使用离线安装包安装\n```shell\napt-get install python3-setuptools -y  # setup.py中的依赖项\napt-get install python3-pip -y\ntar -xvf Django-2.2.28.tar.gz \ncd Django-2.2.28/\npython3 setup.py install\npip3 freeze |grep Django # 查看是否安装成功\n```\n\n\n\n\n# vscode调试python单个文件\n只需要直接F5，自动生成的就可以了\n\n\n\n# 常用命令\npython3 manage.py runserver # 启动服务\npython3 manage.py startapp # 创建应用\npython3 manage.py migrate # 数据库迁移\npython3 manage.py  # 列出所有Django子命令\n\n\n\n# 项目结构\n_init : Python包的初始化文件\nwsgi.py : WEB服务网关的配置文件– Django正式启动时，需要用到\nurls.py :项目的主路由配置- HTTP请求进入Django时，优先调用该文件\nsettings.py:项目的配置文件–包含项目启动时需要的配置\n\n\n# 搭建第一个Django程序\n\n1. 安装环境\n2. django-admin startproject mysite1\n3. 需要在setting中改为，ALLOWED_HOSTS = [\"192.168.1.19\"]\n4. python3 manage.py runserver 0.0.0.0:8000 # 将所有IP的请求都接入进来\n5. 成功连接\n\n常见修改\nLANGUAGE_CODE = 'zh-Hans'\n\nTIME_ZONE = 'Asia/Shanghai'\n\n# 参考资料\n[anaconda启动非常慢，一直卡在Initializing(看起来没什么用，FQ马上打开了)]https://blog.csdn.net/qq_40051406/article/details/121365478\n[Anaconda超详细安装教程（Windows环境下）]https://blog.csdn.net/fan18317517352/article/details/123035625\n[新手教程一：Anaconda新建开发环境]https://blog.csdn.net/qq_42573052/article/details/113770662\n[anaconda 换清华镜像源 windows](https://blog.csdn.net/jasneik/article/details/114227716)\n[Python命名规范-大小写]https://blog.csdn.net/quietbxj/article/details/107188786\n[Solving environment: failed with initial frozen solve. Retrying with flexible solve的解决]https://blog.csdn.net/Brookekitty/article/details/106226285\n[Python使用conda安装requirement.txt的扩展包]https://blog.csdn.net/weixin_45092662/article/details/106906719\n[安装PyTorch详细过程]https://blog.csdn.net/MCYZSF/article/details/116525159\n[清华大学开源软件镜像站]https://mirrors.tuna.tsinghua.edu.cn/\n[Pytorch教程（一）：Pytorch安装教程-使用pip在conda里面装上了]https://zhuanlan.zhihu.com/p/88903659\n[基于pytorch的yolov5运行报错warnings.warn(‘User provided device_type of ‘cuda‘, but CUDA is not available)]https://blog.csdn.net/weixin_50813961/article/details/122587255\n[CUDA 11.7无法安装pytorch的GPU版本]https://blog.csdn.net/qq_46037444/article/details/125991109\n[pytorch官网]https://pytorch.org/get-started/locally/\n[__pycache__文件夹是什么东西？]https://zhuanlan.zhihu.com/p/476772186\n[Anaconda之导出/导出配置好的虚拟环境](https://blog.csdn.net/qq_43382635/article/details/127124980)\n[EISeg工具对应博文]https://blog.csdn.net/qq_37541097/article/details/120154543\n\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"语言规范\"><a href=\"#语言规范\" class=\"headerlink\" title=\"语言规范\"></a>语言规范</h1><ol>\n<li>变量名小写，下划线连接<ol>\n<li>train_txt_file</li>\n</ol>\n</li>\n<li>函数名一般小写，下划线连接<ol>\n<li>def txt_save(self):</li>\n</ol>\n</li>\n<li>类名称一般大驼峰<ol>\n<li>class BatchRename():</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><h2 id=\"inf\"><a href=\"#inf\" class=\"headerlink\" title=\"inf\"></a>inf</h2><p>Python中可以用如下方式表示正负无穷</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>)  <span class=\"comment\"># 正无穷</span></span><br><span class=\"line\"><span class=\"built_in\">float</span>(<span class=\"string\">&quot;-inf&quot;</span>)  <span class=\"comment\"># 负无穷</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>INF做加法、乘法等算数运算仍然会的到inf：</li>\n<li>除了 INF 外的其他数除以 INF ，会得到0：</li>\n<li>任何其他的数值除以 INF 都会得到 INF， 因为INF表示正无穷</li>\n<li>如果 INF 涉及到 &lt; 和 &gt; 不等式的问题，所有数都比 -inf 大，所有数都比 +inf 小就可以了。</li>\n</ol>\n<h1 id=\"Numpy\"><a href=\"#Numpy\" class=\"headerlink\" title=\"Numpy\"></a>Numpy</h1><h2 id=\"np-mean\"><a href=\"#np-mean\" class=\"headerlink\" title=\"np.mean()\"></a>np.mean()</h2><p>np.mean()函数功能：求取均值<br>经常操作的参数为axis，以m * n矩阵举例：<br>axis 不设置值，对 m<em>n 个数求均值，返回一个实数<br>axis &#x3D; 0：压缩行，对各列求均值，返回 1</em> n 矩阵<br>axis &#x3D;1 ：压缩列，对各行求均值，返回 m *1 矩阵</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.mean(num1,<span class=\"number\">0</span>)</span><br><span class=\"line\">num1 = np.array(<span class=\"string\">[[1,2,3],[2,3,4],[3,4,5],[4,5,6]]</span>)</span><br><span class=\"line\">num2 = np.mat(num1)</span><br><span class=\"line\"></span><br><span class=\"line\">ans = np.mean(num1,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">3.5</span></span><br><span class=\"line\">ans = np.mean(num1,<span class=\"number\">0</span>) # 压缩行，对各列求均值</span><br><span class=\"line\">matrix(<span class=\"string\">[[ 2.5,  3.5,  4.5]]</span>)</span><br><span class=\"line\">ans = np.mean(num1,<span class=\"number\">1</span>) # 压缩列，对各行求均值</span><br><span class=\"line\">matrix(<span class=\"string\">[[ 2.],</span></span><br><span class=\"line\"><span class=\"string\">        [ 3.],</span></span><br><span class=\"line\"><span class=\"string\">        [ 4.],</span></span><br><span class=\"line\"><span class=\"string\">        [ 5.]]</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"np-fliplr\"><a href=\"#np-fliplr\" class=\"headerlink\" title=\"np.fliplr()\"></a>np.fliplr()</h2><p>将数组在左右方向上翻转</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = np.array(<span class=\"string\">[[[0,1],[2,3]]</span>,<span class=\"string\">[[4,5],[6,7]]</span>], dtype=float)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(arr)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(np.fliplr(arr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">[[[0,1], [2, 3]]</span></span><br><span class=\"line\"> <span class=\"string\">[[4,5], [6, 7]]</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">[[[2, 3], [0, 1]]</span></span><br><span class=\"line\"> <span class=\"string\">[[6, 7], [4, 5]]</span> ]</span><br></pre></td></tr></table></figure>\n<pre><code>px, py = np.transpose(np.flipud(np.fliplr(path)))\n</code></pre>\n<h2 id=\"np-flipud\"><a href=\"#np-flipud\" class=\"headerlink\" title=\"np.flipud()\"></a>np.flipud()</h2><p>翻转列表，将矩阵进行上下翻转</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr=np<span class=\"selector-class\">.diag</span>(<span class=\"selector-attr\">[1,2,3,4]</span>) #diag用于声明对角矩阵</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(arr)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(np.flipud(arr)</span></span>)</span><br><span class=\"line\"><span class=\"selector-attr\">[[1 0 0 0]</span></span><br><span class=\"line\"> <span class=\"selector-attr\">[0 2 0 0]</span></span><br><span class=\"line\"> <span class=\"selector-attr\">[0 0 3 0]</span></span><br><span class=\"line\"> <span class=\"selector-attr\">[0 0 0 4]</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[[0, 0, 0, 4]</span>,</span><br><span class=\"line\"> <span class=\"selector-attr\">[0, 0, 3, 0]</span>,</span><br><span class=\"line\"> <span class=\"selector-attr\">[0, 2, 0, 0]</span>,</span><br><span class=\"line\"> <span class=\"selector-attr\">[1, 0, 0, 0]</span>]</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"np-transpose\"><a href=\"#np-transpose\" class=\"headerlink\" title=\"np.transpose()\"></a>np.transpose()</h2><p>transpose在不指定参数是默认是矩阵转置</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = np.arange(<span class=\"number\">4</span>).reshape((<span class=\"number\">2</span>,<span class=\"number\">2</span>))</span><br><span class=\"line\"><span class=\"string\">[[0, 1],</span></span><br><span class=\"line\"><span class=\"string\">[2, 3]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">[[0, 2],</span></span><br><span class=\"line\"><span class=\"string\">[1, 3]]</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"求维数，求长宽\"><a href=\"#求维数，求长宽\" class=\"headerlink\" title=\"求维数，求长宽\"></a>求维数，求长宽</h1><p>data &#x3D; np.array([<br>        [1,2,3],<br>        [4,5,6],<br>        [7,8,9],<br>        [0,0,0]<br>    ])</p>\n<p>print(data)<br>print(data.ndim)<br>print(data.shape) </p>\n<p>2<br>(4, 3)</p>\n<h1 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h1><h2 id=\"math-ceil\"><a href=\"#math-ceil\" class=\"headerlink\" title=\"math.ceil()\"></a>math.ceil()</h2><p>ceil() 向上取整</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ans</span> = math.ceil(-<span class=\"number\">45</span>.<span class=\"number\">17</span>) : -<span class=\"number\">45</span>.<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attribute\">ans</span> = math.ceil(<span class=\"number\">100</span>.<span class=\"number\">12</span>) :  <span class=\"number\">101</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"anaconda\"><a href=\"#anaconda\" class=\"headerlink\" title=\"anaconda\"></a>anaconda</h1><ol>\n<li>打开anaconda,初始化自己的环境</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 装python3.6版本，环境所用的python版本需要在后面指定，如果不指定默认Anaconda自带python版本</span></span><br><span class=\"line\"><span class=\"comment\"># doccano 是环境名称，可根据自己命名区分不同自己的环境</span></span><br><span class=\"line\">conda create -n labeme python=<span class=\"number\">3.10</span></span><br><span class=\"line\"><span class=\"comment\"># 激活自己的环境</span></span><br><span class=\"line\">conda activate ant</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在pycharm中配置<br>file-&gt;setting-&gt;Project: Complete Coverage Pat…-&gt;Python Interpreter</li>\n</ol>\n<p>安装过程增加环境变量<br>E:\\Anaconda<br>E:\\Anaconda\\Scripts<br>E:\\Anaconda\\Library\\mingw-w64\\bin<br>E:\\Anaconda\\Library\\usr\\bin<br>E:\\Anaconda\\Library\\bin</p>\n<p>conda update -n base conda</p>\n<p>conda install –yes –file requirements.txt</p>\n<p>conda config –remove-key channels<br>conda config –show # 查看conda的配置，确认channels<br>conda config –show-sources # 仅查看所有镜像</p>\n<p>查看已经添加的channels</p>\n<p>conda config –get channels<br>conda config –show channels</p>\n<h2 id=\"修改文件\"><a href=\"#修改文件\" class=\"headerlink\" title=\"修改文件\"></a>修改文件</h2><p>在C:\\Users{username} 文件夹下面修改.condarc<br>channels:</p>\n<ul>\n<li>defaults<br>show_channel_urls: true<br>default_channels:</li>\n<li><a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a></li>\n<li><a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</a></li>\n<li><a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</a><br>custom_channels:<br>  conda-forge: <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</a><br>  msys2: <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</a><br>  bioconda: <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</a><br>  menpo: <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</a><br>  pytorch: <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</a><br>  pytorch-lts: <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</a><br>  simpleitk: <a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</a></li>\n</ul>\n<p>channel_priority: flexible</p>\n<p>conda list</p>\n<p>pip3 install torch torchvision -i <a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>\n<p>import torch</p>\n<p>print(torch.<strong>version</strong>)<br>print(torch.cuda.is_available())</p>\n<h1 id=\"argparse\"><a href=\"#argparse\" class=\"headerlink\" title=\"argparse\"></a>argparse</h1><h1 id=\"pycharm\"><a href=\"#pycharm\" class=\"headerlink\" title=\"pycharm\"></a>pycharm</h1><ol>\n<li>python的编译过程</li>\n</ol>\n<p>没有二进制文件，直接编译成字节码了</p>\n<p>pip3 install paddlepaddle -i <a href=\"https://mirror.baidu.com/pypi/simple/\">https://mirror.baidu.com/pypi/simple/</a></p>\n<p>pip3 install eiseg -i <a href=\"https://mirror.baidu.com/pypi/simple/\">https://mirror.baidu.com/pypi/simple/</a></p>\n<h1 id=\"anaconda导出环境\"><a href=\"#anaconda导出环境\" class=\"headerlink\" title=\"anaconda导出环境\"></a>anaconda导出环境</h1><p>conda env export &gt; environment.yaml</p>\n<p>导入环境<br>conda env create -f environment.yaml</p>\n<h1 id=\"安装anaconda环境\"><a href=\"#安装anaconda环境\" class=\"headerlink\" title=\"安装anaconda环境\"></a>安装anaconda环境</h1><h1 id=\"pip3\"><a href=\"#pip3\" class=\"headerlink\" title=\"pip3\"></a>pip3</h1><p>pip3 安装在&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages<br>pip3 freeze # 查看安装了什么包<br>pip3 show <package_name><br>pip3 list -v # 列出所有已安装包的位置<br>pip3 –version 查看 pip3 的默认安装位置</p>\n<h1 id=\"Linux下安装Django\"><a href=\"#Linux下安装Django\" class=\"headerlink\" title=\"Linux下安装Django\"></a>Linux下安装Django</h1><p>使用在线安装<br>sudo pip3 install django&#x3D;&#x3D;2.2.28</p>\n<p>使用离线安装包安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install python3-setuptools -y  # setup.py中的依赖项</span><br><span class=\"line\">apt-get install python3-pip -y</span><br><span class=\"line\">tar -xvf Django-2.2.28.tar.gz </span><br><span class=\"line\">cd Django-2.2.28/</span><br><span class=\"line\">python3 setup.py install</span><br><span class=\"line\">pip3 freeze |grep Django # 查看是否安装成功</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"vscode调试python单个文件\"><a href=\"#vscode调试python单个文件\" class=\"headerlink\" title=\"vscode调试python单个文件\"></a>vscode调试python单个文件</h1><p>只需要直接F5，自动生成的就可以了</p>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><p>python3 manage.py runserver # 启动服务<br>python3 manage.py startapp # 创建应用<br>python3 manage.py migrate # 数据库迁移<br>python3 manage.py  # 列出所有Django子命令</p>\n<h1 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h1><p>_init : Python包的初始化文件<br>wsgi.py : WEB服务网关的配置文件– Django正式启动时，需要用到<br>urls.py :项目的主路由配置- HTTP请求进入Django时，优先调用该文件<br>settings.py:项目的配置文件–包含项目启动时需要的配置</p>\n<h1 id=\"搭建第一个Django程序\"><a href=\"#搭建第一个Django程序\" class=\"headerlink\" title=\"搭建第一个Django程序\"></a>搭建第一个Django程序</h1><ol>\n<li>安装环境</li>\n<li>django-admin startproject mysite1</li>\n<li>需要在setting中改为，ALLOWED_HOSTS &#x3D; [“192.168.1.19”]</li>\n<li>python3 manage.py runserver 0.0.0.0:8000 # 将所有IP的请求都接入进来</li>\n<li>成功连接</li>\n</ol>\n<p>常见修改<br>LANGUAGE_CODE &#x3D; ‘zh-Hans’</p>\n<p>TIME_ZONE &#x3D; ‘Asia&#x2F;Shanghai’</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[anaconda启动非常慢，一直卡在Initializing(看起来没什么用，FQ马上打开了)]<a href=\"https://blog.csdn.net/qq_40051406/article/details/121365478\">https://blog.csdn.net/qq_40051406/article/details/121365478</a><br>[Anaconda超详细安装教程（Windows环境下）]<a href=\"https://blog.csdn.net/fan18317517352/article/details/123035625\">https://blog.csdn.net/fan18317517352/article/details/123035625</a><br>[新手教程一：Anaconda新建开发环境]<a href=\"https://blog.csdn.net/qq_42573052/article/details/113770662\">https://blog.csdn.net/qq_42573052/article/details/113770662</a><br><a href=\"https://blog.csdn.net/jasneik/article/details/114227716\">anaconda 换清华镜像源 windows</a><br>[Python命名规范-大小写]<a href=\"https://blog.csdn.net/quietbxj/article/details/107188786\">https://blog.csdn.net/quietbxj/article/details/107188786</a><br>[Solving environment: failed with initial frozen solve. Retrying with flexible solve的解决]<a href=\"https://blog.csdn.net/Brookekitty/article/details/106226285\">https://blog.csdn.net/Brookekitty/article/details/106226285</a><br>[Python使用conda安装requirement.txt的扩展包]<a href=\"https://blog.csdn.net/weixin_45092662/article/details/106906719\">https://blog.csdn.net/weixin_45092662/article/details/106906719</a><br>[安装PyTorch详细过程]<a href=\"https://blog.csdn.net/MCYZSF/article/details/116525159\">https://blog.csdn.net/MCYZSF/article/details/116525159</a><br>[清华大学开源软件镜像站]<a href=\"https://mirrors.tuna.tsinghua.edu.cn/\">https://mirrors.tuna.tsinghua.edu.cn/</a><br>[Pytorch教程（一）：Pytorch安装教程-使用pip在conda里面装上了]<a href=\"https://zhuanlan.zhihu.com/p/88903659\">https://zhuanlan.zhihu.com/p/88903659</a><br>[基于pytorch的yolov5运行报错warnings.warn(‘User provided device_type of ‘cuda‘, but CUDA is not available)]<a href=\"https://blog.csdn.net/weixin_50813961/article/details/122587255\">https://blog.csdn.net/weixin_50813961/article/details/122587255</a><br>[CUDA 11.7无法安装pytorch的GPU版本]<a href=\"https://blog.csdn.net/qq_46037444/article/details/125991109\">https://blog.csdn.net/qq_46037444/article/details/125991109</a><br>[pytorch官网]<a href=\"https://pytorch.org/get-started/locally/\">https://pytorch.org/get-started/locally/</a><br>[__pycache__文件夹是什么东西？]<a href=\"https://zhuanlan.zhihu.com/p/476772186\">https://zhuanlan.zhihu.com/p/476772186</a><br><a href=\"https://blog.csdn.net/qq_43382635/article/details/127124980\">Anaconda之导出&#x2F;导出配置好的虚拟环境</a><br>[EISeg工具对应博文]<a href=\"https://blog.csdn.net/qq_37541097/article/details/120154543\">https://blog.csdn.net/qq_37541097/article/details/120154543</a></p>\n","slug":"Grammar/python-Grammar","updated":"15/04/2023","comments":true,"link":"","permalink":"http://example.com/2022/02/24/Grammar/python-Grammar/","excerpt":"","categories":[],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"hexo-Logs","date":"21/02/2022","path":"2022/02/21/Others/hexo-Logs/","text":"2022-2-12 创建博客，添加了两篇文章 2022-2-21 更改了主题，统计访问人数，更改分类，改了网站图标 2022-3-21 不断增加文章 2022-4-5 暂时用路过图床作为图床，图片本地保存一份，起码可以上传图片了 以后考虑用腾讯云的CDS来代替https://imgtu.com/ytgh678 做了一些头像等细节的优化，图片放大插件，阅读时长，字数统计 2022-6-21 修复了左边导航栏的问题 添加了搜索功能 等待加入的功能 刚进入的页面要弄得整齐 置顶某一篇文章 每篇文章的显示更加详细 做归档那边的功能，不能空着 每个分类点进去应该是横着的格式，而不是现在的样子 改变字体颜色 同一个页面下的多级目录 左下角显示时间，访客 可以被搜索到 修改markdown样式分开统计每个页面浏览量标签云添加颜色图片点一下会放大 文章中还没有添加的 厨房烧菜的内容 vscode的linux环境的配置写task.josn和lanch.json每个选项到底是怎么用的，还有怎么开始调试和配置、 周会的记录，看看测试和产品干的内容写进来 redis相关，mysql相关都没有总结 TIDB的相关知识 mysql面试问题 如何搭建环境 租房指南 如何提升系统性能（???还不知道怎么去做）","raw":"---\ntitle: hexo-Logs\ntoc: true\ndate: 2022-02-21 20:41:42\ntags:\n- 其他\n---\n\n\n\n\n## 2022-2-12\n- 创建博客，添加了两篇文章\n\n## 2022-2-21\n- 更改了主题，统计访问人数，更改分类，改了网站图标\n\n## 2022-3-21\n- 不断增加文章\n\n## 2022-4-5\n- 暂时用路过图床作为图床，图片本地保存一份，起码可以上传图片了\n- 以后考虑用腾讯云的CDS来代替\nhttps://imgtu.com/ytgh678\n- 做了一些头像等细节的优化，图片放大插件，阅读时长，字数统计\n\n## 2022-6-21\n- 修复了左边导航栏的问题\n- 添加了搜索功能\n\n\n\n\n# 等待加入的功能\n\n1. 刚进入的页面要弄得整齐\n    - 置顶某一篇文章\n    - 每篇文章的显示更加详细\n\n2. 做归档那边的功能，不能空着\n3. 每个分类点进去应该是横着的格式，而不是现在的样子\n    \n--------\n1. 改变字体颜色\n2. 同一个页面下的多级目录\n4. 左下角显示时间，访客\n5. 可以被搜索到\n6. 修改markdown样式\n分开统计每个页面浏览量\n标签云添加颜色\n图片点一下会放大\n\n\n# 文章中还没有添加的\n\n1. 厨房烧菜的内容\n2. vscode的linux环境的配置\n写task.josn和lanch.json每个选项到底是怎么用的，还有怎么开始调试和配置、\n3. 周会的记录，看看测试和产品干的内容写进来\n4. redis相关，mysql相关都没有总结\n5. TIDB的相关知识\n6. mysql面试问题\n\n\n7. 如何搭建环境\n8. 租房指南\n9. 如何提升系统性能（???还不知道怎么去做）\n","content":"<h2 id=\"2022-2-12\"><a href=\"#2022-2-12\" class=\"headerlink\" title=\"2022-2-12\"></a>2022-2-12</h2><ul>\n<li>创建博客，添加了两篇文章</li>\n</ul>\n<h2 id=\"2022-2-21\"><a href=\"#2022-2-21\" class=\"headerlink\" title=\"2022-2-21\"></a>2022-2-21</h2><ul>\n<li>更改了主题，统计访问人数，更改分类，改了网站图标</li>\n</ul>\n<h2 id=\"2022-3-21\"><a href=\"#2022-3-21\" class=\"headerlink\" title=\"2022-3-21\"></a>2022-3-21</h2><ul>\n<li>不断增加文章</li>\n</ul>\n<h2 id=\"2022-4-5\"><a href=\"#2022-4-5\" class=\"headerlink\" title=\"2022-4-5\"></a>2022-4-5</h2><ul>\n<li>暂时用路过图床作为图床，图片本地保存一份，起码可以上传图片了</li>\n<li>以后考虑用腾讯云的CDS来代替<br><a href=\"https://imgtu.com/ytgh678\">https://imgtu.com/ytgh678</a></li>\n<li>做了一些头像等细节的优化，图片放大插件，阅读时长，字数统计</li>\n</ul>\n<h2 id=\"2022-6-21\"><a href=\"#2022-6-21\" class=\"headerlink\" title=\"2022-6-21\"></a>2022-6-21</h2><ul>\n<li>修复了左边导航栏的问题</li>\n<li>添加了搜索功能</li>\n</ul>\n<h1 id=\"等待加入的功能\"><a href=\"#等待加入的功能\" class=\"headerlink\" title=\"等待加入的功能\"></a>等待加入的功能</h1><ol>\n<li><p>刚进入的页面要弄得整齐</p>\n<ul>\n<li>置顶某一篇文章</li>\n<li>每篇文章的显示更加详细</li>\n</ul>\n</li>\n<li><p>做归档那边的功能，不能空着</p>\n</li>\n<li><p>每个分类点进去应该是横着的格式，而不是现在的样子</p>\n</li>\n</ol>\n<hr>\n<ol>\n<li>改变字体颜色</li>\n<li>同一个页面下的多级目录</li>\n<li>左下角显示时间，访客</li>\n<li>可以被搜索到</li>\n<li>修改markdown样式<br>分开统计每个页面浏览量<br>标签云添加颜色<br>图片点一下会放大</li>\n</ol>\n<h1 id=\"文章中还没有添加的\"><a href=\"#文章中还没有添加的\" class=\"headerlink\" title=\"文章中还没有添加的\"></a>文章中还没有添加的</h1><ol>\n<li><p>厨房烧菜的内容</p>\n</li>\n<li><p>vscode的linux环境的配置<br>写task.josn和lanch.json每个选项到底是怎么用的，还有怎么开始调试和配置、</p>\n</li>\n<li><p>周会的记录，看看测试和产品干的内容写进来</p>\n</li>\n<li><p>redis相关，mysql相关都没有总结</p>\n</li>\n<li><p>TIDB的相关知识</p>\n</li>\n<li><p>mysql面试问题</p>\n</li>\n<li><p>如何搭建环境</p>\n</li>\n<li><p>租房指南</p>\n</li>\n<li><p>如何提升系统性能（???还不知道怎么去做）</p>\n</li>\n</ol>\n","slug":"Others/hexo-Logs","updated":"22/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/21/Others/hexo-Logs/","excerpt":"","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"cmake 教程","date":"21/02/2022","path":"2022/02/21/Tutorial/linux-dev-env/cmake-tutorial/","text":"PROJECT 指令的语法12PROJECT(projectname [CXX] [C] [Java])PROJECT (HELLO) 定义了工程的名称为HELLO SET 指令的语法123SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])SET(SRC_LIST main.c t1.c t2.c)SET(SRC_LIST main.c)也可以写成 SET(SRC_LIST “main.c”) SET 指令可以用来显式的定义变量即可 MESSAGE 指令的语法123MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] &quot;message to display&quot;...)MESSAGE(STATUS &quot;This is BINARY dir &quot; $&#123;HELLO_BINARY_DIR&#125;) 由 PROJECT 指令定义的两个隐式变量HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。 SEND_ERROR，产生错误，生成过程被跳过SATUS，输出前缀为—的信息FATAL_ERROR，立即终止所有 cmake 过程 ADD_EXECUTABLE 指令的语法1ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;) 定义了这个工程会生成一个文件名为 hello 的可执行文件 变量${}来引用变量，这是 cmake 的变量引用方式如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。 清理1make clean cmake 并不支持 make distclean，无法清理构建过程产生的中间文件 cmake使用时候的命名cmake .. -DCMAKE_BUILD_TYPE&#x3D;Debug CMAKE_BUILD_TYPE可选值包括：Debug：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件Release：用于构建的优化的库或可执行文件，不包含调试符号RelWithDebInfo：由于构建较少的优化库或可执行文件，包含调试符号MinSizeRel：用于不增加目标代码大小的优化方式，来构建或可执行文件 交叉编译工具CMAKE给交叉编译预留了一个变量CMAKE_TOOLCHAIN_FILE，它定义了一个.cmake文件的路径，该文件里面设置了一系列CMAKE变量和属性，比如C_COMPILER，CXX_COMPILER等。.cmake文件的好处是一次编写多次使用，不同平台架构的交叉编译工具链可以编写一个独立的toolchain.cmake文件，而工程的CMakeLists.txt可以编写为通用格式，对工具链不可见。cmake脚本可以如下形式： add_library()：这是一个CMake函数，用于创建一个库文件。 add_executable()：这是一个CMake函数，用于创建一个可执行文件。 target_link_libraries()：这是一个CMake函数，用于指定链接的库文件。 include_directories()：这是一个CMake函数，用于指定头文件的搜索路径。 add_subdirectory():添加一个子目录并构建该子目录。 参考文献[find_package讲解]https://blog.csdn.net/zhanghm1995/article/details/105466372[C++连接mysql用cmake编译]https://blog.csdn.net/lbwanghr/article/details/111076593[什么是交叉编译]https://zhuanlan.zhihu.com/p/77116555","raw":"---\ntitle: cmake 教程\ndate: 2022-02-21 17:40:18\ntags:\n- 教程\n---\n\n\n# PROJECT 指令的语法\n```\nPROJECT(projectname [CXX] [C] [Java])\nPROJECT (HELLO)\n```\n定义了工程的名称为HELLO\n\n\n# SET 指令的语法\n```\nSET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])\nSET(SRC_LIST main.c t1.c t2.c)\nSET(SRC_LIST main.c)也可以写成 SET(SRC_LIST “main.c”)\n```\nSET 指令可以用来显式的定义变量即可\n\n\n# MESSAGE 指令的语法\n```\nMESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] \"message to display\"\n...)\nMESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR})\n```\n\n由 PROJECT 指令定义的两个隐式变量HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。\n\n**SEND_ERROR，产生错误，生成过程被跳过\nSATUS，输出前缀为—的信息\nFATAL_ERROR，立即终止所有 cmake 过程**\n\n\n# ADD_EXECUTABLE 指令的语法\n```\nADD_EXECUTABLE(hello ${SRC_LIST})\n```\n定义了这个工程会生成一个文件名为 hello 的可执行文件\n\n# 变量\n${}来引用变量，这是 cmake 的变量引用方式\n如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。\n\n\n# 清理\n```\nmake clean\n```\ncmake 并不支持 make distclean，无法清理构建过程产生的中间文件\n\n\n# cmake使用时候的命名\n\ncmake .. -DCMAKE_BUILD_TYPE=Debug\n\nCMAKE_BUILD_TYPE\n可选值包括：\nDebug：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件\nRelease：用于构建的优化的库或可执行文件，不包含调试符号\nRelWithDebInfo：由于构建较少的优化库或可执行文件，包含调试符号\nMinSizeRel：用于不增加目标代码大小的优化方式，来构建或可执行文件\n\n\n\n# 交叉编译工具\nCMAKE给交叉编译预留了一个变量CMAKE_TOOLCHAIN_FILE，它定义了一个.cmake文件的路径，该文件里面设置了一系列CMAKE变量和属性，比如C_COMPILER，CXX_COMPILER等。.cmake文件的好处是一次编写多次使用，不同平台架构的交叉编译工具链可以编写一个独立的toolchain.cmake文件，而工程的CMakeLists.txt可以编写为通用格式，对工具链不可见。cmake脚本可以如下形式：\n\n\n\n\nadd_library()：这是一个CMake函数，用于创建一个库文件。\n\nadd_executable()：这是一个CMake函数，用于创建一个可执行文件。\n\ntarget_link_libraries()：这是一个CMake函数，用于指定链接的库文件。\n\ninclude_directories()：这是一个CMake函数，用于指定头文件的搜索路径。\n\n\nadd_subdirectory():添加一个子目录并构建该子目录。\n\n\n# 参考文献\n\n[find_package讲解]https://blog.csdn.net/zhanghm1995/article/details/105466372\n[C++连接mysql用cmake编译]https://blog.csdn.net/lbwanghr/article/details/111076593\n[什么是交叉编译]https://zhuanlan.zhihu.com/p/77116555\n\n","content":"<h1 id=\"PROJECT-指令的语法\"><a href=\"#PROJECT-指令的语法\" class=\"headerlink\" title=\"PROJECT 指令的语法\"></a>PROJECT 指令的语法</h1><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROJECT(projectname <span class=\"selector-attr\">[CXX]</span> <span class=\"selector-attr\">[C]</span> <span class=\"selector-attr\">[Java]</span>)</span><br><span class=\"line\">PROJECT (HELLO)</span><br></pre></td></tr></table></figure>\n<p>定义了工程的名称为HELLO</p>\n<h1 id=\"SET-指令的语法\"><a href=\"#SET-指令的语法\" class=\"headerlink\" title=\"SET 指令的语法\"></a>SET 指令的语法</h1><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span></span><br><span class=\"line\"><span class=\"constructor\">SET(SRC_LIST <span class=\"params\">main</span>.<span class=\"params\">c</span> <span class=\"params\">t1</span>.<span class=\"params\">c</span> <span class=\"params\">t2</span>.<span class=\"params\">c</span>)</span></span><br><span class=\"line\"><span class=\"constructor\">SET(SRC_LIST <span class=\"params\">main</span>.<span class=\"params\">c</span>)</span>也可以写成 <span class=\"constructor\">SET(SRC_LIST “<span class=\"params\">main</span>.<span class=\"params\">c</span>”)</span></span><br></pre></td></tr></table></figure>\n<p>SET 指令可以用来显式的定义变量即可</p>\n<h1 id=\"MESSAGE-指令的语法\"><a href=\"#MESSAGE-指令的语法\" class=\"headerlink\" title=\"MESSAGE 指令的语法\"></a>MESSAGE 指令的语法</h1><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">MESSAGE</span>(<span class=\"selector-attr\">[SEND_ERROR | STATUS | FATAL_ERROR]</span> <span class=\"string\">&quot;message to display&quot;</span></span><br><span class=\"line\">...)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MESSAGE</span><span class=\"params\">(STATUS <span class=\"string\">&quot;This is BINARY dir &quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>由 PROJECT 指令定义的两个隐式变量HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。</p>\n<p><strong>SEND_ERROR，产生错误，生成过程被跳过<br>SATUS，输出前缀为—的信息<br>FATAL_ERROR，立即终止所有 cmake 过程</strong></p>\n<h1 id=\"ADD-EXECUTABLE-指令的语法\"><a href=\"#ADD-EXECUTABLE-指令的语法\" class=\"headerlink\" title=\"ADD_EXECUTABLE 指令的语法\"></a>ADD_EXECUTABLE 指令的语法</h1><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">ADD_EXECUTABLE</span><span class=\"params\">(hello $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure>\n<p>定义了这个工程会生成一个文件名为 hello 的可执行文件</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p>${}来引用变量，这是 cmake 的变量引用方式<br>如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。</p>\n<h1 id=\"清理\"><a href=\"#清理\" class=\"headerlink\" title=\"清理\"></a>清理</h1><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">make clean</span></span><br></pre></td></tr></table></figure>\n<p>cmake 并不支持 make distclean，无法清理构建过程产生的中间文件</p>\n<h1 id=\"cmake使用时候的命名\"><a href=\"#cmake使用时候的命名\" class=\"headerlink\" title=\"cmake使用时候的命名\"></a>cmake使用时候的命名</h1><p>cmake .. -DCMAKE_BUILD_TYPE&#x3D;Debug</p>\n<p>CMAKE_BUILD_TYPE<br>可选值包括：<br>Debug：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件<br>Release：用于构建的优化的库或可执行文件，不包含调试符号<br>RelWithDebInfo：由于构建较少的优化库或可执行文件，包含调试符号<br>MinSizeRel：用于不增加目标代码大小的优化方式，来构建或可执行文件</p>\n<h1 id=\"交叉编译工具\"><a href=\"#交叉编译工具\" class=\"headerlink\" title=\"交叉编译工具\"></a>交叉编译工具</h1><p>CMAKE给交叉编译预留了一个变量CMAKE_TOOLCHAIN_FILE，它定义了一个.cmake文件的路径，该文件里面设置了一系列CMAKE变量和属性，比如C_COMPILER，CXX_COMPILER等。.cmake文件的好处是一次编写多次使用，不同平台架构的交叉编译工具链可以编写一个独立的toolchain.cmake文件，而工程的CMakeLists.txt可以编写为通用格式，对工具链不可见。cmake脚本可以如下形式：</p>\n<p>add_library()：这是一个CMake函数，用于创建一个库文件。</p>\n<p>add_executable()：这是一个CMake函数，用于创建一个可执行文件。</p>\n<p>target_link_libraries()：这是一个CMake函数，用于指定链接的库文件。</p>\n<p>include_directories()：这是一个CMake函数，用于指定头文件的搜索路径。</p>\n<p>add_subdirectory():添加一个子目录并构建该子目录。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[find_package讲解]<a href=\"https://blog.csdn.net/zhanghm1995/article/details/105466372\">https://blog.csdn.net/zhanghm1995/article/details/105466372</a><br>[C++连接mysql用cmake编译]<a href=\"https://blog.csdn.net/lbwanghr/article/details/111076593\">https://blog.csdn.net/lbwanghr/article/details/111076593</a><br>[什么是交叉编译]<a href=\"https://zhuanlan.zhihu.com/p/77116555\">https://zhuanlan.zhihu.com/p/77116555</a></p>\n","slug":"Tutorial/linux-dev-env/cmake-tutorial","updated":"02/03/2023","comments":true,"link":"","permalink":"http://example.com/2022/02/21/Tutorial/linux-dev-env/cmake-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"物理机安装 ubuntu20","date":"12/02/2022","path":"2022/02/12/Environment-Configuration/install-ubuntu20/","text":"惠普进入BOIS模式，直接按F10 [win10安装]https://zhuanlan.zhihu.com/p/108156241win10安装ubuntu双系统","raw":"---\ntitle: 物理机安装 ubuntu20\ndate: 2022-02-12 18:40:28\ntags:\n- 环境配置\n---\n\n\n惠普进入BOIS模式，直接按F10\n\n\n\n[win10安装]https://zhuanlan.zhihu.com/p/108156241\n[win10安装ubuntu双系统](https://zhuanlan.zhihu.com/p/363640824#:~:text=Windows%2BUbuntu20.04%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%201%201.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Ubuntu20.04%202%202.%20%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%203,%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85%2012%204.%20%E6%9B%B4%E6%94%B9BIOS%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9.%20%E6%8C%89ENTER%E5%B0%86Ubuntu%E5%90%AF%E5%8A%A8%E7%A7%BB%E5%88%B0%E7%AC%AC%E4%B8%80%E4%BD%8D%EF%BC%8C%E4%BF%9D%E5%AD%98%E9%80%80%E5%87%BA%EF%BC%8C%E5%BC%80%E6%9C%BA%E8%BF%9B%E5%85%A5%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%80%89%E9%A1%B9%E4%BA%86%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%BD%8D%E6%98%AFUbuntu%EF%BC%8C%E7%AC%AC%E4%B8%89%E4%B8%AA%E6%98%AFWindows.%2013%20%E5%9B%9B.%20%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90)","content":"<p>惠普进入BOIS模式，直接按F10</p>\n<p>[win10安装]<a href=\"https://zhuanlan.zhihu.com/p/108156241\">https://zhuanlan.zhihu.com/p/108156241</a><br><a href=\"https://zhuanlan.zhihu.com/p/363640824#:~:text=Windows%2BUbuntu20.04%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%201%201.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Ubuntu20.04%202%202.%20%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%203,%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85%2012%204.%20%E6%9B%B4%E6%94%B9BIOS%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9.%20%E6%8C%89ENTER%E5%B0%86Ubuntu%E5%90%AF%E5%8A%A8%E7%A7%BB%E5%88%B0%E7%AC%AC%E4%B8%80%E4%BD%8D%EF%BC%8C%E4%BF%9D%E5%AD%98%E9%80%80%E5%87%BA%EF%BC%8C%E5%BC%80%E6%9C%BA%E8%BF%9B%E5%85%A5%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%80%89%E9%A1%B9%E4%BA%86%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%BD%8D%E6%98%AFUbuntu%EF%BC%8C%E7%AC%AC%E4%B8%89%E4%B8%AA%E6%98%AFWindows.%2013%20%E5%9B%9B.%20%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90\">win10安装ubuntu双系统</a></p>\n","slug":"Environment-Configuration/install-ubuntu20","updated":"29/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/12/Environment-Configuration/install-ubuntu20/","excerpt":"","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"hexo 教程","date":"12/02/2022","path":"2022/02/12/Tutorial/hexo-tutorial/","text":"常见的博客种类的介绍 动态博客 全都自己搭建 springboot +js+mysql wordpress docker PHP 静态博客 基于XXX的开源博客 hexo 纯前端，纯js的展示界面 node.js jekyllrb Ruby hugo go语言 VuePress solo java 一、hexo 安装教程1.下载node.js去http://nodejs.cn/ 下载长期支持版直接下一步安装即可安装后有两个东西node.js本身npm包管理器确认安装成功 1234node -vv16.13.1npm -v8.1.2 2.安装cnpm代替npm在国内npm比较慢npm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org确认安装成功 1cnpm -v 3..cnpm安装hexocnpm install -g hexo-cli确认安装成功 1hexo -v 到这里，hexo博客的框架已经安装好了 二、搭建第一个hexo博客1.新建一个文件夹D盘随便新建一个文件夹blog以后的东西都是在里面用的，如果出错了直接删掉找个文件夹重来就可以了 2.初始化博客进入文件夹hexo init 3.第一次启动博客hexo s粘贴网址，查看启动的博客 4.部署到github安装一个git插件npm install hexo-deployer-git –save 5.对hexo进行配置打开blog文件夹下的_config.yml拉到最底部 12deploy: type: &#x27;&#x27; 改为 1234deploy: type: git repository: # github中仓库的地址 branch: master/main # 参考github中主分支的名字 git config –global user.name “name”git config –global user.email “emal” hexo d # 推送上去，就推送到github了 6.在github中开启GitHub Pages服务在最上面一行找到settings找到Pages 三、hexo 常用命令下次开始再次编辑的时候，在需要编辑的文件夹里面打开git bash，不需要hexo init,直接hexo s就可以启动本地页面 初始化1hexo init 创建新页面12hexo n &quot;我的页面名称&quot;hexo new [layout] &quot;我的页面名称&quot; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 生成静态文件12hexo g hexo generate 启动服务器每次再次想要编辑网站的时候可以直接用这个命令 12hexo s hexo server 部署网站12hexo d hexo deploy 清除缓存文件1hexo clean 列出网站资料1234hexo list Usage: hexo list &lt;type&gt;Arguments: type Available types: page, post, route, tag, category 链接12https://hexo.io/zh-cn/docs/commands.html直接放链接就可以了 四、修复一些问题hexo下markdown表格失效表格和正文空开一行 编码使用UTF-8编码GB 2312会乱码 标题文件名没有用，只有文章里面的内容的名字才有用直接新建文件，开头用如下格式，就可以新建文章 123456---title: day07123141date: 2022-04-03 15:51:39tags:- Linux网络编程--- Cannot GET&#x2F;xxxx使用了pure主题以后，多出了很多的分类，比如友链，书单之类的，点进出会出现Cannot GET /book的错误，实际情况希望能获取到自己想要的页面修复方法 步骤一：去主题目录下查看\\blog\\theme\\pure_config.yml这就是当前左边的主标签1234567menu: Home: . Archives: archives # 归档 Categories: categories # 分类 Links: links # 友链 About: about # 关于 Books: book # 关于 步骤二：想要创建对应的标签的内容，以book举例在控制台中执行hexo new page “book”\\blog\\source\\book\\index.mdindex.md就是每个文件都要包含的文件，也是需要展示的内容直接生成就可以了 步骤三：如果需要建立新的标签，重复上面两个步骤如果不改编码，会在左侧标签出现menu.book的问题由于使用了中文字符编码，所以需要进入主题中改一下yml文件\\blog\\themes\\pure\\languages使用的是zh-CN.yml12345678menu: Home: 首页 Archives: 归档 Categories: 分类 ... book: 书 About: 关于 Cat: 猫 # 自己添加的标签 将自己想要添加标签写上重新生成 添加搜索功能安装插件npm i -S hexo-generator-json-content在你运行 hexo g 或者 hexo s 时生效，在 hexo g 生成站点时, 会在根目录下生成 content.json 该文件内容即为搜索内容。你可以对搜索内容进行自定义的配置， 只要在 _config.yml 中配置 12345678910111213141516171819# 示例: 隐藏分类和标签的搜索jsonContent: dateFormat: DD/MM/YYYY posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false author: false 五、配置相关配置语言12language: zh-CN # 中文language: en # 英文 得查看当前使用的主题使用的什么配置我使用的主题是pure里面有languages文件有配置文件名字zh-CN.yml，使用中文需要改成这个 pure主题的改变fancybox：实现点击图片放大的部件，默认关闭，打开后会导致友链打不开profile：改变个人信息 改变每页的文章数目per_page: 20 参考文献[B站羊哥的教程]https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca[官方的链接参考] https://hexo.io/zh-cn/docs/commands.htmlhexo下Markdown语法失效总结 https://blog.csdn.net/weixin_42932905/article/details/106153679?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-106153679.pc_agg_new_rank&amp;utm_term=hexo+markdown%E4%B8%8D%E7%94%9F%E6%95%88&amp;spm=1000.2123.3001.4430大佬的一些教程 https://hwame.top/[hexo博客出现“Cannot GET&#x2F;xxxx”的错误]https://blog.csdn.net/weixin_30699831/article/details/96894620[启用搜索功能]https://blog.plcent.com/2019/11/05/hexo-theme-pure/[添加友链]https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md[启用RSS订阅]https://wxnacy.com/2018/12/12/hexo-add-rss/[启用RSS订阅]https://www.jianshu.com/p/2aaac7a19736","raw":"---\ntitle: hexo 教程\ndate: 2022-02-12 18:18:12\ntags:\n- 教程\n---\n\n# 常见的博客种类的介绍\n\n- 动态博客\n    - 全都自己搭建\n        - springboot +js+mysql\n    - wordpress\n        - docker\n        - PHP\n\n- 静态博客\n    - 基于XXX的开源博客\n    - hexo\n        - 纯前端，纯js的展示界面\n        - node.js\n    - jekyllrb\n        - Ruby\n    - hugo\n        - go语言\n    - VuePress\n    - solo\n        - java\n\n# 一、hexo 安装教程\n\n## 1.下载node.js\n去http://nodejs.cn/ 下载长期支持版\n直接下一步安装即可\n安装后有两个东西\nnode.js本身\nnpm包管理器\n确认安装成功\n```\nnode -v\nv16.13.1\nnpm -v\n8.1.2\n```\n## 2.安装cnpm代替npm\n在国内npm比较慢\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n确认安装成功\n```\ncnpm -v\n```\n## 3..cnpm安装hexo\ncnpm install -g hexo-cli\n确认安装成功\n```\nhexo -v\n```\n到这里，hexo博客的框架已经安装好了\n\n# 二、搭建第一个hexo博客\n## 1.新建一个文件夹\nD盘随便新建一个文件夹blog\n以后的东西都是在里面用的，如果出错了直接删掉找个文件夹重来就可以了\n## 2.初始化博客\n进入文件夹\nhexo init\n## 3.第一次启动博客\nhexo s\n粘贴网址，查看启动的博客\n## 4.部署到github\n安装一个git插件\nnpm install hexo-deployer-git --save\n## 5.对hexo进行配置\n打开blog文件夹下的_config.yml\n拉到最底部\n```\ndeploy:\n  type: ''\n```\n改为\n```\ndeploy:\n  type: git\n  repository: # github中仓库的地址\n  branch: master/main # 参考github中主分支的名字\n```\ngit config --global user.name  \"name\"\ngit config --global user.email  \"emal\"\n\nhexo d # 推送上去，就推送到github了\n\n## 6.在github中开启GitHub Pages服务\n在最上面一行找到settings\n找到Pages\n\n\n\n# 三、hexo 常用命令\n下次开始再次编辑的时候，在需要编辑的文件夹里面打开git bash，不需要hexo init,直接hexo s就可以启动本地页面\n\n## 初始化\n``` \nhexo init\n```\n\n## 创建新页面\n``` \nhexo n \"我的页面名称\"\nhexo new [layout] \"我的页面名称\"\n```\n您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。\n\n## 生成静态文件\n``` \nhexo g \nhexo generate\n```\n\n## 启动服务器\n每次再次想要编辑网站的时候可以直接用这个命令\n``` \nhexo s \nhexo server\n```\n\n## 部署网站\n```\nhexo d \nhexo deploy\n```\n\n## 清除缓存文件\n```\nhexo clean\n```\n## 列出网站资料\n```\nhexo list \nUsage: hexo list <type>\nArguments:\n  type  Available types: page, post, route, tag, category\n```\n\n## 链接\n```\nhttps://hexo.io/zh-cn/docs/commands.html\n直接放链接就可以了\n```\n# 四、修复一些问题\n## hexo下markdown表格失效\n表格和正文空开一行\n\n## 编码\n使用UTF-8编码\nGB 2312会乱码\n\n## 标题\n文件名没有用，只有文章里面的内容的名字才有用\n直接新建文件，开头用如下格式，就可以新建文章\n\n```\n---\ntitle: day07123141\ndate: 2022-04-03 15:51:39\ntags:\n- Linux网络编程\n---\n```\n## Cannot GET/xxxx\n使用了pure主题以后，多出了很多的分类，比如友链，书单之类的，点进出会出现```Cannot GET /book```的错误，实际情况希望能获取到自己想要的页面修复方法\n- 步骤一：\n去主题目录下查看\\blog\\theme\\pure\\_config.yml\n这就是当前左边的主标签\n```\nmenu:\n  Home: .\n  Archives: archives  # 归档\n  Categories: categories  # 分类\n  Links: links  # 友链\n  About: about  # 关于\n  Books: book  # 关于\n```\n- 步骤二：\n想要创建对应的标签的内容，以book举例\n在控制台中执行\nhexo new page \"book\"\n\\blog\\source\\book\\index.md\nindex.md就是每个文件都要包含的文件，也是需要展示的内容\n直接生成就可以了\n- 步骤三：\n如果需要建立新的标签，重复上面两个步骤\n如果不改编码，会在左侧标签出现\nmenu.book的问题\n由于使用了中文字符编码，所以需要进入主题中改一下yml文件\n\\blog\\themes\\pure\\languages\\\n使用的是zh-CN.yml\n```\nmenu:\n  Home: 首页\n  Archives: 归档\n  Categories: 分类\n  ...\n  book: 书\n  About: 关于\n  Cat: 猫 # 自己添加的标签\n```\n将自己想要添加标签写上\n重新生成\n\n## 添加搜索功能\n安装插件\nnpm i -S hexo-generator-json-content \n在你运行 hexo g 或者 hexo s 时生效，在 hexo g 生成站点时, 会在根目录下生成 content.json 该文件内容即为搜索内容。\n你可以对搜索内容进行自定义的配置， 只要在 _config.yml 中配置\n```\n# 示例: 隐藏分类和标签的搜索\njsonContent:\n  dateFormat: DD/MM/YYYY\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: false\n    author: false\n```\n\n# 五、配置相关\n## 配置语言\n```\nlanguage: zh-CN  # 中文\nlanguage: en        # 英文\n```\n得查看当前使用的主题使用的什么配置\n我使用的主题是pure里面有languages文件有配置文件名字zh-CN.yml，使用中文需要改成这个\n\n## pure主题的改变\nfancybox：实现点击图片放大的部件，默认关闭，打开后会导致友链打不开\nprofile：改变个人信息\n\n### 改变每页的文章数目\nper_page: 20\n\n# 参考文献\n[B站羊哥的教程]https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&vd_source=76dff3ae3b42b00d067c0921bf6859ca\n[官方的链接参考] https://hexo.io/zh-cn/docs/commands.html\nhexo下Markdown语法失效总结 https://blog.csdn.net/weixin_42932905/article/details/106153679?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-106153679.pc_agg_new_rank&utm_term=hexo+markdown%E4%B8%8D%E7%94%9F%E6%95%88&spm=1000.2123.3001.4430\n大佬的一些教程 https://hwame.top/\n[hexo博客出现“Cannot GET/xxxx”的错误]https://blog.csdn.net/weixin_30699831/article/details/96894620\n[启用搜索功能]https://blog.plcent.com/2019/11/05/hexo-theme-pure/\n[添加友链]https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md\n[启用RSS订阅]https://wxnacy.com/2018/12/12/hexo-add-rss/\n[启用RSS订阅]https://www.jianshu.com/p/2aaac7a19736","content":"<h1 id=\"常见的博客种类的介绍\"><a href=\"#常见的博客种类的介绍\" class=\"headerlink\" title=\"常见的博客种类的介绍\"></a>常见的博客种类的介绍</h1><ul>\n<li><p>动态博客</p>\n<ul>\n<li>全都自己搭建<ul>\n<li>springboot +js+mysql</li>\n</ul>\n</li>\n<li>wordpress<ul>\n<li>docker</li>\n<li>PHP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>静态博客</p>\n<ul>\n<li>基于XXX的开源博客</li>\n<li>hexo<ul>\n<li>纯前端，纯js的展示界面</li>\n<li>node.js</li>\n</ul>\n</li>\n<li>jekyllrb<ul>\n<li>Ruby</li>\n</ul>\n</li>\n<li>hugo<ul>\n<li>go语言</li>\n</ul>\n</li>\n<li>VuePress</li>\n<li>solo<ul>\n<li>java</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"一、hexo-安装教程\"><a href=\"#一、hexo-安装教程\" class=\"headerlink\" title=\"一、hexo 安装教程\"></a>一、hexo 安装教程</h1><h2 id=\"1-下载node-js\"><a href=\"#1-下载node-js\" class=\"headerlink\" title=\"1.下载node.js\"></a>1.下载node.js</h2><p>去<a href=\"http://nodejs.cn/\">http://nodejs.cn/</a> 下载长期支持版<br>直接下一步安装即可<br>安装后有两个东西<br>node.js本身<br>npm包管理器<br>确认安装成功</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">node</span> -v</span><br><span class=\"line\"><span class=\"attribute\">v16</span>.<span class=\"number\">13</span>.<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attribute\">npm</span> -v</span><br><span class=\"line\"><span class=\"attribute\">8</span>.<span class=\"number\">1</span>.<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-安装cnpm代替npm\"><a href=\"#2-安装cnpm代替npm\" class=\"headerlink\" title=\"2.安装cnpm代替npm\"></a>2.安装cnpm代替npm</h2><p>在国内npm比较慢<br>npm install -g cnpm –registry&#x3D;<a href=\"https://registry.npm.taobao.org/\">https://registry.npm.taobao.org</a><br>确认安装成功</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">cnpm -v</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-cnpm安装hexo\"><a href=\"#3-cnpm安装hexo\" class=\"headerlink\" title=\"3..cnpm安装hexo\"></a>3..cnpm安装hexo</h2><p>cnpm install -g hexo-cli<br>确认安装成功</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo -v</span></span><br></pre></td></tr></table></figure>\n<p>到这里，hexo博客的框架已经安装好了</p>\n<h1 id=\"二、搭建第一个hexo博客\"><a href=\"#二、搭建第一个hexo博客\" class=\"headerlink\" title=\"二、搭建第一个hexo博客\"></a>二、搭建第一个hexo博客</h1><h2 id=\"1-新建一个文件夹\"><a href=\"#1-新建一个文件夹\" class=\"headerlink\" title=\"1.新建一个文件夹\"></a>1.新建一个文件夹</h2><p>D盘随便新建一个文件夹blog<br>以后的东西都是在里面用的，如果出错了直接删掉找个文件夹重来就可以了</p>\n<h2 id=\"2-初始化博客\"><a href=\"#2-初始化博客\" class=\"headerlink\" title=\"2.初始化博客\"></a>2.初始化博客</h2><p>进入文件夹<br>hexo init</p>\n<h2 id=\"3-第一次启动博客\"><a href=\"#3-第一次启动博客\" class=\"headerlink\" title=\"3.第一次启动博客\"></a>3.第一次启动博客</h2><p>hexo s<br>粘贴网址，查看启动的博客</p>\n<h2 id=\"4-部署到github\"><a href=\"#4-部署到github\" class=\"headerlink\" title=\"4.部署到github\"></a>4.部署到github</h2><p>安装一个git插件<br>npm install hexo-deployer-git –save</p>\n<h2 id=\"5-对hexo进行配置\"><a href=\"#5-对hexo进行配置\" class=\"headerlink\" title=\"5.对hexo进行配置\"></a>5.对hexo进行配置</h2><p>打开blog文件夹下的_config.yml<br>拉到最底部</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: <span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">deploy:</span></span><br><span class=\"line\"><span class=\"symbol\">  type:</span> git</span><br><span class=\"line\"><span class=\"symbol\">  repository:</span> <span class=\"meta\"># github中仓库的地址</span></span><br><span class=\"line\"><span class=\"symbol\">  branch:</span> master/main <span class=\"meta\"># 参考github中主分支的名字</span></span><br></pre></td></tr></table></figure>\n<p>git config –global user.name  “name”<br>git config –global user.email  “emal”</p>\n<p>hexo d # 推送上去，就推送到github了</p>\n<h2 id=\"6-在github中开启GitHub-Pages服务\"><a href=\"#6-在github中开启GitHub-Pages服务\" class=\"headerlink\" title=\"6.在github中开启GitHub Pages服务\"></a>6.在github中开启GitHub Pages服务</h2><p>在最上面一行找到settings<br>找到Pages</p>\n<h1 id=\"三、hexo-常用命令\"><a href=\"#三、hexo-常用命令\" class=\"headerlink\" title=\"三、hexo 常用命令\"></a>三、hexo 常用命令</h1><p>下次开始再次编辑的时候，在需要编辑的文件夹里面打开git bash，不需要hexo init,直接hexo s就可以启动本地页面</p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">init</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建新页面\"><a href=\"#创建新页面\" class=\"headerlink\" title=\"创建新页面\"></a>创建新页面</h2><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n <span class=\"string\">&quot;我的页面名称&quot;</span></span><br><span class=\"line\">hexo <span class=\"keyword\">new</span> <span class=\"type\"></span>[layout] <span class=\"string\">&quot;我的页面名称&quot;</span></span><br></pre></td></tr></table></figure>\n<p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p>\n<h2 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h2><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g </span><br><span class=\"line\">hexo <span class=\"keyword\">generate</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p>每次再次想要编辑网站的时候可以直接用这个命令</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s </span><br><span class=\"line\">hexo <span class=\"keyword\">server</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"部署网站\"><a href=\"#部署网站\" class=\"headerlink\" title=\"部署网站\"></a>部署网站</h2><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo d </span></span><br><span class=\"line\"><span class=\"attribute\">hexo deploy</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"清除缓存文件\"><a href=\"#清除缓存文件\" class=\"headerlink\" title=\"清除缓存文件\"></a>清除缓存文件</h2><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo clean</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"列出网站资料\"><a href=\"#列出网站资料\" class=\"headerlink\" title=\"列出网站资料\"></a>列出网站资料</h2><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">hexo</span> list </span><br><span class=\"line\"><span class=\"type\">Usage</span>: hexo list &lt;<span class=\"keyword\">type</span>&gt;</span><br><span class=\"line\"><span class=\"type\">Arguments</span>:</span><br><span class=\"line\">  <span class=\"keyword\">type</span>  <span class=\"type\">Available</span> types: page, post, route, tag, category</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https:<span class=\"regexp\">//</span>hexo.io<span class=\"regexp\">/zh-cn/</span>docs/commands.html</span><br><span class=\"line\">直接放链接就可以了</span><br></pre></td></tr></table></figure>\n<h1 id=\"四、修复一些问题\"><a href=\"#四、修复一些问题\" class=\"headerlink\" title=\"四、修复一些问题\"></a>四、修复一些问题</h1><h2 id=\"hexo下markdown表格失效\"><a href=\"#hexo下markdown表格失效\" class=\"headerlink\" title=\"hexo下markdown表格失效\"></a>hexo下markdown表格失效</h2><p>表格和正文空开一行</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>使用UTF-8编码<br>GB 2312会乱码</p>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>文件名没有用，只有文章里面的内容的名字才有用<br>直接新建文件，开头用如下格式，就可以新建文章</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">day07123141</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2022-04-03 15:51:39</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">Linux网络编程</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Cannot-GET-x2F-xxxx\"><a href=\"#Cannot-GET-x2F-xxxx\" class=\"headerlink\" title=\"Cannot GET&#x2F;xxxx\"></a>Cannot GET&#x2F;xxxx</h2><p>使用了pure主题以后，多出了很多的分类，比如友链，书单之类的，点进出会出现<code>Cannot GET /book</code>的错误，实际情况希望能获取到自己想要的页面修复方法</p>\n<ul>\n<li>步骤一：<br>去主题目录下查看\\blog\\theme\\pure_config.yml<br>这就是当前左边的主标签<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">menu:</span></span><br><span class=\"line\"><span class=\"symbol\">  Home:</span> .</span><br><span class=\"line\"><span class=\"symbol\">  Archives:</span> archives  <span class=\"meta\"># 归档</span></span><br><span class=\"line\"><span class=\"symbol\">  Categories:</span> categories  <span class=\"meta\"># 分类</span></span><br><span class=\"line\"><span class=\"symbol\">  Links:</span> links  <span class=\"meta\"># 友链</span></span><br><span class=\"line\"><span class=\"symbol\">  About:</span> about  <span class=\"meta\"># 关于</span></span><br><span class=\"line\"><span class=\"symbol\">  Books:</span> book  <span class=\"meta\"># 关于</span></span><br></pre></td></tr></table></figure></li>\n<li>步骤二：<br>想要创建对应的标签的内容，以book举例<br>在控制台中执行<br>hexo new page “book”<br>\\blog\\source\\book\\index.md<br>index.md就是每个文件都要包含的文件，也是需要展示的内容<br>直接生成就可以了</li>\n<li>步骤三：<br>如果需要建立新的标签，重复上面两个步骤<br>如果不改编码，会在左侧标签出现<br>menu.book的问题<br>由于使用了中文字符编码，所以需要进入主题中改一下yml文件<br>\\blog\\themes\\pure\\languages<br>使用的是zh-CN.yml<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">menu:</span></span><br><span class=\"line\"><span class=\"symbol\">  Home:</span> 首页</span><br><span class=\"line\"><span class=\"symbol\">  Archives:</span> 归档</span><br><span class=\"line\"><span class=\"symbol\">  Categories:</span> 分类</span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"symbol\">  book:</span> 书</span><br><span class=\"line\"><span class=\"symbol\">  About:</span> 关于</span><br><span class=\"line\"><span class=\"symbol\">  Cat:</span> 猫 <span class=\"meta\"># 自己添加的标签</span></span><br></pre></td></tr></table></figure>\n将自己想要添加标签写上<br>重新生成</li>\n</ul>\n<h2 id=\"添加搜索功能\"><a href=\"#添加搜索功能\" class=\"headerlink\" title=\"添加搜索功能\"></a>添加搜索功能</h2><p>安装插件<br>npm i -S hexo-generator-json-content<br>在你运行 hexo g 或者 hexo s 时生效，在 hexo g 生成站点时, 会在根目录下生成 content.json 该文件内容即为搜索内容。<br>你可以对搜索内容进行自定义的配置， 只要在 _config.yml 中配置</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例: 隐藏分类和标签的搜索</span></span><br><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\">  <span class=\"attr\">dateFormat:</span> <span class=\"string\">DD/MM/YYYY</span></span><br><span class=\"line\">  <span class=\"attr\">posts:</span></span><br><span class=\"line\">    <span class=\"attr\">title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">tags:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">author:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"五、配置相关\"><a href=\"#五、配置相关\" class=\"headerlink\" title=\"五、配置相关\"></a>五、配置相关</h1><h2 id=\"配置语言\"><a href=\"#配置语言\" class=\"headerlink\" title=\"配置语言\"></a>配置语言</h2><figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">language:</span> <span class=\"built_in\">zh</span>-CN  <span class=\"meta\"># 中文</span></span><br><span class=\"line\"><span class=\"symbol\">language:</span> en        <span class=\"meta\"># 英文</span></span><br></pre></td></tr></table></figure>\n<p>得查看当前使用的主题使用的什么配置<br>我使用的主题是pure里面有languages文件有配置文件名字zh-CN.yml，使用中文需要改成这个</p>\n<h2 id=\"pure主题的改变\"><a href=\"#pure主题的改变\" class=\"headerlink\" title=\"pure主题的改变\"></a>pure主题的改变</h2><p>fancybox：实现点击图片放大的部件，默认关闭，打开后会导致友链打不开<br>profile：改变个人信息</p>\n<h3 id=\"改变每页的文章数目\"><a href=\"#改变每页的文章数目\" class=\"headerlink\" title=\"改变每页的文章数目\"></a>改变每页的文章数目</h3><p>per_page: 20</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[B站羊哥的教程]<a href=\"https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca\">https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&amp;vd_source=76dff3ae3b42b00d067c0921bf6859ca</a><br>[官方的链接参考] <a href=\"https://hexo.io/zh-cn/docs/commands.html\">https://hexo.io/zh-cn/docs/commands.html</a><br>hexo下Markdown语法失效总结 <a href=\"https://blog.csdn.net/weixin_42932905/article/details/106153679?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-106153679.pc_agg_new_rank&amp;utm_term=hexo+markdown%E4%B8%8D%E7%94%9F%E6%95%88&amp;spm=1000.2123.3001.4430\">https://blog.csdn.net/weixin_42932905/article/details/106153679?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-106153679.pc_agg_new_rank&amp;utm_term=hexo+markdown%E4%B8%8D%E7%94%9F%E6%95%88&amp;spm=1000.2123.3001.4430</a><br>大佬的一些教程 <a href=\"https://hwame.top/\">https://hwame.top/</a><br>[hexo博客出现“Cannot GET&#x2F;xxxx”的错误]<a href=\"https://blog.csdn.net/weixin_30699831/article/details/96894620\">https://blog.csdn.net/weixin_30699831/article/details/96894620</a><br>[启用搜索功能]<a href=\"https://blog.plcent.com/2019/11/05/hexo-theme-pure/\">https://blog.plcent.com/2019/11/05/hexo-theme-pure/</a><br>[添加友链]<a href=\"https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md\">https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md</a><br>[启用RSS订阅]<a href=\"https://wxnacy.com/2018/12/12/hexo-add-rss/\">https://wxnacy.com/2018/12/12/hexo-add-rss/</a><br>[启用RSS订阅]<a href=\"https://www.jianshu.com/p/2aaac7a19736\">https://www.jianshu.com/p/2aaac7a19736</a></p>\n","slug":"Tutorial/hexo-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/12/Tutorial/hexo-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Markdown 教程","date":"12/02/2022","path":"2022/02/12/Tutorial/Markdown-tutorial/","text":"生成目录 [TOC][TOC] 1标题1234567891011# 这是 &lt;h1&gt; 一级标题## 这是 &lt;h2&gt; 二级标题### 这是 &lt;h3&gt; 三级标题#### 这是 &lt;h4&gt; 四级标题##### 这是 &lt;h5&gt; 五级标题###### 这是 &lt;h6&gt; 六级标题 2斜体123456```*这会是 斜体 的文字*``` *这会是 斜体 的文字*```_这会是 斜体 的文字_``` _这会是 斜体 的文字_```**这会是 粗体 的文字**``` **这会是 粗体 的文字**```__这会是 粗体 的文字__``` __这会是 粗体 的文字__```_你也 **组合** 这些符号_``` _你也 **组合** 这些符号_```~~这个文字将会被横线删除~~``` ~~这个文字将会被横线删除~~ 3列表无序列表 Item 1 Item 2 Item 2a Item 2b 1234- Item 1- Item 2 - Item 2a - Item 2b 有序列表 Item 1 Item 2 Item 3 Item 3a Item 3b123451. Item 11. Item 21. Item 3 1. Item 3a 1. Item 3b 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 1234567891011* 第一项 * 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项 图片1![Alt text](图片链接 &quot;optional title&quot;) Alt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。图片链接：可以是图片的本地地址或者是网址。“optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。 引用12&gt; We&#x27;re living the future so&gt; the present is our past. 4分隔符 连字符星号下划线你可以在你的代码上面和下面添加 &#96;&#96;&#96; 来表示代码块。 1printf(&quot;hello world&quot;) 5创建表格默认表格1234| 标题1 | 标题2 | 标题3 || ------ | ------ | ------ || 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 || 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 | 标题1 标题2 标题3 文本好短 文本不短也不长 文本好长文本好长文本好长 文本好长文本好长文本好长 文本好短 文本不短也不长 带有对齐格式的表格1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 || 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 | 左对齐 右对齐 居中对齐 文本好短 文本不短也不长 文本好长文本好长文本好长 文本好长文本好长文本好长 文本好短 文本不短也不长 Markdown关于表格的语法默认标题居中对齐，内容居左对齐:-内容和标题栏居左对齐，:-:内容和标题栏居中对齐，-:内容和标题栏居右对齐| - :之间多余的空格会被忽略，-的数量至少一个内容和|之间多余的空格会被忽略 表格内换行&lt;br&gt; 转义字符\\&lt;mutex&gt;&lt;mutex&gt; 6代码块123456789@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): &#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Greater&#x27; return (param2 - param1 + 1) or Noneclass SomeClass: pass 12345#include &quot;config.h&quot;Config::Config()&#123; //端口号,默认9006 PORT = 9006;&#125; 7已完成的标记+引用[^code] 有一个launch.json文件，会调用刚刚写的 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） &#x2F;&#x2F; 引用[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8隐藏超链接[md文件编写可以使用在线所见即所得编辑器]https://www.zybuluo.com/mdeditormd文件编写可以使用在线所见即所得编辑器 参考文献https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basicshttps://www.jianshu.com/p/280c6a6f2594[md文件编写可以使用在线所见即所得编辑器]https://www.zybuluo.com/mdeditor","raw":"---\ntitle: Markdown 教程\ndate: 2022-02-12 16:44:29\ntags:\n- 教程\n---\n\n生成目录 [TOC]\n[TOC]\n\n# 1标题\n```\n# 这是 <h1> 一级标题\n\n## 这是 <h2> 二级标题\n\n### 这是 <h3> 三级标题\n\n#### 这是 <h4> 四级标题\n\n##### 这是 <h5> 五级标题\n\n###### 这是 <h6> 六级标题\n```\n\n# 2斜体\n\n```\n```*这会是 斜体 的文字*``` *这会是 斜体 的文字*\n```_这会是 斜体 的文字_``` _这会是 斜体 的文字_\n```**这会是 粗体 的文字**``` **这会是 粗体 的文字**\n```__这会是 粗体 的文字__``` __这会是 粗体 的文字__\n```_你也 **组合** 这些符号_``` _你也 **组合** 这些符号_\n```~~这个文字将会被横线删除~~``` ~~这个文字将会被横线删除~~\n```\n\n\n\n\n# 3列表\n## 无序列表\n- Item 1\n- Item 2\n  - Item 2a\n  - Item 2b\n\n```\n- Item 1\n- Item 2\n  - Item 2a\n  - Item 2b\n```\n\n## 有序列表\n1. Item 1\n1. Item 2\n1. Item 3\n   1. Item 3a\n   1. Item 3b\n```\n1. Item 1\n1. Item 2\n1. Item 3\n   1. Item 3a\n   1. Item 3b\n```\n* 第一项      \n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n\n```\n* 第一项      \n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n\n# 图片\n\n```\n![Alt text](图片链接 \"optional title\")\n```\nAlt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。 \n图片链接：可以是图片的本地地址或者是网址。\n\"optional title\"：鼠标悬置于图片上会出现的标题文字，可以不写。\n\n![Hollow Knight](../img/1.jpg)\n\n# 引用\n```\n> We're living the future so\n> the present is our past.\n```\n\n# 4分隔符\n---\n连字符\n---\n星号\n---\n下划线\n---\n\n\n你可以在你的代码上面和下面添加 ``` 来表示代码块。\n\n```\nprintf(\"hello world\") \n```\n\n\n# 5创建表格\n\n## 默认表格\n```\n| 标题1 | 标题2 | 标题3 |\n| ------ | ------ | ------ |\n| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |\n| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |\n```\n| 标题1 | 标题2 | 标题3 |\n| ------ | ------ | ------ |\n| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |\n| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |\n\n## 带有对齐格式的表格\n```\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |\n| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |\n```\n\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |\n| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |\n\n\n## Markdown关于表格的语法\n默认标题居中对齐，内容居左对齐\n:-内容和标题栏居左对齐，:-:内容和标题栏居中对齐，-:内容和标题栏居右对齐\n| - :之间多余的空格会被忽略，-的数量至少一个\n内容和|之间多余的空格会被忽略\n\n## 表格内换行\n```<br>```\n\n## 转义字符\n\n``\\<mutex>``\n\\<mutex>\n\n# 6代码块\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\n\nclass SomeClass:\n    pass\n```\n\n\n```cpp\n#include \"config.h\"\nConfig::Config(){\n    //端口号,默认9006\n    PORT = 9006;\n}\n```\n\n\n# 7已完成的标记+引用[^code]\n- [x] 有一个launch.json文件，会调用刚刚写的\n- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n- [x] 新增 Todo 列表功能\n\n\n> * 整理知识，学习笔记\n> * 发布日记，杂文，所见所想\n> * 撰写发布技术文稿（代码支持）\n> * 撰写发布学术论文（LaTeX 公式支持）\n\n\n// 引用\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，**四十一**种主流编程语言。\n\n\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n\n# 8隐藏超链接\n[md文件编写可以使用在线所见即所得编辑器]https://www.zybuluo.com/mdeditor\n[md文件编写可以使用在线所见即所得编辑器](https://www.zybuluo.com/mdeditor)\n\n\n# 参考文献\nhttps://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics\nhttps://www.jianshu.com/p/280c6a6f2594\n[md文件编写可以使用在线所见即所得编辑器]https://www.zybuluo.com/mdeditor\n\n","content":"<p>生成目录 [TOC]<br>[TOC]</p>\n<h1 id=\"1标题\"><a href=\"#1标题\" class=\"headerlink\" title=\"1标题\"></a>1标题</h1><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是 &lt;h1&gt; 一级标题</span><br><span class=\"line\"></span><br><span class=\"line\">## 这是 &lt;h2&gt; 二级标题</span><br><span class=\"line\"></span><br><span class=\"line\">### 这是 &lt;h3&gt; 三级标题</span><br><span class=\"line\"></span><br><span class=\"line\">#### 这是 &lt;h4&gt; 四级标题</span><br><span class=\"line\"></span><br><span class=\"line\">##### 这是 &lt;h5&gt; 五级标题</span><br><span class=\"line\"></span><br><span class=\"line\">###### 这是 &lt;h6&gt; 六级标题</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2斜体\"><a href=\"#2斜体\" class=\"headerlink\" title=\"2斜体\"></a>2斜体</h1><figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```*这会是 斜体 的文字*``` *这会是 斜体 的文字*</span><br><span class=\"line\">```_这会是 斜体 的文字_``` _这会是 斜体 的文字_</span><br><span class=\"line\">```**这会是 粗体 的文字**``` **这会是 粗体 的文字**</span><br><span class=\"line\">```__这会是 粗体 的文字__``` __这会是 粗体 的文字__</span><br><span class=\"line\">```_你也 **组合** 这些符号_``` _你也 **组合** 这些符号_</span><br><span class=\"line\">```~~这个文字将会被横线删除~~``` ~~这个文字将会被横线删除~~</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"3列表\"><a href=\"#3列表\" class=\"headerlink\" title=\"3列表\"></a>3列表</h1><h2 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h2><ul>\n<li>Item 1</li>\n<li>Item 2<ul>\n<li>Item 2a</li>\n<li>Item 2b</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> Item 1</span><br><span class=\"line\"><span class=\"bullet\">-</span> Item 2</span><br><span class=\"line\"><span class=\"bullet\">  -</span> Item 2a</span><br><span class=\"line\"><span class=\"bullet\">  -</span> Item 2b</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h2><ol>\n<li>Item 1</li>\n<li>Item 2</li>\n<li>Item 3<ol>\n<li>Item 3a</li>\n<li>Item 3b<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">1</span>. Item <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attribute\">1</span>. Item <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"attribute\">1</span>. Item <span class=\"number\">3</span></span><br><span class=\"line\">   <span class=\"attribute\">1</span>. Item <span class=\"number\">3</span>a</span><br><span class=\"line\">   <span class=\"attribute\">1</span>. Item <span class=\"number\">3</span>b</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>第一项      </li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">*</span> 第一项      </span><br><span class=\"line\"><span class=\"bullet\">*</span> 第二项</span><br><span class=\"line\"><span class=\"bullet\">*</span> 第三项</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">+</span> 第一项</span><br><span class=\"line\"><span class=\"bullet\">+</span> 第二项</span><br><span class=\"line\"><span class=\"bullet\">+</span> 第三项</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> 第一项</span><br><span class=\"line\"><span class=\"bullet\">-</span> 第二项</span><br><span class=\"line\"><span class=\"bullet\">-</span> 第三项</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h1><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![Alt <span class=\"built_in\">text</span>](图片链接 <span class=\"string\">&quot;optional title&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>Alt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。<br>图片链接：可以是图片的本地地址或者是网址。<br>“optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。</p>\n<p><img src=\"/../img/1.jpg\" alt=\"Hollow Knight\"></p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><figure class=\"highlight node-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"title class_\">We</span><span class=\"string\">&#x27;re living the future so</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span> <span class=\"language-javascript\"><span class=\"string\">the present is our past.</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4分隔符\"><a href=\"#4分隔符\" class=\"headerlink\" title=\"4分隔符\"></a>4分隔符</h1><hr>\n<h2 id=\"连字符\"><a href=\"#连字符\" class=\"headerlink\" title=\"连字符\"></a>连字符</h2><h2 id=\"星号\"><a href=\"#星号\" class=\"headerlink\" title=\"星号\"></a>星号</h2><h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>你可以在你的代码上面和下面添加 &#96;&#96;&#96; 来表示代码块。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">printf</span><span class=\"params\">(<span class=\"string\">&quot;hello world&quot;</span>)</span></span> </span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"5创建表格\"><a href=\"#5创建表格\" class=\"headerlink\" title=\"5创建表格\"></a>5创建表格</h1><h2 id=\"默认表格\"><a href=\"#默认表格\" class=\"headerlink\" title=\"默认表格\"></a>默认表格</h2><figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|<span class=\"string\"> 标题1 </span>|<span class=\"string\"> 标题2 </span>|<span class=\"string\"> 标题3 </span>|</span><br><span class=\"line\">|<span class=\"string\"> ------ </span>|<span class=\"string\"> ------ </span>|<span class=\"string\"> ------ </span>|</span><br><span class=\"line\">|<span class=\"string\"> 文本好短 </span>|<span class=\"string\"> 文本不短也不长 </span>|<span class=\"string\"> 文本好长文本好长文本好长 </span>|</span><br><span class=\"line\">|<span class=\"string\"> 文本好长文本好长文本好长 </span>|<span class=\"string\"> 文本好短 </span>|<span class=\"string\"> 文本不短也不长 </span>|</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>标题1</th>\n<th>标题2</th>\n<th>标题3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文本好短</td>\n<td>文本不短也不长</td>\n<td>文本好长文本好长文本好长</td>\n</tr>\n<tr>\n<td>文本好长文本好长文本好长</td>\n<td>文本好短</td>\n<td>文本不短也不长</td>\n</tr>\n</tbody></table>\n<h2 id=\"带有对齐格式的表格\"><a href=\"#带有对齐格式的表格\" class=\"headerlink\" title=\"带有对齐格式的表格\"></a>带有对齐格式的表格</h2><figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|<span class=\"string\"> 左对齐 </span>|<span class=\"string\"> 右对齐 </span>|<span class=\"string\"> 居中对齐 </span>|</span><br><span class=\"line\">|<span class=\"string\"> :-----</span>|<span class=\"string\"> ----: </span>|<span class=\"string\"> :----: </span>|</span><br><span class=\"line\">|<span class=\"string\"> 文本好短 </span>|<span class=\"string\"> 文本不短也不长 </span>|<span class=\"string\"> 文本好长文本好长文本好长 </span>|</span><br><span class=\"line\">|<span class=\"string\"> 文本好长文本好长文本好长 </span>|<span class=\"string\"> 文本好短 </span>|<span class=\"string\"> 文本不短也不长 </span>|</span><br></pre></td></tr></table></figure>\n\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">左对齐</th>\n<th align=\"right\">右对齐</th>\n<th align=\"center\">居中对齐</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">文本好短</td>\n<td align=\"right\">文本不短也不长</td>\n<td align=\"center\">文本好长文本好长文本好长</td>\n</tr>\n<tr>\n<td align=\"left\">文本好长文本好长文本好长</td>\n<td align=\"right\">文本好短</td>\n<td align=\"center\">文本不短也不长</td>\n</tr>\n</tbody></table>\n<h2 id=\"Markdown关于表格的语法\"><a href=\"#Markdown关于表格的语法\" class=\"headerlink\" title=\"Markdown关于表格的语法\"></a>Markdown关于表格的语法</h2><p>默认标题居中对齐，内容居左对齐<br>:-内容和标题栏居左对齐，:-:内容和标题栏居中对齐，-:内容和标题栏居右对齐<br>| - :之间多余的空格会被忽略，-的数量至少一个<br>内容和|之间多余的空格会被忽略</p>\n<h2 id=\"表格内换行\"><a href=\"#表格内换行\" class=\"headerlink\" title=\"表格内换行\"></a>表格内换行</h2><p><code>&lt;br&gt;</code></p>\n<h2 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h2><p><code>\\&lt;mutex&gt;</code><br>&lt;mutex&gt;</p>\n<h1 id=\"6代码块\"><a href=\"#6代码块\" class=\"headerlink\" title=\"6代码块\"></a>6代码块</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@requires_authorization</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">somefunc</span>(<span class=\"params\">param1=<span class=\"string\">&#x27;&#x27;</span>, param2=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> param1 &gt; param2: <span class=\"comment\"># interesting</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&#x27;Greater&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (param2 - param1 + <span class=\"number\">1</span>) <span class=\"keyword\">or</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SomeClass</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;config.h&quot;</span></span></span><br><span class=\"line\">Config::<span class=\"built_in\">Config</span>()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//端口号,默认9006</span></span><br><span class=\"line\">    PORT = <span class=\"number\">9006</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"7已完成的标记-引用-code\"><a href=\"#7已完成的标记-引用-code\" class=\"headerlink\" title=\"7已完成的标记+引用[^code]\"></a>7已完成的标记+引用[^code]</h1><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 有一个launch.json文件，会调用刚刚写的</li>\n<li><input disabled=\"\" type=\"checkbox\"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新增 Todo 列表功能</li>\n</ul>\n<blockquote>\n<ul>\n<li>整理知识，学习笔记</li>\n<li>发布日记，杂文，所见所想</li>\n<li>撰写发布技术文稿（代码支持）</li>\n<li>撰写发布学术论文（LaTeX 公式支持）</li>\n</ul>\n</blockquote>\n<p>&#x2F;&#x2F; 引用<br>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>\n<p><i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>\n<h1 id=\"8隐藏超链接\"><a href=\"#8隐藏超链接\" class=\"headerlink\" title=\"8隐藏超链接\"></a>8隐藏超链接</h1><p>[md文件编写可以使用在线所见即所得编辑器]<a href=\"https://www.zybuluo.com/mdeditor\">https://www.zybuluo.com/mdeditor</a><br><a href=\"https://www.zybuluo.com/mdeditor\">md文件编写可以使用在线所见即所得编辑器</a></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics\">https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics</a><br><a href=\"https://www.jianshu.com/p/280c6a6f2594\">https://www.jianshu.com/p/280c6a6f2594</a><br>[md文件编写可以使用在线所见即所得编辑器]<a href=\"https://www.zybuluo.com/mdeditor\">https://www.zybuluo.com/mdeditor</a></p>\n","slug":"Tutorial/Markdown-tutorial","updated":"17/08/2022","comments":true,"link":"","permalink":"http://example.com/2022/02/12/Tutorial/Markdown-tutorial/","excerpt":"","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]}],"categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://example.com/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"反思","slug":"反思","permalink":"http://example.com/tags/%E5%8F%8D%E6%80%9D/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]}