<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gtoo8888</title>
  
  <subtitle>会扇扇子的猪</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-16T12:07:08.395Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kuku De</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文章暂存</title>
    <link href="http://example.com/2022/08/16/%E6%96%87%E7%AB%A0%E6%9A%82%E5%AD%98/"/>
    <id>http://example.com/2022/08/16/%E6%96%87%E7%AB%A0%E6%9A%82%E5%AD%98/</id>
    <published>2022-08-16T05:35:06.000Z</published>
    <updated>2022-08-16T12:07:08.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[CAP理论]<a href="https://cloud.tencent.com/developer/article/1860632">https://cloud.tencent.com/developer/article/1860632</a><br>[CAP 定理的含义- 阮一峰的网络日志]<a href="https://www.ruanyifeng.com/blog/2018/07/cap.html">https://www.ruanyifeng.com/blog/2018/07/cap.html</a><br><a href="http://erdengk.top/archives/jian-li--mian-shi">http://erdengk.top/archives/jian-li--mian-shi</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;[CAP理论]&lt;a href=&quot;https://cloud.tencent.com/developer/article/18</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s教程</title>
    <link href="http://example.com/2022/08/11/%E6%95%99%E7%A8%8B/k8s%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/08/11/%E6%95%99%E7%A8%8B/k8s%E6%95%99%E7%A8%8B/</id>
    <published>2022-08-11T02:15:04.000Z</published>
    <updated>2022-08-16T12:31:37.320Z</updated>
    
    <content type="html"><![CDATA[<p>kubectl get rs my-name -n dev -o -wide </p><p>-n 命名空间<br>-o 查看pod节点详情</p><h1 id="查看kubernetes的资源情况："><a href="#查看kubernetes的资源情况：" class="headerlink" title="查看kubernetes的资源情况："></a>查看kubernetes的资源情况：</h1><p>kubectl get ns</p><h1 id="查看kubernetes集群状态："><a href="#查看kubernetes集群状态：" class="headerlink" title="查看kubernetes集群状态："></a>查看kubernetes集群状态：</h1><p> kubectl get cs</p><p>kubectl -n lookonce describe pods&#x2F;web-588rc<br>查看pod的信息</p><h1 id="Etcd-数据持久化和复制"><a href="#Etcd-数据持久化和复制" class="headerlink" title="Etcd 数据持久化和复制"></a>Etcd 数据持久化和复制</h1><p>snap：用于存放快照数据。Etcd 为防止 WAL 文件过多会创建快照，snap 用于存储 Etcd 的快照数据状态。<br>wal：用于存放预写式日志，其最大的作用是记录整个数据变化的全部历程。在 Etcd 中，所有数据的修改在提交前，都要先写入 WAL 中。使用 WAL 进行数据的存储使得 Etcd 拥有故障快速回复和数据回滚这两个重要功能。</p><h1 id="删除pod"><a href="#删除pod" class="headerlink" title="删除pod"></a>删除pod</h1><p>kubectl delete pod basic-pd-0 -n tidb-cluster</p><h1 id="Statefulset"><a href="#Statefulset" class="headerlink" title="Statefulset"></a>Statefulset</h1><p>kubectl -n tidb-cluster describe pod basic-pd-0</p><p>t edit  StatefulSet basic-pd</p><h1 id="查看一个pod的状态"><a href="#查看一个pod的状态" class="headerlink" title="查看一个pod的状态"></a>查看一个pod的状态</h1><p>t describe pods basic-pd-0</p><p>重启策略<br>restartPolicy: Never<br>Always:容器失效时，自动重启该容器，这也是默认值<br>OnFailure:容器终止运行且退出码不为0时重启<br>Never :不论状态为何，都不重启该容器</p><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>post start<br>pre stop</p><p>钩子处理器支持使用下面三种方式定义动作：</p><p>Exec命令：在容器内执行一次命令</p><p>……<br>  lifecycle:<br>    postStart:<br>      exec:<br>        command:<br>        - cat<br>        - &#x2F;tmp&#x2F;healthy<br>……<br>TCPSocket：在当前容器尝试访问指定的socket</p><p>……<br>  lifecycle:<br>    postStart:<br>      tcpSocket:<br>        port: 8080<br>……<br>HTTPGet：在当前容器中向某url发起http请求</p><p>……<br>  lifecycle:<br>    postStart:<br>      httpGet:<br>        path: &#x2F; #URI地址<br>        port: 80 #端口号<br>        host: 192.168.5.3 #主机地址<br>        scheme: HTTP #支持的协议，http或者https<br>……</p><h1 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h1><p>kubectl api-versions</p><p>kubectl api-resources</p><p>t get endpoints</p><p>kubectl get pod -A</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/paul8339/p/15629241.html#:~:text=%E5%A4%87%E4%BB%BD%E6%93%8D%E4%BD%9C%E5%9C%A8etcd%E9%9B%86%E7%BE%A4%E7%9A%84%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E3%80%82%20%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFetcd%20v3%E7%9A%84api%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BB%8E%20k8s%201.13,%E5%BC%80%E5%A7%8B%EF%BC%8Ck8s%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%20v2%20%E7%89%88%E6%9C%AC%E7%9A%84%20etcd%EF%BC%8C%E5%8D%B3k8s%E7%9A%84%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E9%83%BD%E5%AD%98%E5%9C%A8%E4%BA%86v3%E7%89%88%E6%9C%AC%E7%9A%84etcd%E4%B8%AD%E3%80%82%20%E6%95%85%E5%A4%87%E4%BB%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%9F%E5%8F%AA%E5%A4%87%E4%BB%BD%E4%BA%86%E4%BD%BF%E7%94%A8v3%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%EF%BC%8Cv2%E6%B7%BB%E5%8A%A0%E7%9A%84etcd%E6%95%B0%E6%8D%AE%E6%98%AF%E6%B2%A1%E6%9C%89%E5%81%9A%E5%A4%87%E4%BB%BD%E7%9A%84%E3%80%82">备份etcd</a><br>[kubernetes之StatefulSet详解]<a href="https://www.cnblogs.com/tylerzhou/p/11027559.html">https://www.cnblogs.com/tylerzhou/p/11027559.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;kubectl get rs my-name -n dev -o -wide &lt;/p&gt;
&lt;p&gt;-n 命名空间&lt;br&gt;-o 查看pod节点详情&lt;/p&gt;
&lt;h1 id=&quot;查看kubernetes的资源情况：&quot;&gt;&lt;a href=&quot;#查看kubernetes的资源情况：&quot; clas</summary>
      
    
    
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>自己用到的脚本</title>
    <link href="http://example.com/2022/07/25/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E8%87%AA%E5%B7%B1%E7%94%A8%E5%88%B0%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://example.com/2022/07/25/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C/%E8%87%AA%E5%B7%B1%E7%94%A8%E5%88%B0%E7%9A%84%E8%84%9A%E6%9C%AC/</id>
    <published>2022-07-25T13:03:06.000Z</published>
    <updated>2022-07-25T13:26:27.283Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;统计文件中代码行数&quot;</span></span><br><span class="line">c1=<span class="constructor">$(<span class="params">find</span> -<span class="params">name</span> <span class="string">&quot;*.cpp&quot;</span>  | <span class="params">wc</span> -<span class="params">l</span>)</span></span><br><span class="line">h1=<span class="constructor">$(<span class="params">find</span> -<span class="params">name</span> <span class="string">&quot;*.h&quot;</span>  | <span class="params">wc</span> -<span class="params">l</span>)</span></span><br><span class="line">echo <span class="string">&quot;文件个数：$(expr $&#123;c1&#125; + $&#123;h1&#125;),*.cpp:$&#123;c1&#125;,*.h:$&#123;h1&#125;&quot;</span></span><br><span class="line">c2=<span class="constructor">$(<span class="params">find</span> -<span class="params">name</span> <span class="string">&quot;*.cpp&quot;</span>  | <span class="params">xargs</span> <span class="params">cat</span> | <span class="params">wc</span> -<span class="params">l</span>)</span></span><br><span class="line">h2=<span class="constructor">$(<span class="params">find</span> -<span class="params">name</span> <span class="string">&quot;*.cpp&quot;</span>  | <span class="params">xargs</span> <span class="params">cat</span> | <span class="params">wc</span> -<span class="params">l</span>)</span></span><br><span class="line">echo <span class="string">&quot;总行数：$(expr $&#123;c2&#125; + $&#123;c2&#125;),*.cpp:$&#123;c2&#125;,*.h:$&#123;h2&#125;&quot;</span></span><br><span class="line">c3=<span class="constructor">$(<span class="params">find</span> -<span class="params">name</span> <span class="string">&quot;*.cpp&quot;</span>  | <span class="params">xargs</span> <span class="params">cat</span> | <span class="params">grep</span> -<span class="params">v</span> ^$| <span class="params">wc</span> -<span class="params">l</span>)</span></span><br><span class="line">h3=<span class="constructor">$(<span class="params">find</span> -<span class="params">name</span> <span class="string">&quot;*.cpp&quot;</span>  | <span class="params">xargs</span> <span class="params">cat</span> | <span class="params">grep</span> -<span class="params">v</span> ^$| <span class="params">wc</span> -<span class="params">l</span>)</span></span><br><span class="line">echo <span class="string">&quot;去掉空格行数：$(expr $&#123;c3&#125; + $&#123;c3&#125;),*.cpp:$&#123;c3&#125;,*.h:$&#123;h3&#125;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight reasonml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>做饭相关</title>
    <link href="http://example.com/2022/07/25/%E5%85%B6%E4%BB%96/%E5%81%9A%E9%A5%AD%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/07/25/%E5%85%B6%E4%BB%96/%E5%81%9A%E9%A5%AD%E7%9B%B8%E5%85%B3/</id>
    <published>2022-07-24T16:49:09.000Z</published>
    <updated>2022-08-05T16:00:25.765Z</updated>
    
    <content type="html"><![CDATA[<p>可乐鸡翅</p><p>鱼香肉丝、糖醋排骨、锅包肉<br>紫菜皮蛋汤<br>虾仁炒蛋<br>青椒塞肉<br>炸茄子</p><h3 id="可乐鸡翅的改进"><a href="#可乐鸡翅的改进" class="headerlink" title="可乐鸡翅的改进"></a>可乐鸡翅的改进</h3><p>步骤一：<br>生姜、料酒，浸泡20分钟<br>步骤二：<br>焯水<br>鸡翅切开<br>树叶、八角、葱，料酒放到水里面煮到没有泡沫出来<br>用冷水还是热水开始煮？？？<br>步骤三：<br>炒出糖色<br>放八角、树叶、料酒、蒜、大葱<br>炒到两面金黄，一直用大火<br>放生抽、老抽、盐（一点）<br>最后放入可乐，小火开始炖，可乐不要太多，要没过鸡翅就可以了，可乐可以分多次加<br>炖20分钟，汤汁烧干<br>汤汁烧干以后，打开锅盖，烧到出泡泡<br>装盘</p><ol><li>需要炒出糖色来</li><li>没有粘稠的感觉，感觉像是汤</li><li>可乐加的有点多</li></ol><h3 id="糖醋排骨"><a href="#糖醋排骨" class="headerlink" title="糖醋排骨"></a>糖醋排骨</h3><p>主材料：排骨<br>辅助材料：葱、大蒜、红尖椒<br>调味料：盐</p><p>步骤一：备料</p><ol><li>切排骨</li><li>放在清水中，放盐、淀粉，用手抓清洗，10min</li><li>焯水：冷水，生姜、葱、排骨、料酒<br>不断的捞出泡沫</li><li>准备调味料：</li></ol><ul><li>料酒</li><li>生抽</li><li>香醋<br>冰糖、</li></ul><ol start="5"><li>焯水之后用温水洗干净</li></ol><p>步骤二：开始烧<br>5. 排骨放到锅里面，家常做法用油煎，水分炒出来，炒到金黄，拿出来<br>6. 炒糖色，放入冰糖，大火熬化，变成枣红色，开小火，开始冒小泡，放入排骨<br>加入调料，香叶、两个八角、葱段、桂皮<br>7. 把嫩汁炒成糖色，放入料酒，生抽，放醋<br>8. 加入温水或热水，水没过排骨，放入冰糖<br>9. 炖半个小时，小料拿出来，调出香料，开大火收汁，7-8分钟，自然芡<br>10. 汤汁粘稠，放入米醋&#x2F;香醋</p><h3 id="红烧茄子"><a href="#红烧茄子" class="headerlink" title="红烧茄子"></a>红烧茄子</h3><h4 id="基础做法一："><a href="#基础做法一：" class="headerlink" title="基础做法一："></a>基础做法一：</h4><p>主材料：圆茄子<br>辅助材料：葱、大蒜、红尖椒</p><ol><li>切掉头，滚刀切块</li><li>茄子切好，放在碗里，放盐搅拌，腌制10分钟</li><li>调味料</li></ol><ul><li>生抽</li><li>老抽</li><li>白糖</li><li>盐   </li><li>清水</li><li><input disabled="" type="checkbox"> 耗油</li><li><input disabled="" type="checkbox"> 淀粉</li></ul><p>葱、大蒜、尖椒</p><ol start="4"><li><p>茄子用手挤出水分，挤干（为了防止吸油）<br>加入淀粉搅拌均匀</p></li><li><p>先炒（炸）茄子，开大火，油温要高<br>表面焦黄、倒入蒜末，炒出香味<br>倒入汤汁<br>收干汤汁，加入葱花</p></li></ol><h4 id="进阶做法二："><a href="#进阶做法二：" class="headerlink" title="进阶做法二："></a>进阶做法二：</h4><p>主材料：圆茄子<br>次要材料：西红柿、青椒<br>辅助材料：葱、大蒜</p><p>前4步相同</p><p>开始炒的时候不同<br>5. 用宽油，先开大火炸茄子，炸酥脆以后捞出来<br>6. 油温到7-8成以后，再放进去炸一遍，把青椒也放进去炸<br>7. 炸好以后捞出来，开始烧新的，烧西红柿<br>加入调味料，炒出汁水<br>8. 放入刚刚炸过的茄子</p><h2 id="下周计划"><a href="#下周计划" class="headerlink" title="下周计划"></a>下周计划</h2><p>鱼香肉丝<br>茄子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可乐鸡翅&lt;/p&gt;
&lt;p&gt;鱼香肉丝、糖醋排骨、锅包肉&lt;br&gt;紫菜皮蛋汤&lt;br&gt;虾仁炒蛋&lt;br&gt;青椒塞肉&lt;br&gt;炸茄子&lt;/p&gt;
&lt;h3 id=&quot;可乐鸡翅的改进&quot;&gt;&lt;a href=&quot;#可乐鸡翅的改进&quot; class=&quot;headerlink&quot; title=&quot;可乐鸡翅的改进&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>截图工具</title>
    <link href="http://example.com/2022/07/25/%E9%A1%B9%E7%9B%AE/%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2022/07/25/%E9%A1%B9%E7%9B%AE/%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/</id>
    <published>2022-07-24T16:44:29.000Z</published>
    <updated>2022-07-27T13:31:29.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>看看市面上的截图工具</p><p>QQ截图独立版：<a href="https://bbs.pediy.com/thread-271332.htm">https://bbs.pediy.com/thread-271332.htm</a><br>Snipaste官网：<a href="https://zh.snipaste.com/">https://zh.snipaste.com/</a><br>eSearch官网：<a href="https://esearch.vercel.app/">https://esearch.vercel.app/</a><br>PicPick官网：<a href="https://picpick.app/zh/">https://picpick.app/zh/</a><br>FastStone Capture官网：<a href="https://www.faststone.org/FSCaptureDetail.htm">https://www.faststone.org/FSCaptureDetail.htm</a><br>ShareX官网：<a href="https://getsharex.com/">https://getsharex.com/</a></p><p>自己想要什么功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h1&gt;&lt;p&gt;看看市面上的截图工具&lt;/p&gt;
&lt;p&gt;QQ截图独立版：&lt;a href=&quot;https://bbs.pediy.com/threa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>webserver</title>
    <link href="http://example.com/2022/07/25/%E9%A1%B9%E7%9B%AE/webserver/"/>
    <id>http://example.com/2022/07/25/%E9%A1%B9%E7%9B%AE/webserver/</id>
    <published>2022-07-24T16:41:31.000Z</published>
    <updated>2022-08-01T11:40:41.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2022-7-24"><a href="#2022-7-24" class="headerlink" title="2022-7-24"></a>2022-7-24</h2><ol><li>task.josn和lanch.json可以跑起来了，可以用vscode远程连接调试</li><li>使用cmake进行编译</li><li>cmake编译中添加了mysql,可以操作数据库了</li></ol><h2 id="2022-7-25"><a href="#2022-7-25" class="headerlink" title="2022-7-25"></a>2022-7-25</h2><ol><li>学习了namespace和share_ptr是怎么使用的</li></ol><h1 id="2022-7-30"><a href="#2022-7-30" class="headerlink" title="2022-7-30"></a>2022-7-30</h1><ol><li><p>之前发现使用语句，但是日志无法写入<br>fix:使用阻塞队列插入，但是自己还没有实现阻塞队列的内容，导致一直是空实现，就没法写进去了</p></li><li><p>遗留的问题：单例模式在vscode中如何调试，因为进去就是一个instant()函数了</p></li></ol><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>使用vcpkg做包管理<br>cmake中使用vcpkg<br>使用httplib库<br>使用jsoncpp库</p><h1 id="epoll-event"><a href="#epoll-event" class="headerlink" title="epoll_event"></a>epoll_event</h1><p>EPOLLIN<br>        The associated file is available for read(2) operations.</p><p>EPOLLOUT<br>        The associated file is available for write(2) operations.</p><p>EPOLLRDHUP (since Linux 2.6.17) # 读取到一半连接关闭<br>        # 读关闭<br>        在使用 epoll 时，对端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件。在低于 2.6.17 版本的内核中，这个 epoll 事件一般是 EPOLLIN，即 0x1，代表连接可读。<br>        返回到上层以后，上层读取会EOF，报告错误。<br>        现在增加了这个以后，客户端断开连接，就可以在底层处理了<br>        Stream socket peer closed connection, or shut  down  writing  half  of<br>        connection.   (This  flag is especially useful for writing simple code<br>        to detect peer shutdown when using Edge Triggered monitoring.)</p><p>EPOLLERR<br>        # EPOLLERR 是服务器这边出错<br>        相关文件描述符上发生错误情况。 这个<br>         当读取结束时，管道的写入结束也会报告事件<br>         已被关闭。 epoll_wait(2) 将始终报告此事件； 它<br>         没有必要在事件中设置它。<br>        Error  condition  happened  on  the  associated file descriptor.  This<br>        event is also reported for the write end of a pipe when the  read  end<br>        has  been closed.  epoll_wait(2) will always report for this event; it<br>        is not necessary to set it in events.</p><p>EPOLLHUP<br>        # 读写都关闭<br>        Hang up happened on the  associated  file  descriptor.   epoll_wait(2)<br>        will  always  wait  for  this  event; it is not necessary to set it in<br>        events.</p><pre><code>    Note that when reading from a channel such  as  a  pipe  or  a  stream    socket,  this  event  merely indicates that the peer closed its end of    the channel.  Subsequent reads from the channel will return 0 (end  of    file)  only  after  all  outstanding data in the channel has been con‐    sumed.</code></pre><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[日志系统]<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650122657&amp;idx=1&amp;sn=c5ce1d8059c40e4cd6deb42a34f8fe49&amp;chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650122657&amp;idx=1&amp;sn=c5ce1d8059c40e4cd6deb42a34f8fe49&amp;chksm=f36bb480c41c3d96f69a9fbbc8e7e1515b8bbec87742f76fa3dfda0019a7b58aa282c3ef9bde&amp;scene=21#wechat_redirect</a><br>[Reactor模型和Proactor模型]<a href="https://cloud.tencent.com/developer/article/1488120">https://cloud.tencent.com/developer/article/1488120</a><br>[Reactor模型]<a href="https://www.cnblogs.com/CodeBear/p/12567022.html">https://www.cnblogs.com/CodeBear/p/12567022.html</a><br>[epoll 事件之 EPOLLRDHUP]<a href="https://yangwenbo.com/articles/epoll-event-epollrdhup.html">https://yangwenbo.com/articles/epoll-event-epollrdhup.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2022-7-24&quot;&gt;&lt;a href=&quot;#2022-7-24&quot; class=&quot;headerlink&quot; title=&quot;2022-7-24&quot;&gt;&lt;/a&gt;2022-7-24&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;task.josn和lanch.json可以跑起来了，可以用vscode</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Golang 面试</title>
    <link href="http://example.com/2022/06/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/Golang%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2022/06/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/Golang%E9%9D%A2%E8%AF%95/</id>
    <published>2022-06-27T15:29:24.000Z</published>
    <updated>2022-08-15T14:02:42.504Z</updated>
    
    <content type="html"><![CDATA[<p>Go实现了两种并发形式<br>第一种是，多线程共享内存。就是C++中实现的并发模型，他们线程间通信都是通过共享内存的方式来进行的。在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问。Go中也实现了传统的线程并发模型。<br>另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。</p><p>Go的CSP并发模型，是通过goroutine和channel来实现的。</p><p>goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。<br>channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。</p><h1 id="GMP模型介绍一下"><a href="#GMP模型介绍一下" class="headerlink" title="GMP模型介绍一下"></a>GMP模型介绍一下</h1><p>go runtinue使用了一个MPG模型来实现<br>M指的是Machine，一个M直接关联了一个内核线程。所有的G(goroutine)任务最终都会在M上执行。<br>P指的是processor，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。它负责衔接M和G的调度上下文，将等待执行的G与M对接。<br>1．代表一个处理器，每个运行的M都必须绑定一个P。P的个数是GOMAXPOCS，最大为256，在程序启动时固<br>定，一般不去修改。<br>2.GOMAXPOCS默认值是当前电脑的核心数，单核CPU就只能设置为1，如果设置&gt;1，在GOMAXPOCS函数中<br>也会被修改为1。<br>3.M和P的个数不一定一样多，M&gt;&#x3D;P，每一个P都会保存本地的G任务队列，另外还有一个全局的G任务队列。G<br>任务队列可以认为线程池中的线程队列。</p><p>G指的是Goroutine，代表一个goroutine对象，每次go调用的时候都会创建一个G对象，其实本质上也是一种轻量级的线程。包括了调用栈，重要的调度信息，例如channel等。</p><h1 id="go-rutine调度流程"><a href="#go-rutine调度流程" class="headerlink" title="go rutine调度流程"></a>go rutine调度流程</h1><ol><li>启动一个goroutine<br>也就是创建一个G对象，然后加入到本地队列或者全局队列中</li></ol><p>goroutineฎ按照抢占式进⾏调度，一个goroutine最多执行10ms就会换下一个<br>2. 查找是否有空闲的P<br>如果没有就直接返回<br>如果有，就用系统API创建一个M(线程)<br>3. 由这个刚创建的M循环执行能找到的G任务<br>4. G任务执行的循序<br>先从本地队列找，本地没有找到就从全局队列找，如果还没有找到就去其他P中找<br>5. 所有的G任务的执行是按照go的调用顺序执行的<br>6. 如果一个系统调用或者G任务执行的时间太长，就会一直占用这个线程</p><h1 id="slice-底层和扩容"><a href="#slice-底层和扩容" class="headerlink" title="slice 底层和扩容"></a>slice 底层和扩容</h1><h1 id="defer-应用和底层"><a href="#defer-应用和底层" class="headerlink" title="defer 应用和底层"></a>defer 应用和底层</h1><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>熟悉docker，k8s，了解两者基本原理，了解devops实施方案，CICD，服务发现，灰度发布等</p><h1 id="语法关键点"><a href="#语法关键点" class="headerlink" title="语法关键点"></a>语法关键点</h1><p>defer关键字<br>defer和go一样都是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。一般采用如下模式：<br>defer是在return之前执行的。这个在 官方文档中是明确说明了的。要使用defer时不踩坑，最重要的一点就是要明白，return xxx这一条语句并不是一条原子指令!<br>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。<br>defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。<br><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a></p><p>make关键字<br>chan关键字</p><p>反射机制</p><p>多进程go机制</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[全面的golang教程]<a href="http://c.biancheng.net/golang/">http://c.biancheng.net/golang/</a><br>[defer关键字]<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a><br>[GORM docs]<a href="https://gorm.io/zh_CN/docs/index.html">https://gorm.io/zh_CN/docs/index.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go实现了两种并发形式&lt;br&gt;第一种是，多线程共享内存。就是C++中实现的并发模型，他们线程间通信都是通过共享内存的方式来进行的。在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问。Go中也实现了传统的线程并发模型。&lt;br&gt;另外一种是Go语言特有的</summary>
      
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>百度和谷歌的比较</title>
    <link href="http://example.com/2022/06/22/%E5%85%B6%E4%BB%96/%E7%99%BE%E5%BA%A6%E5%92%8C%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://example.com/2022/06/22/%E5%85%B6%E4%BB%96/%E7%99%BE%E5%BA%A6%E5%92%8C%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2022-06-22T15:22:01.000Z</published>
    <updated>2022-06-22T15:49:34.319Z</updated>
    
    <content type="html"><![CDATA[<p>很多人都觉得百度也将就能用，之前我也是这么觉得的，后来能用谷歌以后，才发现区别是这么大，特地开一篇文章来对比谷歌和百度的搜索结果。<br>以前四个页面搜索到为标准，如果还没有找到合适的答案，那么就选择正确的回回答</p><h1 id="一、关键词：win11没有hyper-v"><a href="#一、关键词：win11没有hyper-v" class="headerlink" title="一、关键词：win11没有hyper-v"></a>一、关键词：win11没有hyper-v</h1><p>百度：<br><a href="https://imgtu.com/i/j9IRd1"><img src="https://s1.ax1x.com/2022/06/22/j9IRd1.png" alt="j9IRd1.png"></a></p><p>百度回答1：<br>看起来是个可以用的回答，但是这个命令的格式有点问题，有中文符号在里面，作为一个小白的话，直接粘贴肯定是没有效果的<br><a href="https://imgtu.com/i/j9o00A"><img src="https://s1.ax1x.com/2022/06/22/j9o00A.png" alt="j9o00A.png"></a></p><p>百度回答2：<br>怎么还是一样的回答，还是一样的错误格式<br><a href="https://imgtu.com/i/j9orkt"><img src="https://s1.ax1x.com/2022/06/22/j9orkt.png" alt="j9orkt.png"></a></p><p>百度回答3：<br>还是一样的错误格式<br><a href="https://imgtu.com/i/j9o26g"><img src="https://s1.ax1x.com/2022/06/22/j9o26g.png" alt="j9o26g.png"></a></p><p>百度回答3：<br>百度自家的内容，这种回答一般情况都是垃圾，这次也还是不知道哪里抄的回答，还是一样的格式错误<br><a href="https://imgtu.com/i/j9ostP"><img src="https://s1.ax1x.com/2022/06/22/j9ostP.png" alt="j9ostP.png"></a></p><p>百度回答5：<br>终于有了一个靠谱的回答，可以粘贴了<br><a href="https://imgtu.com/i/j9oBTI"><img src="https://s1.ax1x.com/2022/06/22/j9oBTI.png" alt="j9oBTI.png"></a></p><p>谷歌：<br><a href="https://imgtu.com/i/j9I2ZR"><img src="https://s1.ax1x.com/2022/06/22/j9I2ZR.png" alt="j9I2ZR.png"></a></p><p>谷歌回答1：<br>第一个回答就直接是格式正确的，并且作者还附上了下载链接，不会用的直接下载就可以，第一个答案就直接解决了<br><a href="https://imgtu.com/i/j9oyff"><img src="https://s1.ax1x.com/2022/06/22/j9oyff.png" alt="j9oyff.png"></a></p><p>谷歌回答2：<br>一个微软官方的回答，看起来比较靠谱，可以作为第一种无效的试一试的方案<br><a href="https://imgtu.com/i/j9ocp8"><img src="https://s1.ax1x.com/2022/06/22/j9ocp8.png" alt="j9ocp8.png"></a></p><p>谷歌回答3：<br>又是一个正确的格式的回答，可以直接粘贴解决问题<br><a href="https://imgtu.com/i/j9og1S"><img src="https://s1.ax1x.com/2022/06/22/j9og1S.png" alt="j9og1S.png"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很多人都觉得百度也将就能用，之前我也是这么觉得的，后来能用谷歌以后，才发现区别是这么大，特地开一篇文章来对比谷歌和百度的搜索结果。&lt;br&gt;以前四个页面搜索到为标准，如果还没有找到合适的答案，那么就选择正确的回回答&lt;/p&gt;
&lt;h1 id=&quot;一、关键词：win11没有hyper</summary>
      
    
    
    
    
    <category term="其他" scheme="http://example.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>docker安装教程</title>
    <link href="http://example.com/2022/06/22/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/06/22/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/docker%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2022-06-22T15:16:36.000Z</published>
    <updated>2022-06-22T15:21:44.721Z</updated>
    
    <content type="html"><![CDATA[<p>在windows中安装docker desktop</p><p>win11家庭版，没有开启hyper-v功能选项<br>在桌面新建txt文件，复制下面代码，然后改名hyper-v.cmd，<strong>管理员方式</strong>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> <span class="string">&quot;%~dp0&quot;</span></span><br><span class="line"><span class="built_in">dir</span> /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"><span class="keyword">for</span> /f %%i <span class="keyword">in</span> (<span class="string">&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;</span>) <span class="keyword">do</span> dism /online /norestart /add-package:<span class="string">&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span></span><br><span class="line">del hyper-v.txt</span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure><p>右键开始图标-&gt;应用和功能-&gt;左侧应用-&gt;可选功能-&gt;更多windows功能-&gt;hyper-v开启</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[windwos11没有Hyper-V的解决方法]<a href="https://www.jianshu.com/p/96aa6eeacb56">https://www.jianshu.com/p/96aa6eeacb56</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在windows中安装docker desktop&lt;/p&gt;
&lt;p&gt;win11家庭版，没有开启hyper-v功能选项&lt;br&gt;在桌面新建txt文件，复制下面代码，然后改名hyper-v.cmd，&lt;strong&gt;管理员方式&lt;/strong&gt;执行&lt;/p&gt;
&lt;figure class</summary>
      
    
    
    
    
    <category term="环境配置" scheme="http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Golang 语法</title>
    <link href="http://example.com/2022/06/21/%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/Golang%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/06/21/%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/Golang%E8%AF%AD%E6%B3%95/</id>
    <published>2022-06-20T16:03:01.000Z</published>
    <updated>2022-08-15T14:02:42.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实习中用到的技术点"><a href="#实习中用到的技术点" class="headerlink" title="实习中用到的技术点"></a>实习中用到的技术点</h1><h1 id="常用的框架"><a href="#常用的框架" class="headerlink" title="常用的框架"></a>常用的框架</h1><h2 id="minio分布式存储"><a href="#minio分布式存储" class="headerlink" title="minio分布式存储"></a>minio分布式存储</h2><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><h2 id="GORM"><a href="#GORM" class="headerlink" title="GORM"></a>GORM</h2><h1 id="context包"><a href="#context包" class="headerlink" title="context包"></a>context包</h1><p>context上下文包解析</p><p>go 1.7以后才支持</p><p>用在协程里面</p><p>控制并发两种方式<br>    使用 WaitGroup<br>    使用Context</p><p>通用场景，多个goroutine执行同一件事情</p><p>主动通知停止<br>channel + select</p><p>如果有多个goroutine,或者goroutine里面又有goroutine</p><p>需要使用context控制</p><p>client -&gt; server#1 -&gt; server#2<br>请求 req<br>应答 res</p><p>用户中间中断请求，那么中间的资源全部浪费了，当用户切断的时候，能马上停止</p><p>ctx :&#x3D; context.Backgroud()</p><p>context.WithCancle(ctx)d</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[语法介绍]<a href="https://www.topgoer.com/">https://www.topgoer.com/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实习中用到的技术点&quot;&gt;&lt;a href=&quot;#实习中用到的技术点&quot; class=&quot;headerlink&quot; title=&quot;实习中用到的技术点&quot;&gt;&lt;/a&gt;实习中用到的技术点&lt;/h1&gt;&lt;h1 id=&quot;常用的框架&quot;&gt;&lt;a href=&quot;#常用的框架&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="语法" scheme="http://example.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>实习内容</title>
    <link href="http://example.com/2022/06/19/%E5%85%B6%E4%BB%96/%E5%AE%9E%E4%B9%A0%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2022/06/19/%E5%85%B6%E4%BB%96/%E5%AE%9E%E4%B9%A0%E5%86%85%E5%AE%B9/</id>
    <published>2022-06-19T15:43:01.000Z</published>
    <updated>2022-08-05T15:58:29.425Z</updated>
    
    <content type="html"><![CDATA[<p>2022.6.13-6.19</p><p>本周的工作内容，<br>周一安装环境，了解docker<br>周二了解docker，可以把docker的镜像跑起来<br>周三出现了巨大问题，程序一直没有弄明白，也没有问别人<br>周四还是在做周三做的事情，而且效率很底下<br>周五完成任务，得到了新的任务</p><p>总结和反思：<br>1.当自己有问题解决不了的，分析问题的原因，来自自己，还是来自别人，接下来，我解决这个问题，需要寻求别人的帮助，还是自己去找方法解决<br>2.下午后半段的工作效率不高，在中午的时候，以3:00区分，规划一下下午的3点前后的任务。<br>在3:00的时候应该对自己当前的工作状况进行反思，看一下现在自己状态好不好，设计一下接下来干什么<br>3.当自己程序看不懂的时候，很大情况下是自己知识点的欠缺，需要去补足，先把东西学会，再去做东西，效率会更高<br>4.应该一直做同一个工作，不要总是换来换去</p><p>需要加强的：<br>构建docker镜像的能力，只是会用docker命令，还是没有具体了解docker内部的情况</p><p>202.6.20-6.24<br>本周内容：<br>周一熟悉gorm,gRPC，看代码，还没有跑起来<br>周二得到需求，分析需求，搭调试环境，学postman<br>周三实现导出名字和身份证<br>周四读取图片，不会连接轨迹服务器<br>周五花了一天的时间连接轨迹服务器，终于连上了</p><p>不足的：<br>1.遇到业务上无法解决的问题，应该及时的提问<br>2.写业务的时候，可以先构思需要的函数的输入输出是什么，然后把每个子函数都写好，然后再去写内容（封装的思想）<br>3.对一个新语言的不熟悉，就是要手打代码段一点一点的多敲才能熟悉，不要总是粘贴<br>4.大佬写的代码总是能一气呵成，修改比较少，自己的代码就是需要反复的修改，所以特别慢，并且这次是新语言，新框架，而且要用数据库，所以写起来，试错的时间更加长了<br>5.总结一下：语法不熟悉、对业务的把控能力很弱、对代码的把控能力很弱（不知道要怎么开这些函数）</p><h1 id="postman-的问题"><a href="#postman-的问题" class="headerlink" title="postman 的问题"></a>postman 的问题</h1><p>如果实际的proto没有更新，但是自己在发送框里面写了内容，实际上是没有发出去的</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[mysql和sqlserver删除指定条数的数据记录，mysql delete limit和sqlserver delete top]<a href="https://blog.csdn.net/guangmo0123/article/details/109353553">https://blog.csdn.net/guangmo0123/article/details/109353553</a><br>[mysql 中数据表 DATA_LENGTH &amp; INDEX_LENGTH]<a href="http://dbaselife.com/project-7/doc-1112/">http://dbaselife.com/project-7/doc-1112/</a><br>[mySQL 数据类型]<a href="https://www.runoob.com/mysql/mysql-data-types.html">https://www.runoob.com/mysql/mysql-data-types.html</a></p><p>[Amazon S3]<a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax">https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html#API_ListObjects_RequestSyntax</a><br>[mysql 官方文档]<a href="https://www.mysqlzh.com/doc/65.html">https://www.mysqlzh.com/doc/65.html</a><br>[mysql 中 创建索引很慢，怎么解决]<a href="https://www.debugease.com/mysql/282296.html">https://www.debugease.com/mysql/282296.html</a><br>[TIDB 的书]<a href="https://book.tidb.io/">https://book.tidb.io/</a><br>[从一个简单的Delete删数据场景谈TiDB数据库开发规范的重要性]<a href="https://zhuanlan.zhihu.com/p/427227246">https://zhuanlan.zhihu.com/p/427227246</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2022.6.13-6.19&lt;/p&gt;
&lt;p&gt;本周的工作内容，&lt;br&gt;周一安装环境，了解docker&lt;br&gt;周二了解docker，可以把docker的镜像跑起来&lt;br&gt;周三出现了巨大问题，程序一直没有弄明白，也没有问别人&lt;br&gt;周四还是在做周三做的事情，而且效率很底下&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker 教程</title>
    <link href="http://example.com/2022/06/19/%E6%95%99%E7%A8%8B/docker%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/06/19/%E6%95%99%E7%A8%8B/docker%E6%95%99%E7%A8%8B/</id>
    <published>2022-06-19T15:39:25.000Z</published>
    <updated>2022-08-15T14:02:42.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、docker-镜像命令"><a href="#一、docker-镜像命令" class="headerlink" title="一、docker 镜像命令"></a>一、docker 镜像命令</h1><h2 id="镜像查看"><a href="#镜像查看" class="headerlink" title="镜像查看"></a>镜像查看</h2><p>docker images -a            #列出本地所有的镜像<br>docker images -q            #只显示镜像ID<br>docker images –digests     #显示镜像的摘要信息<br>docker images –no-trunc    #显示完整的镜像信息</p><p>NAME            #名称<br>DESCRIPTION     #描述<br>STARS           #点赞，关注度，类似GitHub<br>OFFICIAL        #是否官方<br>AUTOMATED       #是否自动构建 请确认输入了正确的用户名和密码。</p><h2 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h2><p>docker pull tomcat      #从Docker Hub上下载tomcat镜像，默认是最新版本。等价于：docker pull tomcat:latest<br>docker pull tomcat:8  # 选择指定版本下载</p><h2 id="镜像运行"><a href="#镜像运行" class="headerlink" title="镜像运行"></a>镜像运行</h2><p>此时从镜像变成了容器<br>docker run 镜像名<br>docker run 镜像名:Tag</p><p>–name&#x3D;”nginx-lb”: 为容器指定一个名称；<br>-P：随机映射<br>    -P后不能指定参数，随机选一个对外端口映射出去<br>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>    -p 8888:6379<br>    -p 8888:6379 解析 将容器内部的 6379端口与docker 宿主机（docker装在哪太服务器 那台服务器 就是其数组机）8888 端口进行映射 那通过外部访问宿主机8888端口 即可访问到 docker 容器 6379 端口了<br>-d: 后台运行容器，并返回容器ID；<br>-i: 以交互模式运行容器，通常与 -t 同时使用；<br>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br> –privileged<br>    大约在0.6版，privileged被引入docker。<br>    使用该参数，container内的root拥有真正的root权限。<br>    否则，container内的root只是外部的一个普通用户权限。<br>    privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。<br>    甚至允许你在docker容器中启动docker容器</p><p>docker run -it –privileged -v D:\test:&#x2F;output -d -p 8010:22 -p 50001:50051 -p 50002:50052 -p 50005:55555 e9e8789a3024</p><p>docker run -it -v $PWD:output test_tool:1-3 &#x2F;bin&#x2F;bash</p><p>在端口映射以后，需要测试一下映射是否成功<br>ssh <a href="mailto:&#114;&#x6f;&#111;&#x74;&#64;&#x31;&#50;&#x37;&#46;&#48;&#46;&#48;&#46;&#x31;">&#114;&#x6f;&#111;&#x74;&#64;&#x31;&#50;&#x37;&#46;&#48;&#46;&#48;&#46;&#x31;</a> -p 8010</p><h2 id="镜像删除"><a href="#镜像删除" class="headerlink" title="镜像删除"></a>镜像删除</h2><p>docker rmi java<br>#强制删除(删除正在运行的镜像，注：以后台方式运行的不能被强制删除)<br>docker rmi -f java<br>#多个镜像删除，不同镜像间以空格间隔<br>docker rmi -f java tomcat nginx<br>#删除本地全部镜像<br>docker rmi -f $(docker images -q)</p><h1 id="二、docker-容器命令"><a href="#二、docker-容器命令" class="headerlink" title="二、docker 容器命令"></a>二、docker 容器命令</h1><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><p>查看正在运行容器列表<br>docker ps<br>查看所有容器 —–包含正在运行 和已停止的<br>docker ps -a</p><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>docker stop 容器名&#x2F;容器ID</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>docker exec -it 容器名&#x2F;容器ID &#x2F;bin&#x2F;bash<br>docker exec -it test01 &#x2F;bin&#x2F;bash</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>docker start 容器ID&#x2F;容器名<br>docker start t1</p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>#删除一个容器<br>docker rm -f 容器名&#x2F;容器ID<br>#删除多个容器 空格隔开要删除的容器名或容器ID<br>docker rm -f 容器名&#x2F;容器ID 容器名&#x2F;容器ID 容器名&#x2F;容器ID<br>#删除全部容器<br>docker rm -f $(docker ps -aq)</p><h2 id="查看容器端口映射"><a href="#查看容器端口映射" class="headerlink" title="查看容器端口映射"></a>查看容器端口映射</h2><p>docker port [容器名]<br>需要这个容器被启动，才能查看到他的端口映射情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、docker-镜像命令&quot;&gt;&lt;a href=&quot;#一、docker-镜像命令&quot; class=&quot;headerlink&quot; title=&quot;一、docker 镜像命令&quot;&gt;&lt;/a&gt;一、docker 镜像命令&lt;/h1&gt;&lt;h2 id=&quot;镜像查看&quot;&gt;&lt;a href=&quot;#镜像查看&quot;</summary>
      
    
    
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>mudduo-ch01</title>
    <link href="http://example.com/2022/05/25/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%99%88%E7%A1%95%E7%9A%84muduo%E5%BA%93/mudduo-ch01/"/>
    <id>http://example.com/2022/05/25/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%99%88%E7%A1%95%E7%9A%84muduo%E5%BA%93/mudduo-ch01/</id>
    <published>2022-05-25T13:15:34.000Z</published>
    <updated>2022-05-25T14:03:59.345Z</updated>
    
    <content type="html"><![CDATA[<p>仅仅只能在linux下运行</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>muduo采用CMake为build system<br>CMake的安装如下：（CMake最好不低于2.8版，CentOS 6自带的2.6版也能用，但是无法自动识别Protobuf库）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install cmake</span><br><span class="line">sudo apt-<span class="built_in">get</span> install g++</span><br></pre></td></tr></table></figure><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>muduo依赖于Boost，Boost的安装如下</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install libboost-<span class="built_in">dev</span> libboost-test-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>安装出现问题</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E: Could <span class="keyword">not</span> <span class="keyword">get</span> <span class="keyword">lock</span> /<span class="keyword">var</span>/lib/dpkg/<span class="keyword">lock</span>-frontend. It <span class="keyword">is</span> held <span class="keyword">by</span> process <span class="number">5865</span> (unattended-upgr)</span><br><span class="line">N: Be aware that removing the <span class="keyword">lock</span> file <span class="keyword">is</span> <span class="keyword">not</span> a solution <span class="keyword">and</span> may <span class="keyword">break</span> your system.</span><br><span class="line">E: <span class="function">Unable to acquire the dpkg frontend <span class="title">lock</span> (<span class="params">/<span class="keyword">var</span>/lib/dpkg/<span class="keyword">lock</span>-frontend</span>), <span class="keyword">is</span> another process <span class="keyword">using</span> it?</span></span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm <span class="regexp">/var/</span>lib<span class="regexp">/dpkg/</span>lock-frontend</span><br><span class="line">sudo rm <span class="regexp">/var/</span>lib<span class="regexp">/dpkg/</span>lock</span><br><span class="line">sudo rm <span class="regexp">/var/</span>cache<span class="regexp">/apt/</span>archives/lock</span><br></pre></td></tr></table></figure><h2 id="第三步（可选）"><a href="#第三步（可选）" class="headerlink" title="第三步（可选）"></a>第三步（可选）</h2><p>muduo有三个非必须的依赖库（curl、c-ares DNS、Google Protobuf）如果安装了这三个库，cmake会自动多编译一些示例<br>安装方法如下：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install libcurl4-openssl-<span class="built_in">dev</span> libc-ares-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install protobuf-compiler libprotobuf-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><h2 id="第四步：下载muduo源码包"><a href="#第四步：下载muduo源码包" class="headerlink" title="第四步：下载muduo源码包"></a>第四步：下载muduo源码包</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/chenshuo/mu</span>duo.git</span><br></pre></td></tr></table></figure><h2 id="第五步：编译muduo"><a href="#第五步：编译muduo" class="headerlink" title="第五步：编译muduo"></a>第五步：编译muduo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载完成之后进入muduo根目录</span></span><br><span class="line"><span class="built_in">cd</span> muduo</span><br><span class="line"><span class="comment"># 编译muduo库和它自带的例子</span></span><br><span class="line">./build.sh -j2</span><br></pre></td></tr></table></figure><p>编译完成之后：<br>会在muduo源码根路径的上一级路径下生成一个build目录（下面全文我们以..&#x2F;build表示）<br>生成的可执行文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;bin<br>静态文件位于：..&#x2F;build&#x2F;release-cpp11&#x2F;lib</p><h2 id="第六步：安装muduo库"><a href="#第六步：安装muduo库" class="headerlink" title="第六步：安装muduo库"></a>第六步：安装muduo库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh install</span><br></pre></td></tr></table></figure><p>muduo头文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;include目录下<br>库文件安装在..&#x2F;build&#x2F;release-install-cpp11&#x2F;lib目录下<br>以便muduo-protorpc和muduo-udns等库使用</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>陈硕的博客 <a href="https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html">https://www.cnblogs.com/Solstice/archive/2011/02/02/1948814.html</a><br>陈硕的csdn <a href="https://blog.csdn.net/Solstice?type=blog">https://blog.csdn.net/Solstice?type=blog</a><br>陈硕的课程主页 <a href="http://chenshuo.com/practical-network-programming/">http://chenshuo.com/practical-network-programming/</a><br>相关的代码仓库：<br><a href="http://github.com/chenshuo/muduo">http://github.com/chenshuo/muduo</a><br><a href="http://github.com/chenshuo/recipes">http://github.com/chenshuo/recipes</a><br><a href="http://github.com/chenshuo/muduo-protorpc">http://github.com/chenshuo/muduo-protorpc</a><br><a href="http://github.com/chenshuo/muduo-examples-in-go">http://github.com/chenshuo/muduo-examples-in-go</a><br>如何安装 <a href="https://www.365seal.com/y/elnWyG1GVr.html">https://www.365seal.com/y/elnWyG1GVr.html</a><br>make编译源码时-j的作用 <a href="https://blog.csdn.net/JeekMrc/article/details/118332252">https://blog.csdn.net/JeekMrc/article/details/118332252</a><br>安装boost的问题 <a href="https://zhuanlan.zhihu.com/p/126538251">https://zhuanlan.zhihu.com/p/126538251</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仅仅只能在linux下运行&lt;/p&gt;
&lt;h2 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;/a&gt;第一步&lt;/h2&gt;&lt;p&gt;muduo采用CMake为build system&lt;br&gt;CMake的安装如下：（CMak</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件工程</title>
    <link href="http://example.com/2022/05/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>http://example.com/2022/05/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</id>
    <published>2022-05-17T04:13:07.000Z</published>
    <updated>2022-05-18T03:55:07.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h1><h2 id="怎么开会？"><a href="#怎么开会？" class="headerlink" title="怎么开会？"></a>怎么开会？</h2><p>开会如何组织？<br>开会内容肯定是最重要的，但是在会议内容之外，组织方面要注意什么<br>一定需要有会议日程，会议记录<br>agenda:<br>过去的开会：几点开会，大概要商量几件时期<br>改进后的开会：几点开会，本次有几个议题，第一个议题讨论多少分钟，第二个讨论多久，每个讨论多久，总会议时间多久<br>方便别人对自己的安排<br>facilitator:(会议主持人)<br>顾客主持，自己主持，仲裁主持<br>主持人的作用：按照会议日程，每个议题讨论多久，就讨论多久，时间到了要切换到下一个议题，不论是否讨论出结果<br>或者时间快到了，一个议题最多讨论30分钟，20分钟过去了，我们要加快出结果<br>如果讨论时间不够，就说明agenda给错了，会议组织人没有做好充分的准备，时间到了也要切换掉，下次再讨论<br>一个人一直在啰嗦，没有说到点子上，主持人要过去打断一下，让他简短一下<br>definition mechanism:(工作台)<br>有一个工具，可以让大家讨论的时候把东西记录下来<br>会议的时候，给每个人发一个纸和笔<br>会议时候有个投影、或者黑板，有人要发表意见的时候，可以在黑板上写两句</p><p>学生的开会：<br>发个QQ消息，把人聚集过来，人反正都来了，也不知道要具体说什么，反正就是说这个项目相关的事情<br>组长想到哪里说到哪里，大家也都是想到哪里，说到哪里<br>产生一个会议纪要</p><p>Quality Function Deployment(QFD)<br>把顾客想要的东西，转换成技术员可以理解的需求<br>以客户满意度最大化去做所有的事情(Maximize customer satisfaction)<br>需要弄清楚客户满意度是什么<br>步骤：<br>1.把要做的每一个功能搞清楚，并且给每个功能一个值，这个功能对客户来说有多少价值<br>2.确定目标和事件<br>3.确定输入输出<br>4.价值分析，对每个需求进行一个打分，对打分进行分类<br>Nomal<br>Expected<br>Exciting<br>需求依次递减，一定得先把Nomal做好，Expected能做就做<br>Exciting有余力再做，看对面钱给的够不够了</p><p>不能本末倒置的做，做个手机，地图，导航，相册，都很好用，但是打电话不好用，这就是QFD做的不好</p><p>需求分析阶段需要给客户提供的：<br>1.可行性分析报告<br>2.系统涵盖的范围是什么样子的<br>3.每个人的通讯方式<br>4.技术环境<br>5.有什么功能，有什么特殊的限制</p><h1 id="谈判"><a href="#谈判" class="headerlink" title="谈判"></a>谈判</h1><p>1.达成双赢目标<br>自己胜利的条件是确定的，但是客户的胜利条件是不确定的，或者说自己是不清楚的<br>2.如果一方占不到便宜，项目失败的可能会很大<br>如果谈判的时候客户比较傻，被自己占到了便宜，但是事后也会有很大的麻烦<br>3.站在对方的角度想，他为什么要做这件事<br>ex:<br>出国留学时候的答辩：<br>1.每个人都说“我很想获得这个机会”<br>2.但是自己很拉，成绩很差，那学院为什么会同意你出去留学，你出去留学，没法双赢</p><p>谈判注意事项；<br>1.谈判不是辩论，不是要说服对方，谈判是妥协的艺术<br>2.谈判是一种策略，给对方营造出不得不接受的情景<br>充分了解对手，了解对方的需求，了解对方的长处和弱点，设计谈判的策略，先说什么，后说什么，把哪件事情谈判到什么程度<br>直接方法：比较直爽，比较不好，上来就一杆子插到底，说我的底线就在这里，上来就谈崩了<br>3.少说，多听<br>可能说的很啰嗦，但是要仔细的听，可能会有弦外之音，可能会透露出本来不想透露出的信息<br>没必要告诉别人过多的信息，尽量从别人的只言片语中得到尽可能多的信息<br>4.站在对方的角度想，对他有什么好处<br>5.不要人身攻击，不要翻旧账，就事论事，对事不对人<br>6.说出去的话，就要去做到<br>谈判的时候，自己抛出的每一个条件，就划线了，这自己就要做得到<br>随时准备好，自己说的这个话，可能作为一条线被画下来<br>7.谈判结束后，看看有没有漏掉什么东西，有什么不一致的地方</p><h1 id="需求模型"><a href="#需求模型" class="headerlink" title="需求模型"></a>需求模型</h1><h1 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;需求工程&quot;&gt;&lt;a href=&quot;#需求工程&quot; class=&quot;headerlink&quot; title=&quot;需求工程&quot;&gt;&lt;/a&gt;需求工程&lt;/h1&gt;&lt;h2 id=&quot;怎么开会？&quot;&gt;&lt;a href=&quot;#怎么开会？&quot; class=&quot;headerlink&quot; title=&quot;怎么开会？&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式学习</title>
    <link href="http://example.com/2022/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-05-15T07:08:04.000Z</published>
    <updated>2022-05-16T07:08:38.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的设计原则，五个"><a href="#面向对象的设计原则，五个" class="headerlink" title="面向对象的设计原则，五个"></a>面向对象的设计原则，五个</h1><p>SOLID指代了<strong>面向对象编程</strong>和<strong>面向对象设计</strong>的五个基本原则</p><table><thead><tr><th>名称</th><th>缩写</th><th>全称</th><th>解释</th></tr></thead><tbody><tr><td>单一职责原则</td><td>SRP</td><td>Single Responsibility Principle</td><td>每个类的职责单一</td></tr><tr><td><strong>开闭原则</strong></td><td>OCP</td><td>Open Closed Principle</td><td>类的改动，增加代码是好的，修改源代码是不好的</td></tr><tr><td>里氏替换原则</td><td>LSP</td><td>Liskov Substitution Principle</td><td>多态</td></tr><tr><td>接口隔离原则</td><td>ISP</td><td>Interface Segregation Principle</td><td>接口隔离</td></tr><tr><td><strong>依赖倒置原则</strong></td><td>DIP</td><td>Dependence Inversion Principle</td><td>依赖抽象接口</td></tr><tr><td>——</td><td>——</td><td>——</td><td>——</td></tr><tr><td>迪米特法则</td><td>LoD</td><td>Law of Demeter</td><td>一个对象应当对其他对象少了解</td></tr><tr><td>组合&#x2F;聚合复用原则</td><td>CRP</td><td>Composite&#x2F;Aggregate Reuse Principle</td><td>继承不好，组合好的</td></tr></tbody></table><p>总体原则：高聚合，低耦合</p><h1 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6.迪米特法则"></a>6.迪米特法则</h1><p>解释：<br>去公司找人修电脑，不应该去找某个具体的小李、小张来修，应该抽象出一个接口类，IT部门，找IT部门修，用抽象接口再去对接实际的类，不然找小张解决不了问题，找小李解决不了问题。<br>结论：迪米特法则强调了类之间的松耦合关系，类之间的耦合越松，越有利于复用。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>本来每个类都需要new出来，现在是通过一个工厂来创建</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>1.客户端和具体实现类解耦<br>2.对于某些对象创建过程比较复杂情况，我们不用考虑这些了</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>1.简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则<br>2.这个类职责过重，这个类发生问题，会影响很多实用这个工厂的模块</p><h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><p>1.工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中个的业务逻辑太过复杂。<br>2.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。<br><strong>解释</strong>：用在不需要关心创建过程，读取什么文件，什么什么的，就想要用这个类<br>比如创建过程很复杂，但是我只是想用这个类，那我就用这个简单工厂创建一下就行，具体的创建过程都放在工厂里面</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h2><p>对于每一个类，都对应一个具体创建的工厂类，然后再定义一个抽象工厂作为接口<br>简单工厂模式 + “开闭原则” &#x3D; 工厂方法模式</p><h2 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h2><p>1.不需要记住具体类名，甚至连具体参数都不用记忆（因为用的是抽象的工厂接口）<br>2.实现了对象创建和使用的分离。<br>3.系统的可扩展性也就变得非常好，无需修改接口和原类。（符合开闭原则）</p><h2 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h2><p>1.增加系统中类的个数，复杂度和理解度增加。<br>2.增加了系统的抽象性和理解难度。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>1.客户端不知道它所需要的对象的类。<br>2.抽象工厂类通过其子类来指定创建哪个对象。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482">https://blog.csdn.net/weixin_42636062/category_11313224.html?spm=1001.2014.3001.5482</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象的设计原则，五个&quot;&gt;&lt;a href=&quot;#面向对象的设计原则，五个&quot; class=&quot;headerlink&quot; title=&quot;面向对象的设计原则，五个&quot;&gt;&lt;/a&gt;面向对象的设计原则，五个&lt;/h1&gt;&lt;p&gt;SOLID指代了&lt;strong&gt;面向对象编程&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PPT制作要点</title>
    <link href="http://example.com/2022/04/23/%E5%85%B6%E4%BB%96/PPT%E5%88%B6%E4%BD%9C%E8%A6%81%E7%82%B9/"/>
    <id>http://example.com/2022/04/23/%E5%85%B6%E4%BB%96/PPT%E5%88%B6%E4%BD%9C%E8%A6%81%E7%82%B9/</id>
    <published>2022-04-23T08:34:57.000Z</published>
    <updated>2022-04-24T08:04:03.371Z</updated>
    
    <content type="html"><![CDATA[<p>以“除草智能装备及机器人”为题目，制作一个PPT</p><p>构思：</p><ol><li><p>首先接到一个做PPT的需求</p></li><li><p>思考从哪几个方面开始写<br>注意：由于是刚刚接触到这个题目，一般是十分的陌生，所以第一个任务就是找出哪几个点去写，但是一般情况下，刚刚提出的都是有问题的<br>但是一定要找到几个要点，先提出来，再后面的不断思考中，会不断改进，自然就会优化了</p></li></ol><p>举例：</p><ul><li>发展现状</li><li>机械介绍</li><li>算法介绍</li><li>未来展望</li></ul><ol start="3"><li>写一个大纲<br>主要内容：<br>大的点，2-3条<br>每个大点里面找要展开来讲的点，3-4条</li></ol><p>举例：</p><ul><li>发展现状<ul><li>农田割草机</li><li>技术情况</li><li>市场情况</li><li>国内</li><li>国外</li></ul></li><li>机械介绍<ul><li>有什么</li></ul></li><li>算法介绍<ul><li>路径规划</li><li>点到点</li><li>全覆盖</li></ul></li><li>未来展望<ul><li>ROS、SLAM</li><li>多机器人</li><li>不规则地块</li></ul></li></ul><hr><p>开始制作：</p><ol start="4"><li><p>确定主题颜色，从要讲述的东西中，选取2-3个主题颜色</p></li><li><p>从头开始<br>对每个点进行扩充，查找图片和相关资料，多找GIF<br>先把内容都填充到PPT中，不用考虑排版<br>差不多半天，比如19:00-22:00这么长时间，可以完成对个大点内容的填充</p></li><li><p>设计每个页面的排版<br>将页面精简，从大段文字中提取出主要内容<br>这个步骤完成后，主要内容已经制作完成了</p></li></ol><hr><p>设计动画：<br>7. 给每个页面加上动画<br>设计每个段落之间的逻辑关系</p><ol start="8"><li>反复看整个PPT的演示效果</li></ol><hr><p>自己复述，设计改怎么表述</p><hr><p>PPT设计要点：</p><ol><li>减少大段文字的出现，大段文字总结成小标题，或者小标题配和一小段文字</li><li>必须出现一小段文字，用红字加粗主要内容</li><li>空荡荡的字放在那里很空虚，最后放一个背景框</li><li>给小标题加上一条线</li><li>没有边框的图标，柱状图，饼图，用框框框起来</li><li>纯白的背景很单调，后面添加一半的纯色背景</li><li>能用图片代替文字就尽量用图片代替</li></ol><p>动画要点</p><ol><li>强调重点的时候，不止用红框框<ul><li>图片+扩展图形放大凸显</li><li>放大镜凸显</li><li>后面加阴影，前面放大</li></ul></li><li>增加时间轴的表现形式</li><li>设计封面的时候，用动画将主要要讲述的物体突出</li><li>红圈，用轮子效果</li><li>半透明形状</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以“除草智能装备及机器人”为题目，制作一个PPT&lt;/p&gt;
&lt;p&gt;构思：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先接到一个做PPT的需求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;思考从哪几个方面开始写&lt;br&gt;注意：由于是刚刚接触到这个题目，一般是十分的陌生，所以第一个任务就是找出哪几个</summary>
      
    
    
    
    
    <category term="其他" scheme="http://example.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/2022/04/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/04/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-19T07:03:57.000Z</published>
    <updated>2022-05-08T14:44:24.722Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://imgtu.com/i/LBSN8S"><img src="https://s1.ax1x.com/2022/04/19/LBSN8S.png" alt="不同算法的时间复杂度"></a></p><p>前缀和</p><p>一维前缀和</p><p>二维前缀和</p><p>第一题就是基本的读入字符串排序，忘记细节了。</p><p>第二题是读入一01串，对应的下标为士兵的能力，0代表攻击士兵，1代表防守士兵，找到一个分割点，使得左侧攻击士兵和右侧防御士兵差的绝对值最小。这题直接用一个求和数组记录遍历就能过。</p><p>第三题是给定一个数组，删掉下标不为质数的值，然后合并起来循环操作，求最后一个数。这题是能找到规律，在某个区间的答案会是一个定值。直接暴力解了。</p><p>第四题是给多个环形链表的部分（可以重叠），把他们串起来然后切开形成最小字典序。这题主要是记录一下链表顺序，正逆比较一下就可以</p><p>第五题买股票进阶版，给定本金，每天都可以买入卖出1笔，而且可以手里留存多笔股票，求最大利润。这题不太会做，暴力DFS做的只过了50，蹲个大佬</p><p>做了4个半，最近一个月才开始补算法，难点的题就做不出来了，以及我是用python写的，可能时间复杂度要求和C++比会有些差别</p><p>作者：Powter<br>链接：<a href="https://leetcode-cn.com/circle/discuss/aWwMc8/">https://leetcode-cn.com/circle/discuss/aWwMc8/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><strong>前缀和</strong>  <a href="https://blog.csdn.net/m0_46201544/article/details/122371482">https://blog.csdn.net/m0_46201544/article/details/122371482</a></p></li><li><p><strong>前缀异或</strong> <a href="https://blog.csdn.net/weixin_50248461/article/details/117045421">https://blog.csdn.net/weixin_50248461/article/details/117045421</a></p></li><li><p><strong>Codeforces游玩攻略</strong> <a href="https://www.luogu.com.cn/blog/ezoixx130/codeforces-tutorial">https://www.luogu.com.cn/blog/ezoixx130/codeforces-tutorial</a></p></li><li><p><strong>Codeforces快速精通</strong> <a href="https://www.luogu.com.cn/blog/ezoixx130/codeforces-advanced-tutorial">https://www.luogu.com.cn/blog/ezoixx130/codeforces-advanced-tutorial</a></p></li><li><p><strong>ACM-高精度模板(综合篇)</strong> <a href="https://blog.csdn.net/u013615904/article/details/43373601">https://blog.csdn.net/u013615904/article/details/43373601</a></p></li><li><p><strong>C++ lambda表达式与函数对象</strong> <a href="https://www.jianshu.com/p/d686ad9de817">https://www.jianshu.com/p/d686ad9de817</a></p></li><li><p><a href="https://codeforces.com/blog/entry/66715">https://codeforces.com/blog/entry/66715</a></p></li><li><p><a href="https://codeforces.com/blog/entry/66909">https://codeforces.com/blog/entry/66909</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://imgtu.com/i/LBSN8S&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2022/04/19/LBSN8S.png&quot; alt=&quot;不同算法的时间复杂度&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前缀和&lt;/p&gt;
&lt;p&gt;一维前缀和&lt;/</summary>
      
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://example.com/2022/04/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/04/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-04-19T06:57:24.000Z</published>
    <updated>2022-04-19T07:08:48.648Z</updated>
    
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>makefile 教程</title>
    <link href="http://example.com/2022/04/05/%E6%95%99%E7%A8%8B/linux%E4%B8%8B%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/makefile%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/04/05/%E6%95%99%E7%A8%8B/linux%E4%B8%8B%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/makefile%E6%95%99%E7%A8%8B/</id>
    <published>2022-04-05T12:34:26.000Z</published>
    <updated>2022-08-15T14:02:42.504Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>自动化变量</th><th>说明</th></tr></thead><tbody><tr><td>$*</td><td>表示目标文件的名称，不包含目标文件的扩展名</td></tr><tr><td>$+</td><td>也是所有依赖目标的集合,这些依赖文件用空格分开，按照出现的先后为顺序，只是它不去除重复的依赖目标</td></tr><tr><td>$&lt;</td><td>规则中的第一个相关文件名</td></tr><tr><td>$?</td><td>规则中日期新于目标的所有相关文件的列表，以空格分割</td></tr><tr><td>$@</td><td>规则的目标所对应的文件名</td></tr><tr><td>$^</td><td>规则中所有相关文件的列表，以空格分割</td></tr><tr><td>$(@D)</td><td>目标文件的目录部分</td></tr><tr><td>$(@F)</td><td>目标文件的文件名部分</td></tr></tbody></table><table><thead><tr><th>常用变量</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>AR</td><td>归档维护程序</td><td>ar</td></tr><tr><td>AS</td><td>汇编程序</td><td>as</td></tr><tr><td>CPP</td><td>c预处理程序</td><td>cpp</td></tr><tr><td>CC</td><td>c编译程序</td><td>cc</td></tr><tr><td>CXX</td><td>c++编译程序</td><td>g++</td></tr><tr><td>RM</td><td>文件删除程序</td><td>rm -f</td></tr><tr><td>ARFLAGS</td><td>传给归档维护程序的标志</td><td>rv</td></tr><tr><td>ASFLAGS</td><td>传给汇编程序的标志</td><td>无默认值</td></tr><tr><td>CFLAGS</td><td>传给c编译程序的标志</td><td>无默认值</td></tr><tr><td>CPPFLAGS</td><td>传给c预处理程序的标志</td><td>无默认值</td></tr><tr><td>CXXFLAGS</td><td>传给c++编译器的标志</td><td>无默认值</td></tr><tr><td>LDFLAGS</td><td>传给链接程序（ld）的标志</td><td>无默认值</td></tr></tbody></table><p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为5）。</p><p>如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：<br>    %.o : %.c </p><p>markdown中的函数</p><p>获取匹配模式的文件名 wildcard<br>src &#x3D; $(wildcard *.c)</p><p>模式替换函数 patsubst</p><p>循环函数 foreach</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/yi412/article/details/69941791">https://blog.csdn.net/yi412/article/details/69941791</a><br><a href="https://blog.csdn.net/marc07/article/details/62885868">https://blog.csdn.net/marc07/article/details/62885868</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;自动化变量&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;$*&lt;/td&gt;
&lt;td&gt;表示目标文件的名称，不包含目标文件的扩展名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$+&lt;/td&gt;</summary>
      
    
    
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>vscode 教程</title>
    <link href="http://example.com/2022/04/05/%E6%95%99%E7%A8%8B/vscode%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/04/05/%E6%95%99%E7%A8%8B/vscode%E6%95%99%E7%A8%8B/</id>
    <published>2022-04-05T12:33:12.000Z</published>
    <updated>2022-08-16T12:07:23.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码里的左侧颜色标识"><a href="#代码里的左侧颜色标识" class="headerlink" title="代码里的左侧颜色标识:"></a>代码里的左侧颜色标识:</h1><p>红色，未加入版本控制; (刚clone到本地)<br>绿色，已经加入版本控制暂未提交; (新增部分)<br>蓝色，加入版本控制，已提交，有改动； (修改部分)<br>白色，加入版本控制，已提交，无改动；<br>灰色：版本控制已忽略文件。</p><p>git文件标识:</p><p>A: 增加的文件.<br>C: 文件的一个新拷贝.<br>D: 删除的一个文件.<br>M: 文件的内容或者mode被修改了.<br>R: 文件名被修改了。<br>T: 文件的类型被修改了。<br>U: 文件没有被合并(你需要完成合并才能进行提交)<br>X: 未知状态</p><h1 id="使用VSCode远程调试linux"><a href="#使用VSCode远程调试linux" class="headerlink" title="使用VSCode远程调试linux"></a>使用VSCode远程调试linux</h1><ol><li>准备工作<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> update</span><br><span class="line">apt-<span class="built_in">get</span> install sudo</span><br><span class="line">apt-<span class="built_in">get</span> install vim</span><br><span class="line">passwd # 修改密码</span><br></pre></td></tr></table></figure></li><li>安装openssh<br>apt-get install openssh-server<br>apt-get install openssh-client</li><li>修改ssh配置文件<br>sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>PermitRootLogin yes<br>（默认为#PermitRootLogin prohibit-password）前面的#号要放开</li><li>启动服务<br>&#x2F;etc&#x2F;init.d&#x2F;ssh restart</li><li>连接测试<br>ssh user@[ip] -p [端口]<br>ssh <a href="mailto:&#x75;&#115;&#101;&#114;&#x40;&#x31;&#x39;&#x32;&#46;&#49;&#x36;&#x38;&#x2e;&#x30;&#46;&#51;">&#x75;&#115;&#101;&#114;&#x40;&#x31;&#x39;&#x32;&#46;&#49;&#x36;&#x38;&#x2e;&#x30;&#46;&#51;</a> -p 22</li><li>vscode配置<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host <span class="number">192.168</span>.<span class="number">0.3</span></span><br><span class="line">  HostName <span class="number">192.168</span>.<span class="number">0.3</span></span><br><span class="line">  <span class="keyword">User</span> <span class="title">username</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="使用VSCode远程调试linux中的容器"><a href="#使用VSCode远程调试linux中的容器" class="headerlink" title="使用VSCode远程调试linux中的容器"></a>使用VSCode远程调试linux中的容器</h1><ol><li>需要把容器的端口映射出来</li></ol><p>容器内的ssh修改需要把root登录打开<br>sudo vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>PermitRootLogin yes<br>重启，连接测试，可以连接</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host <span class="number">15.1</span>.<span class="number">0.89</span>      <span class="comment"># 显示的名字</span></span><br><span class="line">  HostName <span class="number">15.1</span>.<span class="number">0.89</span></span><br><span class="line">  <span class="keyword">User</span> <span class="title">root</span></span><br><span class="line">  Port <span class="number">38529</span>        <span class="comment"># 使用的端口号</span></span><br><span class="line">  IdentityFile ~\.ssh\id_rsa</span><br></pre></td></tr></table></figure><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">ctl + k + 0</td><td align="center">快速收缩全部代码</td></tr><tr><td align="center">ctl + k + j</td><td align="center">展开全部代码</td></tr><tr><td align="center">ctl + shift + [</td><td align="center">收缩当前代码</td></tr><tr><td align="center">ctl + shift + ]</td><td align="center">展开当前代码</td></tr><tr><td align="center">alt + left</td><td align="center">向后</td></tr><tr><td align="center">alt + left</td><td align="center">向前</td></tr><tr><td align="center">ctl + g</td><td align="center">跳到指定行</td></tr><tr><td align="center">ctl + b</td><td align="center">关闭左侧栏</td></tr><tr><td align="center">ctl + j</td><td align="center">关闭下面栏</td></tr></tbody></table><h1 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h1><p>C++不报错<br>C_Cpp.errorSquiggles</p><h1 id="调试相关的三个主要文件"><a href="#调试相关的三个主要文件" class="headerlink" title="调试相关的三个主要文件"></a>调试相关的三个主要文件</h1><p>调试的基本思路：<br>步骤一：<br>先有一个tasks.json文件可以对文件进行生成<br>对于C++来说，可以使用gcc,g++,make,cmake,shell脚本，都可以进行生成<br>可以先测试task能否正常运行，这一步的测试就是测试程序是否能编译通过<br>步骤二：</p><h3 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;compile&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;./build.sh&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;problemMatcher&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;clean&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;clean&quot;</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> https:<span class="regexp">//</span>code.visualstudio.com<span class="regexp">/docs/</span>cpp/c-cpp-properties-schema-reference</span><br><span class="line"><span class="regexp">//</span>.vscode文件夹局部的配置c_cpp_properties.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [            <span class="regexp">//</span> 这个是使用头文件时候vscode查找的路径，如果路径没有包含进来，头文件会有红色波浪线</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>, <span class="regexp">//</span></span><br><span class="line">                <span class="string">&quot;/vcpkg/x64-linux/installed/x64-linux/include/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;F_OS_LINUX&quot;</span>,         <span class="regexp">//</span> 这里定义的头文件在程序中使用的时候，<span class="comment">#ifndef的内容不会灰色</span></span><br><span class="line">              <span class="string">&quot;_DEBUG&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,       <span class="regexp">//</span> 指定c语言使用的语法版本</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,   <span class="regexp">//</span> 指定c++使用的语法版本</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;linux-gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些问题：</p><ol><li>使用了C++11的语法，但是C++11的语句，比如auto还是会报错<br>“cStandard”: “c17”,<br>“cppStandard”: “c++17”,</li><li>使用了外部的库，比如opencv,QThread等库的时候，编译可以通过但是无法转跳</li></ol><h1 id="各种插件推荐"><a href="#各种插件推荐" class="headerlink" title="各种插件推荐"></a>各种插件推荐</h1><h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>格式化工具<br>shell-format</p><p>代码提示工具<br>shellman</p><h1 id="前端使用的插件"><a href="#前端使用的插件" class="headerlink" title="前端使用的插件"></a>前端使用的插件</h1><p>快捷键<br>开头按输入!,自动填充基础内容</p><ol><li>Auto Rename Tag<br>自动修改前后标签名</li><li>open in browser<br>在浏览器中打开</li><li>CSS Peek<br>追踪CSS样式</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[在VScode中，代码提示左边的图标各自代表的含义]<a href="https://blog.csdn.net/qq_42838904/article/details/108222619">https://blog.csdn.net/qq_42838904/article/details/108222619</a><br>[c_cpp_properties.json]<a href="https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference">https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代码里的左侧颜色标识&quot;&gt;&lt;a href=&quot;#代码里的左侧颜色标识&quot; class=&quot;headerlink&quot; title=&quot;代码里的左侧颜色标识:&quot;&gt;&lt;/a&gt;代码里的左侧颜色标识:&lt;/h1&gt;&lt;p&gt;红色，未加入版本控制; (刚clone到本地)&lt;br&gt;绿色，已经加入版本</summary>
      
    
    
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
